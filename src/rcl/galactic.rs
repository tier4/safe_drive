/* automatically generated by rust-bindgen 0.60.1 */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const RCUTILS_RET_OK: u32 = 0;
pub const RCUTILS_RET_WARN: u32 = 1;
pub const RCUTILS_RET_ERROR: u32 = 2;
pub const RCUTILS_RET_BAD_ALLOC: u32 = 10;
pub const RCUTILS_RET_INVALID_ARGUMENT: u32 = 11;
pub const RCUTILS_RET_NOT_ENOUGH_SPACE: u32 = 12;
pub const RCUTILS_RET_NOT_INITIALIZED: u32 = 13;
pub const RCUTILS_RET_NOT_FOUND: u32 = 14;
pub const RCUTILS_RET_STRING_MAP_ALREADY_INIT: u32 = 30;
pub const RCUTILS_RET_STRING_MAP_INVALID: u32 = 31;
pub const RCUTILS_RET_STRING_KEY_NOT_FOUND: u32 = 32;
pub const RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID: u32 = 40;
pub const RCUTILS_RET_LOGGING_SEVERITY_STRING_INVALID: u32 = 41;
pub const RCUTILS_RET_HASH_MAP_NO_MORE_ENTRIES: u32 = 50;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const RMW_DEFAULT_DOMAIN_ID: i32 = -1;
pub const RMW_RET_OK: u32 = 0;
pub const RMW_RET_ERROR: u32 = 1;
pub const RMW_RET_TIMEOUT: u32 = 2;
pub const RMW_RET_UNSUPPORTED: u32 = 3;
pub const RMW_RET_BAD_ALLOC: u32 = 10;
pub const RMW_RET_INVALID_ARGUMENT: u32 = 11;
pub const RMW_RET_INCORRECT_RMW_IMPLEMENTATION: u32 = 12;
pub const RMW_RET_NODE_NAME_NON_EXISTENT: u32 = 203;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const _ASSERT_H: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &[u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const RCUTILS_FAULT_INJECTION_NEVER_FAIL: i32 = -1;
pub const RCUTILS_FAULT_INJECTION_FAIL_NOW: u32 = 0;
pub const RCUTILS_ERROR_STATE_LINE_NUMBER_STR_MAX_LENGTH: u32 = 20;
pub const RCUTILS_ERROR_FORMATTING_CHARACTERS: u32 = 6;
pub const RCUTILS_ERROR_MESSAGE_MAX_LENGTH: u32 = 1024;
pub const RCUTILS_ERROR_STATE_MESSAGE_MAX_LENGTH: u32 = 768;
pub const RCUTILS_ERROR_STATE_FILE_MAX_LENGTH: u32 = 229;
pub const RCUTILS_LOGGING_SEPARATOR_STRING: &[u8; 2usize] = b".\0";
pub const RMW_GID_STORAGE_SIZE: u32 = 24;
pub const RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE_DEPRECATED_MSG : & [u8 ; 145usize] = b"RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE is deprecated. Use RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC if manually asserted liveliness is needed.\0" ;
pub const RCL_RET_OK: u32 = 0;
pub const RCL_RET_ERROR: u32 = 1;
pub const RCL_RET_TIMEOUT: u32 = 2;
pub const RCL_RET_BAD_ALLOC: u32 = 10;
pub const RCL_RET_INVALID_ARGUMENT: u32 = 11;
pub const RCL_RET_UNSUPPORTED: u32 = 3;
pub const RCL_RET_ALREADY_INIT: u32 = 100;
pub const RCL_RET_NOT_INIT: u32 = 101;
pub const RCL_RET_MISMATCHED_RMW_ID: u32 = 102;
pub const RCL_RET_TOPIC_NAME_INVALID: u32 = 103;
pub const RCL_RET_SERVICE_NAME_INVALID: u32 = 104;
pub const RCL_RET_UNKNOWN_SUBSTITUTION: u32 = 105;
pub const RCL_RET_ALREADY_SHUTDOWN: u32 = 106;
pub const RCL_RET_NODE_INVALID: u32 = 200;
pub const RCL_RET_NODE_INVALID_NAME: u32 = 201;
pub const RCL_RET_NODE_INVALID_NAMESPACE: u32 = 202;
pub const RCL_RET_NODE_NAME_NON_EXISTENT: u32 = 203;
pub const RCL_RET_PUBLISHER_INVALID: u32 = 300;
pub const RCL_RET_SUBSCRIPTION_INVALID: u32 = 400;
pub const RCL_RET_SUBSCRIPTION_TAKE_FAILED: u32 = 401;
pub const RCL_RET_CLIENT_INVALID: u32 = 500;
pub const RCL_RET_CLIENT_TAKE_FAILED: u32 = 501;
pub const RCL_RET_SERVICE_INVALID: u32 = 600;
pub const RCL_RET_SERVICE_TAKE_FAILED: u32 = 601;
pub const RCL_RET_TIMER_INVALID: u32 = 800;
pub const RCL_RET_TIMER_CANCELED: u32 = 801;
pub const RCL_RET_WAIT_SET_INVALID: u32 = 900;
pub const RCL_RET_WAIT_SET_EMPTY: u32 = 901;
pub const RCL_RET_WAIT_SET_FULL: u32 = 902;
pub const RCL_RET_INVALID_REMAP_RULE: u32 = 1001;
pub const RCL_RET_WRONG_LEXEME: u32 = 1002;
pub const RCL_RET_INVALID_ROS_ARGS: u32 = 1003;
pub const RCL_RET_INVALID_PARAM_RULE: u32 = 1010;
pub const RCL_RET_INVALID_LOG_LEVEL_RULE: u32 = 1020;
pub const RCL_RET_EVENT_INVALID: u32 = 2000;
pub const RCL_RET_EVENT_TAKE_FAILED: u32 = 2001;
pub const RCL_RET_LIFECYCLE_STATE_REGISTERED: u32 = 3000;
pub const RCL_RET_LIFECYCLE_STATE_NOT_REGISTERED: u32 = 3001;
pub const RCL_ROS_ARGS_FLAG: &[u8; 11usize] = b"--ros-args\0";
pub const RCL_ROS_ARGS_EXPLICIT_END_TOKEN: &[u8; 3usize] = b"--\0";
pub const RCL_PARAM_FLAG: &[u8; 8usize] = b"--param\0";
pub const RCL_SHORT_PARAM_FLAG: &[u8; 3usize] = b"-p\0";
pub const RCL_PARAM_FILE_FLAG: &[u8; 14usize] = b"--params-file\0";
pub const RCL_REMAP_FLAG: &[u8; 8usize] = b"--remap\0";
pub const RCL_SHORT_REMAP_FLAG: &[u8; 3usize] = b"-r\0";
pub const RCL_ENCLAVE_FLAG: &[u8; 10usize] = b"--enclave\0";
pub const RCL_SHORT_ENCLAVE_FLAG: &[u8; 3usize] = b"-e\0";
pub const RCL_LOG_LEVEL_FLAG: &[u8; 12usize] = b"--log-level\0";
pub const RCL_EXTERNAL_LOG_CONFIG_FLAG: &[u8; 18usize] = b"--log-config-file\0";
pub const RCL_LOG_STDOUT_FLAG_SUFFIX: &[u8; 12usize] = b"stdout-logs\0";
pub const RCL_LOG_ROSOUT_FLAG_SUFFIX: &[u8; 12usize] = b"rosout-logs\0";
pub const RCL_LOG_EXT_LIB_FLAG_SUFFIX: &[u8; 18usize] = b"external-lib-logs\0";
pub const __alignas_is_defined: u32 = 1;
pub const __alignof_is_defined: u32 = 1;
pub const RCL_DEFAULT_DOMAIN_ID: i32 = -1;
pub const RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID: i32 = -1;
pub const RCL_RET_ACTION_NAME_INVALID: u32 = 2000;
pub const RCL_RET_ACTION_GOAL_ACCEPTED: u32 = 2100;
pub const RCL_RET_ACTION_GOAL_REJECTED: u32 = 2101;
pub const RCL_RET_ACTION_CLIENT_INVALID: u32 = 2102;
pub const RCL_RET_ACTION_CLIENT_TAKE_FAILED: u32 = 2103;
pub const RCL_RET_ACTION_SERVER_INVALID: u32 = 2200;
pub const RCL_RET_ACTION_SERVER_TAKE_FAILED: u32 = 2201;
pub const RCL_RET_ACTION_GOAL_HANDLE_INVALID: u32 = 2300;
pub const RCL_RET_ACTION_GOAL_EVENT_INVALID: u32 = 2301;
pub const UUID_SIZE: u32 = 16;
pub const GOAL_STATE_NUM_STATES: u32 = 7;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    fn test_field___clang_max_align_nonce1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<max_align_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(max_align_t),
                "::",
                stringify!(__clang_max_align_nonce1)
            )
        );
    }
    test_field___clang_max_align_nonce1();
    fn test_field___clang_max_align_nonce2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<max_align_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(max_align_t),
                "::",
                stringify!(__clang_max_align_nonce2)
            )
        );
    }
    test_field___clang_max_align_nonce2();
}
#[doc = " The type that holds a return value for an rcutils operation."]
pub type rcutils_ret_t = ::std::os::raw::c_int;
#[doc = " Encapsulation of an allocator."]
#[doc = "* *"]
#[doc = "* The default allocator uses malloc(), free(), calloc(), and realloc()."]
#[doc = "* It can be obtained using rcutils_get_default_allocator()."]
#[doc = "* "]
#[doc = "* The allocator should be trivially copyable."]
#[doc = "* Meaning that the struct should continue to work after being assignment"]
#[doc = "* copied into a new struct."]
#[doc = "* Specifically the object pointed to by the state pointer should remain valid"]
#[doc = "* until all uses of the allocator have been made."]
#[doc = "* Particular care should be taken when giving an allocator to functions like"]
#[doc = "* rcutils_*_init() where it is stored within another object and used later."]
#[doc = "* Developers should note that, while the fields of a const-qualified allocator"]
#[doc = "* struct cannot be modified, the state of the allocator can be modified."]
#[doc = "* /"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_allocator_t {
    #[doc = " Allocate memory, given a size and the `state` pointer."]
    #[doc = "* * An error should be indicated by returning `NULL`. */"]
    pub allocate: ::std::option::Option<
        unsafe extern "C" fn(
            size: size_t,
            state: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Deallocate previously allocated memory, mimicking free()."]
    #[doc = "* * Also takes the `state` pointer. */"]
    pub deallocate: ::std::option::Option<
        unsafe extern "C" fn(
            pointer: *mut ::std::os::raw::c_void,
            state: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Reallocate if possible, otherwise it deallocates and allocates."]
    #[doc = "* *"]
    #[doc = "* Also takes the `state` pointer."]
    #[doc = "* "]
    #[doc = "* If unsupported then do deallocate and then allocate."]
    #[doc = "* This should behave as realloc() does, as opposed to posix's"]
    #[doc = "* [reallocf](https://linux.die.net/man/3/reallocf), i.e. the memory given"]
    #[doc = "* by pointer will not be free'd automatically if realloc() fails."]
    #[doc = "* For reallocf-like behavior use rcutils_reallocf()."]
    #[doc = "* This function must be able to take an input pointer of `NULL` and succeed."]
    #[doc = "* /"]
    pub reallocate: ::std::option::Option<
        unsafe extern "C" fn(
            pointer: *mut ::std::os::raw::c_void,
            size: size_t,
            state: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Allocate memory with all elements set to zero, given a number of elements and their size."]
    #[doc = "* * An error should be indicated by returning `NULL`. */"]
    pub zero_allocate: ::std::option::Option<
        unsafe extern "C" fn(
            number_of_elements: size_t,
            size_of_element: size_t,
            state: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Implementation defined state storage."]
    #[doc = "* *"]
    #[doc = "* This is passed as the final parameter to other allocator functions."]
    #[doc = "* Note that the contents of the state can be modified even in const-qualified"]
    #[doc = "* allocator objects."]
    #[doc = "* /"]
    pub state: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rcutils_allocator_t() {
    assert_eq!(
        ::std::mem::size_of::<rcutils_allocator_t>(),
        40usize,
        concat!("Size of: ", stringify!(rcutils_allocator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcutils_allocator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcutils_allocator_t))
    );
    fn test_field_allocate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_allocator_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocate) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_allocator_t),
                "::",
                stringify!(allocate)
            )
        );
    }
    test_field_allocate();
    fn test_field_deallocate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_allocator_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deallocate) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_allocator_t),
                "::",
                stringify!(deallocate)
            )
        );
    }
    test_field_deallocate();
    fn test_field_reallocate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_allocator_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reallocate) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_allocator_t),
                "::",
                stringify!(reallocate)
            )
        );
    }
    test_field_reallocate();
    fn test_field_zero_allocate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_allocator_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).zero_allocate) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_allocator_t),
                "::",
                stringify!(zero_allocate)
            )
        );
    }
    test_field_zero_allocate();
    fn test_field_state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_allocator_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_allocator_t),
                "::",
                stringify!(state)
            )
        );
    }
    test_field_state();
}
extern "C" {
    #[doc = " Return a zero initialized allocator."]
    #[doc = "* *"]
    #[doc = "* Note that this is an invalid allocator and should only be used as a placeholder."]
    #[doc = "* /"]
    pub fn rcutils_get_zero_initialized_allocator() -> rcutils_allocator_t;
}
extern "C" {
    #[doc = " Return a properly initialized rcutils_allocator_t with default values."]
    #[doc = "* *"]
    #[doc = "* This defaults to:"]
    #[doc = "* "]
    #[doc = "* - allocate = wraps malloc()"]
    #[doc = "* - deallocate = wraps free()"]
    #[doc = "* - reallocate = wraps realloc()"]
    #[doc = "* - zero_allocate = wraps calloc()"]
    #[doc = "* - state = `NULL`"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* /"]
    pub fn rcutils_get_default_allocator() -> rcutils_allocator_t;
}
extern "C" {
    #[doc = " Return true if the given allocator has non-null function pointers."]
    #[doc = "* *"]
    #[doc = "* \\param[in] allocator to be checked by the function"]
    #[doc = "* \\return `true` if the allocator is valid, `false` otherwise."]
    #[doc = "* /"]
    pub fn rcutils_allocator_is_valid(allocator: *const rcutils_allocator_t) -> bool;
}
extern "C" {
    #[doc = " Emulate the behavior of [reallocf](https://linux.die.net/man/3/reallocf)."]
    #[doc = "* *"]
    #[doc = "* This function will return `NULL` if the allocator is `NULL` or has `NULL` for"]
    #[doc = "* function pointer fields."]
    #[doc = "* \\param[inout] pointer to the memory which will be reallocated"]
    #[doc = "* \\param[in] size in bytes"]
    #[doc = "* \\param[in] allocator to be used to allocate and deallocate memory"]
    #[doc = "* /"]
    pub fn rcutils_reallocf(
        pointer: *mut ::std::os::raw::c_void,
        size: size_t,
        allocator: *mut rcutils_allocator_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " Encapsulation of an allocator."]
#[doc = "* *"]
#[doc = "* The default allocator uses malloc(), free(), calloc(), and realloc()."]
#[doc = "* It can be obtained using rcutils_get_default_allocator()."]
#[doc = "* "]
#[doc = "* The allocator should be trivially copyable."]
#[doc = "* Meaning that the struct should continue to work after being assignment"]
#[doc = "* copied into a new struct."]
#[doc = "* Specifically the object pointed to by the state pointer should remain valid"]
#[doc = "* until all uses of the allocator have been made."]
#[doc = "* Particular care should be taken when giving an allocator to functions like"]
#[doc = "* rcutils_*_init() where it is stored within another object and used later."]
#[doc = "* Developers should note that, while the fields of a const-qualified allocator"]
#[doc = "* struct cannot be modified, the state of the allocator can be modified."]
#[doc = "* /"]
pub type rcl_allocator_t = rcutils_allocator_t;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__fsid_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__fsid_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " Uses ROS_LOCALHOST_ONLY environment variable."]
pub const rmw_localhost_only_t_RMW_LOCALHOST_ONLY_DEFAULT: rmw_localhost_only_t = 0;
#[doc = " Forces using only localhost."]
pub const rmw_localhost_only_t_RMW_LOCALHOST_ONLY_ENABLED: rmw_localhost_only_t = 1;
#[doc = " Forces disabling localhost only."]
pub const rmw_localhost_only_t_RMW_LOCALHOST_ONLY_DISABLED: rmw_localhost_only_t = 2;
#[doc = " Used to specify if the context can only communicate through localhost."]
pub type rmw_localhost_only_t = ::std::os::raw::c_uint;
#[doc = " Return code for rmw functions"]
pub type rmw_ret_t = i32;
pub const rmw_security_enforcement_policy_t_RMW_SECURITY_ENFORCEMENT_PERMISSIVE:
    rmw_security_enforcement_policy_t = 0;
pub const rmw_security_enforcement_policy_t_RMW_SECURITY_ENFORCEMENT_ENFORCE:
    rmw_security_enforcement_policy_t = 1;
pub type rmw_security_enforcement_policy_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_security_options_t {
    pub enforce_security: rmw_security_enforcement_policy_t,
    pub security_root_path: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rmw_security_options_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_security_options_t>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_security_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_security_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_security_options_t))
    );
    fn test_field_enforce_security() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_security_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enforce_security) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_security_options_t),
                "::",
                stringify!(enforce_security)
            )
        );
    }
    test_field_enforce_security();
    fn test_field_security_root_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_security_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).security_root_path) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_security_options_t),
                "::",
                stringify!(security_root_path)
            )
        );
    }
    test_field_security_root_path();
}
extern "C" {
    #[doc = " Get zero initialized security options."]
    pub fn rmw_get_zero_initialized_security_options() -> rmw_security_options_t;
}
extern "C" {
    #[doc = " Get default initialized security options."]
    pub fn rmw_get_default_security_options() -> rmw_security_options_t;
}
extern "C" {
    #[doc = " Copy the given security options."]
    #[doc = "* *"]
    #[doc = "* \\param[in] src security options to be copied."]
    #[doc = "* \\param[in] allocator allocator used when copying data to the new security options."]
    #[doc = "* \\param[out] dst security options to be set."]
    #[doc = "* \\returns RMW_RET_BAD_ALLOC, or"]
    #[doc = "* \\returns RMW_RET_OK"]
    #[doc = "* /"]
    pub fn rmw_security_options_copy(
        src: *const rmw_security_options_t,
        allocator: *const rcutils_allocator_t,
        dst: *mut rmw_security_options_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Set the security root path for the given security options."]
    #[doc = "* *"]
    #[doc = "* The provided `security_root_path` will be copied into allocated memory."]
    #[doc = "* "]
    #[doc = "* \\param[in] security_root_path path to be set."]
    #[doc = "* \\param[in] allocator allocator used to allocate the new path."]
    #[doc = "* \\param[in|out] security_options security options to be set."]
    #[doc = "* \\returns RMW_RET_BAD_ALLOC, or"]
    #[doc = "* \\returns RMW_RET_OK"]
    #[doc = "* /"]
    pub fn rmw_security_options_set_root_path(
        security_root_path: *const ::std::os::raw::c_char,
        allocator: *const rcutils_allocator_t,
        security_options: *mut rmw_security_options_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Finalize the given security_options."]
    #[doc = "* *"]
    #[doc = "* \\param[in] security_options security options to be finalized."]
    #[doc = "* \\param[in] allocator allocator used to deallocate the root path."]
    #[doc = "* \\returns RMW_RET_ERROR, or"]
    #[doc = "* \\returns RMW_RET_OK"]
    #[doc = "* /"]
    pub fn rmw_security_options_fini(
        security_options: *mut rmw_security_options_t,
        allocator: *const rcutils_allocator_t,
    ) -> rmw_ret_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_init_options_impl_t {
    _unused: [u8; 0],
}
#[doc = " Options structure used during rmw_init()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_init_options_t {
    #[doc = " Locally (process local) unique ID that represents this init/shutdown cycle."]
    #[doc = "* *"]
    #[doc = "* This should be set by the caller of `rmw_init()` to a number that is"]
    #[doc = "* unique within this process."]
    #[doc = "* It is designed to be used with `rcl_init()` and `rcl_get_instance_id()`."]
    #[doc = "* /"]
    pub instance_id: u64,
    #[doc = " Implementation identifier, used to ensure two different implementations are not being mixed."]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " ROS domain id"]
    pub domain_id: size_t,
    #[doc = " Security options"]
    pub security_options: rmw_security_options_t,
    #[doc = " Enable localhost only"]
    pub localhost_only: rmw_localhost_only_t,
    #[doc = " Enclave, name used to find security artifacts in a sros2 keystore."]
    pub enclave: *mut ::std::os::raw::c_char,
    #[doc = " Allocator used during internal allocation of init options, if needed."]
    pub allocator: rcutils_allocator_t,
    #[doc = " Implementation defined init options."]
    #[doc = "* * May be NULL if there are no implementation defined options. */"]
    pub impl_: *mut rmw_init_options_impl_t,
}
#[test]
fn bindgen_test_layout_rmw_init_options_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_init_options_t>(),
        104usize,
        concat!("Size of: ", stringify!(rmw_init_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_init_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_init_options_t))
    );
    fn test_field_instance_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_init_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).instance_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_init_options_t),
                "::",
                stringify!(instance_id)
            )
        );
    }
    test_field_instance_id();
    fn test_field_implementation_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_init_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_init_options_t),
                "::",
                stringify!(implementation_identifier)
            )
        );
    }
    test_field_implementation_identifier();
    fn test_field_domain_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_init_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).domain_id) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_init_options_t),
                "::",
                stringify!(domain_id)
            )
        );
    }
    test_field_domain_id();
    fn test_field_security_options() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_init_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).security_options) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_init_options_t),
                "::",
                stringify!(security_options)
            )
        );
    }
    test_field_security_options();
    fn test_field_localhost_only() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_init_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).localhost_only) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_init_options_t),
                "::",
                stringify!(localhost_only)
            )
        );
    }
    test_field_localhost_only();
    fn test_field_enclave() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_init_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enclave) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_init_options_t),
                "::",
                stringify!(enclave)
            )
        );
    }
    test_field_enclave();
    fn test_field_allocator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_init_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_init_options_t),
                "::",
                stringify!(allocator)
            )
        );
    }
    test_field_allocator();
    fn test_field_impl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_init_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_init_options_t),
                "::",
                stringify!(impl_)
            )
        );
    }
    test_field_impl();
}
extern "C" {
    #[doc = " Return a zero initialized init options structure."]
    pub fn rmw_get_zero_initialized_init_options() -> rmw_init_options_t;
}
extern "C" {
    #[doc = " Initialize given init options with the default values and implementation specific values."]
    #[doc = "* *"]
    #[doc = "* The given allocator is used, if required, during setup of the init options,"]
    #[doc = "* but is also used during initialization."]
    #[doc = "* "]
    #[doc = "* In either case the given allocator is stored in the returned init options."]
    #[doc = "* "]
    #[doc = "* The `impl` pointer should not be changed manually."]
    #[doc = "* "]
    #[doc = "* \\pre The given init options must be zero initialized."]
    #[doc = "* "]
    #[doc = "* \\post If initialization fails, init options will remain zero initialized."]
    #[doc = "* "]
    #[doc = "* \\remark Giving an already initialized init options will result"]
    #[doc = "* in a failure with return code `RMW_RET_INVALID_ARGUMENT`."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* This should be defined by the rmw implementation."]
    #[doc = "* "]
    #[doc = "* \\param[inout] init_options object to be setup"]
    #[doc = "* \\param[in] allocator to be used during setup and during initialization"]
    #[doc = "* \\return `RMW_RET_OK` if setup is successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RMW_RET_BAD_ALLOC` if allocating memory failed, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rmw_init_options_init(
        init_options: *mut rmw_init_options_t,
        allocator: rcutils_allocator_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Copy the given source init options to the destination init options."]
    #[doc = "* *"]
    #[doc = "* The allocator from the source is used for any allocations and stored in the"]
    #[doc = "* destination."]
    #[doc = "* "]
    #[doc = "* \\pre The source init options must have been initialized"]
    #[doc = "* i.e. had `rmw_init_options_init()` called on."]
    #[doc = "* \\pre The destination init options must be zero initialized."]
    #[doc = "* "]
    #[doc = "* \\post If copy fails, destination init options will remain zero initialized."]
    #[doc = "* "]
    #[doc = "* \\remark Giving an zero initialized init options as a source will result"]
    #[doc = "* in a failure with return code `RMW_RET_INVALID_ARGUMENT`."]
    #[doc = "* \\remark Giving an already initialized init options for the destination will result"]
    #[doc = "* in a failure with return code `RMW_RET_INVALID_ARGUMENT`."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* This should be defined by the rmw implementation."]
    #[doc = "* "]
    #[doc = "* \\param[in] src rcl_init_options_t object to be copied from"]
    #[doc = "* \\param[out] dst rcl_init_options_t object to be copied into"]
    #[doc = "* \\return `RMW_RET_OK` if the copy is successful, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation"]
    #[doc = "* identifier for src does not match the implementation of this function, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RMW_RET_BAD_ALLOC` if allocating memory failed, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rmw_init_options_copy(
        src: *const rmw_init_options_t,
        dst: *mut rmw_init_options_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Finalize the given init options."]
    #[doc = "* *"]
    #[doc = "* This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`"]
    #[doc = "* or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given init options"]
    #[doc = "* unchanged."]
    #[doc = "* Otherwise, it will proceed despite errors, freeing as much resources as it can and zero"]
    #[doc = "* initializing the given init options."]
    #[doc = "* "]
    #[doc = "* \\pre The given init options must have been initialized"]
    #[doc = "* i.e. had `rmw_init_options_init()` called on."]
    #[doc = "* "]
    #[doc = "* \\remarks If init options are zero initialized,"]
    #[doc = "* then `RMW_RET_INVALID_ARGUMENT` is returned."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* This should be defined by the rmw implementation."]
    #[doc = "* "]
    #[doc = "* \\param[inout] init_options object to finalized"]
    #[doc = "* \\return `RMW_RET_OK` if finalization is successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation"]
    #[doc = "* identifier does not match the implementation of this function, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rmw_init_options_fini(init_options: *mut rmw_init_options_t) -> rmw_ret_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_context_impl_t {
    _unused: [u8; 0],
}
#[doc = " Initialization context structure which is used to store init specific information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_context_t {
    #[doc = " Locally (process local) unique ID that represents this init/shutdown cycle."]
    pub instance_id: u64,
    #[doc = " Implementation identifier, used to ensure two different implementations are not being mixed."]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Options used to initialize the context."]
    pub options: rmw_init_options_t,
    #[doc = " Domain id that is being used."]
    pub actual_domain_id: size_t,
    #[doc = " Implementation defined context information."]
    #[doc = "* * May be NULL if there is no implementation defined context information. */"]
    pub impl_: *mut rmw_context_impl_t,
}
#[test]
fn bindgen_test_layout_rmw_context_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_context_t>(),
        136usize,
        concat!("Size of: ", stringify!(rmw_context_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_context_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_context_t))
    );
    fn test_field_instance_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).instance_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_context_t),
                "::",
                stringify!(instance_id)
            )
        );
    }
    test_field_instance_id();
    fn test_field_implementation_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_context_t),
                "::",
                stringify!(implementation_identifier)
            )
        );
    }
    test_field_implementation_identifier();
    fn test_field_options() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_context_t),
                "::",
                stringify!(options)
            )
        );
    }
    test_field_options();
    fn test_field_actual_domain_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).actual_domain_id) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_context_t),
                "::",
                stringify!(actual_domain_id)
            )
        );
    }
    test_field_actual_domain_id();
    fn test_field_impl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_context_t),
                "::",
                stringify!(impl_)
            )
        );
    }
    test_field_impl();
}
extern "C" {
    #[doc = " Return a zero initialized context structure."]
    pub fn rmw_get_zero_initialized_context() -> rmw_context_t;
}
extern "C" {
    #[doc = " Initialize the middleware with the given options, and yielding an context."]
    #[doc = "* *"]
    #[doc = "* Context is filled with middleware specific data upon success of this function."]
    #[doc = "* The context is used when initializing some entities like nodes and"]
    #[doc = "* guard conditions, and is also required to properly call `rmw_shutdown()`."]
    #[doc = "* "]
    #[doc = "* \\pre The given options must have been initialized"]
    #[doc = "* i.e. `rmw_init_options_init()` called on it and"]
    #[doc = "* an enclave set."]
    #[doc = "* \\pre The given context must be zero initialized."]
    #[doc = "* "]
    #[doc = "* \\post If initialization fails, context will remain zero initialized."]
    #[doc = "* \\post `context->actual_domain_id` will be set with the domain id the rmw implementation is using."]
    #[doc = "* This matches `options->domain_id` if it is not RMW_DEFAULT_DOMAIN_ID."]
    #[doc = "* In other case, the value is rmw implementation dependent."]
    #[doc = "* "]
    #[doc = "* \\remarks If options are zero-initialized, then `RMW_RET_INVALID_ARGUMENT` is returned."]
    #[doc = "* If options are initialized but no enclave is provided, then `RMW_RET_INVALID_ARGUMENT`"]
    #[doc = "* is returned."]
    #[doc = "* If context has been already initialized (`rmw_init()` was called on it), then"]
    #[doc = "* `RMW_RET_INVALID_ARGUMENT` is returned."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* This should be defined by the rmw implementation."]
    #[doc = "* "]
    #[doc = "* \\param[in] options initialization options to be used during initialization"]
    #[doc = "* \\param[out] context resulting context struct"]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation"]
    #[doc = "* identifier does not match, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_init(options: *const rmw_init_options_t, context: *mut rmw_context_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Shutdown the middleware for a given context."]
    #[doc = "* *"]
    #[doc = "* \\pre The given context must be a valid context which has been initialized with `rmw_init()`."]
    #[doc = "* "]
    #[doc = "* \\remarks If context is zero initialized, then `RMW_RET_INVALID_ARGUMENT` is returned."]
    #[doc = "* If context has been already invalidated (`rmw_shutdown()` was called on it), then"]
    #[doc = "* this function is a no-op and `RMW_RET_OK` is returned."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* This should be defined by the rmw implementation."]
    #[doc = "* "]
    #[doc = "* \\param[in] context resulting context struct"]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if any argument are invalid, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation"]
    #[doc = "* identifier does not match, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_shutdown(context: *mut rmw_context_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Finalize a context."]
    #[doc = "* *"]
    #[doc = "* This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`"]
    #[doc = "* or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given context unchanged."]
    #[doc = "* Otherwise, it will proceed despite errors, freeing as much resources as it can and zero"]
    #[doc = "* initializing the given context."]
    #[doc = "* "]
    #[doc = "* \\pre The context to be finalized must have been previously initialized with"]
    #[doc = "* `rmw_init()`, and then later invalidated with `rmw_shutdown()`."]
    #[doc = "* "]
    #[doc = "* \\remarks If context is zero initialized, then `RMW_RET_INVALID_ARGUMENT` is returned."]
    #[doc = "* If context is initialized and valid (`rmw_shutdown()` was not called on it), then"]
    #[doc = "* `RMW_RET_INVALID_ARGUMENT` is returned."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes [1]"]
    #[doc = "* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>"]
    #[doc = "* "]
    #[doc = "* This should be defined by the rmw implementation."]
    #[doc = "* "]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation"]
    #[doc = "* identifier does not match, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unspecified error occur."]
    #[doc = "* /"]
    pub fn rmw_context_fini(context: *mut rmw_context_t) -> rmw_ret_t;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    fn test_field___wch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wch)
            )
        );
    }
    test_field___wch();
    fn test_field___wchb() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wchb)
            )
        );
    }
    test_field___wchb();
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    fn test_field___count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__count)
            )
        );
    }
    test_field___count();
    fn test_field___value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__value)
            )
        );
    }
    test_field___value();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    fn test_field___pos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_G_fpos_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_G_fpos_t),
                "::",
                stringify!(__pos)
            )
        );
    }
    test_field___pos();
    fn test_field___state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_G_fpos_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_G_fpos_t),
                "::",
                stringify!(__state)
            )
        );
    }
    test_field___state();
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    fn test_field___pos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_G_fpos64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_G_fpos64_t),
                "::",
                stringify!(__pos)
            )
        );
    }
    test_field___pos();
    fn test_field___state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_G_fpos64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_G_fpos64_t),
                "::",
                stringify!(__state)
            )
        );
    }
    test_field___state();
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    fn test_field__flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags)
            )
        );
    }
    test_field__flags();
    fn test_field__IO_read_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_ptr)
            )
        );
    }
    test_field__IO_read_ptr();
    fn test_field__IO_read_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_end)
            )
        );
    }
    test_field__IO_read_end();
    fn test_field__IO_read_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_base)
            )
        );
    }
    test_field__IO_read_base();
    fn test_field__IO_write_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_base)
            )
        );
    }
    test_field__IO_write_base();
    fn test_field__IO_write_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_ptr)
            )
        );
    }
    test_field__IO_write_ptr();
    fn test_field__IO_write_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_end)
            )
        );
    }
    test_field__IO_write_end();
    fn test_field__IO_buf_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_base)
            )
        );
    }
    test_field__IO_buf_base();
    fn test_field__IO_buf_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_end)
            )
        );
    }
    test_field__IO_buf_end();
    fn test_field__IO_save_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_base)
            )
        );
    }
    test_field__IO_save_base();
    fn test_field__IO_backup_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_backup_base)
            )
        );
    }
    test_field__IO_backup_base();
    fn test_field__IO_save_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_end)
            )
        );
    }
    test_field__IO_save_end();
    fn test_field__markers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_markers)
            )
        );
    }
    test_field__markers();
    fn test_field__chain() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_chain)
            )
        );
    }
    test_field__chain();
    fn test_field__fileno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_fileno)
            )
        );
    }
    test_field__fileno();
    fn test_field__flags2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags2)
            )
        );
    }
    test_field__flags2();
    fn test_field__old_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_old_offset)
            )
        );
    }
    test_field__old_offset();
    fn test_field__cur_column() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_cur_column)
            )
        );
    }
    test_field__cur_column();
    fn test_field__vtable_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize
            },
            130usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_vtable_offset)
            )
        );
    }
    test_field__vtable_offset();
    fn test_field__shortbuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize
            },
            131usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_shortbuf)
            )
        );
    }
    test_field__shortbuf();
    fn test_field__lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_lock)
            )
        );
    }
    test_field__lock();
    fn test_field__offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_offset)
            )
        );
    }
    test_field__offset();
    fn test_field__codecvt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_codecvt)
            )
        );
    }
    test_field__codecvt();
    fn test_field__wide_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_wide_data)
            )
        );
    }
    test_field__wide_data();
    fn test_field__freeres_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_freeres_list)
            )
        );
    }
    test_field__freeres_list();
    fn test_field__freeres_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_freeres_buf)
            )
        );
    }
    test_field__freeres_buf();
    fn test_field___pad5() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(__pad5)
            )
        );
    }
    test_field___pad5();
    fn test_field__mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_mode)
            )
        );
    }
    test_field__mode();
    fn test_field__unused2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize
            },
            196usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_unused2)
            )
        );
    }
    test_field__unused2();
}
pub type off_t = __off_t;
pub type ssize_t = __ssize_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: size_t,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    );
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<div_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(div_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<div_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(div_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ldiv_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ldiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(lldiv_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(lldiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigset_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigset_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_usec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval),
                "::",
                stringify!(tv_usec)
            )
        );
    }
    test_field_tv_usec();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_nsec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_nsec)
            )
        );
    }
    test_field_tv_nsec();
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    fn test_field___fds_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fd_set>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fd_set),
                "::",
                stringify!(__fds_bits)
            )
        );
    }
    test_field___fds_bits();
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    fn test_field___prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_internal_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_list),
                "::",
                stringify!(__prev)
            )
        );
    }
    test_field___prev();
    fn test_field___next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_internal_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_list),
                "::",
                stringify!(__next)
            )
        );
    }
    test_field___next();
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    fn test_field___next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_internal_slist>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_slist),
                "::",
                stringify!(__next)
            )
        );
    }
    test_field___next();
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    fn test_field___lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__lock)
            )
        );
    }
    test_field___lock();
    fn test_field___count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__count)
            )
        );
    }
    test_field___count();
    fn test_field___owner() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__owner)
            )
        );
    }
    test_field___owner();
    fn test_field___nusers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__nusers)
            )
        );
    }
    test_field___nusers();
    fn test_field___kind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__kind)
            )
        );
    }
    test_field___kind();
    fn test_field___spins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__spins)
            )
        );
    }
    test_field___spins();
    fn test_field___elision() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize
            },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__elision)
            )
        );
    }
    test_field___elision();
    fn test_field___list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__list)
            )
        );
    }
    test_field___list();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    fn test_field___readers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__readers)
            )
        );
    }
    test_field___readers();
    fn test_field___writers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__writers)
            )
        );
    }
    test_field___writers();
    fn test_field___wrphase_futex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__wrphase_futex)
            )
        );
    }
    test_field___wrphase_futex();
    fn test_field___writers_futex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__writers_futex)
            )
        );
    }
    test_field___writers_futex();
    fn test_field___pad3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad3)
            )
        );
    }
    test_field___pad3();
    fn test_field___pad4() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad4)
            )
        );
    }
    test_field___pad4();
    fn test_field___cur_writer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__cur_writer)
            )
        );
    }
    test_field___cur_writer();
    fn test_field___shared() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__shared)
            )
        );
    }
    test_field___shared();
    fn test_field___rwelision() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__rwelision)
            )
        );
    }
    test_field___rwelision();
    fn test_field___pad1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize
            },
            33usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad1)
            )
        );
    }
    test_field___pad1();
    fn test_field___pad2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad2)
            )
        );
    }
    test_field___pad2();
    fn test_field___flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__flags)
            )
        );
    }
    test_field___flags();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field___low() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(__low)
            )
        );
    }
    test_field___low();
    fn test_field___high() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(__high)
            )
        );
    }
    test_field___high();
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    fn test_field___wseq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_1),
                "::",
                stringify!(__wseq)
            )
        );
    }
    test_field___wseq();
    fn test_field___wseq32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wseq32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_1),
                "::",
                stringify!(__wseq32)
            )
        );
    }
    test_field___wseq32();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    fn test_field___low() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(__low)
            )
        );
    }
    test_field___low();
    fn test_field___high() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(__high)
            )
        );
    }
    test_field___high();
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    fn test_field___g1_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_2),
                "::",
                stringify!(__g1_start)
            )
        );
    }
    test_field___g1_start();
    fn test_field___g1_start32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g1_start32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_2),
                "::",
                stringify!(__g1_start32)
            )
        );
    }
    test_field___g1_start32();
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    fn test_field___g_refs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g_refs)
            )
        );
    }
    test_field___g_refs();
    fn test_field___g_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g_size)
            )
        );
    }
    test_field___g_size();
    fn test_field___g1_orig_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g1_orig_size)
            )
        );
    }
    test_field___g1_orig_size();
    fn test_field___wrefs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__wrefs)
            )
        );
    }
    test_field___wrefs();
    fn test_field___g_signals() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g_signals)
            )
        );
    }
    test_field___g_signals();
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutexattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutexattr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutexattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutexattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_condattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_condattr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_condattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_condattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_attr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_attr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_attr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_attr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_cond_t),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_cond_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_cond_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlock_t),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlock_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlock_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlockattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlockattr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlockattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlockattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_barrier_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrier_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_barrier_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrier_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_barrierattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrierattr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_barrierattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrierattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    fn test_field_fptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(fptr)
            )
        );
    }
    test_field_fptr();
    fn test_field_rptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(rptr)
            )
        );
    }
    test_field_rptr();
    fn test_field_state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(state)
            )
        );
    }
    test_field_state();
    fn test_field_rand_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(rand_type)
            )
        );
    }
    test_field_rand_type();
    fn test_field_rand_deg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(rand_deg)
            )
        );
    }
    test_field_rand_deg();
    fn test_field_rand_sep() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(rand_sep)
            )
        );
    }
    test_field_rand_sep();
    fn test_field_end_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(end_ptr)
            )
        );
    }
    test_field_end_ptr();
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    fn test_field___x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__x)
            )
        );
    }
    test_field___x();
    fn test_field___old_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__old_x)
            )
        );
    }
    test_field___old_x();
    fn test_field___c() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__c)
            )
        );
    }
    test_field___c();
    fn test_field___init() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize
            },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__init)
            )
        );
    }
    test_field___init();
    fn test_field___a() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__a)
            )
        );
    }
    test_field___a();
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::std::os::raw::c_char,
        __pwcs: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    fn test_field___locales() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__locales)
            )
        );
    }
    test_field___locales();
    fn test_field___ctype_b() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_b)
            )
        );
    }
    test_field___ctype_b();
    fn test_field___ctype_tolower() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_tolower)
            )
        );
    }
    test_field___ctype_tolower();
    fn test_field___ctype_toupper() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_toupper)
            )
        );
    }
    test_field___ctype_toupper();
    fn test_field___names() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__names)
            )
        );
    }
    test_field___names();
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: size_t,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Format a string."]
    #[doc = "* *"]
    #[doc = "* This function just wraps snprintf() as defined in C11 in a portable way."]
    #[doc = "* "]
    #[doc = "* On Windows this defaults to the _TRUNCATE behavior of _snprintf_s(), but"]
    #[doc = "* only returns -1 if errno is not 0."]
    #[doc = "* Unlike _snprintf_s() which returns -1 when truncation occurs, this function"]
    #[doc = "* behaves like snprintf() (http://en.cppreference.com/w/cpp/io/c/fprintf):"]
    #[doc = "* "]
    #[doc = "* > Number of characters written if successful or negative value if an error"]
    #[doc = "* > occurred."]
    #[doc = "* > If the resulting string gets truncated due to buf_size limit, function"]
    #[doc = "* > returns the total number of characters (not including the terminating"]
    #[doc = "* > null-byte) which would have been written, if the limit was not imposed."]
    #[doc = "* "]
    #[doc = "* If `NULL` and `0` are given for buffer and buffer_size respectively, the"]
    #[doc = "* size of the string that would be generated is returned."]
    #[doc = "* Either snprintf() or _vscprintf() is used to calculate this value."]
    #[doc = "* "]
    #[doc = "* \\see snprintf()"]
    #[doc = "* \\see _snprintf_s()"]
    #[doc = "* \\return the number of bytes that would have been written given enough space, or"]
    #[doc = "* \\return a negative number if there is an error, but unlike _snprintf_s(),"]
    #[doc = "* -1 is not returned if there is truncation."]
    #[doc = "* /"]
    pub fn rcutils_snprintf(
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: size_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Format a string with va_list for arguments, see rcutils_snprintf()."]
    pub fn rcutils_vsnprintf(
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: size_t,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcutils_fault_injection_is_test_complete() -> bool;
}
extern "C" {
    #[doc = " \\brief Atomically set the fault injection counter."]
    #[doc = ""]
    #[doc = " This is typically not the preferred method of interacting directly with the fault injection"]
    #[doc = " logic, instead use `RCUTILS_FAULT_INJECTION_TEST` instead."]
    #[doc = ""]
    #[doc = " This function may also be used for pausing code inside of a `RCUTILS_FAULT_INJECTION_TEST` with"]
    #[doc = " something like the following:"]
    #[doc = ""]
    #[doc = " RCUTILS_FAULT_INJECTION_TEST({"]
    #[doc = "     ...  // code to run with fault injection"]
    #[doc = "     int64_t count = rcutils_fault_injection_get_count();"]
    #[doc = "     rcutils_fault_injection_set_count(RCUTILS_FAULT_INJECTION_NEVER_FAIL);"]
    #[doc = "     ...  // code to run without fault injection"]
    #[doc = "     rcutils_fault_injection_set_count(count);"]
    #[doc = "     ...  // code to run with fault injection"]
    #[doc = " });"]
    #[doc = ""]
    #[doc = " \\param count The count to set the fault injection counter to. If count is negative, then fault"]
    #[doc = " injection errors will be disabled. The counter is globally initialized to"]
    #[doc = " RCUTILS_FAULT_INJECTION_NEVER_FAIL."]
    pub fn rcutils_fault_injection_set_count(count: int_least64_t);
}
extern "C" {
    #[doc = " \\brief Atomically get the fault injection counter value"]
    #[doc = ""]
    #[doc = " This function is typically not used directly but instead indirectly inside an"]
    #[doc = " `RCUTILS_FAULT_INJECTION_TEST`"]
    pub fn rcutils_fault_injection_get_count() -> int_least64_t;
}
extern "C" {
    #[doc = " \\brief Implementation of fault injection decrementer"]
    #[doc = ""]
    #[doc = " This is included inside of macros, so it needs to be exported as a public function, but it"]
    #[doc = " should not be used directly."]
    pub fn _rcutils_fault_injection_maybe_fail() -> int_least64_t;
}
#[doc = " Struct wrapping a fixed-size c string used for returning the formatted error string."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_error_string_t {
    #[doc = " The fixed-size C string used for returning the formatted error string."]
    pub str_: [::std::os::raw::c_char; 1024usize],
}
#[test]
fn bindgen_test_layout_rcutils_error_string_t() {
    assert_eq!(
        ::std::mem::size_of::<rcutils_error_string_t>(),
        1024usize,
        concat!("Size of: ", stringify!(rcutils_error_string_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcutils_error_string_t>(),
        1usize,
        concat!("Alignment of ", stringify!(rcutils_error_string_t))
    );
    fn test_field_str() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_error_string_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_error_string_t),
                "::",
                stringify!(str_)
            )
        );
    }
    test_field_str();
}
#[doc = " Struct which encapsulates the error state set by RCUTILS_SET_ERROR_MSG()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_error_state_t {
    #[doc = " User message storage, limited to RCUTILS_ERROR_STATE_MESSAGE_MAX_LENGTH characters."]
    pub message: [::std::os::raw::c_char; 768usize],
    #[doc = " File name, limited to what's left from RCUTILS_ERROR_STATE_MAX_SIZE characters"]
    #[doc = " after subtracting storage for others."]
    pub file: [::std::os::raw::c_char; 229usize],
    #[doc = " Line number of error."]
    pub line_number: u64,
}
#[test]
fn bindgen_test_layout_rcutils_error_state_t() {
    assert_eq!(
        ::std::mem::size_of::<rcutils_error_state_t>(),
        1008usize,
        concat!("Size of: ", stringify!(rcutils_error_state_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcutils_error_state_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcutils_error_state_t))
    );
    fn test_field_message() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_error_state_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_error_state_t),
                "::",
                stringify!(message)
            )
        );
    }
    test_field_message();
    fn test_field_file() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_error_state_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize
            },
            768usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_error_state_t),
                "::",
                stringify!(file)
            )
        );
    }
    test_field_file();
    fn test_field_line_number() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_error_state_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).line_number) as usize - ptr as usize
            },
            1000usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_error_state_t),
                "::",
                stringify!(line_number)
            )
        );
    }
    test_field_line_number();
}
extern "C" {
    #[doc = " Forces initialization of thread-local storage if called in a newly created thread."]
    #[doc = "* *"]
    #[doc = "* If this function is not called beforehand, then the first time the error"]
    #[doc = "* state is set or the first time the error message is retrieved, the default"]
    #[doc = "* allocator will be used to allocate thread-local storage."]
    #[doc = "* "]
    #[doc = "* This function may or may not allocate memory."]
    #[doc = "* The system's thread-local storage implementation may need to allocate"]
    #[doc = "* memory, since it usually has no way of knowing how much storage is needed"]
    #[doc = "* without knowing how many threads will be created."]
    #[doc = "* Most implementations (e.g. C11, C++11, and pthread) do not have ways to"]
    #[doc = "* specify how this memory is allocated, but if the implementation allows, the"]
    #[doc = "* given allocator to this function will be used, but is otherwise unused."]
    #[doc = "* This only occurs when creating and destroying threads, which can be avoided"]
    #[doc = "* in the \"steady\" state by reusing pools of threads."]
    #[doc = "* "]
    #[doc = "* It is worth considering that repeated thread creation and destruction will"]
    #[doc = "* result in repeated memory allocations and could result in memory"]
    #[doc = "* fragmentation."]
    #[doc = "* This is typically avoided anyways by using pools of threads."]
    #[doc = "* "]
    #[doc = "* In case an error is indicated by the return code, no error message will have"]
    #[doc = "* been set."]
    #[doc = "* "]
    #[doc = "* If called more than once in a thread, or after implicitly initialized by"]
    #[doc = "* setting the error state, it will still return `RCUTILS_RET_OK`, even"]
    #[doc = "* if the given allocator is invalid."]
    #[doc = "* Essentially this function does nothing if thread-local storage has already"]
    #[doc = "* been called."]
    #[doc = "* If already initialized, the given allocator is ignored, even if it does not"]
    #[doc = "* match the allocator used originally to initialize the thread-local storage."]
    #[doc = "* "]
    #[doc = "* \\param[in] allocator to be used to allocate and deallocate memory"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT if the allocator is invalid, or"]
    #[doc = "* \\return #RCUTILS_RET_BAD_ALLOC if allocating memory fails, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcutils_initialize_error_handling_thread_local_storage(
        allocator: rcutils_allocator_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Set the error message, as well as the file and line on which it occurred."]
    #[doc = "* *"]
    #[doc = "* This is not meant to be used directly, but instead via the"]
    #[doc = "* RCUTILS_SET_ERROR_MSG(msg) macro."]
    #[doc = "* "]
    #[doc = "* The error_msg parameter is copied into the internal error storage and must"]
    #[doc = "* be null terminated."]
    #[doc = "* The file parameter is copied into the internal error storage and must"]
    #[doc = "* be null terminated."]
    #[doc = "* "]
    #[doc = "* \\param[in] error_string The error message to set."]
    #[doc = "* \\param[in] file The path to the file in which the error occurred."]
    #[doc = "* \\param[in] line_number The line number on which the error occurred."]
    #[doc = "* /"]
    pub fn rcutils_set_error_state(
        error_string: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line_number: size_t,
    );
}
extern "C" {
    #[doc = " Return `true` if the error is set, otherwise `false`."]
    pub fn rcutils_error_is_set() -> bool;
}
extern "C" {
    #[doc = " Return an rcutils_error_state_t which was set with rcutils_set_error_state()."]
    #[doc = "* *"]
    #[doc = "* The returned pointer will be NULL if no error has been set in this thread."]
    #[doc = "* "]
    #[doc = "* The returned pointer is valid until RCUTILS_SET_ERROR_MSG, rcutils_set_error_state,"]
    #[doc = "* or rcutils_reset_error are called in the same thread."]
    #[doc = "* "]
    #[doc = "* \\return A pointer to the current error state struct."]
    #[doc = "* /"]
    pub fn rcutils_get_error_state() -> *const rcutils_error_state_t;
}
extern "C" {
    #[doc = " Return the error message followed by `, at <file>:<line>` if set, else \"error not set\"."]
    #[doc = "* *"]
    #[doc = "* This function is \"safe\" because it returns a copy of the current error"]
    #[doc = "* string or one containing the string \"error not set\" if no error was set."]
    #[doc = "* This ensures that the copy is owned by the calling thread and is therefore"]
    #[doc = "* never invalidated by other error handling calls, and that the C string"]
    #[doc = "* inside is always valid and null terminated."]
    #[doc = "* "]
    #[doc = "* \\return The current error string, with file and line number, or \"error not set\" if not set."]
    #[doc = "* /"]
    pub fn rcutils_get_error_string() -> rcutils_error_string_t;
}
extern "C" {
    #[doc = " Reset the error state by clearing any previously set error state."]
    pub fn rcutils_reset_error();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_array_list_impl_t {
    _unused: [u8; 0],
}
#[doc = " The structure holding the metadata for an array list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_array_list_t {
    #[doc = " A pointer to the PIMPL implementation type."]
    pub impl_: *mut rcutils_array_list_impl_t,
}
#[test]
fn bindgen_test_layout_rcutils_array_list_t() {
    assert_eq!(
        ::std::mem::size_of::<rcutils_array_list_t>(),
        8usize,
        concat!("Size of: ", stringify!(rcutils_array_list_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcutils_array_list_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcutils_array_list_t))
    );
    fn test_field_impl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_array_list_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_array_list_t),
                "::",
                stringify!(impl_)
            )
        );
    }
    test_field_impl();
}
extern "C" {
    #[doc = " Return an empty array_list struct."]
    #[doc = "* *"]
    #[doc = "* This function returns an empty and zero initialized array_list struct."]
    #[doc = "* Calling rcutils_array_list_fini() on any non-initialized instance leads"]
    #[doc = "* to undefined behavior."]
    #[doc = "* Every instance of array_list_t has to either be zero_initialized with this"]
    #[doc = "* function or manually allocated."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* Example:"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* rcutils_array_list_t foo;"]
    #[doc = "* rcutils_array_list_fini(&foo); // undefined behavior!"]
    #[doc = "* "]
    #[doc = "* rcutils_array_list_t bar = rcutils_get_zero_initialized_array_list();"]
    #[doc = "* rcutils_array_list_fini(&bar); // ok"]
    #[doc = "* ```"]
    #[doc = "* /"]
    pub fn rcutils_get_zero_initialized_array_list() -> rcutils_array_list_t;
}
extern "C" {
    #[doc = " Initialize an array list with a given initial capacity."]
    #[doc = "* *"]
    #[doc = "* This function will initialize a given, zero initialized, array_list to"]
    #[doc = "* a given size."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* Example:"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* rcutils_allocator_t allocator = rcutils_get_default_allocator();"]
    #[doc = "* rcutils_array_list_t array_list = rcutils_get_zero_initialized_array_list();"]
    #[doc = "* rcutils_ret_t ret = rcutils_array_list_init(&array_list, 2, sizeof(int), &allocator);"]
    #[doc = "* if (ret != RCUTILS_RET_OK) {"]
    #[doc = "* // ... error handling"]
    #[doc = "* }"]
    #[doc = "* int data = 42;"]
    #[doc = "* int out_data = 0;"]
    #[doc = "* ret = rcutils_array_list_add(&array_list, &data);"]
    #[doc = "* data++;"]
    #[doc = "* ret = rcutils_array_list_get(&array_list, 0, &out_data);"]
    #[doc = "* assert(42 == out_data);"]
    #[doc = "* ret = rcutils_array_list_fini(&array_list);"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* \\param[inout] array_list object to be initialized"]
    #[doc = "* \\param[in] initial_capacity the initial capacity to allocate in the list"]
    #[doc = "* \\param[in] data_size the size (in bytes) of the data object being stored in the list"]
    #[doc = "* \\param[in] allocator to be used to allocate and deallocate memory"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_array_list_init(
        array_list: *mut rcutils_array_list_t,
        initial_capacity: size_t,
        data_size: size_t,
        allocator: *const rcutils_allocator_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Finalize an array list, reclaiming all resources."]
    #[doc = "* *"]
    #[doc = "* This function reclaims any memory owned by the array list."]
    #[doc = "* "]
    #[doc = "* The allocator used to initialize the array list is used to deallocate each"]
    #[doc = "* entry in the list and the list itself."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] array_list object to be finalized"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_array_list_fini(array_list: *mut rcutils_array_list_t) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Adds an entry to the list"]
    #[doc = "* *"]
    #[doc = "* This function adds the provided data to the end of the list. A shallow copy of"]
    #[doc = "* the provided data is made to store in the list instead of just storing"]
    #[doc = "* the pointer to the provided data."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] array_list to add the data to"]
    #[doc = "* \\param[in] data a pointer to the data to add to the list"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_array_list_add(
        array_list: *mut rcutils_array_list_t,
        data: *const ::std::os::raw::c_void,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Sets an entry in the list to the provided data"]
    #[doc = "* *"]
    #[doc = "* This function sets the provided data at the specified index in the list."]
    #[doc = "* A shallow copy of the provided data is made to store in the list instead"]
    #[doc = "* of just storing the pointer to the provided data."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] array_list to add the data to"]
    #[doc = "* \\param[in] index the position in the list to set the data"]
    #[doc = "* \\param[in] data a pointer to the data that will be set in the list"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT if index out of bounds, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_array_list_set(
        array_list: *mut rcutils_array_list_t,
        index: size_t,
        data: *const ::std::os::raw::c_void,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Removes an entry in the list at the provided index"]
    #[doc = "* *"]
    #[doc = "* This function removes data from the list at the specified index. The capacity"]
    #[doc = "* of the list will never decrease when entries are removed."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] array_list to add the data to"]
    #[doc = "* \\param[in] index the index of the item to remove from the list"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT if index out of bounds, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_array_list_remove(
        array_list: *mut rcutils_array_list_t,
        index: size_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Retrieves an entry in the list at the provided index"]
    #[doc = "* *"]
    #[doc = "* This function retrieves a copy of the data stored in the list at the provided index."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* "]
    #[doc = "* \\param[in] array_list to add the data to"]
    #[doc = "* \\param[in] index the index at which to get the data"]
    #[doc = "* \\param[out] data a copy of the data stored in the list"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_array_list_get(
        array_list: *const rcutils_array_list_t,
        index: size_t,
        data: *mut ::std::os::raw::c_void,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Retrieves the size of the provided array_list"]
    #[doc = "* *"]
    #[doc = "* This function retrieves the number of items in the provided array list"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* "]
    #[doc = "* \\param[in] array_list list to get the size of"]
    #[doc = "* \\param[out] size The number of items currently stored in the list"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_array_list_get_size(
        array_list: *const rcutils_array_list_t,
        size: *mut size_t,
    ) -> rcutils_ret_t;
}
#[doc = " The structure holding the metadata for a char array."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_char_array_t {
    #[doc = " A pointer to the allocated memory for this char array."]
    pub buffer: *mut ::std::os::raw::c_char,
    #[doc = " if this is true, we may safely free/realloc the buffer as needed;"]
    #[doc = " otherwise we will leave the buffer alone and alloc new memory if"]
    #[doc = " more space is needed"]
    pub owns_buffer: bool,
    #[doc = " The length of the data stored in the buffer pointer."]
    pub buffer_length: size_t,
    #[doc = " The maximum capacity of the buffer pointer."]
    pub buffer_capacity: size_t,
    #[doc = " The allocator used to allocate and free the data in the pointer."]
    pub allocator: rcutils_allocator_t,
}
#[test]
fn bindgen_test_layout_rcutils_char_array_t() {
    assert_eq!(
        ::std::mem::size_of::<rcutils_char_array_t>(),
        72usize,
        concat!("Size of: ", stringify!(rcutils_char_array_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcutils_char_array_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcutils_char_array_t))
    );
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_char_array_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_char_array_t),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
    fn test_field_owns_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_char_array_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).owns_buffer) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_char_array_t),
                "::",
                stringify!(owns_buffer)
            )
        );
    }
    test_field_owns_buffer();
    fn test_field_buffer_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_char_array_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer_length) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_char_array_t),
                "::",
                stringify!(buffer_length)
            )
        );
    }
    test_field_buffer_length();
    fn test_field_buffer_capacity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_char_array_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer_capacity) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_char_array_t),
                "::",
                stringify!(buffer_capacity)
            )
        );
    }
    test_field_buffer_capacity();
    fn test_field_allocator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_char_array_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_char_array_t),
                "::",
                stringify!(allocator)
            )
        );
    }
    test_field_allocator();
}
extern "C" {
    #[doc = " Return a zero initialized char array struct."]
    #[doc = "* *"]
    #[doc = "* \\return rcutils_char_array_t a zero initialized char array struct"]
    #[doc = "* /"]
    pub fn rcutils_get_zero_initialized_char_array() -> rcutils_char_array_t;
}
extern "C" {
    #[doc = " Initialize a zero initialized char array struct."]
    #[doc = "* *"]
    #[doc = "* This function may leak if the char array struct is already"]
    #[doc = "* pre-initialized."]
    #[doc = "* If the capacity is set to 0, no memory is allocated and the internal buffer"]
    #[doc = "* is still NULL."]
    #[doc = "* "]
    #[doc = "* \\param[in] char_array a pointer to the to be initialized char array struct"]
    #[doc = "* \\param[in] buffer_capacity the size of the memory to allocate for the byte stream"]
    #[doc = "* \\param[in] allocator the allocator to use for the memory allocation"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCUTILS_RET_BAD_ALLOC if no memory could be allocated correctly"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rcutils_char_array_init(
        char_array: *mut rcutils_char_array_t,
        buffer_capacity: size_t,
        allocator: *const rcutils_allocator_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Finalize a char array struct."]
    #[doc = "* *"]
    #[doc = "* Cleans up and deallocates any resources owned by rcutils_char_array_t."]
    #[doc = "* The array passed to this function needs to have been initialized by"]
    #[doc = "* rcutils_char_array_init()."]
    #[doc = "* If .owns_buffer is false, this function has no effect because that"]
    #[doc = "* implies that the char_array does not own the internal buffer."]
    #[doc = "* Passing an uninitialized instance to this function leads to undefined"]
    #[doc = "* behavior."]
    #[doc = "* "]
    #[doc = "* \\param[in] char_array pointer to the rcutils_char_array_t to be cleaned up"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT if the char_array argument is invalid"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rcutils_char_array_fini(char_array: *mut rcutils_char_array_t) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Resize the internal buffer of the char array."]
    #[doc = "* *"]
    #[doc = "* The internal buffer of the char array can be resized dynamically if needed."]
    #[doc = "* If the new size is smaller than the current capacity, then the memory is"]
    #[doc = "* truncated."]
    #[doc = "* Be aware, that this will deallocate the memory and therefore invalidates any"]
    #[doc = "* pointers to this storage."]
    #[doc = "* If the new size is larger, new memory is getting allocated and the existing"]
    #[doc = "* content is copied over."]
    #[doc = "* Note that if the array doesn't own the current buffer the function just"]
    #[doc = "* allocates a new block of memory and copies the contents of the old buffer"]
    #[doc = "* instead of resizing the existing buffer."]
    #[doc = "* "]
    #[doc = "* \\param[in] char_array pointer to the instance of rcutils_char_array_t which is being resized"]
    #[doc = "* \\param[in] new_size the new size of the internal buffer"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT if new_size is set to zero"]
    #[doc = "* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rcutils_char_array_resize(
        char_array: *mut rcutils_char_array_t,
        new_size: size_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Expand the internal buffer of the char array."]
    #[doc = "* *"]
    #[doc = "* This function is equivalent to `rcutils_char_array_resize` except that it resizes"]
    #[doc = "* the internal buffer only when it is not big enough."]
    #[doc = "* If the buffer is already big enough for `new_size`, it returns `RCUTILS_RET_OK` without"]
    #[doc = "* doing anything."]
    #[doc = "* "]
    #[doc = "* \\param[inout] char_array pointer to the instance of rcutils_char_array_t which is being resized"]
    #[doc = "* \\param[in] new_size the new size of the internal buffer"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rcutils_char_array_expand_as_needed(
        char_array: *mut rcutils_char_array_t,
        new_size: size_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Produce output according to format and args."]
    #[doc = "* *"]
    #[doc = "* This function is equivalent to `vsprintf(char_array->buffer, format, args)`"]
    #[doc = "* except that the buffer grows as needed so a user doesn't have to deal with"]
    #[doc = "* memory management."]
    #[doc = "* The `va_list args` will be cloned before being used, so a user can safely"]
    #[doc = "* use it again after calling this function."]
    #[doc = "* "]
    #[doc = "* \\param[inout] char_array pointer to the instance of rcutils_char_array_t which is being"]
    #[doc = "* written to"]
    #[doc = "* \\param[in] format the format string used by the underlying `vsnprintf`"]
    #[doc = "* \\param[in] args the `va_list` used by the underlying `vsnprintf`"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rcutils_char_array_vsprintf(
        char_array: *mut rcutils_char_array_t,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Append a string (or part of it) to the string in buffer."]
    #[doc = "* *"]
    #[doc = "* This function treats the internal buffer as a string and appends the src string to it."]
    #[doc = "* If src is longer than n, n bytes will be used and an extra null byte will be appended."]
    #[doc = "* It is virtually equivalent to `strncat(char_array->buffer, src, n)` except that the buffer"]
    #[doc = "* grows as needed so a user doesn't have to deal with memory management."]
    #[doc = "* "]
    #[doc = "* \\param[inout] char_array pointer to the instance of rcutils_char_array_t which is being appended to"]
    #[doc = "* \\param[in] src the string to be appended to the end of the string in buffer"]
    #[doc = "* \\param[in] n it uses at most n bytes from the src string"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rcutils_char_array_strncat(
        char_array: *mut rcutils_char_array_t,
        src: *const ::std::os::raw::c_char,
        n: size_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Append a string to the string in buffer."]
    #[doc = "* *"]
    #[doc = "* This function treats the internal buffer as a string and appends the src string to it."]
    #[doc = "* It is virtually equivalent to `strcat(char_array->buffer, src)` except that the buffer"]
    #[doc = "* grows as needed. That is to say, a user can safely use it without doing calculation or"]
    #[doc = "* checks on the sizes of the src and buffer."]
    #[doc = "* "]
    #[doc = "* \\param[inout] char_array pointer to the instance of rcutils_char_array_t which is being"]
    #[doc = "* appended to"]
    #[doc = "* \\param[in] src the string to be appended to the end of the string in buffer"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rcutils_char_array_strcat(
        char_array: *mut rcutils_char_array_t,
        src: *const ::std::os::raw::c_char,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Copy memory to buffer."]
    #[doc = "* *"]
    #[doc = "* This function is equivalent to `memcpy(char_array->buffer, src, n)` except that the buffer"]
    #[doc = "* grows as needed so a user doesn't have to worry about overflow."]
    #[doc = "* "]
    #[doc = "* \\param[inout] char_array pointer to the instance of rcutils_char_array_t which is being resized"]
    #[doc = "* \\param[in] src the memory to be copied from"]
    #[doc = "* \\param[in] n a total of n bytes will be copied"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rcutils_char_array_memcpy(
        char_array: *mut rcutils_char_array_t,
        src: *const ::std::os::raw::c_char,
        n: size_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Copy a string to buffer."]
    #[doc = "* *"]
    #[doc = "* This function is equivalent to `strcpy(char_array->buffer, src)` except that the buffer"]
    #[doc = "* grows as needed so that `src` will fit without overflow."]
    #[doc = "* "]
    #[doc = "* \\param[inout] char_array pointer to the instance of rcutils_char_array_t which is being"]
    #[doc = "* copied to"]
    #[doc = "* \\param[in] src the string to be copied from"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rcutils_char_array_strcpy(
        char_array: *mut rcutils_char_array_t,
        src: *const ::std::os::raw::c_char,
    ) -> rcutils_ret_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_hash_map_impl_t {
    _unused: [u8; 0],
}
#[doc = " The structure holding the metadata for a hash map."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_hash_map_t {
    #[doc = " A pointer to the PIMPL implementation type."]
    pub impl_: *mut rcutils_hash_map_impl_t,
}
#[test]
fn bindgen_test_layout_rcutils_hash_map_t() {
    assert_eq!(
        ::std::mem::size_of::<rcutils_hash_map_t>(),
        8usize,
        concat!("Size of: ", stringify!(rcutils_hash_map_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcutils_hash_map_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcutils_hash_map_t))
    );
    fn test_field_impl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_hash_map_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_hash_map_t),
                "::",
                stringify!(impl_)
            )
        );
    }
    test_field_impl();
}
#[doc = " The function signature for a key hashing function."]
#[doc = "* *"]
#[doc = "* \\param[in] key The key that needs to be hashed"]
#[doc = "* \\return A hash value for the provided string"]
#[doc = "* /"]
pub type rcutils_hash_map_key_hasher_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void) -> size_t>;
#[doc = " The function signature for a key comparison function."]
#[doc = "* *"]
#[doc = "* \\param[in] val1 The first value to compare"]
#[doc = "* \\param[in] val2 The second value to compare"]
#[doc = "* \\return A negative number if val1 < val2, or"]
#[doc = "* \\return A positve number if val1 > val2, or"]
#[doc = "* \\return Zero if val1 == val2."]
#[doc = "* /"]
pub type rcutils_hash_map_key_cmp_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " A hashing function for a null terminated c string."]
    #[doc = "* *"]
    #[doc = "* A hashing function for a null terminated c string."]
    #[doc = "* Should be used when your key is just a pointer to a c-string"]
    #[doc = "* /"]
    pub fn rcutils_hash_map_string_hash_func(key_str: *const ::std::os::raw::c_void) -> size_t;
}
extern "C" {
    #[doc = " A comparison function for a null terminated c string."]
    #[doc = "* *"]
    #[doc = "* A comparison function for a null terminated c string."]
    #[doc = "* Should be used when your key is just a pointer to a c-string"]
    #[doc = "* /"]
    pub fn rcutils_hash_map_string_cmp_func(
        val1: *const ::std::os::raw::c_void,
        val2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return an empty hash_map struct."]
    #[doc = "* *"]
    #[doc = "* This function returns an empty and zero initialized hash_map struct."]
    #[doc = "* All hash maps should be initialized with this or manually initialized"]
    #[doc = "* before being used."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* Example:"]
    #[doc = "* ```c"]
    #[doc = "* // Do not do this:"]
    #[doc = "* // rcutils_hash_map_t foo;"]
    #[doc = "* // rcutils_hash_map_fini(&foo); // undefined behavior!"]
    #[doc = "* "]
    #[doc = "* // Do this instead:"]
    #[doc = "* rcutils_hash_map_t bar = rcutils_get_zero_initialized_hash_map();"]
    #[doc = "* rcutils_hash_map_fini(&bar); // ok"]
    #[doc = "* ```"]
    #[doc = "* */"]
    pub fn rcutils_get_zero_initialized_hash_map() -> rcutils_hash_map_t;
}
extern "C" {
    #[doc = " Initialize a rcutils_hash_map_t, allocating space for given capacity."]
    #[doc = "* *"]
    #[doc = "* This function initializes the rcutils_hash_map_t with a given initial"]
    #[doc = "* capacity for entries."]
    #[doc = "* Note this does not allocate space for keys or values in the hash_map, just the"]
    #[doc = "* arrays of pointers to the keys and values."]
    #[doc = "* rcutils_hash_map_set() should still be used when assigning values."]
    #[doc = "* "]
    #[doc = "* The hash_map argument should point to allocated memory and should have"]
    #[doc = "* been zero initialized with rcutils_get_zero_initialized_hash_map()."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* Example:"]
    #[doc = "* ```c"]
    #[doc = "* rcutils_hash_map_t hash_map = rcutils_get_zero_initialized_hash_map();"]
    #[doc = "* rcutils_ret_t ret ="]
    #[doc = "* rcutils_hash_map_init(&hash_map, 10, rcutils_get_default_allocator());"]
    #[doc = "* if (ret != RCUTILS_RET_OK) {"]
    #[doc = "* // ... do error handling"]
    #[doc = "* }"]
    #[doc = "* // ... use the hash_map and when done:"]
    #[doc = "* ret = rcutils_hash_map_fini(&hash_map);"]
    #[doc = "* if (ret != RCUTILS_RET_OK) {"]
    #[doc = "* // ... do error handling"]
    #[doc = "* }"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* \\param[inout] hash_map rcutils_hash_map_t to be initialized"]
    #[doc = "* \\param[in] initial_capacity the amount of initial capacity for the hash_map"]
    #[doc = "* \\param[in] key_size the size (in bytes) of the key used to index the data"]
    #[doc = "* \\param[in] data_size the size (in bytes) of the data being stored"]
    #[doc = "* \\param[in] key_hashing_func a function that returns a hashed value for a key"]
    #[doc = "* \\param[in] key_cmp_func a function used to compare keys"]
    #[doc = "* \\param[in] allocator the allocator to use through out the lifetime of the hash_map"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or"]
    #[doc = "* \\return #RCUTILS_RET_STRING_MAP_ALREADY_INIT if alread initialized, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_hash_map_init(
        hash_map: *mut rcutils_hash_map_t,
        initial_capacity: size_t,
        key_size: size_t,
        data_size: size_t,
        key_hashing_func: rcutils_hash_map_key_hasher_t,
        key_cmp_func: rcutils_hash_map_key_cmp_t,
        allocator: *const rcutils_allocator_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Finalize the previously initialized hash_map struct."]
    #[doc = "* *"]
    #[doc = "* This function will free any resources which were created when initializing"]
    #[doc = "* or when calling rcutils_hash_map_set()."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] hash_map rcutils_hash_map_t to be finalized"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_hash_map_fini(hash_map: *mut rcutils_hash_map_t) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Get the current capacity of the hash_map."]
    #[doc = "* *"]
    #[doc = "* This function will return the internal capacity of the hash_map, which is the"]
    #[doc = "* number of buckets the hash_map uses to sort the keys."]
    #[doc = "* The capacity does not indicate how many key value pairs are stored in the"]
    #[doc = "* hash_map, the rcutils_hash_map_get_size() function can provide that, nor the"]
    #[doc = "* maximum number that can be stored without increasing the capacity."]
    #[doc = "* The capacity can be set initially with rcutils_hash_map_init()."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] hash_map rcutils_hash_map_t to be queried"]
    #[doc = "* \\param[out] capacity capacity of the hash_map"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_NOT_INITIALIZED if the hash_map is invalid, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_hash_map_get_capacity(
        hash_map: *const rcutils_hash_map_t,
        capacity: *mut size_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Get the current size of the hash_map."]
    #[doc = "* *"]
    #[doc = "* This function will return the internal size of the hash_map, which is the"]
    #[doc = "* current number of key value pairs in the hash_map."]
    #[doc = "* The size is changed when calling rcutils_hash_map_set() or rcutils_hash_map_unset()."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] hash_map rcutils_hash_map_t to be queried"]
    #[doc = "* \\param[out] size size of the hash_map"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_NOT_INITIALIZED if the hash_map is invalid, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_hash_map_get_size(
        hash_map: *const rcutils_hash_map_t,
        size: *mut size_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Set a key value pair in the hash_map, increasing capacity if necessary."]
    #[doc = "* *"]
    #[doc = "* If the key already exists in the map then the value is updated to the new value"]
    #[doc = "* provided. If it does not already exist then a new entry is added for the new key"]
    #[doc = "* and value. The capacity will be increased if needed."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] hash_map rcutils_hash_map_t to be updated"]
    #[doc = "* \\param[in] key hash_map key"]
    #[doc = "* \\param[in] value value for given hash_map key"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or"]
    #[doc = "* \\return #RCUTILS_RET_NOT_INITIALIZED if the hash_map is invalid, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_hash_map_set(
        hash_map: *mut rcutils_hash_map_t,
        key: *const ::std::os::raw::c_void,
        value: *const ::std::os::raw::c_void,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Unset a key value pair in the hash_map."]
    #[doc = "* *"]
    #[doc = "* Unsets the key value pair in the hash_map and frees any internal resources allocated"]
    #[doc = "* for the entry. This function will never decrease the capacity when removing keys."]
    #[doc = "* If the given key is not found, RCUTILS_RET_STRING_KEY_NOT_FOUND is returned."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] hash_map rcutils_hash_map_t to be updated"]
    #[doc = "* \\param[in] key hash_map key, must be null terminated c string"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_NOT_INITIALIZED if the hash_map is invalid, or"]
    #[doc = "* \\return #RCUTILS_RET_STRING_KEY_NOT_FOUND if the key is not found in the map, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_hash_map_unset(
        hash_map: *mut rcutils_hash_map_t,
        key: *const ::std::os::raw::c_void,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Get whether or not a key exists."]
    #[doc = "* *"]
    #[doc = "* Returns true if the provided key exists in the hash_map or false if it does not or"]
    #[doc = "* if the hash_map or key are invalid."]
    #[doc = "* In all cases no error message is set."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] hash_map rcutils_hash_map_t to be searched"]
    #[doc = "* \\param[in] key hash_map key, must be null terminated c string"]
    #[doc = "* \\return `true` if key is in the hash_map, or"]
    #[doc = "* \\return `false` if key is not in the hash_map, or"]
    #[doc = "* \\return `false` for invalid arguments, or"]
    #[doc = "* \\return `false` if the hash_map is invalid."]
    #[doc = "* /"]
    pub fn rcutils_hash_map_key_exists(
        hash_map: *const rcutils_hash_map_t,
        key: *const ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Get value given a key."]
    #[doc = "* *"]
    #[doc = "* This function can be used to retrieve a shallow copy of the stored data. The data"]
    #[doc = "* pointer must point to a section of memory large enough to copy the full size of"]
    #[doc = "* the data being stored, which is specified when the hash_map in initialized."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] hash_map rcutils_hash_map_t to be searched"]
    #[doc = "* \\param[in] key hash_map key to look up the data for"]
    #[doc = "* \\param[out] data A copy of the data stored in the map"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_NOT_INITIALIZED if the hash_map is invalid, or"]
    #[doc = "* \\return #RCUTILS_RET_NOT_FOUND if the key doesn't exist in the map, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_hash_map_get(
        hash_map: *const rcutils_hash_map_t,
        key: *const ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Get the next key in the hash_map, unless NULL is given, then get the first key."]
    #[doc = "* *"]
    #[doc = "* This function allows you to iteratively get each key/value pair in the hash_map."]
    #[doc = "* "]
    #[doc = "* If NULL is given for the previous_key, then the first key in the hash_map is returned."]
    #[doc = "* If that returned key is given as the previous_key for the next call to this function,"]
    #[doc = "* then the next key in the hash_map is returned."]
    #[doc = "* If there are no more keys in the hash_map or if the given key is not in the hash_map,"]
    #[doc = "* an error will be returned."]
    #[doc = "* "]
    #[doc = "* The order of the keys in the hash_map is arbitrary and if the hash_map is modified"]
    #[doc = "* between calls to this function the behavior is undefined."]
    #[doc = "* If the hash_map is modified then iteration should begin again by passing NULL to"]
    #[doc = "* get the first key again."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* Example:"]
    #[doc = "* ```c"]
    #[doc = "* printf(\"entries in the hash_map:\\n\");"]
    #[doc = "* int key = 0, data = 0;"]
    #[doc = "* rcutils_ret_t status = rcutils_hash_map_get_next_key(&hash_map, NULL, &key, &data);"]
    #[doc = "* while (RCUTILS_RET_OK == status) {"]
    #[doc = "* printf(\"%i: %i\\n\", key, data);"]
    #[doc = "* status = rcutils_hash_map_get_next_key(&hash_map, &key, &key, &data);"]
    #[doc = "* }"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* \\param[in] hash_map rcutils_hash_map_t to be queried"]
    #[doc = "* \\param[in] previous_key NULL to get the first key or the previous key to get the next for"]
    #[doc = "* \\param[out] key A copy of the next key in the sequence"]
    #[doc = "* \\param[out] data A copy of the next data in the sequence"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_NOT_INITIALIZED if the hash_map is invalid, or"]
    #[doc = "* \\return #RCUTILS_RET_NOT_FOUND if the previous_key doesn't exist in the map, or"]
    #[doc = "* \\return #RCUTILS_RET_HASH_MAP_NO_MORE_ENTRIES if there is no more data beyound the previous_key, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_hash_map_get_next_key_and_data(
        hash_map: *const rcutils_hash_map_t,
        previous_key: *const ::std::os::raw::c_void,
        key: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Interface to qsort with rcutils-style argument validation."]
    #[doc = "* *"]
    #[doc = "* This function changes the order of the elements in the array so that they"]
    #[doc = "* are in ascending order according to the given comparison function."]
    #[doc = "* "]
    #[doc = "* This function is thread-safe."]
    #[doc = "* "]
    #[doc = "* \\param[inout] ptr object whose elements should be sorted."]
    #[doc = "* \\param[in] count number of elements present in the object."]
    #[doc = "* \\param[in] size size of each element, in bytes."]
    #[doc = "* \\param[in] comp function used to compare two elements."]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_qsort(
        ptr: *mut ::std::os::raw::c_void,
        count: size_t,
        size: size_t,
        comp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> rcutils_ret_t;
}
#[doc = " The structure holding the metadata for a string array."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_string_array_t {
    #[doc = " The number of strings that can be stored in the string array."]
    pub size: size_t,
    #[doc = " The allocated memory for the string array."]
    pub data: *mut *mut ::std::os::raw::c_char,
    #[doc = " The allocator used to allocate and free memory for the string array."]
    pub allocator: rcutils_allocator_t,
}
#[test]
fn bindgen_test_layout_rcutils_string_array_t() {
    assert_eq!(
        ::std::mem::size_of::<rcutils_string_array_t>(),
        56usize,
        concat!("Size of: ", stringify!(rcutils_string_array_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcutils_string_array_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcutils_string_array_t))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_string_array_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_string_array_t),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_string_array_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_string_array_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_allocator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_string_array_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_string_array_t),
                "::",
                stringify!(allocator)
            )
        );
    }
    test_field_allocator();
}
extern "C" {
    #[doc = " Return an empty string array struct."]
    #[doc = "* *"]
    #[doc = "* This function returns an empty and zero initialized string array struct."]
    #[doc = "* Calling rcutils_string_array_fini() on any non-initialized instance leads"]
    #[doc = "* to undefined behavior."]
    #[doc = "* Every instance of string_array_t has to either be zero_initialized with this"]
    #[doc = "* function or manually allocated."]
    #[doc = "* "]
    #[doc = "* Example:"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* rcutils_string_array_t foo;"]
    #[doc = "* rcutils_string_array_fini(&foo); // undefined behavior!"]
    #[doc = "* "]
    #[doc = "* rcutils_string_array_t bar = rcutils_get_zero_initialized_string_array();"]
    #[doc = "* rcutils_string_array_fini(&bar); // ok"]
    #[doc = "* ```"]
    #[doc = "* /"]
    pub fn rcutils_get_zero_initialized_string_array() -> rcutils_string_array_t;
}
extern "C" {
    #[doc = " Initialize a string array with a given size."]
    #[doc = "* *"]
    #[doc = "* This function will initialize a given, zero initialized, string array to"]
    #[doc = "* a given size."]
    #[doc = "* "]
    #[doc = "* Note that putting a string into the array gives owenship to the array."]
    #[doc = "* "]
    #[doc = "* Example:"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* rcutils_allocator_t allocator = rcutils_get_default_allocator();"]
    #[doc = "* rcutils_string_array_t string_array = rcutils_get_zero_initialized_string_array();"]
    #[doc = "* rcutils_ret_t ret = rcutils_string_array_init(&string_array, 2, &allocator);"]
    #[doc = "* if (ret != RCUTILS_RET_OK) {"]
    #[doc = "* // ... error handling"]
    #[doc = "* }"]
    #[doc = "* string_array.data[0] = rcutils_strdup(\"Hello\", &allocator);"]
    #[doc = "* string_array.data[1] = rcutils_strdup(\"World\", &allocator);"]
    #[doc = "* ret = rcutils_string_array_fini(&string_array);"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* \\param[inout] string_array object to be initialized"]
    #[doc = "* \\param[in] size the size the array should be"]
    #[doc = "* \\param[in] allocator to be used to allocate and deallocate memory"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_string_array_init(
        string_array: *mut rcutils_string_array_t,
        size: size_t,
        allocator: *const rcutils_allocator_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Finalize a string array, reclaiming all resources."]
    #[doc = "* *"]
    #[doc = "* This function reclaims any memory owned by the string array, including the"]
    #[doc = "* strings it references."]
    #[doc = "* "]
    #[doc = "* The allocator used to initialize the string array is used to deallocate each"]
    #[doc = "* string in the array and the array of strings itself."]
    #[doc = "* "]
    #[doc = "* \\param[inout] string_array object to be finalized"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_string_array_fini(string_array: *mut rcutils_string_array_t) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Compare two string arrays."]
    #[doc = "* *"]
    #[doc = "* The two string arrays are compared according to lexicographical order."]
    #[doc = "* "]
    #[doc = "* \\param[in] lhs The first string array."]
    #[doc = "* \\param[in] rhs The second string array."]
    #[doc = "* \\param[out] res Negative value if `lhs` appears before `rhs` in lexicographical order."]
    #[doc = "* Zero if `lhs` and `rhs` are equal."]
    #[doc = "* Positive value if `lhs` appears after `rhs` in lexographical order."]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT if any argument is `NULL, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT if `lhs->data` or `rhs->data` is `NULL, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_string_array_cmp(
        lhs: *const rcutils_string_array_t,
        rhs: *const rcutils_string_array_t,
        res: *mut ::std::os::raw::c_int,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Resize a string array, reclaiming removed resources."]
    #[doc = "* *"]
    #[doc = "* This function changes the size of an existing string array."]
    #[doc = "* If the new size is larger, new entries are added to the end of the array and"]
    #[doc = "* are zero- initialized."]
    #[doc = "* If the new size is smaller, entries are removed from the end of the array"]
    #[doc = "* and their resources reclaimed."]
    #[doc = "* "]
    #[doc = "* \\par Note:"]
    #[doc = "* Resizing to 0 is not a substitute for calling ::rcutils_string_array_fini."]
    #[doc = "* "]
    #[doc = "* \\par Note:"]
    #[doc = "* If this function fails, \\p string_array remains unchanged and should still"]
    #[doc = "* be reclaimed with ::rcutils_string_array_fini."]
    #[doc = "* "]
    #[doc = "* \\param[inout] string_array object to be resized."]
    #[doc = "* \\param[in] new_size the size the array should be changed to."]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_string_array_resize(
        string_array: *mut rcutils_string_array_t,
        new_size: size_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Lexicographic comparer for pointers to string pointers."]
    #[doc = "* *"]
    #[doc = "* This functions compares pointers to string pointers lexicographically"]
    #[doc = "* ascending."]
    #[doc = "* "]
    #[doc = "* \\param[in] lhs pointer to the first string pointer."]
    #[doc = "* \\param[in] rhs pointer to the second string pointer."]
    #[doc = "* \\return <0 if lhs is lexicographically lower, or"]
    #[doc = "* \\return 0 if the strings are the same, or"]
    #[doc = "* \\return >0 if lhs is lexicographically higher."]
    #[doc = "* /"]
    pub fn rcutils_string_array_sort_compare(
        lhs: *const ::std::os::raw::c_void,
        rhs: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_string_map_impl_t {
    _unused: [u8; 0],
}
#[doc = " The structure holding the metadata for a string map."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_string_map_t {
    #[doc = " A pointer to the PIMPL implementation type."]
    pub impl_: *mut rcutils_string_map_impl_t,
}
#[test]
fn bindgen_test_layout_rcutils_string_map_t() {
    assert_eq!(
        ::std::mem::size_of::<rcutils_string_map_t>(),
        8usize,
        concat!("Size of: ", stringify!(rcutils_string_map_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcutils_string_map_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcutils_string_map_t))
    );
    fn test_field_impl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_string_map_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_string_map_t),
                "::",
                stringify!(impl_)
            )
        );
    }
    test_field_impl();
}
extern "C" {
    #[doc = " Return an empty string map struct."]
    #[doc = "* *"]
    #[doc = "* This function returns an empty and zero initialized string map struct."]
    #[doc = "* "]
    #[doc = "* Example:"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* // Do not do this:"]
    #[doc = "* // rcutils_string_map_t foo;"]
    #[doc = "* // rcutils_string_map_fini(&foo); // undefined behavior!"]
    #[doc = "* "]
    #[doc = "* // Do this instead:"]
    #[doc = "* rcutils_string_map_t bar = rcutils_get_zero_initialized_string_map();"]
    #[doc = "* rcutils_string_map_fini(&bar); // ok"]
    #[doc = "* ```"]
    #[doc = "* */"]
    pub fn rcutils_get_zero_initialized_string_map() -> rcutils_string_map_t;
}
extern "C" {
    #[doc = " Initialize a rcutils_string_map_t, allocating space for given capacity."]
    #[doc = "* *"]
    #[doc = "* This function initializes the rcutils_string_map_t with a given initial"]
    #[doc = "* capacity for entries."]
    #[doc = "* Note this does not allocate space for keys or values in the map, just the"]
    #[doc = "* arrays of pointers to the keys and values."]
    #[doc = "* rcutils_string_map_set() should still be used when assigning values."]
    #[doc = "* "]
    #[doc = "* The string_map argument should point to allocated memory and should have"]
    #[doc = "* been zero initialized with rcutils_get_zero_initialized_string_map()."]
    #[doc = "* For example:"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* rcutils_string_map_t string_map = rcutils_get_zero_initialized_string_map();"]
    #[doc = "* rcutils_ret_t ret ="]
    #[doc = "* rcutils_string_map_init(&string_map, 10, rcutils_get_default_allocator());"]
    #[doc = "* if (ret != RCUTILS_RET_OK) {"]
    #[doc = "* // ... do error handling"]
    #[doc = "* }"]
    #[doc = "* // ... use the string map and when done:"]
    #[doc = "* ret = rcutils_string_map_fini(&string_map);"]
    #[doc = "* if (ret != RCUTILS_RET_OK) {"]
    #[doc = "* // ... do error handling"]
    #[doc = "* }"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* \\param[inout] string_map rcutils_string_map_t to be initialized"]
    #[doc = "* \\param[in] initial_capacity the amount of initial capacity for the string map"]
    #[doc = "* \\param[in] allocator the allocator to use through out the lifetime of the map"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or"]
    #[doc = "* \\return #RCUTILS_RET_STRING_MAP_ALREADY_INIT if already initialized, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_string_map_init(
        string_map: *mut rcutils_string_map_t,
        initial_capacity: size_t,
        allocator: rcutils_allocator_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Finalize the previously initialized string map struct."]
    #[doc = "* *"]
    #[doc = "* This function will free any resources which were created when initializing"]
    #[doc = "* or when calling rcutils_string_map_set()."]
    #[doc = "* "]
    #[doc = "* \\param[inout] string_map rcutils_string_map_t to be finalized"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_string_map_fini(string_map: *mut rcutils_string_map_t) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Get the current capacity of the string map."]
    #[doc = "* *"]
    #[doc = "* This function will return the internal capacity of the map, which is the"]
    #[doc = "* maximum number of key value pairs the map could hold."]
    #[doc = "* The capacity can be set initially with rcutils_string_map_init() or"]
    #[doc = "* with rcutils_string_map_reserve()."]
    #[doc = "* The capacity does not indicate how many key value paris are stored in the"]
    #[doc = "* map, the rcutils_string_map_get_size() function can provide that."]
    #[doc = "* "]
    #[doc = "* \\param[in] string_map rcutils_string_map_t to be queried"]
    #[doc = "* \\param[out] capacity capacity of the string map"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_string_map_get_capacity(
        string_map: *const rcutils_string_map_t,
        capacity: *mut size_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Get the current size of the string map."]
    #[doc = "* *"]
    #[doc = "* This function will return the internal size of the map, which is the"]
    #[doc = "* current number of key value pairs in the map."]
    #[doc = "* The size is changed when calling rcutils_string_map_set_no_resize(),"]
    #[doc = "* rcutils_string_map_set(), or rcutils_string_map_unset()."]
    #[doc = "* "]
    #[doc = "* \\param[in] string_map rcutils_string_map_t to be queried"]
    #[doc = "* \\param[out] size size of the string map"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_string_map_get_size(
        string_map: *const rcutils_string_map_t,
        size: *mut size_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Reserve a given amount of capacity in the map."]
    #[doc = "* *"]
    #[doc = "* Increases the capacity of the map to at least the given size."]
    #[doc = "* "]
    #[doc = "* If the current capacity is less than requested capacity then the capacity"]
    #[doc = "* is increased using the allocator given during initialization of the map in"]
    #[doc = "* rcutils_string_map_init()."]
    #[doc = "* If the requested capacity is less than the current capacity, the capacity"]
    #[doc = "* may be reduced, but no existing key value pairs will be truncated to do so."]
    #[doc = "* In effect, the capacity will be shrunk to fit the number of items in map or"]
    #[doc = "* the requested capacity, which ever is larger."]
    #[doc = "* "]
    #[doc = "* If recovering all resources is desired first call rcutils_string_map_clear()"]
    #[doc = "* and then this function with a capacity of 0."]
    #[doc = "* "]
    #[doc = "* \\param[inout] string_map rcutils_string_map_t to have space reserved in"]
    #[doc = "* \\param[in] capacity requested size to reserve in the map"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or"]
    #[doc = "* \\return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_string_map_reserve(
        string_map: *mut rcutils_string_map_t,
        capacity: size_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Remove all key value pairs from the map."]
    #[doc = "* *"]
    #[doc = "* This function will remove all key value pairs from the map, and it will"]
    #[doc = "* reclaim all resources allocated as a result of setting key value pairs."]
    #[doc = "* rcutils_string_map_fini() should still be called after this."]
    #[doc = "* "]
    #[doc = "* \\param[inout] string_map rcutils_string_map_t to be cleared"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_string_map_clear(string_map: *mut rcutils_string_map_t) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Set a key value pair in the map, increasing capacity if necessary."]
    #[doc = "* *"]
    #[doc = "* The capacity will be increased if needed using rcutils_string_map_reserve()."]
    #[doc = "* Otherwise it is the same as rcutils_string_map_set_no_resize()."]
    #[doc = "* "]
    #[doc = "* \\see rcutils_string_map_set_no_resize()"]
    #[doc = "* "]
    #[doc = "* \\param[inout] string_map rcutils_string_map_t to be updated"]
    #[doc = "* \\param[in] key map key, must be null terminated c string"]
    #[doc = "* \\param[in] value value for given map key, must be null terminated c string"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or"]
    #[doc = "* \\return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_string_map_set(
        string_map: *mut rcutils_string_map_t,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Set a key value pair in the map but only if the map has enough capacity."]
    #[doc = "* *"]
    #[doc = "* If the map already contains the given key, the existing value will be"]
    #[doc = "* replaced with the given value."]
    #[doc = "* If the map does not contain the given key, and the map has additional"]
    #[doc = "* unused capacity, then it will store the given key and value in the map."]
    #[doc = "* If there is no unused capacity in the map, then RCUTILS_RET_NOT_ENOUGH_SPACE"]
    #[doc = "* is returned."]
    #[doc = "* "]
    #[doc = "* The given key and value c strings are copied into the map, and so storage is"]
    #[doc = "* allocated for them in the map when this function is called if necessary."]
    #[doc = "* The storage allocated for this purpose is reclaimed either when"]
    #[doc = "* rcutils_string_map_fini() is called on this map or when using this function"]
    #[doc = "* or rcutils_string_map_unset()."]
    #[doc = "* "]
    #[doc = "* Any allocation that occurs in this functions uses the allocator of the map,"]
    #[doc = "* which is given when the map is initialized in rcutils_string_map_init()."]
    #[doc = "* "]
    #[doc = "* \\param[inout] string_map rcutils_string_map_t to be updated"]
    #[doc = "* \\param[in] key map key, must be null terminated c string"]
    #[doc = "* \\param[in] value value for given map key, must be null terminated c string"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or"]
    #[doc = "* \\return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or"]
    #[doc = "* \\return #RCUTILS_RET_NOT_ENOUGH_SPACE if map is full, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_string_map_set_no_resize(
        string_map: *mut rcutils_string_map_t,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Unset a key value pair in the map."]
    #[doc = "* *"]
    #[doc = "* The key needs to be a null terminated c string."]
    #[doc = "* If the given key is not found, RCUTILS_RET_STRING_KEY_NOT_FOUND is returned."]
    #[doc = "* "]
    #[doc = "* \\param[inout] string_map rcutils_string_map_t to be updated"]
    #[doc = "* \\param[in] key map key, must be null terminated c string"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or"]
    #[doc = "* \\return #RCUTILS_RET_STRING_KEY_NOT_FOUND if key not found, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_string_map_unset(
        string_map: *mut rcutils_string_map_t,
        key: *const ::std::os::raw::c_char,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Get whether or not a key exists."]
    #[doc = "* *"]
    #[doc = "* The key needs to be a null terminated c string."]
    #[doc = "* "]
    #[doc = "* This function can fail and return false if the key is not found,"]
    #[doc = "* or the string_map is NULL or invalid, or if the key is NULL."]
    #[doc = "* In all cases no error message is set."]
    #[doc = "* "]
    #[doc = "* \\param[in] string_map rcutils_string_map_t to be searched"]
    #[doc = "* \\param[in] key map key, must be null terminated c string"]
    #[doc = "* \\return `true` if key is in the map, or"]
    #[doc = "* \\return `false` if key is not in the map, or"]
    #[doc = "* \\return `false` for invalid arguments, or"]
    #[doc = "* \\return `false` if the string map is invalid."]
    #[doc = "* /"]
    pub fn rcutils_string_map_key_exists(
        string_map: *const rcutils_string_map_t,
        key: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Get whether or not a key of known length exists."]
    #[doc = "* *"]
    #[doc = "* Identical to rcutils_string_map_key_exists() but without relying on key to be"]
    #[doc = "* a null terminated c string."]
    #[doc = "* "]
    #[doc = "* \\param[in] string_map rcutils_string_map_t to be searched"]
    #[doc = "* \\param[in] key map key"]
    #[doc = "* \\param[in] key_length map key length"]
    #[doc = "* \\return `true` if key is in the map, or"]
    #[doc = "* \\return `false` if key is not in the map, or"]
    #[doc = "* \\return `false` for invalid arguments, or"]
    #[doc = "* \\return `false` if the string map is invalid."]
    #[doc = "* /"]
    pub fn rcutils_string_map_key_existsn(
        string_map: *const rcutils_string_map_t,
        key: *const ::std::os::raw::c_char,
        key_length: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Get value given a key."]
    #[doc = "* *"]
    #[doc = "* The key needs to be a null terminated c string."]
    #[doc = "* "]
    #[doc = "* This function can fail, and therefore return NULL, if the key is not found,"]
    #[doc = "* or the string_map is NULL or invalid, or if the key is NULL."]
    #[doc = "* In all cases no error message is set."]
    #[doc = "* "]
    #[doc = "* The returned value string is still owned by the map, and it should not be"]
    #[doc = "* modified or free'd."]
    #[doc = "* This also means that the value pointer becomes invalid if either"]
    #[doc = "* rcutils_string_map_clear() or rcutils_string_map_fini() are called or if"]
    #[doc = "* the key value pair is updated or removed with one of rcutils_string_map_set()"]
    #[doc = "* or rcutils_string_map_set_no_resize() or rcutils_string_map_unset()."]
    #[doc = "* "]
    #[doc = "* \\param[in] string_map rcutils_string_map_t to be searched"]
    #[doc = "* \\param[in] key map key, must be null terminated c string"]
    #[doc = "* \\return value for the given key if successful, or"]
    #[doc = "* \\return `NULL` for invalid arguments, or"]
    #[doc = "* \\return `NULL` if the string map is invalid, or"]
    #[doc = "* \\return `NULL` if key not found, or"]
    #[doc = "* \\return `NULL` if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_string_map_get(
        string_map: *const rcutils_string_map_t,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get value given a key and key length."]
    #[doc = "* *"]
    #[doc = "* Identical to rcutils_string_map_get() but without relying on key to be a"]
    #[doc = "* null terminated c string."]
    #[doc = "* "]
    #[doc = "* \\param[in] string_map rcutils_string_map_t to be searched"]
    #[doc = "* \\param[in] key map key"]
    #[doc = "* \\param[in] key_length map key length"]
    #[doc = "* \\return value for the given key if successful, or"]
    #[doc = "* \\return `NULL` for invalid arguments, or"]
    #[doc = "* \\return `NULL` if the string map is invalid, or"]
    #[doc = "* \\return `NULL` if key not found, or"]
    #[doc = "* \\return `NULL` if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_string_map_getn(
        string_map: *const rcutils_string_map_t,
        key: *const ::std::os::raw::c_char,
        key_length: size_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the next key in the map, unless NULL is given, then get the first key."]
    #[doc = "* *"]
    #[doc = "* This function allows you iteratively get each key in the map."]
    #[doc = "* "]
    #[doc = "* If NULL is given for the key, then the first key in the map is returned."]
    #[doc = "* If that returned key if given to the this function, then the next key in the"]
    #[doc = "* map is returned."]
    #[doc = "* If there are no more keys in the map or if the given key is not in the map,"]
    #[doc = "* NULL is returned."]
    #[doc = "* "]
    #[doc = "* The order of the keys in the map is arbitrary and if the map is modified"]
    #[doc = "* between calls to this function the behavior is undefined."]
    #[doc = "* If the map is modifeid then iteration should begin again by passing NULL to"]
    #[doc = "* get the first key again."]
    #[doc = "* "]
    #[doc = "* This function operates based on the address of the pointer, you cannot pass"]
    #[doc = "* a copy of a key to get the next key."]
    #[doc = "* "]
    #[doc = "* Example:"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* printf(\"keys in the map:\\n\");"]
    #[doc = "* const char * current_key = rcutils_string_map_get_next_key(&map, NULL);"]
    #[doc = "* while (current_key) {"]
    #[doc = "* printf(\"  - %s\\n\", current_key);"]
    #[doc = "* current_key = rcutils_string_map_get_next_key(&map, current_key);"]
    #[doc = "* }"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* NULL can also be returned if NULL is given for the string_map or if the"]
    #[doc = "* string_map is invalid."]
    #[doc = "* "]
    #[doc = "* \\param[in] string_map rcutils_string_map_t to be queried"]
    #[doc = "* \\param[in] key NULL to get the first key or the previous key to get the next"]
    #[doc = "* \\return value for the given key if successful, or"]
    #[doc = "* \\return `NULL` for invalid arguments, or"]
    #[doc = "* \\return `NULL` if the string map is invalid, or"]
    #[doc = "* \\return `NULL` if key not found, or"]
    #[doc = "* \\return `NULL` if there are no more keys in the map, or"]
    #[doc = "* \\return `NULL` if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_string_map_get_next_key(
        string_map: *const rcutils_string_map_t,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Copy all the key value pairs from one map into another, overwritting and resizing if needed."]
    #[doc = "* *"]
    #[doc = "* If the destination string map does not have enough storage, then it is will"]
    #[doc = "* be resized."]
    #[doc = "* If a key value pair exists in the destination map, its value will be"]
    #[doc = "* replaced with the source map's value."]
    #[doc = "* "]
    #[doc = "* It is possible for only some of the values to be copied if an error happens"]
    #[doc = "* during the copying process, e.g. if memory allocation fails."]
    #[doc = "* "]
    #[doc = "* \\param[in] src_string_map rcutils_string_map_t to be copied from"]
    #[doc = "* \\param[inout] dst_string_map rcutils_string_map_t to be copied to"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or"]
    #[doc = "* \\return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unknown error occurs."]
    #[doc = "* /"]
    pub fn rcutils_string_map_copy(
        src_string_map: *const rcutils_string_map_t,
        dst_string_map: *mut rcutils_string_map_t,
    ) -> rcutils_ret_t;
}
#[doc = " The structure holding the metadata for a uint8 array."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_uint8_array_t {
    #[doc = " The allocated memory for the uint8 array."]
    pub buffer: *mut u8,
    #[doc = " The number of valid elements in the uint8 array."]
    pub buffer_length: size_t,
    #[doc = " The maximum capacity of the uint8 array."]
    pub buffer_capacity: size_t,
    #[doc = " The allocator used to allocate and free memory for the uint8 array."]
    pub allocator: rcutils_allocator_t,
}
#[test]
fn bindgen_test_layout_rcutils_uint8_array_t() {
    assert_eq!(
        ::std::mem::size_of::<rcutils_uint8_array_t>(),
        64usize,
        concat!("Size of: ", stringify!(rcutils_uint8_array_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcutils_uint8_array_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcutils_uint8_array_t))
    );
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_uint8_array_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_uint8_array_t),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
    fn test_field_buffer_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_uint8_array_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer_length) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_uint8_array_t),
                "::",
                stringify!(buffer_length)
            )
        );
    }
    test_field_buffer_length();
    fn test_field_buffer_capacity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_uint8_array_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer_capacity) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_uint8_array_t),
                "::",
                stringify!(buffer_capacity)
            )
        );
    }
    test_field_buffer_capacity();
    fn test_field_allocator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_uint8_array_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_uint8_array_t),
                "::",
                stringify!(allocator)
            )
        );
    }
    test_field_allocator();
}
extern "C" {
    #[doc = " Return a zero initialized uint8 array struct."]
    #[doc = "* *"]
    #[doc = "* \\return rcutils_uint8_array_t a zero initialized uint8 array struct"]
    #[doc = "* /"]
    pub fn rcutils_get_zero_initialized_uint8_array() -> rcutils_uint8_array_t;
}
extern "C" {
    #[doc = " Initialize a zero initialized uint8 array struct."]
    #[doc = "* *"]
    #[doc = "* This function may leak if the uint8 array struct is already initialized."]
    #[doc = "* If the capacity is set to 0, no memory is allocated and the internal buffer"]
    #[doc = "* is still NULL."]
    #[doc = "* "]
    #[doc = "* \\param[inout] uint8_array a pointer to the to be initialized uint8 array struct"]
    #[doc = "* \\param[in] buffer_capacity the size of the memory to allocate for the byte stream"]
    #[doc = "* \\param[in] allocator the allocator to use for the memory allocation"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return 'RCUTILS_RET_BAD_ALLOC` if no memory could be allocated correctly"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rcutils_uint8_array_init(
        uint8_array: *mut rcutils_uint8_array_t,
        buffer_capacity: size_t,
        allocator: *const rcutils_allocator_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Finalize a uint8 array struct."]
    #[doc = "* *"]
    #[doc = "* Cleans up and deallocates any resources used in a rcutils_uint8_array_t."]
    #[doc = "* The array passed to this function needs to have been initialized by"]
    #[doc = "* rcutils_uint8_array_init()."]
    #[doc = "* Passing an uninitialized instance to this function leads to undefined"]
    #[doc = "* behavior."]
    #[doc = "* "]
    #[doc = "* \\param[in] uint8_array pointer to the rcutils_uint8_array_t to be cleaned up"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT if the uint8_array argument is invalid"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rcutils_uint8_array_fini(uint8_array: *mut rcutils_uint8_array_t) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Resize the internal buffer of the uint8 array."]
    #[doc = "* *"]
    #[doc = "* The internal buffer of the uint8 array can be resized dynamically if needed."]
    #[doc = "* If the new size is smaller than the current capacity, then the memory is"]
    #[doc = "* truncated."]
    #[doc = "* Be aware, that this might deallocate the memory and therefore invalidates any"]
    #[doc = "* pointers to this storage."]
    #[doc = "* "]
    #[doc = "* \\param[inout] uint8_array pointer to the instance of rcutils_uint8_array_t which is"]
    #[doc = "* being resized"]
    #[doc = "* \\param[in] new_size the new size of the internal buffer"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT if new_size is set to zero"]
    #[doc = "* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rcutils_uint8_array_resize(
        uint8_array: *mut rcutils_uint8_array_t,
        new_size: size_t,
    ) -> rcutils_ret_t;
}
#[doc = " A single point in time, measured in nanoseconds since the Unix epoch."]
pub type rcutils_time_point_value_t = i64;
#[doc = " A duration of time, measured in nanoseconds."]
pub type rcutils_duration_value_t = i64;
extern "C" {
    #[doc = " This function returns the time from a system clock."]
    #[doc = " The closest equivalent would be to std::chrono::system_clock::now();"]
    #[doc = ""]
    #[doc = " The resolution (e.g. nanoseconds vs microseconds) is not guaranteed."]
    #[doc = ""]
    #[doc = " The now argument must point to an allocated rcutils_time_point_value_t object,"]
    #[doc = " as the result is copied into this variable."]
    #[doc = ""]
    #[doc = " <hr>"]
    #[doc = " Attribute          | Adherence"]
    #[doc = " ------------------ | -------------"]
    #[doc = " Allocates Memory   | No"]
    #[doc = " Thread-Safe        | Yes"]
    #[doc = " Uses Atomics       | No"]
    #[doc = " Lock-Free          | Yes"]
    #[doc = ""]
    #[doc = " \\param[out] now a datafield in which the current time is stored"]
    #[doc = " \\return #RCUTILS_RET_OK if the current time was successfully obtained, or"]
    #[doc = " \\return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = " \\return #RCUTILS_RET_ERROR if an unspecified error occur."]
    pub fn rcutils_system_time_now(now: *mut rcutils_time_point_value_t) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Retrieve the current time as a rcutils_time_point_value_t object."]
    #[doc = "* *"]
    #[doc = "* This function returns the time from a monotonically increasing clock."]
    #[doc = "* The closest equivalent would be to std::chrono::steady_clock::now();"]
    #[doc = "* "]
    #[doc = "* The resolution (e.g. nanoseconds vs microseconds) is not guaranteed."]
    #[doc = "* "]
    #[doc = "* The now argument must point to an allocated rcutils_time_point_value_t object,"]
    #[doc = "* as the result is copied into this variable."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[out] now a struct in which the current time is stored"]
    #[doc = "* \\return #RCUTILS_RET_OK if the current time was successfully obtained, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcutils_steady_time_now(now: *mut rcutils_time_point_value_t) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Return a time point as nanoseconds in a string."]
    #[doc = "* *"]
    #[doc = "* The number is always fixed width, with left padding zeros up to the maximum"]
    #[doc = "* number of digits the time point can represent."]
    #[doc = "* Right now that is 19 digits (so 19 characters) for a signed 64-bit integer."]
    #[doc = "* Negative values will have a leading `-`, so they will be one character"]
    #[doc = "* longer than the positive values."]
    #[doc = "* "]
    #[doc = "* The recommended minimum size of the input string is 32 characters, but"]
    #[doc = "* 21 (` ` or `-` for sign, 19 digits, null terminator) should be sufficiently"]
    #[doc = "* large for both positive and negative values."]
    #[doc = "* If the given string is not large enough, the result will be truncated."]
    #[doc = "* If you need a string with variable width, using `snprintf()` directly is"]
    #[doc = "* recommended."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No [1]"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* <i>[1] if `snprintf()` does not allocate additional memory internally</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] time_point the time to be made into a string"]
    #[doc = "* \\param[out] str the output string in which it is stored"]
    #[doc = "* \\param[in] str_size the size of the output string"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful (even if truncated), or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcutils_time_point_value_as_nanoseconds_string(
        time_point: *const rcutils_time_point_value_t,
        str_: *mut ::std::os::raw::c_char,
        str_size: size_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Return a time point as floating point seconds in a string."]
    #[doc = "* *"]
    #[doc = "* The number is always fixed width, with left padding zeros up to the maximum"]
    #[doc = "* number of digits for the mantissa that the time point can represent and a"]
    #[doc = "* characteristic (fractional-part) with a fixed width of 9 digits."]
    #[doc = "* Right now that means the mantissa is always 10 digits to add up to 19 total"]
    #[doc = "* for the signed 64-bit time point type."]
    #[doc = "* Negative values will have a leading `-`, so they will be one character"]
    #[doc = "* longer then positive values."]
    #[doc = "* "]
    #[doc = "* The recommended minimum size of the input string is 32 characters, but"]
    #[doc = "* 22 (` ` or `-` for sign, 19 digits, decimal point, null terminator) should"]
    #[doc = "* be sufficient for now."]
    #[doc = "* If the given string is not large enough, the result will be truncated."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No [1]"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* <i>[1] if `snprintf()` does not allocate additional memory internally</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] time_point the time to be made into a string"]
    #[doc = "* \\param[out] str the output string in which it is stored"]
    #[doc = "* \\param[in] str_size the size of the output string"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful (even if truncated), or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcutils_time_point_value_as_seconds_string(
        time_point: *const rcutils_time_point_value_t,
        str_: *mut ::std::os::raw::c_char,
        str_size: size_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " The flag if the logging system has been initialized."]
    pub static mut g_rcutils_logging_initialized: bool;
}
extern "C" {
    #[doc = " Initialize the logging system using the specified allocator."]
    #[doc = "* *"]
    #[doc = "* Initialize the logging system only if it was not in an initialized state."]
    #[doc = "* "]
    #[doc = "* If an invalid allocator is passed, the initialization will fail."]
    #[doc = "* Otherwise, this function will still set the internal state to initialized"]
    #[doc = "* even if an error occurs, to avoid repeated failing initialization attempts"]
    #[doc = "* since this function is called automatically from logging macros."]
    #[doc = "* To re-attempt initialization, call rcutils_logging_shutdown() before"]
    #[doc = "* re-calling this function."]
    #[doc = "* "]
    #[doc = "* If multiple errors occur, the error code of the last error will be returned."]
    #[doc = "* "]
    #[doc = "* The `RCUTILS_CONSOLE_OUTPUT_FORMAT` environment variable can be used to set"]
    #[doc = "* the output format of messages logged to the console."]
    #[doc = "* Available tokens are:"]
    #[doc = "* - `file_name`, the full file name of the caller including the path"]
    #[doc = "* - `function_name`, the function name of the caller"]
    #[doc = "* - `line_number`, the line number of the caller"]
    #[doc = "* - `message`, the message string after it has been formatted"]
    #[doc = "* - `name`, the full logger name"]
    #[doc = "* - `severity`, the name of the severity level, e.g. `INFO`"]
    #[doc = "* - `time`, the timestamp of log message in floating point seconds"]
    #[doc = "* - `time_as_nanoseconds`, the timestamp of log message in integer nanoseconds"]
    #[doc = "* "]
    #[doc = "* The `RCUTILS_COLORIZED_OUTPUT` environment variable allows configuring if colours"]
    #[doc = "* are used or not. Available values are:"]
    #[doc = "* - `1`: Force using colours."]
    #[doc = "* - `0`: Don't use colours."]
    #[doc = "* If it is unset, colours are used depending if the target stream is a terminal or not."]
    #[doc = "* See `isatty` documentation."]
    #[doc = "* "]
    #[doc = "* The format string can use these tokens by referencing them in curly brackets,"]
    #[doc = "* e.g. `\"[{severity}] [{name}]: {message} ({function_name}() at {file_name}:{line_number})\"`."]
    #[doc = "* Any number of tokens can be used."]
    #[doc = "* The limit of the format string is 2048 characters."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] allocator rcutils_allocator_t to be used."]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT if the allocator is invalid, in which"]
    #[doc = "* case initialization will fail, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT if an error occurs reading the output"]
    #[doc = "* format from the `RCUTILS_CONSOLE_OUTPUT_FORMAT` environment variable, in"]
    #[doc = "* which case the default format will be used, or"]
    #[doc = "* \\return #RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID if the internal logger"]
    #[doc = "* severity level map cannot be initialized, in which case logger severity"]
    #[doc = "* levels will not be configurable."]
    #[doc = "* /"]
    pub fn rcutils_logging_initialize_with_allocator(
        allocator: rcutils_allocator_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Initialize the logging system."]
    #[doc = "* *"]
    #[doc = "* Call rcutils_logging_initialize_with_allocator() using the default allocator."]
    #[doc = "* This function is called automatically when using the logging macros."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT if an error occurs reading the output"]
    #[doc = "* format from the `RCUTILS_CONSOLE_OUTPUT_FORMAT` environment variable, in"]
    #[doc = "* which case the default format will be used, or"]
    #[doc = "* \\return #RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID if the internal logger"]
    #[doc = "* severity level map cannot be initialized, in which case logger levels"]
    #[doc = "* will not be configurable."]
    #[doc = "* /"]
    pub fn rcutils_logging_initialize() -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Shutdown the logging system."]
    #[doc = "* *"]
    #[doc = "* Free the resources allocated for the logging system."]
    #[doc = "* This puts the system into a state equivalent to being uninitialized."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID if the internal logger"]
    #[doc = "* severity level map cannot be finalized."]
    #[doc = "* /"]
    pub fn rcutils_logging_shutdown() -> rcutils_ret_t;
}
#[doc = " The structure identifying the caller location in the source code."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_log_location_t {
    #[doc = " The name of the function containing the log call."]
    pub function_name: *const ::std::os::raw::c_char,
    #[doc = " The name of the source file containing the log call."]
    pub file_name: *const ::std::os::raw::c_char,
    #[doc = " The line number containing the log call."]
    pub line_number: size_t,
}
#[test]
fn bindgen_test_layout_rcutils_log_location_t() {
    assert_eq!(
        ::std::mem::size_of::<rcutils_log_location_t>(),
        24usize,
        concat!("Size of: ", stringify!(rcutils_log_location_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcutils_log_location_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcutils_log_location_t))
    );
    fn test_field_function_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_log_location_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).function_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_log_location_t),
                "::",
                stringify!(function_name)
            )
        );
    }
    test_field_function_name();
    fn test_field_file_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_log_location_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).file_name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_log_location_t),
                "::",
                stringify!(file_name)
            )
        );
    }
    test_field_file_name();
    fn test_field_line_number() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcutils_log_location_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).line_number) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rcutils_log_location_t),
                "::",
                stringify!(line_number)
            )
        );
    }
    test_field_line_number();
}
#[doc = "< The unset log level"]
pub const RCUTILS_LOG_SEVERITY_RCUTILS_LOG_SEVERITY_UNSET: RCUTILS_LOG_SEVERITY = 0;
#[doc = "< The debug log level"]
pub const RCUTILS_LOG_SEVERITY_RCUTILS_LOG_SEVERITY_DEBUG: RCUTILS_LOG_SEVERITY = 10;
#[doc = "< The info log level"]
pub const RCUTILS_LOG_SEVERITY_RCUTILS_LOG_SEVERITY_INFO: RCUTILS_LOG_SEVERITY = 20;
#[doc = "< The warn log level"]
pub const RCUTILS_LOG_SEVERITY_RCUTILS_LOG_SEVERITY_WARN: RCUTILS_LOG_SEVERITY = 30;
#[doc = "< The error log level"]
pub const RCUTILS_LOG_SEVERITY_RCUTILS_LOG_SEVERITY_ERROR: RCUTILS_LOG_SEVERITY = 40;
#[doc = "< The fatal log level"]
pub const RCUTILS_LOG_SEVERITY_RCUTILS_LOG_SEVERITY_FATAL: RCUTILS_LOG_SEVERITY = 50;
#[doc = " The severity levels of log messages / loggers."]
pub type RCUTILS_LOG_SEVERITY = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " The names of severity levels."]
    pub static g_rcutils_log_severity_names: [*const ::std::os::raw::c_char; 51usize];
}
extern "C" {
    #[doc = " Get a severity value from its string representation (e.g. DEBUG)."]
    #[doc = "* *"]
    #[doc = "* String representation must match one of the values in"]
    #[doc = "* `g_rcutils_log_severity_names`, but is not case-sensitive."]
    #[doc = "* Examples: UNSET, DEBUG, INFO, WARN, Error, fatal."]
    #[doc = "* "]
    #[doc = "* \\param[in] severity_string String representation of the severity, must be a"]
    #[doc = "* null terminated c string"]
    #[doc = "* \\param[in] allocator rcutils_allocator_t to be used"]
    #[doc = "* \\param[in,out] severity The severity level as a represented by the"]
    #[doc = "* `RCUTILS_LOG_SEVERITY` enum"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful, or"]
    #[doc = "* \\return #RCUTILS_RET_INVALID_ARGUMENT on invalid arguments, or"]
    #[doc = "* \\return #RCUTILS_RET_LOGGING_SEVERITY_STRING_INVALID if unable to match"]
    #[doc = "* string, or"]
    #[doc = "* \\return #RCUTILS_RET_ERROR if an unspecified error occured."]
    #[doc = "* /"]
    pub fn rcutils_logging_severity_level_from_string(
        severity_string: *const ::std::os::raw::c_char,
        allocator: rcutils_allocator_t,
        severity: *mut ::std::os::raw::c_int,
    ) -> rcutils_ret_t;
}
#[doc = " The function signature to log messages."]
#[doc = "* *"]
#[doc = "* \\param[in] location The location information about where the log came from"]
#[doc = "* \\param[in] severity The severity of the log message expressed as an integer"]
#[doc = "* \\param[in] name The name of the logger that this message came from"]
#[doc = "* \\param[in] timestamp The time at which the log message was generated"]
#[doc = "* \\param[in] format The list of arguments to insert into the formatted log message"]
#[doc = "* \\param[in] args The variable argument list"]
#[doc = "* /"]
pub type rcutils_logging_output_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rcutils_log_location_t,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: rcutils_time_point_value_t,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut va_list,
    ),
>;
extern "C" {
    #[doc = " The function pointer of the current output handler."]
    pub static mut g_rcutils_logging_output_handler: rcutils_logging_output_handler_t;
}
extern "C" {
    #[doc = " Get the current output handler."]
    #[doc = "* *"]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No, provided logging system is already initialized"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\return The function pointer of the current output handler."]
    #[doc = "* /"]
    pub fn rcutils_logging_get_output_handler() -> rcutils_logging_output_handler_t;
}
extern "C" {
    #[doc = " Set the current output handler."]
    #[doc = "* *"]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No, provided logging system is already initialized"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] function The function pointer of the output handler to be used."]
    #[doc = "* /"]
    pub fn rcutils_logging_set_output_handler(function: rcutils_logging_output_handler_t);
}
extern "C" {
    #[doc = " Formats a log message according to RCUTILS_CONSOLE_OUTPUT_FORMAT"]
    #[doc = "* *"]
    #[doc = "* A formatter that is meant to be used by an output handler to format a log message to the match"]
    #[doc = "* the format specified in RCUTILS_CONSOLE_OUTPUT_FORMAT by performing token replacement."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] location The location information about where the log came from"]
    #[doc = "* \\param[in] severity The severity of the log message expressed as an integer"]
    #[doc = "* \\param[in] name The name of the logger that this message came from"]
    #[doc = "* \\param[in] timestamp The time at which the log message was generated"]
    #[doc = "* \\param[in] msg The message being logged"]
    #[doc = "* \\param[out] logging_output An output buffer for the formatted message"]
    #[doc = "* \\return #RCUTILS_RET_OK if successful."]
    #[doc = "* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation error occured"]
    #[doc = "* /"]
    pub fn rcutils_logging_format_message(
        location: *const rcutils_log_location_t,
        severity: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        timestamp: rcutils_time_point_value_t,
        msg: *const ::std::os::raw::c_char,
        logging_output: *mut rcutils_char_array_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " The default severity level for loggers."]
    #[doc = "* *"]
    #[doc = "* This level is used for (1) nameless log calls and (2) named log"]
    #[doc = "* calls where the effective level of the logger name is unspecified."]
    #[doc = "* "]
    #[doc = "* \\see rcutils_logging_get_logger_effective_level()"]
    #[doc = "* /"]
    pub static mut g_rcutils_logging_default_logger_level: ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the default level for loggers."]
    #[doc = "* *"]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No, provided logging system is already initialized"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\return The level."]
    #[doc = "* /"]
    pub fn rcutils_logging_get_default_logger_level() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the default severity level for loggers."]
    #[doc = "* *"]
    #[doc = "* If the severity level requested is `RCUTILS_LOG_SEVERITY_UNSET`, the default"]
    #[doc = "* value for the default logger (`RCUTILS_DEFAULT_LOGGER_DEFAULT_LEVEL`)"]
    #[doc = "* will be restored instead."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No, provided logging system is already initialized"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] level The level to be used."]
    #[doc = "* /"]
    pub fn rcutils_logging_set_default_logger_level(level: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Get the severity level for a logger."]
    #[doc = "* *"]
    #[doc = "* This considers the severity level of the specifed logger only."]
    #[doc = "* To get the effective level of a logger given the severity level of its"]
    #[doc = "* ancestors, see rcutils_logging_get_logger_effective_level()."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No, provided logging system is already initialized"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] name The name of the logger, must be null terminated c string"]
    #[doc = "* \\return The level of the logger if it has been set, or"]
    #[doc = "* \\return `RCUTILS_LOG_SEVERITY_UNSET` if unset, or"]
    #[doc = "* \\return `g_rcutils_logging_default_logger_level` for an empty name, or"]
    #[doc = "* \\return -1 on invalid arguments, or"]
    #[doc = "* \\return -1 if an error occurred"]
    #[doc = "* /"]
    pub fn rcutils_logging_get_logger_level(
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the level for a logger and its name length."]
    #[doc = "* *"]
    #[doc = "* Identical to rcutils_logging_get_logger_level() but without"]
    #[doc = "* relying on the logger name to be a null terminated c string."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No, provided logging system is already initialized"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] name The name of the logger"]
    #[doc = "* \\param[in] name_length Logger name length"]
    #[doc = "* \\return The level of the logger if it has been set, or"]
    #[doc = "* \\return `RCUTILS_LOG_SEVERITY_UNSET` if unset, or"]
    #[doc = "* \\return `g_rcutils_logging_default_logger_level` for `name_length` of `0`, or"]
    #[doc = "* \\return -1 on invalid arguments, or"]
    #[doc = "* \\return -1 if an error occurred"]
    #[doc = "* /"]
    pub fn rcutils_logging_get_logger_leveln(
        name: *const ::std::os::raw::c_char,
        name_length: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the severity level for a logger."]
    #[doc = "* *"]
    #[doc = "* If an empty string is specified as the name, the"]
    #[doc = "* `g_rcutils_logging_default_logger_level` will be set."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] name The name of the logger, must be null terminated c string."]
    #[doc = "* \\param[in] level The level to be used."]
    #[doc = "* \\return `RCUTILS_RET_OK` if successful, or"]
    #[doc = "* \\return `RCUTILS_RET_INVALID_ARGUMENT` on invalid arguments, or"]
    #[doc = "* \\return `RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID` if severity map invalid, or"]
    #[doc = "* \\return `RCUTILS_RET_ERROR` if an unspecified error occured"]
    #[doc = "* /"]
    pub fn rcutils_logging_set_logger_level(
        name: *const ::std::os::raw::c_char,
        level: ::std::os::raw::c_int,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Determine if a logger is enabled for a severity level."]
    #[doc = "* *"]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No, provided logging system is already initialized"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] name The name of the logger, must be null terminated c string or NULL."]
    #[doc = "* \\param[in] severity The severity level."]
    #[doc = "* "]
    #[doc = "* \\return `true` if the logger is enabled for the level, or"]
    #[doc = "* \\return `false` otherwise."]
    #[doc = "* /"]
    pub fn rcutils_logging_logger_is_enabled_for(
        name: *const ::std::os::raw::c_char,
        severity: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " Determine the effective level for a logger."]
    #[doc = "* *"]
    #[doc = "* The effective level is determined as the severity level of"]
    #[doc = "* the logger if it is set, otherwise it is the first specified severity"]
    #[doc = "* level of the logger's ancestors, starting with its closest ancestor."]
    #[doc = "* The ancestor hierarchy is signified by logger names being separated by dots:"]
    #[doc = "* a logger named `x` is an ancestor of `x.y`, and both `x` and `x.y` are"]
    #[doc = "* ancestors of `x.y.z`, etc."]
    #[doc = "* If the level has not been set for the logger nor any of its"]
    #[doc = "* ancestors, the default level is used."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No, provided logging system is already initialized"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] name The name of the logger, must be null terminated c string."]
    #[doc = "* "]
    #[doc = "* \\return The level, or"]
    #[doc = "* \\return -1 on invalid arguments, or"]
    #[doc = "* \\return -1 if an error occurred."]
    #[doc = "* /"]
    pub fn rcutils_logging_get_logger_effective_level(
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Log a message."]
    #[doc = "* *"]
    #[doc = "* The attributes of this function are also being influenced by the currently"]
    #[doc = "* set output handler."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No, for formatted outputs <= 1023 characters"]
    #[doc = "* | Yes, for formatted outputs >= 1024 characters"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] location The pointer to the location struct or NULL"]
    #[doc = "* \\param[in] severity The severity level"]
    #[doc = "* \\param[in] name The name of the logger, must be null terminated c string or NULL"]
    #[doc = "* \\param[in] format The format string"]
    #[doc = "* \\param[in] ... The variable arguments"]
    #[doc = "* /"]
    pub fn rcutils_log(
        location: *const rcutils_log_location_t,
        severity: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " The default output handler outputs log messages to the standard streams."]
    #[doc = "* *"]
    #[doc = "* The messages with a severity level `DEBUG` and `INFO` are written to `stdout`."]
    #[doc = "* The messages with a severity level `WARN`, `ERROR`, and `FATAL` are written"]
    #[doc = "* to `stderr`."]
    #[doc = "* The console output format of the logged message can be configured through"]
    #[doc = "* the `RCUTILS_CONSOLE_OUTPUT_FORMAT` environment variable: see"]
    #[doc = "* rcutils_logging_initialize_with_allocator() for details."]
    #[doc = "* For configuring if using colours or not, `RCUTILS_COLORIZED_OUTPUT` can be used:"]
    #[doc = "* see rcutils_logging_initialize_with_allocator() for details."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes, if the underlying *printf functions are"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] location The pointer to the location struct or NULL"]
    #[doc = "* \\param[in] severity The severity level"]
    #[doc = "* \\param[in] name The name of the logger, must be null terminated c string"]
    #[doc = "* \\param[in] timestamp The timestamp for when the log message was made"]
    #[doc = "* \\param[in] format The format string"]
    #[doc = "* \\param[in] args The `va_list` used by the logger"]
    #[doc = "* /"]
    pub fn rcutils_logging_console_output_handler(
        location: *const rcutils_log_location_t,
        severity: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        timestamp: rcutils_time_point_value_t,
        format: *const ::std::os::raw::c_char,
        args: *mut va_list,
    );
}
pub const rmw_qos_policy_kind_t_RMW_QOS_POLICY_INVALID: rmw_qos_policy_kind_t = 1;
pub const rmw_qos_policy_kind_t_RMW_QOS_POLICY_DURABILITY: rmw_qos_policy_kind_t = 2;
pub const rmw_qos_policy_kind_t_RMW_QOS_POLICY_DEADLINE: rmw_qos_policy_kind_t = 4;
pub const rmw_qos_policy_kind_t_RMW_QOS_POLICY_LIVELINESS: rmw_qos_policy_kind_t = 8;
pub const rmw_qos_policy_kind_t_RMW_QOS_POLICY_RELIABILITY: rmw_qos_policy_kind_t = 16;
pub const rmw_qos_policy_kind_t_RMW_QOS_POLICY_HISTORY: rmw_qos_policy_kind_t = 32;
pub const rmw_qos_policy_kind_t_RMW_QOS_POLICY_LIFESPAN: rmw_qos_policy_kind_t = 64;
pub const rmw_qos_policy_kind_t_RMW_QOS_POLICY_DEPTH: rmw_qos_policy_kind_t = 128;
pub const rmw_qos_policy_kind_t_RMW_QOS_POLICY_LIVELINESS_LEASE_DURATION: rmw_qos_policy_kind_t =
    256;
pub const rmw_qos_policy_kind_t_RMW_QOS_POLICY_AVOID_ROS_NAMESPACE_CONVENTIONS:
    rmw_qos_policy_kind_t = 512;
#[doc = " QoS Policy Kinds"]
pub type rmw_qos_policy_kind_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_qos_incompatible_event_status_t {
    #[doc = " Total cumulative number of times the concerned subscription discovered a"]
    #[doc = " publisher for the same topic with an offered QoS that was incompatible"]
    #[doc = " with that requested by the subscription."]
    pub total_count: i32,
    #[doc = " The change in total_count since the last time the status was read."]
    pub total_count_change: i32,
    #[doc = " The Qos Policy Kind of one of the policies that was found to be"]
    #[doc = " incompatible the last time an incompatibility was detected."]
    pub last_policy_kind: rmw_qos_policy_kind_t,
}
#[test]
fn bindgen_test_layout_rmw_qos_incompatible_event_status_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_qos_incompatible_event_status_t>(),
        12usize,
        concat!("Size of: ", stringify!(rmw_qos_incompatible_event_status_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_qos_incompatible_event_status_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rmw_qos_incompatible_event_status_t)
        )
    );
    fn test_field_total_count() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rmw_qos_incompatible_event_status_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).total_count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_qos_incompatible_event_status_t),
                "::",
                stringify!(total_count)
            )
        );
    }
    test_field_total_count();
    fn test_field_total_count_change() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rmw_qos_incompatible_event_status_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).total_count_change) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_qos_incompatible_event_status_t),
                "::",
                stringify!(total_count_change)
            )
        );
    }
    test_field_total_count_change();
    fn test_field_last_policy_kind() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rmw_qos_incompatible_event_status_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).last_policy_kind) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_qos_incompatible_event_status_t),
                "::",
                stringify!(last_policy_kind)
            )
        );
    }
    test_field_last_policy_kind();
}
#[doc = " Event state for a subscription's 'RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE' events."]
pub type rmw_requested_qos_incompatible_event_status_t = rmw_qos_incompatible_event_status_t;
#[doc = " Event state for a publisher's 'RMW_EVENT_OFFERED_QOS_INCOMPATIBLE' events."]
pub type rmw_offered_qos_incompatible_event_status_t = rmw_qos_incompatible_event_status_t;
#[doc = " QoS Liveliness Changed information provided by a subscription."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_liveliness_changed_status_t {
    #[doc = " The total number of currently active Publishers which publish to the topic associated with"]
    #[doc = " the Subscription."]
    #[doc = " This count increases when a newly matched Publisher asserts its liveliness for the first time"]
    #[doc = " or when a Publisher previously considered to be not alive reasserts its liveliness."]
    #[doc = " The count decreases when a Publisher considered alive fails to assert its liveliness and"]
    #[doc = " becomes not alive, whether because it was deleted normally or for some other reason."]
    pub alive_count: i32,
    #[doc = " The total count of current Publishers which publish to the topic associated with the"]
    #[doc = " Subscription that are no longer asserting their liveliness."]
    #[doc = " This count increases when a Publisher considered alive fails to assert its liveliness and"]
    #[doc = " becomes not alive for some reason other than the normal deletion of that Publisher."]
    #[doc = " It decreases when a previously not alive Publisher either reasserts its liveliness or is"]
    #[doc = " deleted normally."]
    pub not_alive_count: i32,
    #[doc = " The change in the alive_count since the status was last read."]
    pub alive_count_change: i32,
    #[doc = " The change in the not_alive_count since the status was last read."]
    pub not_alive_count_change: i32,
}
#[test]
fn bindgen_test_layout_rmw_liveliness_changed_status_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_liveliness_changed_status_t>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_liveliness_changed_status_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_liveliness_changed_status_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rmw_liveliness_changed_status_t))
    );
    fn test_field_alive_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_liveliness_changed_status_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alive_count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_liveliness_changed_status_t),
                "::",
                stringify!(alive_count)
            )
        );
    }
    test_field_alive_count();
    fn test_field_not_alive_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_liveliness_changed_status_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).not_alive_count) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_liveliness_changed_status_t),
                "::",
                stringify!(not_alive_count)
            )
        );
    }
    test_field_not_alive_count();
    fn test_field_alive_count_change() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_liveliness_changed_status_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alive_count_change) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_liveliness_changed_status_t),
                "::",
                stringify!(alive_count_change)
            )
        );
    }
    test_field_alive_count_change();
    fn test_field_not_alive_count_change() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_liveliness_changed_status_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).not_alive_count_change) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_liveliness_changed_status_t),
                "::",
                stringify!(not_alive_count_change)
            )
        );
    }
    test_field_not_alive_count_change();
}
#[doc = " QoS Liveliness Lost information provided by a publisher."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_liveliness_lost_status_t {
    #[doc = " Lifetime cumulative number of times that a previously-alive Publisher became not alive due to"]
    #[doc = " a failure to actively signal its liveliness within its offered liveliness period."]
    #[doc = " This count does not change when an already not alive Publisher simply remains not alive for"]
    #[doc = " another liveliness period."]
    pub total_count: i32,
    #[doc = " The change in total_count since the last time the status was last read."]
    pub total_count_change: i32,
}
#[test]
fn bindgen_test_layout_rmw_liveliness_lost_status_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_liveliness_lost_status_t>(),
        8usize,
        concat!("Size of: ", stringify!(rmw_liveliness_lost_status_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_liveliness_lost_status_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rmw_liveliness_lost_status_t))
    );
    fn test_field_total_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_liveliness_lost_status_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).total_count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_liveliness_lost_status_t),
                "::",
                stringify!(total_count)
            )
        );
    }
    test_field_total_count();
    fn test_field_total_count_change() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_liveliness_lost_status_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).total_count_change) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_liveliness_lost_status_t),
                "::",
                stringify!(total_count_change)
            )
        );
    }
    test_field_total_count_change();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_message_lost_status_t {
    #[doc = " Total number of messages lost."]
    pub total_count: size_t,
    #[doc = " Number of messages lost since last callback."]
    pub total_count_change: size_t,
}
#[test]
fn bindgen_test_layout_rmw_message_lost_status_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_message_lost_status_t>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_message_lost_status_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_message_lost_status_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_message_lost_status_t))
    );
    fn test_field_total_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_message_lost_status_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).total_count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_message_lost_status_t),
                "::",
                stringify!(total_count)
            )
        );
    }
    test_field_total_count();
    fn test_field_total_count_change() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_message_lost_status_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).total_count_change) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_message_lost_status_t),
                "::",
                stringify!(total_count_change)
            )
        );
    }
    test_field_total_count_change();
}
#[doc = " QoS Deadline Missed information provided by a publisher."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_offered_deadline_missed_status_t {
    #[doc = " Lifetime cumulative number of offered deadline periods elapsed during which a Publisher failed"]
    #[doc = " to provide data."]
    #[doc = " Missed deadlines accumulate; that is, each deadline period the total_count will be incremented"]
    #[doc = " by one."]
    pub total_count: i32,
    #[doc = " The change in total_count since the last time the status was last read."]
    pub total_count_change: i32,
}
#[test]
fn bindgen_test_layout_rmw_offered_deadline_missed_status_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_offered_deadline_missed_status_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rmw_offered_deadline_missed_status_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_offered_deadline_missed_status_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rmw_offered_deadline_missed_status_t)
        )
    );
    fn test_field_total_count() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rmw_offered_deadline_missed_status_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).total_count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_offered_deadline_missed_status_t),
                "::",
                stringify!(total_count)
            )
        );
    }
    test_field_total_count();
    fn test_field_total_count_change() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rmw_offered_deadline_missed_status_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).total_count_change) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_offered_deadline_missed_status_t),
                "::",
                stringify!(total_count_change)
            )
        );
    }
    test_field_total_count_change();
}
#[doc = " QoS Requested Deadline Missed information provided by a subscription."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_requested_deadline_missed_status_t {
    #[doc = " Lifetime cumulative number of missed deadlines detected for any instance read by the"]
    #[doc = " subscription."]
    #[doc = " Missed deadlines accumulate; that is, each deadline period the total_count will be incremented"]
    #[doc = " by one for each instance for which data was not received."]
    pub total_count: i32,
    #[doc = " The incremental number of deadlines detected since the status was read."]
    pub total_count_change: i32,
}
#[test]
fn bindgen_test_layout_rmw_requested_deadline_missed_status_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_requested_deadline_missed_status_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rmw_requested_deadline_missed_status_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_requested_deadline_missed_status_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rmw_requested_deadline_missed_status_t)
        )
    );
    fn test_field_total_count() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rmw_requested_deadline_missed_status_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).total_count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_requested_deadline_missed_status_t),
                "::",
                stringify!(total_count)
            )
        );
    }
    test_field_total_count();
    fn test_field_total_count_change() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rmw_requested_deadline_missed_status_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).total_count_change) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_requested_deadline_missed_status_t),
                "::",
                stringify!(total_count_change)
            )
        );
    }
    test_field_total_count_change();
}
#[doc = " The structure holding the metadata for a uint8 array."]
pub type rmw_serialized_message_t = rcutils_uint8_array_t;
#[doc = " A struct representing a duration or relative time in RMW - does not encode an origin."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_time_t {
    #[doc = " Seconds component"]
    pub sec: u64,
    #[doc = " Nanoseconds component"]
    pub nsec: u64,
}
#[test]
fn bindgen_test_layout_rmw_time_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_time_t>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_time_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_time_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_time_t))
    );
    fn test_field_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_time_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_time_t),
                "::",
                stringify!(sec)
            )
        );
    }
    test_field_sec();
    fn test_field_nsec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_time_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nsec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_time_t),
                "::",
                stringify!(nsec)
            )
        );
    }
    test_field_nsec();
}
pub type rmw_time_point_value_t = rcutils_time_point_value_t;
pub type rmw_duration_t = rcutils_duration_value_t;
extern "C" {
    #[doc = " Check whether two rmw_time_t represent the same time."]
    pub fn rmw_time_equal(left: rmw_time_t, right: rmw_time_t) -> bool;
}
extern "C" {
    #[doc = " Return the total nanosecond representation of a time."]
    #[doc = "* *"]
    #[doc = "* \\return INT64_MAX if input is too large to store in 64 bits"]
    #[doc = "* /"]
    pub fn rmw_time_total_nsec(time: rmw_time_t) -> rmw_duration_t;
}
extern "C" {
    #[doc = " Construct rmw_time_t from a total nanoseconds representation."]
    #[doc = "* *"]
    #[doc = "* rmw_time_t only specifies relative time, so the origin is not relevant for this calculation."]
    #[doc = "* \\return RMW_DURATION_INFINITE if input is negative, which is not representable in rmw_time_t"]
    #[doc = "* /"]
    pub fn rmw_time_from_nsec(nanoseconds: rmw_duration_t) -> rmw_time_t;
}
extern "C" {
    #[doc = " Ensure that an rmw_time_t does not have nanoseconds > 1 second."]
    pub fn rmw_time_normalize(time: rmw_time_t) -> rmw_time_t;
}
#[doc = " Structure which encapsulates an rmw node"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_node_t {
    #[doc = " Name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Type erased pointer to this node's data"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " A concise name of this rmw node for identification"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " The namespace of this rmw node"]
    pub namespace_: *const ::std::os::raw::c_char,
    #[doc = " Context information about node's init specific information"]
    pub context: *mut rmw_context_t,
}
#[test]
fn bindgen_test_layout_rmw_node_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_node_t>(),
        40usize,
        concat!("Size of: ", stringify!(rmw_node_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_node_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_node_t))
    );
    fn test_field_implementation_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_node_t),
                "::",
                stringify!(implementation_identifier)
            )
        );
    }
    test_field_implementation_identifier();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_node_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_node_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_namespace_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).namespace_) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_node_t),
                "::",
                stringify!(namespace_)
            )
        );
    }
    test_field_namespace_();
    fn test_field_context() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_node_t),
                "::",
                stringify!(context)
            )
        );
    }
    test_field_context();
}
#[doc = " Endpoint type has not yet been set"]
pub const rmw_endpoint_type_t_RMW_ENDPOINT_INVALID: rmw_endpoint_type_t = 0;
#[doc = " Creates and publishes messages to the ROS topic"]
pub const rmw_endpoint_type_t_RMW_ENDPOINT_PUBLISHER: rmw_endpoint_type_t = 1;
#[doc = " Listens for and receives messages from a topic"]
pub const rmw_endpoint_type_t_RMW_ENDPOINT_SUBSCRIPTION: rmw_endpoint_type_t = 2;
#[doc = " Endpoint enumeration type"]
pub type rmw_endpoint_type_t = ::std::os::raw::c_uint;
#[doc = " Unique network flow endpoints not required"]
pub const rmw_unique_network_flow_endpoints_requirement_t_RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_NOT_REQUIRED : rmw_unique_network_flow_endpoints_requirement_t = 0 ;
#[doc = " Unique network flow endpoins strictly required."]
#[doc = " Error if not provided by RMW implementation."]
pub const rmw_unique_network_flow_endpoints_requirement_t_RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_STRICTLY_REQUIRED : rmw_unique_network_flow_endpoints_requirement_t = 1 ;
#[doc = " Unique network flow endpoints optionally required."]
#[doc = " No error if not provided RMW implementation."]
pub const rmw_unique_network_flow_endpoints_requirement_t_RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_OPTIONALLY_REQUIRED : rmw_unique_network_flow_endpoints_requirement_t = 2 ;
#[doc = " Unique network flow endpoints requirement decided by system."]
pub const rmw_unique_network_flow_endpoints_requirement_t_RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_SYSTEM_DEFAULT : rmw_unique_network_flow_endpoints_requirement_t = 3 ;
#[doc = " Unique network flow endpoints requirement enumeration"]
pub type rmw_unique_network_flow_endpoints_requirement_t = ::std::os::raw::c_uint;
#[doc = " Options that can be used to configure the creation of a publisher in rmw."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_publisher_options_t {
    #[doc = " Used to pass rmw implementation specific resources during publisher creation."]
    #[doc = "* *"]
    #[doc = "* This field is type erased (rather than forward declared) because it will"]
    #[doc = "* usually be a non-owned reference to an language specific object, e.g."]
    #[doc = "* C++ it may be a polymorphic class that only the rmw implementation can use."]
    #[doc = "* "]
    #[doc = "* The resource pointed to here needs to outlive this options structure, and"]
    #[doc = "* any rmw_publisher objects that are created using it, as they copy this"]
    #[doc = "* structure and may use this payload throughout their lifetime."]
    #[doc = "* /"]
    pub rmw_specific_publisher_payload: *mut ::std::os::raw::c_void,
    #[doc = " Require middleware to generate unique network flow endpoints."]
    #[doc = "* *"]
    #[doc = "* Unique network flow endpoints are required to differentiate the QoS provided by"]
    #[doc = "* networks for flows between publishers and subscribers in communicating"]
    #[doc = "* nodes."]
    #[doc = "* Default value is RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_NOT_REQUIRED."]
    #[doc = "* /"]
    pub require_unique_network_flow_endpoints: rmw_unique_network_flow_endpoints_requirement_t,
}
#[test]
fn bindgen_test_layout_rmw_publisher_options_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_publisher_options_t>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_publisher_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_publisher_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_publisher_options_t))
    );
    fn test_field_rmw_specific_publisher_payload() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_publisher_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rmw_specific_publisher_payload) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_publisher_options_t),
                "::",
                stringify!(rmw_specific_publisher_payload)
            )
        );
    }
    test_field_rmw_specific_publisher_payload();
    fn test_field_require_unique_network_flow_endpoints() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_publisher_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).require_unique_network_flow_endpoints) as usize
                    - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_publisher_options_t),
                "::",
                stringify!(require_unique_network_flow_endpoints)
            )
        );
    }
    test_field_require_unique_network_flow_endpoints();
}
#[doc = " Structure which encapsulates an rmw publisher"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_publisher_t {
    #[doc = " Name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Type erased pointer to this publisher's data"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " The name of the ROS topic this publisher publishes to"]
    pub topic_name: *const ::std::os::raw::c_char,
    #[doc = " Publisher options."]
    #[doc = "* *"]
    #[doc = "* The options structure passed to rmw_create_publisher() should be"]
    #[doc = "* assigned to this field by the rmw implementation."]
    #[doc = "* The fields should not be modified after creation, but"]
    #[doc = "* the contents of the options structure may or may not be const, i.e."]
    #[doc = "* shallow const-ness."]
    #[doc = "* This field is not marked const to avoid any const casting during setup."]
    #[doc = "* /"]
    pub options: rmw_publisher_options_t,
    #[doc = " Indicate whether this publisher supports loaning messages"]
    pub can_loan_messages: bool,
}
#[test]
fn bindgen_test_layout_rmw_publisher_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_publisher_t>(),
        48usize,
        concat!("Size of: ", stringify!(rmw_publisher_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_publisher_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_publisher_t))
    );
    fn test_field_implementation_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_publisher_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_publisher_t),
                "::",
                stringify!(implementation_identifier)
            )
        );
    }
    test_field_implementation_identifier();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_publisher_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_publisher_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_topic_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_publisher_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).topic_name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_publisher_t),
                "::",
                stringify!(topic_name)
            )
        );
    }
    test_field_topic_name();
    fn test_field_options() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_publisher_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_publisher_t),
                "::",
                stringify!(options)
            )
        );
    }
    test_field_options();
    fn test_field_can_loan_messages() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_publisher_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).can_loan_messages) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_publisher_t),
                "::",
                stringify!(can_loan_messages)
            )
        );
    }
    test_field_can_loan_messages();
}
#[doc = " Options that can be used to configure the creation of a subscription in rmw."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_subscription_options_t {
    #[doc = " Used to pass rmw implementation specific resources during subscription creation."]
    #[doc = "* *"]
    #[doc = "* All the same details and restrictions of this field in"]
    #[doc = "* rmw_publisher_options_t apply to this struct as well."]
    #[doc = "* "]
    #[doc = "* \\sa rmw_publisher_options_t.rmw_specific_publisher_payload"]
    #[doc = "* /"]
    pub rmw_specific_subscription_payload: *mut ::std::os::raw::c_void,
    #[doc = " If true then the middleware should not deliver data from local publishers."]
    #[doc = "* *"]
    #[doc = "* This setting is most often used when data should only be received from"]
    #[doc = "* remote nodes, especially to avoid \"double delivery\" when both intra- and"]
    #[doc = "* inter- process communication is taking place."]
    #[doc = "* "]
    #[doc = "* \\TODO(wjwwood): nail this down when participant mapping is sorted out."]
    #[doc = "* See: https://github.com/ros2/design/pull/250"]
    #[doc = "* "]
    #[doc = "* The definition of local is somewhat vague at the moment."]
    #[doc = "* Right now it means local to the node, and that definition works best, but"]
    #[doc = "* may become more complicated when/if participants map to a context instead."]
    #[doc = "* /"]
    pub ignore_local_publications: bool,
    #[doc = " Require middleware to generate unique network flow endpoints."]
    #[doc = "* *"]
    #[doc = "* Unique network flow endpoints are required to differentiate the QoS provided by"]
    #[doc = "* networks for flows between publishers and subscribers in communicating"]
    #[doc = "* nodes."]
    #[doc = "* Default value is RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_NOT_REQUIRED."]
    #[doc = "* /"]
    pub require_unique_network_flow_endpoints: rmw_unique_network_flow_endpoints_requirement_t,
}
#[test]
fn bindgen_test_layout_rmw_subscription_options_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_subscription_options_t>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_subscription_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_subscription_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_subscription_options_t))
    );
    fn test_field_rmw_specific_subscription_payload() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_subscription_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rmw_specific_subscription_payload) as usize
                    - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_subscription_options_t),
                "::",
                stringify!(rmw_specific_subscription_payload)
            )
        );
    }
    test_field_rmw_specific_subscription_payload();
    fn test_field_ignore_local_publications() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_subscription_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ignore_local_publications) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_subscription_options_t),
                "::",
                stringify!(ignore_local_publications)
            )
        );
    }
    test_field_ignore_local_publications();
    fn test_field_require_unique_network_flow_endpoints() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_subscription_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).require_unique_network_flow_endpoints) as usize
                    - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_subscription_options_t),
                "::",
                stringify!(require_unique_network_flow_endpoints)
            )
        );
    }
    test_field_require_unique_network_flow_endpoints();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_subscription_t {
    #[doc = " Name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Type erased pointer to this subscription"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " Name of the ros topic this subscription listens to"]
    pub topic_name: *const ::std::os::raw::c_char,
    #[doc = " Subscription options."]
    #[doc = "* *"]
    #[doc = "* The options structure passed to rmw_create_subscription() should be"]
    #[doc = "* assigned to this field by the rmw implementation."]
    #[doc = "* The fields should not be modified after creation, but"]
    #[doc = "* the contents of the options structure may or may not be const, i.e."]
    #[doc = "* shallow const-ness."]
    #[doc = "* This field is not marked const to avoid any const casting during setup."]
    #[doc = "* /"]
    pub options: rmw_subscription_options_t,
    #[doc = " Indicates whether this subscription can loan messages"]
    pub can_loan_messages: bool,
}
#[test]
fn bindgen_test_layout_rmw_subscription_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_subscription_t>(),
        48usize,
        concat!("Size of: ", stringify!(rmw_subscription_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_subscription_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_subscription_t))
    );
    fn test_field_implementation_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_subscription_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_subscription_t),
                "::",
                stringify!(implementation_identifier)
            )
        );
    }
    test_field_implementation_identifier();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_subscription_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_subscription_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_topic_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_subscription_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).topic_name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_subscription_t),
                "::",
                stringify!(topic_name)
            )
        );
    }
    test_field_topic_name();
    fn test_field_options() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_subscription_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_subscription_t),
                "::",
                stringify!(options)
            )
        );
    }
    test_field_options();
    fn test_field_can_loan_messages() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_subscription_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).can_loan_messages) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_subscription_t),
                "::",
                stringify!(can_loan_messages)
            )
        );
    }
    test_field_can_loan_messages();
}
#[doc = " A handle to an rmw service"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_service_t {
    #[doc = " The name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Type erased pointer to this service"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " The name of this service as exposed to the ros graph"]
    pub service_name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rmw_service_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_service_t>(),
        24usize,
        concat!("Size of: ", stringify!(rmw_service_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_service_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_service_t))
    );
    fn test_field_implementation_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_service_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_service_t),
                "::",
                stringify!(implementation_identifier)
            )
        );
    }
    test_field_implementation_identifier();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_service_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_service_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_service_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_service_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).service_name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_service_t),
                "::",
                stringify!(service_name)
            )
        );
    }
    test_field_service_name();
}
#[doc = " A handle to an rmw service client"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_client_t {
    #[doc = " The name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Type erased pointer to this service client"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " The name of this service as exposed to the ros graph"]
    pub service_name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rmw_client_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_client_t>(),
        24usize,
        concat!("Size of: ", stringify!(rmw_client_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_client_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_client_t))
    );
    fn test_field_implementation_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_client_t),
                "::",
                stringify!(implementation_identifier)
            )
        );
    }
    test_field_implementation_identifier();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_client_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_service_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).service_name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_client_t),
                "::",
                stringify!(service_name)
            )
        );
    }
    test_field_service_name();
}
#[doc = " Handle for an rmw guard condition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_guard_condition_t {
    #[doc = " The name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Type erased pointer to this guard condition"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " rmw context associated with this guard condition"]
    pub context: *mut rmw_context_t,
}
#[test]
fn bindgen_test_layout_rmw_guard_condition_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_guard_condition_t>(),
        24usize,
        concat!("Size of: ", stringify!(rmw_guard_condition_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_guard_condition_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_guard_condition_t))
    );
    fn test_field_implementation_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_guard_condition_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_guard_condition_t),
                "::",
                stringify!(implementation_identifier)
            )
        );
    }
    test_field_implementation_identifier();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_guard_condition_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_guard_condition_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_context() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_guard_condition_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_guard_condition_t),
                "::",
                stringify!(context)
            )
        );
    }
    test_field_context();
}
#[doc = " Allocation of memory for an rmw publisher"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_publisher_allocation_t {
    #[doc = " The name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Type erased pointer to this allocation"]
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rmw_publisher_allocation_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_publisher_allocation_t>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_publisher_allocation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_publisher_allocation_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_publisher_allocation_t))
    );
    fn test_field_implementation_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_publisher_allocation_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_publisher_allocation_t),
                "::",
                stringify!(implementation_identifier)
            )
        );
    }
    test_field_implementation_identifier();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_publisher_allocation_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_publisher_allocation_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
#[doc = " Allocation of memory for an rmw subscription"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_subscription_allocation_t {
    #[doc = " The name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Type erased pointer to this allocation"]
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rmw_subscription_allocation_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_subscription_allocation_t>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_subscription_allocation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_subscription_allocation_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_subscription_allocation_t))
    );
    fn test_field_implementation_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_subscription_allocation_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_subscription_allocation_t),
                "::",
                stringify!(implementation_identifier)
            )
        );
    }
    test_field_implementation_identifier();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_subscription_allocation_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_subscription_allocation_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
#[doc = " Array of subscriber handles."]
#[doc = "* *"]
#[doc = "* An array of void * pointers representing type-erased middleware-specific subscriptions."]
#[doc = "* The number of non-null entries may be smaller than the allocated size of the array."]
#[doc = "* The number of subscriptions represented may be smaller than the allocated size of the array."]
#[doc = "* The creator of this struct is responsible for allocating and deallocating the array."]
#[doc = "* /"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_subscriptions_t {
    #[doc = " The number of subscribers represented by the array."]
    pub subscriber_count: size_t,
    #[doc = " Pointer to an array of void * pointers of subscriptions."]
    pub subscribers: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rmw_subscriptions_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_subscriptions_t>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_subscriptions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_subscriptions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_subscriptions_t))
    );
    fn test_field_subscriber_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_subscriptions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subscriber_count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_subscriptions_t),
                "::",
                stringify!(subscriber_count)
            )
        );
    }
    test_field_subscriber_count();
    fn test_field_subscribers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_subscriptions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subscribers) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_subscriptions_t),
                "::",
                stringify!(subscribers)
            )
        );
    }
    test_field_subscribers();
}
#[doc = " Array of service handles."]
#[doc = "* *"]
#[doc = "* An array of void * pointers representing type-erased middleware-specific services."]
#[doc = "* The number of non-null entries may be smaller than the allocated size of the array."]
#[doc = "* The number of services represented may be smaller than the allocated size of the array."]
#[doc = "* The creator of this struct is responsible for allocating and deallocating the array."]
#[doc = "* /"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_services_t {
    #[doc = " The number of services represented by the array."]
    pub service_count: size_t,
    #[doc = " Pointer to an array of void * pointers of services."]
    pub services: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rmw_services_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_services_t>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_services_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_services_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_services_t))
    );
    fn test_field_service_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_services_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).service_count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_services_t),
                "::",
                stringify!(service_count)
            )
        );
    }
    test_field_service_count();
    fn test_field_services() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_services_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).services) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_services_t),
                "::",
                stringify!(services)
            )
        );
    }
    test_field_services();
}
#[doc = " Array of client handles."]
#[doc = "* *"]
#[doc = "* An array of void * pointers representing type-erased middleware-specific clients."]
#[doc = "* The number of non-null entries may be smaller than the allocated size of the array."]
#[doc = "* The number of clients represented may be smaller than the allocated size of the array."]
#[doc = "* The creator of this struct is responsible for allocating and deallocating the array."]
#[doc = "* /"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_clients_t {
    #[doc = " The number of clients represented by the array."]
    pub client_count: size_t,
    #[doc = " Pointer to an array of void * pointers of clients."]
    pub clients: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rmw_clients_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_clients_t>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_clients_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_clients_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_clients_t))
    );
    fn test_field_client_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_clients_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).client_count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_clients_t),
                "::",
                stringify!(client_count)
            )
        );
    }
    test_field_client_count();
    fn test_field_clients() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_clients_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clients) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_clients_t),
                "::",
                stringify!(clients)
            )
        );
    }
    test_field_clients();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_events_t {
    #[doc = " The number of events represented by the array."]
    pub event_count: size_t,
    #[doc = " Pointer to an array of void * pointers of events."]
    pub events: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rmw_events_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_events_t>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_events_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_events_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_events_t))
    );
    fn test_field_event_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_events_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).event_count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_events_t),
                "::",
                stringify!(event_count)
            )
        );
    }
    test_field_event_count();
    fn test_field_events() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_events_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_events_t),
                "::",
                stringify!(events)
            )
        );
    }
    test_field_events();
}
#[doc = " Array of guard condition handles."]
#[doc = "* *"]
#[doc = "* An array of void * pointers representing type-erased middleware-specific guard conditions."]
#[doc = "* The number of non-null entries may be smaller than the allocated size of the array."]
#[doc = "* The number of guard conditions represented may be smaller than the allocated size of the array."]
#[doc = "* The creator of this struct is responsible for allocating and deallocating the array."]
#[doc = "* /"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_guard_conditions_t {
    #[doc = " The number of guard conditions represented by the array."]
    pub guard_condition_count: size_t,
    #[doc = " Pointer to an array of void * pointers of guard conditions."]
    pub guard_conditions: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rmw_guard_conditions_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_guard_conditions_t>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_guard_conditions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_guard_conditions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_guard_conditions_t))
    );
    fn test_field_guard_condition_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_guard_conditions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).guard_condition_count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_guard_conditions_t),
                "::",
                stringify!(guard_condition_count)
            )
        );
    }
    test_field_guard_condition_count();
    fn test_field_guard_conditions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_guard_conditions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).guard_conditions) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_guard_conditions_t),
                "::",
                stringify!(guard_conditions)
            )
        );
    }
    test_field_guard_conditions();
}
#[doc = " Container for guard conditions to be waited on"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_wait_set_t {
    #[doc = " The name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " The guard condition to be waited on"]
    pub guard_conditions: *mut rmw_guard_conditions_t,
    #[doc = " Type erased pointer to this wait set's data"]
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rmw_wait_set_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_wait_set_t>(),
        24usize,
        concat!("Size of: ", stringify!(rmw_wait_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_wait_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_wait_set_t))
    );
    fn test_field_implementation_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_wait_set_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_wait_set_t),
                "::",
                stringify!(implementation_identifier)
            )
        );
    }
    test_field_implementation_identifier();
    fn test_field_guard_conditions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_wait_set_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).guard_conditions) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_wait_set_t),
                "::",
                stringify!(guard_conditions)
            )
        );
    }
    test_field_guard_conditions();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_wait_set_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_wait_set_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
#[doc = " An rmw service request identifier"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_request_id_t {
    #[doc = " The guid of the writer associated with this request"]
    pub writer_guid: [i8; 16usize],
    #[doc = " Sequence number of this service"]
    pub sequence_number: i64,
}
#[test]
fn bindgen_test_layout_rmw_request_id_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_request_id_t>(),
        24usize,
        concat!("Size of: ", stringify!(rmw_request_id_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_request_id_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_request_id_t))
    );
    fn test_field_writer_guid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_request_id_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).writer_guid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_request_id_t),
                "::",
                stringify!(writer_guid)
            )
        );
    }
    test_field_writer_guid();
    fn test_field_sequence_number() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_request_id_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sequence_number) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_request_id_t),
                "::",
                stringify!(sequence_number)
            )
        );
    }
    test_field_sequence_number();
}
#[doc = " Meta-data for a service-related take."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_service_info_t {
    pub source_timestamp: rmw_time_point_value_t,
    pub received_timestamp: rmw_time_point_value_t,
    pub request_id: rmw_request_id_t,
}
#[test]
fn bindgen_test_layout_rmw_service_info_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_service_info_t>(),
        40usize,
        concat!("Size of: ", stringify!(rmw_service_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_service_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_service_info_t))
    );
    fn test_field_source_timestamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_service_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).source_timestamp) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_service_info_t),
                "::",
                stringify!(source_timestamp)
            )
        );
    }
    test_field_source_timestamp();
    fn test_field_received_timestamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_service_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).received_timestamp) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_service_info_t),
                "::",
                stringify!(received_timestamp)
            )
        );
    }
    test_field_received_timestamp();
    fn test_field_request_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_service_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).request_id) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_service_info_t),
                "::",
                stringify!(request_id)
            )
        );
    }
    test_field_request_id();
}
#[doc = " Implementation specific default"]
pub const rmw_qos_reliability_policy_t_RMW_QOS_POLICY_RELIABILITY_SYSTEM_DEFAULT:
    rmw_qos_reliability_policy_t = 0;
#[doc = " Guarantee that samples are delivered, may retry multiple times."]
pub const rmw_qos_reliability_policy_t_RMW_QOS_POLICY_RELIABILITY_RELIABLE:
    rmw_qos_reliability_policy_t = 1;
#[doc = " Attempt to deliver samples, but some may be lost if the network is not robust"]
pub const rmw_qos_reliability_policy_t_RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT:
    rmw_qos_reliability_policy_t = 2;
#[doc = " Reliability policy has not yet been set"]
pub const rmw_qos_reliability_policy_t_RMW_QOS_POLICY_RELIABILITY_UNKNOWN:
    rmw_qos_reliability_policy_t = 3;
pub type rmw_qos_reliability_policy_t = ::std::os::raw::c_uint;
#[doc = " Implementation default for history policy"]
pub const rmw_qos_history_policy_t_RMW_QOS_POLICY_HISTORY_SYSTEM_DEFAULT: rmw_qos_history_policy_t =
    0;
#[doc = " Only store up to a maximum number of samples, dropping oldest once max is exceeded"]
pub const rmw_qos_history_policy_t_RMW_QOS_POLICY_HISTORY_KEEP_LAST: rmw_qos_history_policy_t = 1;
#[doc = " Store all samples, subject to resource limits"]
pub const rmw_qos_history_policy_t_RMW_QOS_POLICY_HISTORY_KEEP_ALL: rmw_qos_history_policy_t = 2;
#[doc = " History policy has not yet been set"]
pub const rmw_qos_history_policy_t_RMW_QOS_POLICY_HISTORY_UNKNOWN: rmw_qos_history_policy_t = 3;
#[doc = " QoS history enumerations describing how samples endure"]
pub type rmw_qos_history_policy_t = ::std::os::raw::c_uint;
#[doc = " Impplementation specific default"]
pub const rmw_qos_durability_policy_t_RMW_QOS_POLICY_DURABILITY_SYSTEM_DEFAULT:
    rmw_qos_durability_policy_t = 0;
#[doc = " The rmw publisher is responsible for persisting samples for late-joining subscribers"]
pub const rmw_qos_durability_policy_t_RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL:
    rmw_qos_durability_policy_t = 1;
#[doc = " Samples are not persistent"]
pub const rmw_qos_durability_policy_t_RMW_QOS_POLICY_DURABILITY_VOLATILE:
    rmw_qos_durability_policy_t = 2;
#[doc = " Durability policy has not yet been set"]
pub const rmw_qos_durability_policy_t_RMW_QOS_POLICY_DURABILITY_UNKNOWN:
    rmw_qos_durability_policy_t = 3;
#[doc = " QoS durability enumerations describing how samples persist"]
pub type rmw_qos_durability_policy_t = ::std::os::raw::c_uint;
#[doc = " Implementation specific default"]
pub const rmw_qos_liveliness_policy_t_RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT:
    rmw_qos_liveliness_policy_t = 0;
#[doc = " The signal that establishes a Topic is alive comes from the ROS rmw layer."]
pub const rmw_qos_liveliness_policy_t_RMW_QOS_POLICY_LIVELINESS_AUTOMATIC:
    rmw_qos_liveliness_policy_t = 1;
pub const rmw_qos_liveliness_policy_t_RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE:
    rmw_qos_liveliness_policy_t = 2;
#[doc = " The signal that establishes a Topic is alive is at the Topic level. Only publishing a message"]
#[doc = " on the Topic or an explicit signal from the application to assert liveliness on the Topic"]
#[doc = " will mark the Topic as being alive."]
pub const rmw_qos_liveliness_policy_t_RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC:
    rmw_qos_liveliness_policy_t = 3;
#[doc = " Liveliness policy has not yet been set"]
pub const rmw_qos_liveliness_policy_t_RMW_QOS_POLICY_LIVELINESS_UNKNOWN:
    rmw_qos_liveliness_policy_t = 4;
#[doc = " QoS liveliness enumerations that describe a publisher's reporting policy for its alive status."]
#[doc = " For a subscriber, these are its requirements for its topic's publishers."]
pub type rmw_qos_liveliness_policy_t = ::std::os::raw::c_uint;
#[doc = " ROS MiddleWare quality of service profile."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_qos_profile_t {
    pub history: rmw_qos_history_policy_t,
    #[doc = " Size of the message queue."]
    pub depth: size_t,
    #[doc = " Reliabiilty QoS policy setting"]
    pub reliability: rmw_qos_reliability_policy_t,
    #[doc = " Durability QoS policy setting"]
    pub durability: rmw_qos_durability_policy_t,
    #[doc = " The period at which messages are expected to be sent/received"]
    #[doc = "* *"]
    #[doc = "* RMW_DURATION_UNSPEFICIED will use the RMW implementation's default value,"]
    #[doc = "* which may or may not be infinite."]
    #[doc = "* RMW_DURATION_INFINITE explicitly states that messages never miss a deadline expectation."]
    #[doc = "* /"]
    pub deadline: rmw_time_t,
    #[doc = " The age at which messages are considered expired and no longer valid"]
    #[doc = "* *"]
    #[doc = "* RMW_DURATION_UNSPEFICIED will use the RMW implementation's default value,"]
    #[doc = "* which may or may not be infinite."]
    #[doc = "* RMW_DURATION_INFINITE explicitly states that messages do not expire."]
    #[doc = "* /"]
    pub lifespan: rmw_time_t,
    #[doc = " Liveliness QoS policy setting"]
    pub liveliness: rmw_qos_liveliness_policy_t,
    #[doc = " The time within which the RMW node or publisher must show that it is alive"]
    #[doc = "* *"]
    #[doc = "* RMW_DURATION_UNSPEFICIED will use the RMW implementation's default value,"]
    #[doc = "* which may or may not be infinite."]
    #[doc = "* RMW_DURATION_INFINITE explicitly states that liveliness is not enforced."]
    #[doc = "* /"]
    pub liveliness_lease_duration: rmw_time_t,
    #[doc = " If true, any ROS specific namespacing conventions will be circumvented."]
    #[doc = "* *"]
    #[doc = "* In the case of DDS and topics, for example, this means the typical"]
    #[doc = "* ROS specific prefix of `rt` would not be applied as described here:"]
    #[doc = "* "]
    #[doc = "* http://design.ros2.org/articles/topic_and_service_names.html#ros-specific-namespace-prefix"]
    #[doc = "* "]
    #[doc = "* This might be useful when trying to directly connect a native DDS topic"]
    #[doc = "* with a ROS 2 topic."]
    #[doc = "* /"]
    pub avoid_ros_namespace_conventions: bool,
}
#[test]
fn bindgen_test_layout_rmw_qos_profile_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_qos_profile_t>(),
        88usize,
        concat!("Size of: ", stringify!(rmw_qos_profile_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_qos_profile_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_qos_profile_t))
    );
    fn test_field_history() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_qos_profile_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).history) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_qos_profile_t),
                "::",
                stringify!(history)
            )
        );
    }
    test_field_history();
    fn test_field_depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_qos_profile_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_qos_profile_t),
                "::",
                stringify!(depth)
            )
        );
    }
    test_field_depth();
    fn test_field_reliability() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_qos_profile_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reliability) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_qos_profile_t),
                "::",
                stringify!(reliability)
            )
        );
    }
    test_field_reliability();
    fn test_field_durability() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_qos_profile_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).durability) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_qos_profile_t),
                "::",
                stringify!(durability)
            )
        );
    }
    test_field_durability();
    fn test_field_deadline() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_qos_profile_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deadline) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_qos_profile_t),
                "::",
                stringify!(deadline)
            )
        );
    }
    test_field_deadline();
    fn test_field_lifespan() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_qos_profile_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lifespan) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_qos_profile_t),
                "::",
                stringify!(lifespan)
            )
        );
    }
    test_field_lifespan();
    fn test_field_liveliness() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_qos_profile_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).liveliness) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_qos_profile_t),
                "::",
                stringify!(liveliness)
            )
        );
    }
    test_field_liveliness();
    fn test_field_liveliness_lease_duration() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_qos_profile_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).liveliness_lease_duration) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_qos_profile_t),
                "::",
                stringify!(liveliness_lease_duration)
            )
        );
    }
    test_field_liveliness_lease_duration();
    fn test_field_avoid_ros_namespace_conventions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_qos_profile_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).avoid_ros_namespace_conventions) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_qos_profile_t),
                "::",
                stringify!(avoid_ros_namespace_conventions)
            )
        );
    }
    test_field_avoid_ros_namespace_conventions();
}
#[doc = " ROS graph ID of the topic"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_gid_t {
    #[doc = " Name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Bype data Gid value"]
    pub data: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_rmw_gid_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_gid_t>(),
        32usize,
        concat!("Size of: ", stringify!(rmw_gid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_gid_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_gid_t))
    );
    fn test_field_implementation_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_gid_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_gid_t),
                "::",
                stringify!(implementation_identifier)
            )
        );
    }
    test_field_implementation_identifier();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_gid_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_gid_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
#[doc = " Information describing an rmw message"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_message_info_t {
    pub source_timestamp: rmw_time_point_value_t,
    pub received_timestamp: rmw_time_point_value_t,
    pub publisher_gid: rmw_gid_t,
    #[doc = " Whether this message is from intra_process communication or not"]
    pub from_intra_process: bool,
}
#[test]
fn bindgen_test_layout_rmw_message_info_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_message_info_t>(),
        56usize,
        concat!("Size of: ", stringify!(rmw_message_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_message_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_message_info_t))
    );
    fn test_field_source_timestamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_message_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).source_timestamp) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_message_info_t),
                "::",
                stringify!(source_timestamp)
            )
        );
    }
    test_field_source_timestamp();
    fn test_field_received_timestamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_message_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).received_timestamp) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_message_info_t),
                "::",
                stringify!(received_timestamp)
            )
        );
    }
    test_field_received_timestamp();
    fn test_field_publisher_gid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_message_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).publisher_gid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_message_info_t),
                "::",
                stringify!(publisher_gid)
            )
        );
    }
    test_field_publisher_gid();
    fn test_field_from_intra_process() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_message_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).from_intra_process) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_message_info_t),
                "::",
                stringify!(from_intra_process)
            )
        );
    }
    test_field_from_intra_process();
}
extern "C" {
    #[doc = " Get zero initialized mesage info."]
    pub fn rmw_get_zero_initialized_message_info() -> rmw_message_info_t;
}
pub const RMW_QOS_POLICY_DEPTH_SYSTEM_DEFAULT: _bindgen_ty_1 = 0;
#[doc = " Default size of the rmw queue when history is set to RMW_QOS_POLICY_HISTORY_KEEP_LAST,"]
#[doc = " 0 indicates it is currently not set"]
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[doc = " Debug log severity, for pedantic messaging"]
pub const rmw_log_severity_t_RMW_LOG_SEVERITY_DEBUG: rmw_log_severity_t = 10;
#[doc = " Informational log severity, for reporting expected but not overwhelming information"]
pub const rmw_log_severity_t_RMW_LOG_SEVERITY_INFO: rmw_log_severity_t = 20;
#[doc = " Warning log severity, for reporting recoverable issues"]
pub const rmw_log_severity_t_RMW_LOG_SEVERITY_WARN: rmw_log_severity_t = 30;
#[doc = " Error log severity, for reporting uncoverable issues"]
pub const rmw_log_severity_t_RMW_LOG_SEVERITY_ERROR: rmw_log_severity_t = 40;
#[doc = " Fatal log severity, for reporting issue causing imminent shutdown"]
pub const rmw_log_severity_t_RMW_LOG_SEVERITY_FATAL: rmw_log_severity_t = 50;
#[doc = " Type mapping of rcutils log severity types to rmw specific types."]
pub type rmw_log_severity_t = ::std::os::raw::c_uint;
#[doc = " The type that holds an rcl return code."]
pub type rcl_ret_t = rmw_ret_t;
#[doc = " The structure holding the metadata for a uint8 array."]
pub type rcl_serialized_message_t = rmw_serialized_message_t;
#[doc = " The severity levels of log messages / loggers."]
pub use self::RCUTILS_LOG_SEVERITY as rcl_log_severity_t;
#[doc = " A logger item to specify a name and a log level."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_logger_setting_t {
    #[doc = " Name for the logger."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Minimum log level severity of the logger."]
    pub level: rcl_log_severity_t,
}
#[test]
fn bindgen_test_layout_rcl_logger_setting_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_logger_setting_t>(),
        16usize,
        concat!("Size of: ", stringify!(rcl_logger_setting_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_logger_setting_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_logger_setting_t))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_logger_setting_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_logger_setting_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_level() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_logger_setting_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_logger_setting_t),
                "::",
                stringify!(level)
            )
        );
    }
    test_field_level();
}
#[doc = " Hold default logger level and other logger setting."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_log_levels_t {
    #[doc = " Minimum default logger level severity."]
    pub default_logger_level: rcl_log_severity_t,
    #[doc = " Array of logger setting."]
    pub logger_settings: *mut rcl_logger_setting_t,
    #[doc = " Number of logger settings."]
    pub num_logger_settings: size_t,
    #[doc = " Capacity of logger settings."]
    pub capacity_logger_settings: size_t,
    #[doc = " Allocator used to allocate objects in this struct."]
    pub allocator: rcl_allocator_t,
}
#[test]
fn bindgen_test_layout_rcl_log_levels_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_log_levels_t>(),
        72usize,
        concat!("Size of: ", stringify!(rcl_log_levels_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_log_levels_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_log_levels_t))
    );
    fn test_field_default_logger_level() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_log_levels_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).default_logger_level) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_log_levels_t),
                "::",
                stringify!(default_logger_level)
            )
        );
    }
    test_field_default_logger_level();
    fn test_field_logger_settings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_log_levels_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).logger_settings) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_log_levels_t),
                "::",
                stringify!(logger_settings)
            )
        );
    }
    test_field_logger_settings();
    fn test_field_num_logger_settings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_log_levels_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_logger_settings) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_log_levels_t),
                "::",
                stringify!(num_logger_settings)
            )
        );
    }
    test_field_num_logger_settings();
    fn test_field_capacity_logger_settings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_log_levels_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).capacity_logger_settings) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_log_levels_t),
                "::",
                stringify!(capacity_logger_settings)
            )
        );
    }
    test_field_capacity_logger_settings();
    fn test_field_allocator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_log_levels_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_log_levels_t),
                "::",
                stringify!(allocator)
            )
        );
    }
    test_field_allocator();
}
extern "C" {
    #[doc = " Return a rcl_log_levels_t struct with members initialized to zero value."]
    #[doc = "* *"]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\return a rcl_log_levels_t struct with members initialized to zero value."]
    #[doc = "* /"]
    pub fn rcl_get_zero_initialized_log_levels() -> rcl_log_levels_t;
}
extern "C" {
    #[doc = " Initialize a log levels structure."]
    #[doc = "* *"]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] log_levels The structure to be initialized."]
    #[doc = "* \\param[in] allocator Memory allocator to be used and assigned into log_levels."]
    #[doc = "* \\param[in] logger_count Number of logger settings to be allocated."]
    #[doc = "* This reserves memory for logger_settings, but doesn't initialize it."]
    #[doc = "* \\return #RCL_RET_OK if the structure was initialized successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if log_levels is NULL, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if log_levels contains initialized memory, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if allocator is invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed."]
    #[doc = "* /"]
    pub fn rcl_log_levels_init(
        log_levels: *mut rcl_log_levels_t,
        allocator: *const rcl_allocator_t,
        logger_count: size_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Copy one log levels structure into another."]
    #[doc = "* *"]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] src The structure to be copied."]
    #[doc = "* Its allocator is used to copy memory into the new structure."]
    #[doc = "* \\param[out] dst A log levels structure to be copied into."]
    #[doc = "* \\return #RCL_RET_OK if the structure was copied successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if src is NULL, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if src allocator is invalid, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if dst is NULL, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if dst contains already allocated memory, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed."]
    #[doc = "* /"]
    pub fn rcl_log_levels_copy(
        src: *const rcl_log_levels_t,
        dst: *mut rcl_log_levels_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Reclaim resources held inside rcl_log_levels_t structure."]
    #[doc = "* *"]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] log_levels The structure which its resources have to be deallocated."]
    #[doc = "* \\return #RCL_RET_OK if the memory was successfully freed, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if log_levels is NULL, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if the log_levels allocator is invalid and the structure contains initialized memory."]
    #[doc = "* /"]
    pub fn rcl_log_levels_fini(log_levels: *mut rcl_log_levels_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Shrink log levels structure."]
    #[doc = "* *"]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] log_levels The structure to be shrunk."]
    #[doc = "* \\return #RCL_RET_OK if the memory was successfully shrunk, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if log_levels is NULL or if its allocator is invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if reallocating memory failed."]
    #[doc = "* /"]
    pub fn rcl_log_levels_shrink_to_size(log_levels: *mut rcl_log_levels_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Add logger setting with a name and a level."]
    #[doc = "* *"]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] log_levels The structure where to set the logger log level."]
    #[doc = "* \\param[in] logger_name Name for the logger, a copy of it will be stored in the structure."]
    #[doc = "* \\param[in] log_level Minimum log level severity to be set for logger_name."]
    #[doc = "* \\return #RCL_RET_OK if add logger setting successfully, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if log_levels is NULL, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if log_levels was not initialized, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if log_levels allocator is invalid, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if logger_name is NULL, or"]
    #[doc = "* \\return #RCL_RET_ERROR if the log_levels structure is already full."]
    #[doc = "* /"]
    pub fn rcl_log_levels_add_logger_setting(
        log_levels: *mut rcl_log_levels_t,
        logger_name: *const ::std::os::raw::c_char,
        log_level: rcl_log_severity_t,
    ) -> rcl_ret_t;
}
#[doc = " Array of bool values"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_bool_array_s {
    #[doc = " Array with bool values"]
    pub values: *mut bool,
    #[doc = " Number of values in the array"]
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_rcl_bool_array_s() {
    assert_eq!(
        ::std::mem::size_of::<rcl_bool_array_s>(),
        16usize,
        concat!("Size of: ", stringify!(rcl_bool_array_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_bool_array_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_bool_array_s))
    );
    fn test_field_values() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_bool_array_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_bool_array_s),
                "::",
                stringify!(values)
            )
        );
    }
    test_field_values();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_bool_array_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_bool_array_s),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
}
#[doc = " Array of bool values"]
pub type rcl_bool_array_t = rcl_bool_array_s;
#[doc = " Array of int64_t values"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_int64_array_s {
    #[doc = " Array with int64 values"]
    pub values: *mut i64,
    #[doc = " Number of values in the array"]
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_rcl_int64_array_s() {
    assert_eq!(
        ::std::mem::size_of::<rcl_int64_array_s>(),
        16usize,
        concat!("Size of: ", stringify!(rcl_int64_array_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_int64_array_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_int64_array_s))
    );
    fn test_field_values() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_int64_array_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_int64_array_s),
                "::",
                stringify!(values)
            )
        );
    }
    test_field_values();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_int64_array_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_int64_array_s),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
}
#[doc = " Array of int64_t values"]
pub type rcl_int64_array_t = rcl_int64_array_s;
#[doc = " Array of double values"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_double_array_s {
    #[doc = " Array with double values"]
    pub values: *mut f64,
    #[doc = " Number of values in the array"]
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_rcl_double_array_s() {
    assert_eq!(
        ::std::mem::size_of::<rcl_double_array_s>(),
        16usize,
        concat!("Size of: ", stringify!(rcl_double_array_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_double_array_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_double_array_s))
    );
    fn test_field_values() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_double_array_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_double_array_s),
                "::",
                stringify!(values)
            )
        );
    }
    test_field_values();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_double_array_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_double_array_s),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
}
#[doc = " Array of double values"]
pub type rcl_double_array_t = rcl_double_array_s;
#[doc = " Array of byte values"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_byte_array_s {
    #[doc = " Array with uint8_t values"]
    pub values: *mut u8,
    #[doc = " Number of values in the array"]
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_rcl_byte_array_s() {
    assert_eq!(
        ::std::mem::size_of::<rcl_byte_array_s>(),
        16usize,
        concat!("Size of: ", stringify!(rcl_byte_array_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_byte_array_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_byte_array_s))
    );
    fn test_field_values() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_byte_array_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_byte_array_s),
                "::",
                stringify!(values)
            )
        );
    }
    test_field_values();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_byte_array_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_byte_array_s),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
}
#[doc = " Array of byte values"]
pub type rcl_byte_array_t = rcl_byte_array_s;
#[doc = " variant_t stores the value of a parameter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_variant_s {
    #[doc = "< If bool, gets stored here"]
    pub bool_value: *mut bool,
    #[doc = "< If integer, gets stored here"]
    pub integer_value: *mut i64,
    #[doc = "< If double, gets stored here"]
    pub double_value: *mut f64,
    #[doc = "< If string, gets stored here"]
    pub string_value: *mut ::std::os::raw::c_char,
    #[doc = "< If array of bytes"]
    pub byte_array_value: *mut rcl_byte_array_t,
    #[doc = "< If array of bool's"]
    pub bool_array_value: *mut rcl_bool_array_t,
    #[doc = "< If array of integers"]
    pub integer_array_value: *mut rcl_int64_array_t,
    #[doc = "< If array of doubles"]
    pub double_array_value: *mut rcl_double_array_t,
    #[doc = "< If array of strings"]
    pub string_array_value: *mut rcutils_string_array_t,
}
#[test]
fn bindgen_test_layout_rcl_variant_s() {
    assert_eq!(
        ::std::mem::size_of::<rcl_variant_s>(),
        72usize,
        concat!("Size of: ", stringify!(rcl_variant_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_variant_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_variant_s))
    );
    fn test_field_bool_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_variant_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bool_value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_variant_s),
                "::",
                stringify!(bool_value)
            )
        );
    }
    test_field_bool_value();
    fn test_field_integer_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_variant_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integer_value) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_variant_s),
                "::",
                stringify!(integer_value)
            )
        );
    }
    test_field_integer_value();
    fn test_field_double_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_variant_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).double_value) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_variant_s),
                "::",
                stringify!(double_value)
            )
        );
    }
    test_field_double_value();
    fn test_field_string_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_variant_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).string_value) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_variant_s),
                "::",
                stringify!(string_value)
            )
        );
    }
    test_field_string_value();
    fn test_field_byte_array_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_variant_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).byte_array_value) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_variant_s),
                "::",
                stringify!(byte_array_value)
            )
        );
    }
    test_field_byte_array_value();
    fn test_field_bool_array_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_variant_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bool_array_value) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_variant_s),
                "::",
                stringify!(bool_array_value)
            )
        );
    }
    test_field_bool_array_value();
    fn test_field_integer_array_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_variant_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integer_array_value) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_variant_s),
                "::",
                stringify!(integer_array_value)
            )
        );
    }
    test_field_integer_array_value();
    fn test_field_double_array_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_variant_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).double_array_value) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_variant_s),
                "::",
                stringify!(double_array_value)
            )
        );
    }
    test_field_double_array_value();
    fn test_field_string_array_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_variant_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).string_array_value) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_variant_s),
                "::",
                stringify!(string_array_value)
            )
        );
    }
    test_field_string_array_value();
}
#[doc = " variant_t stores the value of a parameter"]
pub type rcl_variant_t = rcl_variant_s;
#[doc = " node_params_t stores all the parameters(key:value) of a single node"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_node_params_s {
    #[doc = "< Array of parameter names (keys)"]
    pub parameter_names: *mut *mut ::std::os::raw::c_char,
    #[doc = "< Array of coressponding parameter values"]
    pub parameter_values: *mut rcl_variant_t,
    #[doc = "< Number of parameters in the node"]
    pub num_params: size_t,
    #[doc = "< Capacity of parameters in the node"]
    pub capacity_params: size_t,
}
#[test]
fn bindgen_test_layout_rcl_node_params_s() {
    assert_eq!(
        ::std::mem::size_of::<rcl_node_params_s>(),
        32usize,
        concat!("Size of: ", stringify!(rcl_node_params_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_node_params_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_node_params_s))
    );
    fn test_field_parameter_names() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_node_params_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parameter_names) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_node_params_s),
                "::",
                stringify!(parameter_names)
            )
        );
    }
    test_field_parameter_names();
    fn test_field_parameter_values() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_node_params_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parameter_values) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_node_params_s),
                "::",
                stringify!(parameter_values)
            )
        );
    }
    test_field_parameter_values();
    fn test_field_num_params() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_node_params_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_params) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_node_params_s),
                "::",
                stringify!(num_params)
            )
        );
    }
    test_field_num_params();
    fn test_field_capacity_params() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_node_params_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).capacity_params) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_node_params_s),
                "::",
                stringify!(capacity_params)
            )
        );
    }
    test_field_capacity_params();
}
#[doc = " node_params_t stores all the parameters(key:value) of a single node"]
pub type rcl_node_params_t = rcl_node_params_s;
#[doc = " stores all the parameters of all nodes of a process"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_params_s {
    #[doc = "< List of names of the node"]
    pub node_names: *mut *mut ::std::os::raw::c_char,
    #[doc = "<  Array of parameters"]
    pub params: *mut rcl_node_params_t,
    #[doc = "< Number of nodes"]
    pub num_nodes: size_t,
    #[doc = "< Capacity of nodes"]
    pub capacity_nodes: size_t,
    #[doc = "< Allocator used"]
    pub allocator: rcutils_allocator_t,
}
#[test]
fn bindgen_test_layout_rcl_params_s() {
    assert_eq!(
        ::std::mem::size_of::<rcl_params_s>(),
        72usize,
        concat!("Size of: ", stringify!(rcl_params_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_params_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_params_s))
    );
    fn test_field_node_names() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_params_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).node_names) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_params_s),
                "::",
                stringify!(node_names)
            )
        );
    }
    test_field_node_names();
    fn test_field_params() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_params_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_params_s),
                "::",
                stringify!(params)
            )
        );
    }
    test_field_params();
    fn test_field_num_nodes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_params_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_nodes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_params_s),
                "::",
                stringify!(num_nodes)
            )
        );
    }
    test_field_num_nodes();
    fn test_field_capacity_nodes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_params_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).capacity_nodes) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_params_s),
                "::",
                stringify!(capacity_nodes)
            )
        );
    }
    test_field_capacity_nodes();
    fn test_field_allocator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_params_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_params_s),
                "::",
                stringify!(allocator)
            )
        );
    }
    test_field_allocator();
}
#[doc = " stores all the parameters of all nodes of a process"]
pub type rcl_params_t = rcl_params_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_arguments_impl_t {
    _unused: [u8; 0],
}
#[doc = " Hold output of parsing command line arguments."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_arguments_t {
    #[doc = " Private implementation pointer."]
    pub impl_: *mut rcl_arguments_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_arguments_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_arguments_t>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_arguments_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_arguments_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_arguments_t))
    );
    fn test_field_impl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_arguments_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_arguments_t),
                "::",
                stringify!(impl_)
            )
        );
    }
    test_field_impl();
}
extern "C" {
    #[doc = " Return a rcl_arguments_t struct with members initialized to `NULL`."]
    pub fn rcl_get_zero_initialized_arguments() -> rcl_arguments_t;
}
extern "C" {
    #[doc = " Parse command line arguments into a structure usable by code."]
    #[doc = "* *"]
    #[doc = "* \\sa rcl_get_zero_initialized_arguments()"]
    #[doc = "* "]
    #[doc = "* ROS arguments are expected to be scoped by a leading `--ros-args` flag and a trailing double"]
    #[doc = "* dash token `--` which may be elided if no non-ROS arguments follow after the last `--ros-args`."]
    #[doc = "* "]
    #[doc = "* Remap rule parsing is supported via `-r/--remap` flags e.g. `--remap from:=to` or `-r from:=to`."]
    #[doc = "* Successfully parsed remap rules are stored in the order they were given in `argv`."]
    #[doc = "* If given arguments `{\"__ns:=/foo\", \"__ns:=/bar\"}` then the namespace used by nodes in this"]
    #[doc = "* process will be `/foo` and not `/bar`."]
    #[doc = "* "]
    #[doc = "* \\sa rcl_remap_topic_name()"]
    #[doc = "* \\sa rcl_remap_service_name()"]
    #[doc = "* \\sa rcl_remap_node_name()"]
    #[doc = "* \\sa rcl_remap_node_namespace()"]
    #[doc = "* "]
    #[doc = "* Parameter override rule parsing is supported via `-p/--param` flags e.g. `--param name:=value`"]
    #[doc = "* or `-p name:=value`."]
    #[doc = "* "]
    #[doc = "* The default log level will be parsed as `--log-level level` and logger levels will be parsed as"]
    #[doc = "* multiple `--log-level name:=level`, where `level` is a name representing one of the log levels"]
    #[doc = "* in the `RCUTILS_LOG_SEVERITY` enum, e.g. `info`, `debug`, `warn`, not case sensitive."]
    #[doc = "* If multiple of these rules are found, the last one parsed will be used."]
    #[doc = "* "]
    #[doc = "* If an argument does not appear to be a valid ROS argument e.g. a `-r/--remap` flag followed by"]
    #[doc = "* anything but a valid remap rule, parsing will fail immediately."]
    #[doc = "* "]
    #[doc = "* If an argument does not appear to be a known ROS argument, then it is skipped and left unparsed."]
    #[doc = "* "]
    #[doc = "* \\sa rcl_arguments_get_count_unparsed_ros()"]
    #[doc = "* \\sa rcl_arguments_get_unparsed_ros()"]
    #[doc = "* "]
    #[doc = "* All arguments found outside a `--ros-args ... --` scope are skipped and left unparsed."]
    #[doc = "* "]
    #[doc = "* \\sa rcl_arguments_get_count_unparsed()"]
    #[doc = "* \\sa rcl_arguments_get_unparsed()"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] argc The number of arguments in argv."]
    #[doc = "* \\param[in] argv The values of the arguments."]
    #[doc = "* \\param[in] allocator A valid allocator."]
    #[doc = "* \\param[out] args_output A structure that will contain the result of parsing."]
    #[doc = "* Must be zero initialized before use."]
    #[doc = "* \\return #RCL_RET_OK if the arguments were parsed successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ROS_ARGS if an invalid ROS argument is found, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_parse_arguments(
        argc: ::std::os::raw::c_int,
        argv: *const *const ::std::os::raw::c_char,
        allocator: rcl_allocator_t,
        args_output: *mut rcl_arguments_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the number of arguments that were not ROS specific arguments."]
    #[doc = "* *"]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] args An arguments structure that has been parsed."]
    #[doc = "* \\return number of unparsed arguments, or"]
    #[doc = "* \\return -1 if args is `NULL` or zero initialized."]
    #[doc = "* /"]
    pub fn rcl_arguments_get_count_unparsed(args: *const rcl_arguments_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a list of indices to non ROS specific arguments."]
    #[doc = "* *"]
    #[doc = "* Non ROS specific arguments may have been provided i.e. arguments outside a '--ros-args' scope."]
    #[doc = "* This function populates an array of indices to these arguments in the original argv array."]
    #[doc = "* Since the first argument is always assumed to be a process name, the list will always contain"]
    #[doc = "* the index 0."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] args An arguments structure that has been parsed."]
    #[doc = "* \\param[in] allocator A valid allocator."]
    #[doc = "* \\param[out] output_unparsed_indices An allocated array of indices into the original argv array."]
    #[doc = "* This array must be deallocated by the caller using the given allocator."]
    #[doc = "* If there are no unparsed args then the output will be set to NULL."]
    #[doc = "* \\return #RCL_RET_OK if everything goes correctly, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_arguments_get_unparsed(
        args: *const rcl_arguments_t,
        allocator: rcl_allocator_t,
        output_unparsed_indices: *mut *mut ::std::os::raw::c_int,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the number of ROS specific arguments that were not successfully parsed."]
    #[doc = "* *"]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] args An arguments structure that has been parsed."]
    #[doc = "* \\return number of unparsed ROS specific arguments, or"]
    #[doc = "* \\return -1 if args is `NULL` or zero initialized."]
    #[doc = "* /"]
    pub fn rcl_arguments_get_count_unparsed_ros(
        args: *const rcl_arguments_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a list of indices to unknown ROS specific arguments that were left unparsed."]
    #[doc = "* *"]
    #[doc = "* Some ROS specific arguments may not have been recognized, or were not intended to be"]
    #[doc = "* parsed by rcl."]
    #[doc = "* This function populates an array of indices to these arguments in the original argv array."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] args An arguments structure that has been parsed."]
    #[doc = "* \\param[in] allocator A valid allocator."]
    #[doc = "* \\param[out] output_unparsed_ros_indices An allocated array of indices into the original argv array."]
    #[doc = "* This array must be deallocated by the caller using the given allocator."]
    #[doc = "* If there are no unparsed ROS specific arguments then the output will be set to NULL."]
    #[doc = "* \\return #RCL_RET_OK if everything goes correctly, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_arguments_get_unparsed_ros(
        args: *const rcl_arguments_t,
        allocator: rcl_allocator_t,
        output_unparsed_ros_indices: *mut *mut ::std::os::raw::c_int,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the number of parameter yaml files given in the arguments."]
    #[doc = "* *"]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] args An arguments structure that has been parsed."]
    #[doc = "* \\return number of yaml files, or"]
    #[doc = "* \\return -1 if args is `NULL` or zero initialized."]
    #[doc = "* /"]
    pub fn rcl_arguments_get_param_files_count(
        args: *const rcl_arguments_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a list of yaml parameter file paths specified on the command line."]
    #[doc = "* *"]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] arguments An arguments structure that has been parsed."]
    #[doc = "* \\param[in] allocator A valid allocator."]
    #[doc = "* \\param[out] parameter_files An allocated array of paramter file names."]
    #[doc = "* This array must be deallocated by the caller using the given allocator."]
    #[doc = "* The output is NULL if there were no paramter files."]
    #[doc = "* \\return #RCL_RET_OK if everything goes correctly, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_arguments_get_param_files(
        arguments: *const rcl_arguments_t,
        allocator: rcl_allocator_t,
        parameter_files: *mut *mut *mut ::std::os::raw::c_char,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return all parameter overrides parsed from the command line."]
    #[doc = "* *"]
    #[doc = "* Parameter overrides are parsed directly from command line arguments and"]
    #[doc = "* parameter files provided in the command line."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] arguments An arguments structure that has been parsed."]
    #[doc = "* \\param[out] parameter_overrides Parameter overrides as parsed from command line arguments."]
    #[doc = "* This structure must be finalized by the caller."]
    #[doc = "* The output is NULL if no parameter overrides were parsed."]
    #[doc = "* \\return #RCL_RET_OK if everything goes correctly, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_arguments_get_param_overrides(
        arguments: *const rcl_arguments_t,
        parameter_overrides: *mut *mut rcl_params_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a list of arguments with ROS-specific arguments removed."]
    #[doc = "* *"]
    #[doc = "* Some arguments may not have been intended as ROS arguments."]
    #[doc = "* This function populates an array of the aruments in a new argv array."]
    #[doc = "* Since the first argument is always assumed to be a process name, the list"]
    #[doc = "* will always contain the first value from the argument vector."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] argv The argument vector"]
    #[doc = "* \\param[in] args An arguments structure that has been parsed."]
    #[doc = "* \\param[in] allocator A valid allocator."]
    #[doc = "* \\param[out] nonros_argc The count of arguments that aren't ROS-specific"]
    #[doc = "* \\param[out] nonros_argv An allocated array of arguments that aren't ROS-specific"]
    #[doc = "* This array must be deallocated by the caller using the given allocator."]
    #[doc = "* If there are no non-ROS args, then the output will be set to NULL."]
    #[doc = "* \\return #RCL_RET_OK if everything goes correctly, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_remove_ros_arguments(
        argv: *const *const ::std::os::raw::c_char,
        args: *const rcl_arguments_t,
        allocator: rcl_allocator_t,
        nonros_argc: *mut ::std::os::raw::c_int,
        nonros_argv: *mut *mut *const ::std::os::raw::c_char,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return log levels parsed from the command line."]
    #[doc = "* *"]
    #[doc = "* Log levels are parsed directly from command line arguments."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] arguments An arguments structure that has been parsed."]
    #[doc = "* \\param[out] log_levels Log levels as parsed from command line arguments."]
    #[doc = "* The output must be finished by the caller if the function successes."]
    #[doc = "* \\return #RCL_RET_OK if everything goes correctly, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed."]
    #[doc = "* /"]
    pub fn rcl_arguments_get_log_levels(
        arguments: *const rcl_arguments_t,
        log_levels: *mut rcl_log_levels_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Copy one arguments structure into another."]
    #[doc = "* *"]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] args The structure to be copied."]
    #[doc = "* Its allocator is used to copy memory into the new structure."]
    #[doc = "* \\param[out] args_out A zero-initialized arguments structure to be copied into."]
    #[doc = "* \\return #RCL_RET_OK if the structure was copied successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_arguments_copy(
        args: *const rcl_arguments_t,
        args_out: *mut rcl_arguments_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Reclaim resources held inside rcl_arguments_t structure."]
    #[doc = "* *"]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] args The structure to be deallocated."]
    #[doc = "* \\return #RCL_RET_OK if the memory was successfully freed, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_arguments_fini(args: *mut rcl_arguments_t) -> rcl_ret_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_init_options_impl_t {
    _unused: [u8; 0],
}
#[doc = " Encapsulation of init options and implementation defined init options."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_init_options_t {
    #[doc = " Implementation specific pointer."]
    pub impl_: *mut rcl_init_options_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_init_options_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_init_options_t>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_init_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_init_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_init_options_t))
    );
    fn test_field_impl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_init_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_init_options_t),
                "::",
                stringify!(impl_)
            )
        );
    }
    test_field_impl();
}
extern "C" {
    #[doc = " Return a zero initialized rcl_init_options_t struct."]
    pub fn rcl_get_zero_initialized_init_options() -> rcl_init_options_t;
}
extern "C" {
    #[doc = " Initialize given init_options with the default values and implementation specific values."]
    #[doc = "* *"]
    #[doc = "* The given allocator is used, if required, during setup of the init options,"]
    #[doc = "* but is also used during initialization."]
    #[doc = "* "]
    #[doc = "* In either case the given allocator is stored in the returned init options."]
    #[doc = "* "]
    #[doc = "* The `impl` pointer should not be changed manually."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] init_options object to be setup"]
    #[doc = "* \\param[in] allocator to be used during setup and during initialization"]
    #[doc = "* \\return #RCL_RET_OK if setup is successful, or"]
    #[doc = "* \\return #RCL_RET_ALREADY_INIT if init_options has already be initialized, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_init_options_init(
        init_options: *mut rcl_init_options_t,
        allocator: rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Copy the given source init_options to the destination init_options."]
    #[doc = "* *"]
    #[doc = "* The allocator from the source is used for any allocations and stored in the"]
    #[doc = "* destination."]
    #[doc = "* "]
    #[doc = "* The destination should either be zero initialized with"]
    #[doc = "* rcl_get_zero_initialized_init_options() or should have had"]
    #[doc = "* rcl_init_options_fini() called on it."]
    #[doc = "* Giving an already initialized init options for the destination will result"]
    #[doc = "* in a failure with return code #RCL_RET_ALREADY_INIT."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] src rcl_init_options_t object to be copied from"]
    #[doc = "* \\param[out] dst rcl_init_options_t object to be copied into"]
    #[doc = "* \\return #RCL_RET_OK if the copy is successful, or"]
    #[doc = "* \\return #RCL_RET_ALREADY_INIT if the dst has already be initialized, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_init_options_copy(
        src: *const rcl_init_options_t,
        dst: *mut rcl_init_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize the given init_options."]
    #[doc = "* *"]
    #[doc = "* The given init_options must be non-`NULL` and valid, i.e. had"]
    #[doc = "* rcl_init_options_init() called on it but not this function yet."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] init_options object to be setup"]
    #[doc = "* \\return #RCL_RET_OK if setup is successful, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_init_options_fini(init_options: *mut rcl_init_options_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the domain_id stored in the init options."]
    #[doc = "* *"]
    #[doc = "* Get the domain id from the specified rcl_init_options_t object."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] init_options object from which the domain id should be retrieved."]
    #[doc = "* \\param[out] domain_id domain id to be set in init_options object."]
    #[doc = "* \\return #RCL_RET_OK if successful, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid."]
    #[doc = "* /"]
    pub fn rcl_init_options_get_domain_id(
        init_options: *const rcl_init_options_t,
        domain_id: *mut size_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Set a domain id in the init options provided."]
    #[doc = "* *"]
    #[doc = "* Store the domain id in the specified init_options object."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] init_options objects in which to set the specified domain id."]
    #[doc = "* \\param[in] domain_id domain id to be set in init_options object."]
    #[doc = "* \\return #RCL_RET_OK if successful, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid."]
    #[doc = "* /"]
    pub fn rcl_init_options_set_domain_id(
        init_options: *mut rcl_init_options_t,
        domain_id: size_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the rmw init options which are stored internally."]
    #[doc = "* *"]
    #[doc = "* This function can fail and return `NULL` if:"]
    #[doc = "* - init_options is NULL"]
    #[doc = "* - init_options is invalid, e.g. init_options->impl is NULL"]
    #[doc = "* "]
    #[doc = "* If NULL is returned an error message will have been set."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] init_options object from which the rmw init options should be retrieved"]
    #[doc = "* \\return pointer to the the rcl init options, or"]
    #[doc = "* \\return `NULL` if there was an error"]
    #[doc = "* /"]
    pub fn rcl_init_options_get_rmw_init_options(
        init_options: *mut rcl_init_options_t,
    ) -> *mut rmw_init_options_t;
}
extern "C" {
    #[doc = " Return the allocator stored in the init_options."]
    #[doc = "* *"]
    #[doc = "* This function can fail and return `NULL` if:"]
    #[doc = "* - init_options is NULL"]
    #[doc = "* - init_options is invalid, e.g. init_options->impl is NULL"]
    #[doc = "* "]
    #[doc = "* If NULL is returned an error message will have been set."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] init_options object from which the allocator should be retrieved"]
    #[doc = "* \\return pointer to the rcl allocator, or"]
    #[doc = "* \\return `NULL` if there was an error"]
    #[doc = "* /"]
    pub fn rcl_init_options_get_allocator(
        init_options: *const rcl_init_options_t,
    ) -> *const rcl_allocator_t;
}
#[doc = " A unique ID per context instance."]
pub type rcl_context_instance_id_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_context_impl_t {
    _unused: [u8; 0],
}
#[doc = " Encapsulates the non-global state of an init/shutdown cycle."]
#[doc = "* *"]
#[doc = "* The context is used in the creation of top level entities like nodes and"]
#[doc = "* guard conditions, as well as to shutdown a specific instance of init."]
#[doc = "* "]
#[doc = "* Here is a diagram of a typical context's lifecycle:"]
#[doc = "* "]
#[doc = "* ```"]
#[doc = "* +---------------+"]
#[doc = "* |               |"]
#[doc = "* +--> uninitialized +---> rcl_get_zero_initialized_context() +"]
#[doc = "* |  |               |                                        |"]
#[doc = "* |  +---------------+                                        |"]
#[doc = "* |                                                           |"]
#[doc = "* |           +-----------------------------------------------+"]
#[doc = "* |           |"]
#[doc = "* |  +--------v---------+                +-----------------------+"]
#[doc = "* |  |                  |                |                       |"]
#[doc = "* |  | zero-initialized +-> rcl_init() +-> initialized and valid +-> rcl_shutdown() +"]
#[doc = "* |  |                  |                |                       |                  |"]
#[doc = "* |  +------------------+                +-----------------------+                  |"]
#[doc = "* |                                                                                 |"]
#[doc = "* |               +-----------------------------------------------------------------+"]
#[doc = "* |               |"]
#[doc = "* |  +------------v------------+"]
#[doc = "* |  |                         |"]
#[doc = "* |  | initialized but invalid +---> finalize all entities, then rcl_context_fini() +"]
#[doc = "* |  |                         |                                                    |"]
#[doc = "* |  +-------------------------+                                                    |"]
#[doc = "* |                                                                                 |"]
#[doc = "* +---------------------------------------------------------------------------------+"]
#[doc = "* ```"]
#[doc = "* "]
#[doc = "* A declared but not defined rcl_context_t instance is considered to be"]
#[doc = "* \"uninitialized\", and passing an uninitialized context to any functions will"]
#[doc = "* result in undefined behavior."]
#[doc = "* Some functions, like rcl_init() require the context instance to be"]
#[doc = "* zero initialized (all members set to \"zero\" state) before use."]
#[doc = "* "]
#[doc = "* Zero initialization of an rcl_context_t should be done with"]
#[doc = "* rcl_get_zero_initialized_context(), which ensures the context is in a safe"]
#[doc = "* state for initialization with rcl_init()."]
#[doc = "* "]
#[doc = "* Initialization of an rcl_context_t should be done with rcl_init(), after"]
#[doc = "* which the context is considered both initialized and valid."]
#[doc = "* After initialization it can be used in the creation of other entities like"]
#[doc = "* nodes and guard conditions."]
#[doc = "* "]
#[doc = "* At any time the context can be invalidated by calling rcl_shutdown() on"]
#[doc = "* the rcl_context_t, after which the context is still initialized but now"]
#[doc = "* invalid."]
#[doc = "* "]
#[doc = "* Invalidation indicates to other entities that the context was shutdown, but"]
#[doc = "* is still accessible for use during cleanup of themselves."]
#[doc = "* "]
#[doc = "* After being invalidated, and after all of the entities which used it have"]
#[doc = "* been finalized, the context should be finalized with rcl_context_fini()."]
#[doc = "* "]
#[doc = "* Finalizing the context while entities which have copies of it have not yet"]
#[doc = "* been finalized is undefined behavior."]
#[doc = "* Therefore, the context's lifetime (between calls to rcl_init() and"]
#[doc = "* rcl_context_fini()) should exceed the lifetime of all entities which use"]
#[doc = "* it directly (e.g. nodes and guard conditions) or indirectly (e.g."]
#[doc = "* subscriptions and topics)."]
#[doc = "* /"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_context_t {
    #[doc = " Global arguments for all nodes which share this context."]
    #[doc = "* * Typically generated by the parsing of argc/argv in rcl_init(). */"]
    pub global_arguments: rcl_arguments_t,
    #[doc = " Implementation specific pointer."]
    pub impl_: *mut rcl_context_impl_t,
    #[doc = " @endcond"]
    #[doc = " Private storage for instance ID atomic."]
    #[doc = "* *"]
    #[doc = "* Accessing the instance id should be done using the function"]
    #[doc = "* rcl_context_get_instance_id() because the instance id's type is an"]
    #[doc = "* atomic and needs to be accessed properly to ensure safety."]
    #[doc = "* "]
    #[doc = "* The instance id should not be changed manually - doing so is undefined"]
    #[doc = "* behavior."]
    #[doc = "* "]
    #[doc = "* The instance id cannot be protected within the `impl` pointer's type"]
    #[doc = "* because it needs to be accessible even when the context is zero"]
    #[doc = "* initialized and therefore `impl` is `NULL`."]
    #[doc = "* Specifically, storing the instance id in the `impl` would introduce a"]
    #[doc = "* race condition between accessing it and finalizing the context."]
    #[doc = "* Additionally, C11 atomics (i.e. \"stdatomic.h\") cannot be used directly"]
    #[doc = "* here in the case that this header is included into a C++ program."]
    #[doc = "* See this paper for an effort to make this possible in the future:"]
    #[doc = "* http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0943r1.html"]
    #[doc = "* /"]
    pub instance_id_storage: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rcl_context_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_context_t>(),
        24usize,
        concat!("Size of: ", stringify!(rcl_context_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_context_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_context_t))
    );
    fn test_field_global_arguments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).global_arguments) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_context_t),
                "::",
                stringify!(global_arguments)
            )
        );
    }
    test_field_global_arguments();
    fn test_field_impl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_context_t),
                "::",
                stringify!(impl_)
            )
        );
    }
    test_field_impl();
    fn test_field_instance_id_storage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).instance_id_storage) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_context_t),
                "::",
                stringify!(instance_id_storage)
            )
        );
    }
    test_field_instance_id_storage();
}
extern "C" {
    #[doc = " Return a zero initialization context object."]
    pub fn rcl_get_zero_initialized_context() -> rcl_context_t;
}
extern "C" {
    #[doc = " Finalize a context."]
    #[doc = "* *"]
    #[doc = "* The context to be finalized must have been previously initialized with"]
    #[doc = "* rcl_init(), and then later invalidated with rcl_shutdown()."]
    #[doc = "* A zero-initialized context that has not been initialized can be finalized."]
    #[doc = "* If context is `NULL`, then #RCL_RET_INVALID_ARGUMENT is returned."]
    #[doc = "* If context is zero-initialized, then #RCL_RET_OK is returned."]
    #[doc = "* If context is initialized and valid (rcl_shutdown() was not called on it),"]
    #[doc = "* then #RCL_RET_INVALID_ARGUMENT is returned."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes [1]"]
    #[doc = "* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>"]
    #[doc = "* "]
    #[doc = "* \\param[inout] context object to be finalized."]
    #[doc = "* \\return #RCL_RET_OK if the shutdown was completed successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_context_fini(context: *mut rcl_context_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the init options used during initialization for this context."]
    #[doc = "* *"]
    #[doc = "* This function can fail and return `NULL` if:"]
    #[doc = "* - context is NULL"]
    #[doc = "* - context is zero-initialized, e.g. context->impl is `NULL`"]
    #[doc = "* "]
    #[doc = "* If context is uninitialized then that is undefined behavior."]
    #[doc = "* "]
    #[doc = "* If `NULL` is returned an error message will have been set."]
    #[doc = "* "]
    #[doc = "* The options are for reference only, and therefore the returned pointer is"]
    #[doc = "* const."]
    #[doc = "* Changing the values in the options is undefined behavior but will likely"]
    #[doc = "* have no effect."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] context object from which the init options should be retrieved"]
    #[doc = "* \\return pointer to the the init options, or"]
    #[doc = "* \\return `NULL` if there was an error"]
    #[doc = "* /"]
    pub fn rcl_context_get_init_options(context: *const rcl_context_t)
        -> *const rcl_init_options_t;
}
extern "C" {
    #[doc = " Returns an unsigned integer that is unique to the given context, or `0` if invalid."]
    #[doc = "* *"]
    #[doc = "* The given context must be non-`NULL`, but does not need to be initialized or valid."]
    #[doc = "* If context is `NULL`, then `0` will be returned."]
    #[doc = "* If context is uninitialized, then it is undefined behavior."]
    #[doc = "* "]
    #[doc = "* The instance ID may be `0` if the context is zero-initialized or if the"]
    #[doc = "* context has been invalidated by rcl_shutdown()."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes [1]"]
    #[doc = "* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] context object from which the instance id should be retrieved"]
    #[doc = "* \\return a unique id specific to this context instance, or"]
    #[doc = "* \\return `0` if invalid, or"]
    #[doc = "* \\return `0` if context is `NULL`"]
    #[doc = "* /"]
    pub fn rcl_context_get_instance_id(context: *const rcl_context_t) -> rcl_context_instance_id_t;
}
extern "C" {
    #[doc = " Returns the context domain id."]
    #[doc = "* *"]
    #[doc = "* \\pre If context is uninitialized, then it is undefined behavior."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes [1]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | No"]
    #[doc = "* "]
    #[doc = "* <i>[1] Calling the function asynchronously with rcl_init() or rcl_shutdown() can result"]
    #[doc = "* in the function sometimes succeeding and sometimes returning #RCL_RET_INVALID_ARGUMENT.</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] context from which the domain id should be retrieved."]
    #[doc = "* \\param[out] domain_id output variable where the domain id will be returned."]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if `context` is invalid (see rcl_context_is_valid()), or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if `domain_id` is `NULL`, or"]
    #[doc = "* \\return #RCL_RET_OK if the domain id was correctly retrieved."]
    #[doc = "* /"]
    pub fn rcl_context_get_domain_id(
        context: *mut rcl_context_t,
        domain_id: *mut size_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return `true` if the given context is currently valid, otherwise `false`."]
    #[doc = "* *"]
    #[doc = "* If context is `NULL`, then `false` is returned."]
    #[doc = "* If context is zero-initialized, then `false` is returned."]
    #[doc = "* If context is uninitialized, then it is undefined behavior."]
    #[doc = "* "]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes [1]"]
    #[doc = "* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] context object which should be checked for validity"]
    #[doc = "* \\return `true` if valid, otherwise `false`"]
    #[doc = "* /"]
    pub fn rcl_context_is_valid(context: *const rcl_context_t) -> bool;
}
extern "C" {
    #[doc = " Return pointer to the rmw context if the given context is currently valid, otherwise `NULL`."]
    #[doc = "* *"]
    #[doc = "* If context is `NULL`, then `NULL` is returned."]
    #[doc = "* If context is zero-initialized, then `NULL` is returned."]
    #[doc = "* If context is uninitialized, then it is undefined behavior."]
    #[doc = "* "]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes [1]"]
    #[doc = "* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] context object from which the rmw context should be retrieved."]
    #[doc = "* \\return pointer to rmw context if valid, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_context_get_rmw_context(context: *mut rcl_context_t) -> *mut rmw_context_t;
}
extern "C" {
    #[doc = " Initialization of rcl."]
    #[doc = "* *"]
    #[doc = "* This function can be run any number of times, so long as the given context"]
    #[doc = "* has been properly prepared."]
    #[doc = "* "]
    #[doc = "* The given rcl_context_t must be zero initialized with the function"]
    #[doc = "* rcl_get_zero_initialized_context() and must not be already initialized"]
    #[doc = "* by this function."]
    #[doc = "* If the context is already initialized this function will fail and return the"]
    #[doc = "* #RCL_RET_ALREADY_INIT error code."]
    #[doc = "* A context may be initialized again after it has been finalized with the"]
    #[doc = "* rcl_shutdown() function and zero initialized again with"]
    #[doc = "* rcl_get_zero_initialized_context()."]
    #[doc = "* "]
    #[doc = "* The `argc` and `argv` parameters may contain command line arguments for the"]
    #[doc = "* program."]
    #[doc = "* rcl specific arguments will be parsed, but not removed."]
    #[doc = "* If `argc` is `0` and `argv` is `NULL` no parameters will be parsed."]
    #[doc = "* "]
    #[doc = "* The `options` argument must be non-`NULL` and must have been initialized"]
    #[doc = "* with rcl_init_options_init()."]
    #[doc = "* It is unmodified by this function, and the ownership is not transfered to"]
    #[doc = "* the context, but instead a copy is made into the context for later reference."]
    #[doc = "* Therefore, the given options need to be cleaned up with"]
    #[doc = "* rcl_init_options_fini() after this function returns."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes [1]"]
    #[doc = "* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] argc number of strings in argv"]
    #[doc = "* \\param[in] argv command line arguments; rcl specific arguments are removed"]
    #[doc = "* \\param[in] options options used during initialization"]
    #[doc = "* \\param[out] context resulting context object that represents this init"]
    #[doc = "* \\return #RCL_RET_OK if initialization is successful, or"]
    #[doc = "* \\return #RCL_RET_ALREADY_INIT if rcl_init has already been called, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ROS_ARGS if an invalid ROS argument is found, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_init(
        argc: ::std::os::raw::c_int,
        argv: *const *const ::std::os::raw::c_char,
        options: *const rcl_init_options_t,
        context: *mut rcl_context_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Shutdown a given rcl context."]
    #[doc = "* *"]
    #[doc = "* The given context must have been initialized with rcl_init()."]
    #[doc = "* If not, this function will fail with #RCL_RET_ALREADY_SHUTDOWN."]
    #[doc = "* "]
    #[doc = "* When this function is called:"]
    #[doc = "* - Any rcl objects created using this context are invalidated."]
    #[doc = "* - Functions called on invalid objects may or may not fail."]
    #[doc = "* - Calls to rcl_context_is_initialized() will return `false`."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes [1]"]
    #[doc = "* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>"]
    #[doc = "* "]
    #[doc = "* \\param[inout] context object to shutdown"]
    #[doc = "* \\return #RCL_RET_OK if the shutdown was completed successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ALREADY_SHUTDOWN if the context is not currently valid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_shutdown(context: *mut rcl_context_t) -> rcl_ret_t;
}
extern "C" {
    pub static RCL_DOMAIN_ID_ENV_VAR: *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Determine the default domain ID, based on the environment."]
    #[doc = "* *"]
    #[doc = "* \\param[out] domain_id Must not be NULL."]
    #[doc = "* \\returns #RCL_RET_INVALID_ARGUMENT if an argument is invalid, or,"]
    #[doc = "* \\returns #RCL_RET_ERROR in case of an unexpected error, or,"]
    #[doc = "* \\returns #RCL_RET_OK."]
    #[doc = "* /"]
    pub fn rcl_get_default_domain_id(domain_id: *mut size_t) -> rcl_ret_t;
}
#[doc = " Structure which encapsulates the options for creating a rcl_node_t."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_node_options_t {
    #[doc = " Custom allocator used for internal allocations."]
    pub allocator: rcl_allocator_t,
    #[doc = " If false then only use arguments in this struct, otherwise use global arguments also."]
    pub use_global_arguments: bool,
    #[doc = " Command line arguments that apply only to this node."]
    pub arguments: rcl_arguments_t,
    #[doc = " Flag to enable rosout for this node"]
    pub enable_rosout: bool,
    #[doc = " Middleware quality of service settings for /rosout."]
    pub rosout_qos: rmw_qos_profile_t,
}
#[test]
fn bindgen_test_layout_rcl_node_options_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_node_options_t>(),
        152usize,
        concat!("Size of: ", stringify!(rcl_node_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_node_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_node_options_t))
    );
    fn test_field_allocator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_node_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_node_options_t),
                "::",
                stringify!(allocator)
            )
        );
    }
    test_field_allocator();
    fn test_field_use_global_arguments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_node_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).use_global_arguments) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_node_options_t),
                "::",
                stringify!(use_global_arguments)
            )
        );
    }
    test_field_use_global_arguments();
    fn test_field_arguments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_node_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arguments) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_node_options_t),
                "::",
                stringify!(arguments)
            )
        );
    }
    test_field_arguments();
    fn test_field_enable_rosout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_node_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enable_rosout) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_node_options_t),
                "::",
                stringify!(enable_rosout)
            )
        );
    }
    test_field_enable_rosout();
    fn test_field_rosout_qos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_node_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rosout_qos) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_node_options_t),
                "::",
                stringify!(rosout_qos)
            )
        );
    }
    test_field_rosout_qos();
}
extern "C" {
    #[doc = " Return the default node options in a rcl_node_options_t."]
    #[doc = "* *"]
    #[doc = "* The default values are:"]
    #[doc = "* "]
    #[doc = "* - allocator = rcl_get_default_allocator()"]
    #[doc = "* - use_global_arguments = true"]
    #[doc = "* - enable_rosout = true"]
    #[doc = "* - arguments = rcl_get_zero_initialized_arguments()"]
    #[doc = "* - rosout_qos = rcl_qos_profile_rosout_default"]
    #[doc = "* "]
    #[doc = "* \\return A structure with the default node options."]
    #[doc = "* /"]
    pub fn rcl_node_get_default_options() -> rcl_node_options_t;
}
extern "C" {
    #[doc = " Copy one options structure into another."]
    #[doc = "* *"]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] options The structure to be copied."]
    #[doc = "* Its allocator is used to copy memory into the new structure."]
    #[doc = "* \\param[out] options_out An options structure containing default values."]
    #[doc = "* \\return #RCL_RET_OK if the structure was copied successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_node_options_copy(
        options: *const rcl_node_options_t,
        options_out: *mut rcl_node_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize the given node_options."]
    #[doc = "* *"]
    #[doc = "* The given node_options must be non-`NULL` and valid, i.e. had"]
    #[doc = "* rcl_node_get_default_options() called on it but not this function yet."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] options object to be finalized"]
    #[doc = "* \\return #RCL_RET_OK if setup is successful, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_node_options_fini(options: *mut rcl_node_options_t) -> rcl_ret_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_node_impl_t {
    _unused: [u8; 0],
}
#[doc = " Structure which encapsulates a ROS Node."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_node_t {
    #[doc = " Context associated with this node."]
    pub context: *mut rcl_context_t,
    #[doc = " Private implementation pointer."]
    pub impl_: *mut rcl_node_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_node_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_node_t>(),
        16usize,
        concat!("Size of: ", stringify!(rcl_node_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_node_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_node_t))
    );
    fn test_field_context() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_node_t),
                "::",
                stringify!(context)
            )
        );
    }
    test_field_context();
    fn test_field_impl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_node_t),
                "::",
                stringify!(impl_)
            )
        );
    }
    test_field_impl();
}
extern "C" {
    #[doc = " Return a rcl_node_t struct with members initialized to `NULL`."]
    pub fn rcl_get_zero_initialized_node() -> rcl_node_t;
}
extern "C" {
    #[doc = " Initialize a ROS node."]
    #[doc = "* *"]
    #[doc = "* Calling this on a rcl_node_t makes it a valid node handle until rcl_shutdown"]
    #[doc = "* is called or until rcl_node_fini is called on it."]
    #[doc = "* "]
    #[doc = "* After calling, the ROS node object can be used to create other middleware"]
    #[doc = "* primitives like publishers, services, parameters, etc."]
    #[doc = "* "]
    #[doc = "* The name of the node must not be NULL and adhere to naming restrictions,"]
    #[doc = "* see the rmw_validate_node_name() function for rules."]
    #[doc = "* "]
    #[doc = "* \\todo TODO(wjwwood): node name uniqueness is not yet enforced"]
    #[doc = "* "]
    #[doc = "* The name of the node cannot coincide with another node of the same name."]
    #[doc = "* If a node of the same name is already in the domain, it will be shutdown."]
    #[doc = "* "]
    #[doc = "* The namespace of the node should not be NULL and should also pass the"]
    #[doc = "* rmw_validate_namespace() function's rules."]
    #[doc = "* "]
    #[doc = "* Additionally this function allows namespaces which lack a leading forward"]
    #[doc = "* slash."]
    #[doc = "* Because there is no notion of a relative namespace, there is no difference"]
    #[doc = "* between a namespace which lacks a forward and the same namespace with a"]
    #[doc = "* leading forward slash."]
    #[doc = "* Therefore, a namespace like ``\"foo/bar\"`` is automatically changed to"]
    #[doc = "* ``\"/foo/bar\"`` by this function."]
    #[doc = "* Similarly, the namespace ``\"\"`` will implicitly become ``\"/\"`` which is a"]
    #[doc = "* valid namespace."]
    #[doc = "* "]
    #[doc = "* \\todo TODO(wjwwood):"]
    #[doc = "* Parameter infrastructure is currently initialized in the language specific"]
    #[doc = "* client library, e.g. rclcpp for C++, but will be initialized here in the"]
    #[doc = "* future. When that happens there will be an option to avoid parameter"]
    #[doc = "* infrastructure with an option in the rcl_node_options_t struct."]
    #[doc = "* "]
    #[doc = "* A node contains infrastructure for ROS parameters, which include advertising"]
    #[doc = "* publishers and service servers."]
    #[doc = "* This function will create those external parameter interfaces even if"]
    #[doc = "* parameters are not used later."]
    #[doc = "* "]
    #[doc = "* The rcl_node_t given must be allocated and zero initialized."]
    #[doc = "* Passing an rcl_node_t which has already had this function called on it, more"]
    #[doc = "* recently than rcl_node_fini, will fail."]
    #[doc = "* An allocated rcl_node_t with uninitialized memory is undefined behavior."]
    #[doc = "* "]
    #[doc = "* Expected usage:"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* rcl_context_t context = rcl_get_zero_initialized_context();"]
    #[doc = "* // ... initialize the context with rcl_init()"]
    #[doc = "* rcl_node_t node = rcl_get_zero_initialized_node();"]
    #[doc = "* rcl_node_options_t node_ops = rcl_node_get_default_options();"]
    #[doc = "* // ... node options customization"]
    #[doc = "* rcl_ret_t ret = rcl_node_init(&node, \"node_name\", \"/node_ns\", &context, &node_ops);"]
    #[doc = "* // ... error handling and then use the node, but eventually deinitialize it:"]
    #[doc = "* ret = rcl_node_fini(&node);"]
    #[doc = "* // ... error handling for rcl_node_fini()"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes [1]"]
    #[doc = "* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>"]
    #[doc = "* "]
    #[doc = "* \\pre the node handle must be allocated, zero initialized, and invalid"]
    #[doc = "* \\pre the context handle must be allocated, initialized, and valid"]
    #[doc = "* \\post the node handle is valid and can be used in other `rcl_*` functions"]
    #[doc = "* "]
    #[doc = "* \\param[inout] node a preallocated rcl_node_t"]
    #[doc = "* \\param[in] name the name of the node, must be a valid c-string"]
    #[doc = "* \\param[in] namespace_ the namespace of the node, must be a valid c-string"]
    #[doc = "* \\param[in] context the context instance with which the node should be"]
    #[doc = "* associated"]
    #[doc = "* \\param[in] options the node options."]
    #[doc = "* The options are deep copied into the node."]
    #[doc = "* The caller is always responsible for freeing memory used options they"]
    #[doc = "* pass in."]
    #[doc = "* \\return #RCL_RET_OK if the node was initialized successfully, or"]
    #[doc = "* \\return #RCL_RET_ALREADY_INIT if the node has already be initialized, or"]
    #[doc = "* \\return #RCL_RET_NOT_INIT if the given context is invalid, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID_NAME if the name is invalid, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID_NAMESPACE if the namespace_ is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_node_init(
        node: *mut rcl_node_t,
        name: *const ::std::os::raw::c_char,
        namespace_: *const ::std::os::raw::c_char,
        context: *mut rcl_context_t,
        options: *const rcl_node_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a rcl_node_t."]
    #[doc = "* *"]
    #[doc = "* Destroys any automatically created infrastructure and deallocates memory."]
    #[doc = "* After calling, the rcl_node_t can be safely deallocated."]
    #[doc = "* "]
    #[doc = "* All middleware primitives created by the user, e.g. publishers, services, etc,"]
    #[doc = "* which were created from this node must be finalized using their respective"]
    #[doc = "* `rcl_*_fini()` functions before this is called."]
    #[doc = "* \\sa rcl_publisher_fini()"]
    #[doc = "* \\sa rcl_subscription_fini()"]
    #[doc = "* \\sa rcl_client_fini()"]
    #[doc = "* \\sa rcl_service_fini()"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes [1]"]
    #[doc = "* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node rcl_node_t to be finalized"]
    #[doc = "* \\return #RCL_RET_OK if node was finalized successfully, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID if the node pointer is null, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_node_fini(node: *mut rcl_node_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return `true` if the node is valid, else `false`."]
    #[doc = "* *"]
    #[doc = "* Also return `false` if the node pointer is `NULL` or the allocator is invalid."]
    #[doc = "* "]
    #[doc = "* A node is invalid if:"]
    #[doc = "* - the implementation is `NULL` (rcl_node_init not called or failed)"]
    #[doc = "* - rcl_shutdown has been called since the node has been initialized"]
    #[doc = "* - the node has been finalized with rcl_node_fini"]
    #[doc = "* "]
    #[doc = "* There is a possible validity race condition."]
    #[doc = "* "]
    #[doc = "* Consider:"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* assert(rcl_node_is_valid(node));  // <-- thread 1"]
    #[doc = "* rcl_shutdown();                   // <-- thread 2"]
    #[doc = "* // use node as if valid           // <-- thread 1"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* In the third line the node is now invalid, even though on the previous line"]
    #[doc = "* of thread 1 it was checked to be valid."]
    #[doc = "* This is why this function is considered not thread-safe."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes [1]"]
    #[doc = "* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node rcl_node_t to be validated"]
    #[doc = "* \\return `true` if the node and allocator are valid, otherwise `false`."]
    #[doc = "* /"]
    pub fn rcl_node_is_valid(node: *const rcl_node_t) -> bool;
}
extern "C" {
    #[doc = " Return true if node is valid, except for the context being valid."]
    #[doc = "* *"]
    #[doc = "* This is used in clean up functions that need to access the node, but do not"]
    #[doc = "* need use any functions with the context."]
    #[doc = "* "]
    #[doc = "* It is identical to rcl_node_is_valid except it ignores the state of the"]
    #[doc = "* context associated with the node."]
    #[doc = "* \\sa rcl_node_is_valid()"]
    #[doc = "* /"]
    pub fn rcl_node_is_valid_except_context(node: *const rcl_node_t) -> bool;
}
extern "C" {
    #[doc = " Return the name of the node."]
    #[doc = "* *"]
    #[doc = "* This function returns the node's internal name string."]
    #[doc = "* This function can fail, and therefore return `NULL`, if:"]
    #[doc = "* - node is `NULL`"]
    #[doc = "* - node has not been initialized (the implementation is invalid)"]
    #[doc = "* "]
    #[doc = "* The returned string is only valid as long as the given rcl_node_t is valid."]
    #[doc = "* The value of the string may change if the value in the rcl_node_t changes,"]
    #[doc = "* and therefore copying the string is recommended if this is a concern."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] node pointer to the node"]
    #[doc = "* \\return name string if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_node_get_name(node: *const rcl_node_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the namespace of the node."]
    #[doc = "* *"]
    #[doc = "* This function returns the node's internal namespace string."]
    #[doc = "* This function can fail, and therefore return `NULL`, if:"]
    #[doc = "* - node is `NULL`"]
    #[doc = "* - node has not been initialized (the implementation is invalid)"]
    #[doc = "* "]
    #[doc = "* The returned string is only valid as long as the given rcl_node_t is valid."]
    #[doc = "* The value of the string may change if the value in the rcl_node_t changes,"]
    #[doc = "* and therefore copying the string is recommended if this is a concern."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] node pointer to the node"]
    #[doc = "* \\return name string if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_node_get_namespace(node: *const rcl_node_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the fully qualified name of the node."]
    #[doc = "* *"]
    #[doc = "* This function returns the node's internal namespace and name combined string."]
    #[doc = "* This function can fail, and therefore return `NULL`, if:"]
    #[doc = "* - node is `NULL`"]
    #[doc = "* - node has not been initialized (the implementation is invalid)"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] node pointer to the node"]
    #[doc = "* \\return fully qualified name string if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_node_get_fully_qualified_name(
        node: *const rcl_node_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the rcl node options."]
    #[doc = "* *"]
    #[doc = "* This function returns the node's internal options struct."]
    #[doc = "* This function can fail, and therefore return `NULL`, if:"]
    #[doc = "* - node is `NULL`"]
    #[doc = "* - node has not been initialized (the implementation is invalid)"]
    #[doc = "* "]
    #[doc = "* The returned struct is only valid as long as the given rcl_node_t is valid."]
    #[doc = "* The values in the struct may change if the options of the rcl_node_t changes,"]
    #[doc = "* and therefore copying the struct is recommended if this is a concern."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] node pointer to the node"]
    #[doc = "* \\return options struct if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_node_get_options(node: *const rcl_node_t) -> *const rcl_node_options_t;
}
extern "C" {
    #[doc = " Return the ROS domain ID that the node is using."]
    #[doc = "* *"]
    #[doc = "* This function returns the ROS domain ID that the node is in."]
    #[doc = "* "]
    #[doc = "* This function should be used to determine what `domain_id` was used rather"]
    #[doc = "* than checking the domain_id field in the node options, because if"]
    #[doc = "* #RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID is used when creating the node then"]
    #[doc = "* it is not changed after creation, but this function will return the actual"]
    #[doc = "* `domain_id` used."]
    #[doc = "* "]
    #[doc = "* The `domain_id` field must point to an allocated `size_t` object to which"]
    #[doc = "* the ROS domain ID will be written."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] node the handle to the node being queried"]
    #[doc = "* \\param[out] domain_id storage for the domain id"]
    #[doc = "* \\return #RCL_RET_OK if node the domain ID was retrieved successfully, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID if the node is invalid, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_node_get_domain_id(node: *const rcl_node_t, domain_id: *mut size_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the rmw node handle."]
    #[doc = "* *"]
    #[doc = "* The handle returned is a pointer to the internally held rmw handle."]
    #[doc = "* This function can fail, and therefore return `NULL`, if:"]
    #[doc = "* - node is `NULL`"]
    #[doc = "* - node has not been initialized (the implementation is invalid)"]
    #[doc = "* "]
    #[doc = "* The returned handle is made invalid if the node is finalized or if"]
    #[doc = "* rcl_shutdown() is called."]
    #[doc = "* The returned handle is not guaranteed to be valid for the life time of the"]
    #[doc = "* node as it may be finalized and recreated itself."]
    #[doc = "* Therefore it is recommended to get the handle from the node using"]
    #[doc = "* this function each time it is needed and avoid use of the handle"]
    #[doc = "* concurrently with functions that might change it."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] node pointer to the rcl node"]
    #[doc = "* \\return rmw node handle if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_node_get_rmw_handle(node: *const rcl_node_t) -> *mut rmw_node_t;
}
extern "C" {
    #[doc = " Return the associated rcl instance id."]
    #[doc = "* *"]
    #[doc = "* This id is stored when rcl_node_init is called and can be compared with the"]
    #[doc = "* value returned by rcl_get_instance_id() to check if this node was created in"]
    #[doc = "* the current rcl context (since the latest call to rcl_init()."]
    #[doc = "* "]
    #[doc = "* This function can fail, and therefore return `0`, if:"]
    #[doc = "* - node is `NULL`"]
    #[doc = "* - node has not been initialized (the implementation is invalid)"]
    #[doc = "* "]
    #[doc = "* This function will succeed even if rcl_shutdown() has been called"]
    #[doc = "* since the node was created."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] node pointer to the rcl node"]
    #[doc = "* \\return rcl instance id captured during node init or `0` on error"]
    #[doc = "* /"]
    pub fn rcl_node_get_rcl_instance_id(node: *const rcl_node_t) -> u64;
}
extern "C" {
    #[doc = " Return a guard condition which is triggered when the ROS graph changes."]
    #[doc = "* *"]
    #[doc = "* The handle returned is a pointer to an internally held rcl guard condition."]
    #[doc = "* This function can fail, and therefore return `NULL`, if:"]
    #[doc = "* - node is `NULL`"]
    #[doc = "* - node is invalid"]
    #[doc = "* "]
    #[doc = "* The returned handle is made invalid if the node is finialized or if"]
    #[doc = "* rcl_shutdown() is called."]
    #[doc = "* "]
    #[doc = "* The guard condition will be triggered anytime a change to the ROS graph occurs."]
    #[doc = "* A ROS graph change includes things like (but not limited to) a new publisher"]
    #[doc = "* advertises, a new subscription is created, a new service becomes available,"]
    #[doc = "* a subscription is canceled, etc."]
    #[doc = "* "]
    #[doc = "* \\todo TODO(wjwwood): link to exhaustive list of graph events"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] node pointer to the rcl node"]
    #[doc = "* \\return rcl guard condition handle if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_node_get_graph_guard_condition(
        node: *const rcl_node_t,
    ) -> *const rcl_guard_condition_t;
}
extern "C" {
    #[doc = " Return the logger name of the node."]
    #[doc = "* *"]
    #[doc = "* This function returns the node's internal logger name string."]
    #[doc = "* This function can fail, and therefore return `NULL`, if:"]
    #[doc = "* - node is `NULL`"]
    #[doc = "* - node has not been initialized (the implementation is invalid)"]
    #[doc = "* "]
    #[doc = "* The returned string is only valid as long as the given rcl_node_t is valid."]
    #[doc = "* The value of the string may change if the value in the rcl_node_t changes,"]
    #[doc = "* and therefore copying the string is recommended if this is a concern."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] node pointer to the node"]
    #[doc = "* \\return logger_name string if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_node_get_logger_name(node: *const rcl_node_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Expand a given name into a fully-qualified topic name and apply remapping rules."]
    #[doc = "* *"]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] node Node object. Its name, namespace, local/global command line arguments are used."]
    #[doc = "* \\param[in] input_name Topic name to be expanded and remapped."]
    #[doc = "* \\param[in] allocator The allocator to be used when creating the output topic."]
    #[doc = "* \\param[in] is_service For services use `true`, for topics use `false`."]
    #[doc = "* \\param[in] only_expand When `true`, remapping rules are ignored."]
    #[doc = "* \\param[out] output_name Output char * pointer."]
    #[doc = "* \\return #RCL_RET_OK if the topic name was expanded successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any of input_name, node_name, node_namespace"]
    #[doc = "* or output_name are NULL, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if both local_args and global_args are NULL, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_TOPIC_NAME_INVALID if the given topic name is invalid"]
    #[doc = "* (see rcl_validate_topic_name()), or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID_NAME if the given node name is invalid"]
    #[doc = "* (see rmw_validate_node_name()), or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID_NAMESPACE if the given node namespace is invalid"]
    #[doc = "* (see rmw_validate_namespace()), or"]
    #[doc = "* \\return #RCL_RET_UNKNOWN_SUBSTITUTION for unknown substitutions in name, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_node_resolve_name(
        node: *const rcl_node_t,
        input_name: *const ::std::os::raw::c_char,
        allocator: rcl_allocator_t,
        is_service: bool,
        only_expand: bool,
        output_name: *mut *mut ::std::os::raw::c_char,
    ) -> rcl_ret_t;
}
pub type rosidl_message_typesupport_handle_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_message_type_support_t,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const rosidl_message_type_support_t,
>;
#[doc = " Contains rosidl message type support data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_message_type_support_t {
    #[doc = " String identifier for the type_support."]
    pub typesupport_identifier: *const ::std::os::raw::c_char,
    #[doc = " Pointer to the message type support library"]
    pub data: *const ::std::os::raw::c_void,
    #[doc = " Pointer to the message type support handler function"]
    pub func: rosidl_message_typesupport_handle_function,
}
#[test]
fn bindgen_test_layout_rosidl_message_type_support_t() {
    assert_eq!(
        ::std::mem::size_of::<rosidl_message_type_support_t>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_message_type_support_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_message_type_support_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rosidl_message_type_support_t))
    );
    fn test_field_typesupport_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rosidl_message_type_support_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).typesupport_identifier) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rosidl_message_type_support_t),
                "::",
                stringify!(typesupport_identifier)
            )
        );
    }
    test_field_typesupport_identifier();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rosidl_message_type_support_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rosidl_message_type_support_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rosidl_message_type_support_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rosidl_message_type_support_t),
                "::",
                stringify!(func)
            )
        );
    }
    test_field_func();
}
extern "C" {
    #[doc = " Get the message type support handle specific to this identifier."]
    #[doc = "* *"]
    #[doc = "* The handle's message typesupport identifier function is returned or if the parameters are NULL"]
    #[doc = "* then an assert will happen."]
    #[doc = "* "]
    #[doc = "* \\param handle Handle to message type support"]
    #[doc = "* \\param identifier The typesupport identifier to get the handle function for"]
    #[doc = "* \\return The associated message typesupport handle function."]
    #[doc = "* /"]
    pub fn get_message_typesupport_handle(
        handle: *const rosidl_message_type_support_t,
        identifier: *const ::std::os::raw::c_char,
    ) -> *const rosidl_message_type_support_t;
}
extern "C" {
    #[doc = " If the identifier is the same as this handle's typesupport_identifier the handle is simply"]
    #[doc = " returned or if the parameters are NULL then an assert will happen."]
    #[doc = ""]
    #[doc = " \\param handle Handle to message type support"]
    #[doc = " \\param identifier The typesupport identifier to get the handle function for"]
    #[doc = " \\return if the identifier match's the handle's identifier then the handle's function"]
    #[doc = "   is returned."]
    pub fn get_message_typesupport_handle_function(
        handle: *const rosidl_message_type_support_t,
        identifier: *const ::std::os::raw::c_char,
    ) -> *const rosidl_message_type_support_t;
}
#[doc = " Internal rcl publisher implementation struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_publisher_impl_t {
    _unused: [u8; 0],
}
#[doc = " Structure which encapsulates a ROS Publisher."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_publisher_t {
    #[doc = " Pointer to the publisher implementation"]
    pub impl_: *mut rcl_publisher_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_publisher_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_publisher_t>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_publisher_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_publisher_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_publisher_t))
    );
    fn test_field_impl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_publisher_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_publisher_t),
                "::",
                stringify!(impl_)
            )
        );
    }
    test_field_impl();
}
#[doc = " Options available for a rcl publisher."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_publisher_options_t {
    #[doc = " Middleware quality of service settings for the publisher."]
    pub qos: rmw_qos_profile_t,
    #[doc = " Custom allocator for the publisher, used for incidental allocations."]
    #[doc = "* * For default behavior (malloc/free), use: rcl_get_default_allocator() */"]
    pub allocator: rcl_allocator_t,
    #[doc = " rmw specific publisher options, e.g. the rmw implementation specific payload."]
    pub rmw_publisher_options: rmw_publisher_options_t,
}
#[test]
fn bindgen_test_layout_rcl_publisher_options_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_publisher_options_t>(),
        144usize,
        concat!("Size of: ", stringify!(rcl_publisher_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_publisher_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_publisher_options_t))
    );
    fn test_field_qos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_publisher_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).qos) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_publisher_options_t),
                "::",
                stringify!(qos)
            )
        );
    }
    test_field_qos();
    fn test_field_allocator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_publisher_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_publisher_options_t),
                "::",
                stringify!(allocator)
            )
        );
    }
    test_field_allocator();
    fn test_field_rmw_publisher_options() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_publisher_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rmw_publisher_options) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_publisher_options_t),
                "::",
                stringify!(rmw_publisher_options)
            )
        );
    }
    test_field_rmw_publisher_options();
}
extern "C" {
    #[doc = " Return a rcl_publisher_t struct with members set to `NULL`."]
    #[doc = "* *"]
    #[doc = "* Should be called to get a null rcl_publisher_t before passing to"]
    #[doc = "* rcl_publisher_init()."]
    #[doc = "* /"]
    pub fn rcl_get_zero_initialized_publisher() -> rcl_publisher_t;
}
extern "C" {
    #[doc = " Initialize a rcl publisher."]
    #[doc = "* *"]
    #[doc = "* After calling this function on a rcl_publisher_t, it can be used to publish"]
    #[doc = "* messages of the given type to the given topic using rcl_publish()."]
    #[doc = "* "]
    #[doc = "* The given rcl_node_t must be valid and the resulting rcl_publisher_t is only"]
    #[doc = "* valid as long as the given rcl_node_t remains valid."]
    #[doc = "* "]
    #[doc = "* The rosidl_message_type_support_t is obtained on a per .msg type basis."]
    #[doc = "* When the user defines a ROS message, code is generated which provides the"]
    #[doc = "* required rosidl_message_type_support_t object."]
    #[doc = "* This object can be obtained using a language appropriate mechanism."]
    #[doc = "* \\todo TODO(wjwwood) write these instructions once and link to it instead"]
    #[doc = "* "]
    #[doc = "* For C, a macro can be used (for example `std_msgs/String`):"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* #include <rosidl_runtime_c/message_type_support_struct.h>"]
    #[doc = "* #include <std_msgs/msg/string.h>"]
    #[doc = "* const rosidl_message_type_support_t * string_ts ="]
    #[doc = "* ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* For C++, a template function is used:"]
    #[doc = "* "]
    #[doc = "* ```cpp"]
    #[doc = "* #include <rosidl_typesupport_cpp/message_type_support.hpp>"]
    #[doc = "* #include <std_msgs/msg/string.hpp>"]
    #[doc = "* const rosidl_message_type_support_t * string_ts ="]
    #[doc = "* rosidl_typesupport_cpp::get_message_type_support_handle<std_msgs::msg::String>();"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* The rosidl_message_type_support_t object contains message type specific"]
    #[doc = "* information used to publish messages."]
    #[doc = "* "]
    #[doc = "* The topic name must be a c string which follows the topic and service name"]
    #[doc = "* format rules for unexpanded names, also known as non-fully qualified names:"]
    #[doc = "* "]
    #[doc = "* \\see rcl_expand_topic_name"]
    #[doc = "* "]
    #[doc = "* The options struct allows the user to set the quality of service settings as"]
    #[doc = "* well as a custom allocator which is used when initializing/finalizing the"]
    #[doc = "* publisher to allocate space for incidentals, e.g. the topic name string."]
    #[doc = "* "]
    #[doc = "* Expected usage (for C messages):"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* #include <rcl/rcl.h>"]
    #[doc = "* #include <rosidl_runtime_c/message_type_support_struct.h>"]
    #[doc = "* #include <std_msgs/msg/string.h>"]
    #[doc = "* "]
    #[doc = "* rcl_node_t node = rcl_get_zero_initialized_node();"]
    #[doc = "* rcl_node_options_t node_ops = rcl_node_get_default_options();"]
    #[doc = "* rcl_ret_t ret = rcl_node_init(&node, \"node_name\", \"/my_namespace\", &node_ops);"]
    #[doc = "* // ... error handling"]
    #[doc = "* const rosidl_message_type_support_t * ts = ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);"]
    #[doc = "* rcl_publisher_t publisher = rcl_get_zero_initialized_publisher();"]
    #[doc = "* rcl_publisher_options_t publisher_ops = rcl_publisher_get_default_options();"]
    #[doc = "* ret = rcl_publisher_init(&publisher, &node, ts, \"chatter\", &publisher_ops);"]
    #[doc = "* // ... error handling, and on shutdown do finalization:"]
    #[doc = "* ret = rcl_publisher_fini(&publisher, &node);"]
    #[doc = "* // ... error handling for rcl_publisher_fini()"]
    #[doc = "* ret = rcl_node_fini(&node);"]
    #[doc = "* // ... error handling for rcl_deinitialize_node()"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] publisher preallocated publisher structure"]
    #[doc = "* \\param[in] node valid rcl node handle"]
    #[doc = "* \\param[in] type_support type support object for the topic's type"]
    #[doc = "* \\param[in] topic_name the name of the topic to publish on"]
    #[doc = "* \\param[in] options publisher options, including quality of service settings"]
    #[doc = "* \\return #RCL_RET_OK if the publisher was initialized successfully, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID if the node is invalid, or"]
    #[doc = "* \\return #RCL_RET_ALREADY_INIT if the publisher is already initialized, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory fails, or"]
    #[doc = "* \\return #RCL_RET_TOPIC_NAME_INVALID if the given topic name is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_publisher_init(
        publisher: *mut rcl_publisher_t,
        node: *const rcl_node_t,
        type_support: *const rosidl_message_type_support_t,
        topic_name: *const ::std::os::raw::c_char,
        options: *const rcl_publisher_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a rcl_publisher_t."]
    #[doc = "* *"]
    #[doc = "* After calling, the node will no longer be advertising that it is publishing"]
    #[doc = "* on this topic (assuming this is the only publisher on this topic)."]
    #[doc = "* "]
    #[doc = "* After calling, calls to rcl_publish will fail when using this publisher."]
    #[doc = "* However, the given node handle is still valid."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] publisher handle to the publisher to be finalized"]
    #[doc = "* \\param[in] node a valid (not finalized) handle to the node used to create the publisher"]
    #[doc = "* \\return #RCL_RET_OK if publisher was finalized successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_PUBLISHER_INVALID if the publisher is invalid, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID if the node is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_publisher_fini(publisher: *mut rcl_publisher_t, node: *mut rcl_node_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the default publisher options in a rcl_publisher_options_t."]
    #[doc = "* *"]
    #[doc = "* The defaults are:"]
    #[doc = "* "]
    #[doc = "* - qos = rmw_qos_profile_default"]
    #[doc = "* - allocator = rcl_get_default_allocator()"]
    #[doc = "* - rmw_publisher_options = rmw_get_default_publisher_options()"]
    #[doc = "* "]
    #[doc = "* \\return A structure with the default publisher options."]
    #[doc = "* /"]
    pub fn rcl_publisher_get_default_options() -> rcl_publisher_options_t;
}
extern "C" {
    #[doc = " Borrow a loaned message."]
    #[doc = "* *"]
    #[doc = "* The memory allocated for the ros message belongs to the middleware and must not be deallocated"]
    #[doc = "* other than by a call to \\sa rcl_return_loaned_message_from_publisher."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No [0]"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* [0] the underlying middleware might allocate new memory or returns an existing chunk form a pool."]
    #[doc = "* The function in rcl however does not allocate any additional memory."]
    #[doc = "* "]
    #[doc = "* \\param[in] publisher Publisher to which the allocated message is associated."]
    #[doc = "* \\param[in] type_support Typesupport to which the internal ros message is allocated."]
    #[doc = "* \\param[out] ros_message The pointer to be filled to a valid ros message by the middleware."]
    #[doc = "* \\return #RCL_RET_OK if the ros message was correctly initialized, or"]
    #[doc = "* \\return #RCL_RET_PUBLISHER_INVALID if the passed publisher is invalid, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if an argument other than the ros message is null, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if the ros message could not be correctly created, or"]
    #[doc = "* \\return #RCL_RET_UNSUPPORTED if the middleware does not support that feature, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unexpected error occured."]
    #[doc = "* /"]
    pub fn rcl_borrow_loaned_message(
        publisher: *const rcl_publisher_t,
        type_support: *const rosidl_message_type_support_t,
        ros_message: *mut *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a loaned message previously borrowed from a publisher."]
    #[doc = "* *"]
    #[doc = "* The ownership of the passed in ros message will be transferred back to the middleware."]
    #[doc = "* The middleware might deallocate and destroy the message so that the pointer is no longer"]
    #[doc = "* guaranteed to be valid after that call."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] publisher Publisher to which the loaned message is associated."]
    #[doc = "* \\param[in] loaned_message Loaned message to be deallocated and destroyed."]
    #[doc = "* \\return #RCL_RET_OK if successful, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if an argument is null, or"]
    #[doc = "* \\return #RCL_RET_UNSUPPORTED if the middleware does not support that feature, or"]
    #[doc = "* \\return #RCL_RET_PUBLISHER_INVALID if the publisher is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unexpected error occurs and no message can be initialized."]
    #[doc = "* /"]
    pub fn rcl_return_loaned_message_from_publisher(
        publisher: *const rcl_publisher_t,
        loaned_message: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Publish a ROS message on a topic using a publisher."]
    #[doc = "* *"]
    #[doc = "* It is the job of the caller to ensure that the type of the ros_message"]
    #[doc = "* parameter and the type associate with the publisher (via the type support)"]
    #[doc = "* match."]
    #[doc = "* Passing a different type to publish produces undefined behavior and cannot"]
    #[doc = "* be checked by this function and therefore no deliberate error will occur."]
    #[doc = "* "]
    #[doc = "* \\todo TODO(wjwwood):"]
    #[doc = "* The blocking behavior of publish is a still a point of dispute."]
    #[doc = "* This section should be updated once the behavior is clearly defined."]
    #[doc = "* See: https://github.com/ros2/ros2/issues/255"]
    #[doc = "* "]
    #[doc = "* Calling rcl_publish() is a potentially blocking call."]
    #[doc = "* When called rcl_publish() will immediately do any publishing related work,"]
    #[doc = "* including, but not limited to, converting the message into a different type,"]
    #[doc = "* serializing the message, collecting publish statistics, etc."]
    #[doc = "* The last thing it will do is call the underlying middleware's publish"]
    #[doc = "* function which may or may not block based on the quality of service settings"]
    #[doc = "* given via the publisher options in rcl_publisher_init()."]
    #[doc = "* For example, if the reliability is set to reliable, then a publish may block"]
    #[doc = "* until space in the publish queue is available, but if the reliability is set"]
    #[doc = "* to best effort then it should not block."]
    #[doc = "* "]
    #[doc = "* The ROS message given by the `ros_message` void pointer is always owned by"]
    #[doc = "* the calling code, but should remain constant during publish."]
    #[doc = "* "]
    #[doc = "* This function is thread safe so long as access to both the publisher and the"]
    #[doc = "* `ros_message` is synchronized."]
    #[doc = "* That means that calling rcl_publish() from multiple threads is allowed, but"]
    #[doc = "* calling rcl_publish() at the same time as non-thread safe publisher"]
    #[doc = "* functions is not, e.g. calling rcl_publish() and rcl_publisher_fini()"]
    #[doc = "* concurrently is not allowed."]
    #[doc = "* Before calling rcl_publish() the message can change and after calling"]
    #[doc = "* rcl_publish() the message can change, but it cannot be changed during the"]
    #[doc = "* publish call."]
    #[doc = "* The same `ros_message`, however, can be passed to multiple calls of"]
    #[doc = "* rcl_publish() simultaneously, even if the publishers differ."]
    #[doc = "* The `ros_message` is unmodified by rcl_publish()."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes [1]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* <i>[1] for unique pairs of publishers and messages, see above for more</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] publisher handle to the publisher which will do the publishing"]
    #[doc = "* \\param[in] ros_message type-erased pointer to the ROS message"]
    #[doc = "* \\param[in] allocation structure pointer, used for memory preallocation (may be NULL)"]
    #[doc = "* \\return #RCL_RET_OK if the message was published successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_PUBLISHER_INVALID if the publisher is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_publish(
        publisher: *const rcl_publisher_t,
        ros_message: *const ::std::os::raw::c_void,
        allocation: *mut rmw_publisher_allocation_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Publish a serialized message on a topic using a publisher."]
    #[doc = "* *"]
    #[doc = "* It is the job of the caller to ensure that the type of the serialized message"]
    #[doc = "* parameter and the type associate with the publisher (via the type support)"]
    #[doc = "* match."]
    #[doc = "* Even though this call to publish takes an already serialized serialized message,"]
    #[doc = "* the publisher has to register its type as a ROS known message type."]
    #[doc = "* Passing a serialized message from a different type leads to undefined behavior on the subscriber side."]
    #[doc = "* The publish call might be able to send any abitrary serialized message, it is however"]
    #[doc = "* not garantueed that the subscriber side successfully deserializes this byte stream."]
    #[doc = "* "]
    #[doc = "* Apart from this, the `publish_serialized` function has the same behavior as rcl_publish()"]
    #[doc = "* expect that no serialization step is done."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes [1]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* <i>[1] for unique pairs of publishers and messages, see above for more</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] publisher handle to the publisher which will do the publishing"]
    #[doc = "* \\param[in] serialized_message  pointer to the already serialized message in raw form"]
    #[doc = "* \\param[in] allocation structure pointer, used for memory preallocation (may be NULL)"]
    #[doc = "* \\return #RCL_RET_OK if the message was published successfully, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_PUBLISHER_INVALID if the publisher is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_publish_serialized_message(
        publisher: *const rcl_publisher_t,
        serialized_message: *const rcl_serialized_message_t,
        allocation: *mut rmw_publisher_allocation_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Publish a loaned message on a topic using a publisher."]
    #[doc = "* *"]
    #[doc = "* A previously borrowed loaned message can be sent via this call to rcl_publish_loaned_message()."]
    #[doc = "* By calling this function, the ownership of the loaned message is getting transferred back"]
    #[doc = "* to the middleware."]
    #[doc = "* The pointer to the `ros_message` is not guaranteed to be valid after as the middleware"]
    #[doc = "* migth deallocate the memory for this message internally."]
    #[doc = "* It is thus recommended to call this function only in combination with"]
    #[doc = "* \\sa rcl_borrow_loaned_message()."]
    #[doc = "* "]
    #[doc = "* Apart from this, the `publish_loaned_message` function has the same behavior as rcl_publish()"]
    #[doc = "* except that no serialization step is done."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No [0]"]
    #[doc = "* Thread-Safe        | Yes [1]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* <i>[0] the middleware might deallocate the loaned message."]
    #[doc = "* The RCL function however does not allocate any memory.</i>"]
    #[doc = "* <i>[1] for unique pairs of publishers and messages, see above for more</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] publisher handle to the publisher which will do the publishing"]
    #[doc = "* \\param[in] ros_message  pointer to the previously borrow loaned message"]
    #[doc = "* \\param[in] allocation structure pointer, used for memory preallocation (may be NULL)"]
    #[doc = "* \\return #RCL_RET_OK if the message was published successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_PUBLISHER_INVALID if the publisher is invalid, or"]
    #[doc = "* \\return #RCL_RET_UNSUPPORTED if the middleware does not support that feature, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_publish_loaned_message(
        publisher: *const rcl_publisher_t,
        ros_message: *mut ::std::os::raw::c_void,
        allocation: *mut rmw_publisher_allocation_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Manually assert that this Publisher is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC)"]
    #[doc = "* *"]
    #[doc = "* If the rmw Liveliness policy is set to RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC, the creator of"]
    #[doc = "* this publisher may manually call `assert_liveliness` at some point in time to signal to the rest"]
    #[doc = "* of the system that this Node is still alive."]
    #[doc = "* This function must be called at least as often as the qos_profile's liveliness_lease_duration"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] publisher handle to the publisher that needs liveliness to be asserted"]
    #[doc = "* \\return #RCL_RET_OK if the liveliness assertion was completed successfully, or"]
    #[doc = "* \\return #RCL_RET_PUBLISHER_INVALID if the publisher is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_publisher_assert_liveliness(publisher: *const rcl_publisher_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the topic name for the publisher."]
    #[doc = "* *"]
    #[doc = "* This function returns the publisher's internal topic name string."]
    #[doc = "* This function can fail, and therefore return `NULL`, if the:"]
    #[doc = "* - publisher is `NULL`"]
    #[doc = "* - publisher is invalid (never called init, called fini, or invalid node)"]
    #[doc = "* "]
    #[doc = "* The returned string is only valid as long as the rcl_publisher_t is valid."]
    #[doc = "* The value of the string may change if the topic name changes, and therefore"]
    #[doc = "* copying the string is recommended if this is a concern."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] publisher pointer to the publisher"]
    #[doc = "* \\return name string if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_publisher_get_topic_name(
        publisher: *const rcl_publisher_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the rcl publisher options."]
    #[doc = "* *"]
    #[doc = "* This function returns the publisher's internal options struct."]
    #[doc = "* This function can fail, and therefore return `NULL`, if the:"]
    #[doc = "* - publisher is `NULL`"]
    #[doc = "* - publisher is invalid (never called init, called fini, or invalid node)"]
    #[doc = "* "]
    #[doc = "* The returned struct is only valid as long as the rcl_publisher_t is valid."]
    #[doc = "* The values in the struct may change if the options of the publisher change,"]
    #[doc = "* and therefore copying the struct is recommended if this is a concern."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] publisher pointer to the publisher"]
    #[doc = "* \\return options struct if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_publisher_get_options(
        publisher: *const rcl_publisher_t,
    ) -> *const rcl_publisher_options_t;
}
extern "C" {
    #[doc = " Return the rmw publisher handle."]
    #[doc = "* *"]
    #[doc = "* The handle returned is a pointer to the internally held rmw handle."]
    #[doc = "* This function can fail, and therefore return `NULL`, if the:"]
    #[doc = "* - publisher is `NULL`"]
    #[doc = "* - publisher is invalid (never called init, called fini, or invalid node)"]
    #[doc = "* "]
    #[doc = "* The returned handle is made invalid if the publisher is finalized or if"]
    #[doc = "* rcl_shutdown() is called."]
    #[doc = "* The returned handle is not guaranteed to be valid for the life time of the"]
    #[doc = "* publisher as it may be finalized and recreated itself."]
    #[doc = "* Therefore it is recommended to get the handle from the publisher using"]
    #[doc = "* this function each time it is needed and avoid use of the handle"]
    #[doc = "* concurrently with functions that might change it."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] publisher pointer to the rcl publisher"]
    #[doc = "* \\return rmw publisher handle if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_publisher_get_rmw_handle(publisher: *const rcl_publisher_t) -> *mut rmw_publisher_t;
}
extern "C" {
    #[doc = " Return the context associated with this publisher."]
    #[doc = "* *"]
    #[doc = "* This function can fail, and therefore return `NULL`, if the:"]
    #[doc = "* - publisher is `NULL`"]
    #[doc = "* - publisher is invalid (never called init, called fini, etc.)"]
    #[doc = "* "]
    #[doc = "* The returned context is made invalid if the publisher is finalized or if"]
    #[doc = "* rcl_shutdown() is called."]
    #[doc = "* Therefore it is recommended to get the handle from the publisher using"]
    #[doc = "* this function each time it is needed and avoid use of the handle"]
    #[doc = "* concurrently with functions that might change it."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] publisher pointer to the rcl publisher"]
    #[doc = "* \\return context if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_publisher_get_context(publisher: *const rcl_publisher_t) -> *mut rcl_context_t;
}
extern "C" {
    #[doc = " Return true if the publisher is valid, otherwise false."]
    #[doc = "* *"]
    #[doc = "* The bool returned is `false` if `publisher` is invalid."]
    #[doc = "* The bool returned is `true` otherwise."]
    #[doc = "* In the case where `false` is to be returned, an error message is set."]
    #[doc = "* This function cannot fail."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] publisher pointer to the rcl publisher"]
    #[doc = "* \\return `true` if `publisher` is valid, otherwise `false`"]
    #[doc = "* /"]
    pub fn rcl_publisher_is_valid(publisher: *const rcl_publisher_t) -> bool;
}
extern "C" {
    #[doc = " Return true if the publisher is valid except the context, otherwise false."]
    #[doc = "* *"]
    #[doc = "* This is used in clean up functions that need to access the publisher, but do"]
    #[doc = "* not need use any functions with the context."]
    #[doc = "* "]
    #[doc = "* It is identical to rcl_publisher_is_valid except it ignores the state of the"]
    #[doc = "* context associated with the publisher."]
    #[doc = "* \\sa rcl_publisher_is_valid()"]
    #[doc = "* /"]
    pub fn rcl_publisher_is_valid_except_context(publisher: *const rcl_publisher_t) -> bool;
}
extern "C" {
    #[doc = " Get the number of subscriptions matched to a publisher."]
    #[doc = "* *"]
    #[doc = "* Used to get the internal count of subscriptions matched to a publisher."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] only if the underlying rmw doesn't make use of this feature </i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] publisher pointer to the rcl publisher"]
    #[doc = "* \\param[out] subscription_count number of matched subscriptions"]
    #[doc = "* \\return #RCL_RET_OK if the count was retrieved, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_PUBLISHER_INVALID if the publisher is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_publisher_get_subscription_count(
        publisher: *const rcl_publisher_t,
        subscription_count: *mut size_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the actual qos settings of the publisher."]
    #[doc = "* *"]
    #[doc = "* Used to get the actual qos settings of the publisher."]
    #[doc = "* The actual configuration applied when using RMW_*_SYSTEM_DEFAULT"]
    #[doc = "* can only be resolved after the creation of the publisher, and it"]
    #[doc = "* depends on the underlying rmw implementation."]
    #[doc = "* If the underlying setting in use can't be represented in ROS terms,"]
    #[doc = "* it will be set to RMW_*_UNKNOWN."]
    #[doc = "* The returned struct is only valid as long as the rcl_publisher_t is valid."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] publisher pointer to the rcl publisher"]
    #[doc = "* \\return qos struct if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_publisher_get_actual_qos(
        publisher: *const rcl_publisher_t,
    ) -> *const rmw_qos_profile_t;
}
extern "C" {
    #[doc = " Check if publisher instance can loan messages."]
    #[doc = "* *"]
    #[doc = "* Depending on the middleware and the message type, this will return true if the middleware"]
    #[doc = "* can allocate a ROS message instance."]
    #[doc = "* /"]
    pub fn rcl_publisher_can_loan_messages(publisher: *const rcl_publisher_t) -> bool;
}
#[doc = " Structure to hold a sequence of ROS messages."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_message_sequence_t {
    #[doc = " Array of pointers to ROS messages."]
    pub data: *mut *mut ::std::os::raw::c_void,
    #[doc = " The number of valid entries in `data`."]
    pub size: size_t,
    #[doc = " The total allocated capacity of the data array."]
    pub capacity: size_t,
    #[doc = " The allocator used to allocate the data array."]
    pub allocator: *mut rcutils_allocator_t,
}
#[test]
fn bindgen_test_layout_rmw_message_sequence_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_message_sequence_t>(),
        32usize,
        concat!("Size of: ", stringify!(rmw_message_sequence_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_message_sequence_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_message_sequence_t))
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_message_sequence_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_message_sequence_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_message_sequence_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_message_sequence_t),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_capacity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_message_sequence_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_message_sequence_t),
                "::",
                stringify!(capacity)
            )
        );
    }
    test_field_capacity();
    fn test_field_allocator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_message_sequence_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_message_sequence_t),
                "::",
                stringify!(allocator)
            )
        );
    }
    test_field_allocator();
}
#[doc = " Structure to hold a sequence of message infos."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_message_info_sequence_t {
    #[doc = " Array of message info."]
    pub data: *mut rmw_message_info_t,
    #[doc = " The number of valid entries in data."]
    pub size: size_t,
    #[doc = " The total allocated capacity of the data array."]
    pub capacity: size_t,
    #[doc = " The allocator used to allocate the data array."]
    pub allocator: *mut rcutils_allocator_t,
}
#[test]
fn bindgen_test_layout_rmw_message_info_sequence_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_message_info_sequence_t>(),
        32usize,
        concat!("Size of: ", stringify!(rmw_message_info_sequence_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_message_info_sequence_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_message_info_sequence_t))
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_message_info_sequence_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_message_info_sequence_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_message_info_sequence_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_message_info_sequence_t),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_capacity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_message_info_sequence_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_message_info_sequence_t),
                "::",
                stringify!(capacity)
            )
        );
    }
    test_field_capacity();
    fn test_field_allocator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_message_info_sequence_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_message_info_sequence_t),
                "::",
                stringify!(allocator)
            )
        );
    }
    test_field_allocator();
}
extern "C" {
    #[doc = " Return an rmw_message_sequence_t struct with members initialized to `NULL`"]
    pub fn rmw_get_zero_initialized_message_sequence() -> rmw_message_sequence_t;
}
extern "C" {
    #[doc = " Initialize an rmw_message_sequence_t object."]
    #[doc = "* *"]
    #[doc = "* \\param[inout] sequence sequence object to be initialized."]
    #[doc = "* \\param[in] size capacity of the sequence to be allocated."]
    #[doc = "* \\param[in] allocator the allcator used to allocate memory."]
    #[doc = "* /"]
    pub fn rmw_message_sequence_init(
        sequence: *mut rmw_message_sequence_t,
        size: size_t,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Finalize an rmw_message_sequence_t object."]
    #[doc = "* *"]
    #[doc = "* The rmw_message_sequence_t struct has members which require memory to be allocated to them"]
    #[doc = "* before setting values."]
    #[doc = "* This function reclaims any allocated resources within the object and zeroes out all other"]
    #[doc = "* members."]
    #[doc = "* "]
    #[doc = "* Note: This will not call `fini` or deallocate the underlying message structures."]
    #[doc = "* "]
    #[doc = "* \\param[inout] sequence sequence object to be finalized."]
    #[doc = "* /"]
    pub fn rmw_message_sequence_fini(sequence: *mut rmw_message_sequence_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Return an rmw_message_info_sequence_t struct with members initialized to `NULL`"]
    pub fn rmw_get_zero_initialized_message_info_sequence() -> rmw_message_info_sequence_t;
}
extern "C" {
    #[doc = " Initialize an rmw_message_info_sequence_t object."]
    #[doc = "* *"]
    #[doc = "* \\param[inout] sequence sequence object to be initialized."]
    #[doc = "* \\param[in] size capacity of the sequence to be allocated."]
    #[doc = "* \\param[in] allocator the allcator used to allocate memory."]
    #[doc = "* /"]
    pub fn rmw_message_info_sequence_init(
        sequence: *mut rmw_message_info_sequence_t,
        size: size_t,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Finalize an rmw_message_sequence_t object."]
    #[doc = "* *"]
    #[doc = "* The rmw_message_sequence_t struct has members which require memory to be allocated to them"]
    #[doc = "* before setting values."]
    #[doc = "* This function reclaims any allocated resources within the object and zeroes out all other"]
    #[doc = "* members."]
    #[doc = "* "]
    #[doc = "* \\param[inout] sequence sequence object to be finalized."]
    #[doc = "* /"]
    pub fn rmw_message_info_sequence_fini(sequence: *mut rmw_message_info_sequence_t) -> rmw_ret_t;
}
#[doc = " Internal rcl implementation struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_subscription_impl_t {
    _unused: [u8; 0],
}
#[doc = " Structure which encapsulates a ROS Subscription."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_subscription_t {
    #[doc = " Pointer to the subscription implementation"]
    pub impl_: *mut rcl_subscription_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_subscription_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_subscription_t>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_subscription_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_subscription_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_subscription_t))
    );
    fn test_field_impl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_subscription_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_subscription_t),
                "::",
                stringify!(impl_)
            )
        );
    }
    test_field_impl();
}
#[doc = " Options available for a rcl subscription."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_subscription_options_t {
    #[doc = " Middleware quality of service settings for the subscription."]
    pub qos: rmw_qos_profile_t,
    #[doc = " Custom allocator for the subscription, used for incidental allocations."]
    #[doc = "* * For default behavior (malloc/free), see: rcl_get_default_allocator() */"]
    pub allocator: rcl_allocator_t,
    #[doc = " rmw specific subscription options, e.g. the rmw implementation specific payload."]
    pub rmw_subscription_options: rmw_subscription_options_t,
}
#[test]
fn bindgen_test_layout_rcl_subscription_options_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_subscription_options_t>(),
        144usize,
        concat!("Size of: ", stringify!(rcl_subscription_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_subscription_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_subscription_options_t))
    );
    fn test_field_qos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_subscription_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).qos) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_subscription_options_t),
                "::",
                stringify!(qos)
            )
        );
    }
    test_field_qos();
    fn test_field_allocator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_subscription_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_subscription_options_t),
                "::",
                stringify!(allocator)
            )
        );
    }
    test_field_allocator();
    fn test_field_rmw_subscription_options() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_subscription_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rmw_subscription_options) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_subscription_options_t),
                "::",
                stringify!(rmw_subscription_options)
            )
        );
    }
    test_field_rmw_subscription_options();
}
extern "C" {
    #[doc = " Return a rcl_subscription_t struct with members set to `NULL`."]
    #[doc = "* *"]
    #[doc = "* Should be called to get a null rcl_subscription_t before passing to"]
    #[doc = "* rcl_subscription_init()."]
    #[doc = "* /"]
    pub fn rcl_get_zero_initialized_subscription() -> rcl_subscription_t;
}
extern "C" {
    #[doc = " Initialize a ROS subscription."]
    #[doc = "* *"]
    #[doc = "* After calling this function on a rcl_subscription_t, it can be used to take"]
    #[doc = "* messages of the given type to the given topic using rcl_take()."]
    #[doc = "* "]
    #[doc = "* The given rcl_node_t must be valid and the resulting rcl_subscription_t is"]
    #[doc = "* only valid as long as the given rcl_node_t remains valid."]
    #[doc = "* "]
    #[doc = "* The rosidl_message_type_support_t is obtained on a per .msg type basis."]
    #[doc = "* When the user defines a ROS message, code is generated which provides the"]
    #[doc = "* required rosidl_message_type_support_t object."]
    #[doc = "* This object can be obtained using a language appropriate mechanism."]
    #[doc = "* \\todo TODO(wjwwood) write these instructions once and link to it instead"]
    #[doc = "* For C a macro can be used (for example `std_msgs/String`):"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* #include <rosidl_runtime_c/message_type_support_struct.h>"]
    #[doc = "* #include <std_msgs/msg/string.h>"]
    #[doc = "* const rosidl_message_type_support_t * string_ts ="]
    #[doc = "* ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* For C++ a template function is used:"]
    #[doc = "* "]
    #[doc = "* ```cpp"]
    #[doc = "* #include <rosidl_runtime_cpp/message_type_support.hpp>"]
    #[doc = "* #include <std_msgs/msgs/string.hpp>"]
    #[doc = "* using rosidl_typesupport_cpp::get_message_type_support_handle;"]
    #[doc = "* const rosidl_message_type_support_t * string_ts ="]
    #[doc = "* get_message_type_support_handle<std_msgs::msg::String>();"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* The rosidl_message_type_support_t object contains message type specific"]
    #[doc = "* information used to publish messages."]
    #[doc = "* "]
    #[doc = "* The topic name must be a c string which follows the topic and service name"]
    #[doc = "* format rules for unexpanded names, also known as non-fully qualified names:"]
    #[doc = "* "]
    #[doc = "* \\see rcl_expand_topic_name"]
    #[doc = "* "]
    #[doc = "* The options struct allows the user to set the quality of service settings as"]
    #[doc = "* well as a custom allocator which is used when (de)initializing the"]
    #[doc = "* subscription to allocate space for incidental things, e.g. the topic"]
    #[doc = "* name string."]
    #[doc = "* "]
    #[doc = "* Expected usage (for C messages):"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* #include <rcl/rcl.h>"]
    #[doc = "* #include <rosidl_runtime_c/message_type_support_struct.h>"]
    #[doc = "* #include <std_msgs/msg/string.h>"]
    #[doc = "* "]
    #[doc = "* rcl_node_t node = rcl_get_zero_initialized_node();"]
    #[doc = "* rcl_node_options_t node_ops = rcl_node_get_default_options();"]
    #[doc = "* rcl_ret_t ret = rcl_node_init(&node, \"node_name\", \"/my_namespace\", &node_ops);"]
    #[doc = "* // ... error handling"]
    #[doc = "* const rosidl_message_type_support_t * ts ="]
    #[doc = "* ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);"]
    #[doc = "* rcl_subscription_t subscription = rcl_get_zero_initialized_subscription();"]
    #[doc = "* rcl_subscription_options_t subscription_ops = rcl_subscription_get_default_options();"]
    #[doc = "* ret = rcl_subscription_init(&subscription, &node, ts, \"chatter\", &subscription_ops);"]
    #[doc = "* // ... error handling, and when finished deinitialization"]
    #[doc = "* ret = rcl_subscription_fini(&subscription, &node);"]
    #[doc = "* // ... error handling for rcl_subscription_fini()"]
    #[doc = "* ret = rcl_node_fini(&node);"]
    #[doc = "* // ... error handling for rcl_node_fini()"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[out] subscription preallocated subscription structure"]
    #[doc = "* \\param[in] node valid rcl node handle"]
    #[doc = "* \\param[in] type_support type support object for the topic's type"]
    #[doc = "* \\param[in] topic_name the name of the topic"]
    #[doc = "* \\param[in] options subscription options, including quality of service settings"]
    #[doc = "* \\return #RCL_RET_OK if subscription was initialized successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ALREADY_INIT if the subcription is already initialized, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID if the node is invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_TOPIC_NAME_INVALID if the given topic name is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_subscription_init(
        subscription: *mut rcl_subscription_t,
        node: *const rcl_node_t,
        type_support: *const rosidl_message_type_support_t,
        topic_name: *const ::std::os::raw::c_char,
        options: *const rcl_subscription_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a rcl_subscription_t."]
    #[doc = "* *"]
    #[doc = "* After calling, the node will no longer be subscribed on this topic"]
    #[doc = "* (assuming this is the only subscription on this topic in this node)."]
    #[doc = "* "]
    #[doc = "* After calling, calls to rcl_wait and rcl_take will fail when using this"]
    #[doc = "* subscription."]
    #[doc = "* Additioanlly rcl_wait will be interrupted if currently blocking."]
    #[doc = "* However, the given node handle is still valid."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] subscription handle to the subscription to be deinitialized"]
    #[doc = "* \\param[in] node a valid (not finalized) handle to the node used to create the subscription"]
    #[doc = "* \\return #RCL_RET_OK if subscription was deinitialized successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_SUBSCRIPTION_INVALID if the subscription is invalid, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID if the node is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_subscription_fini(
        subscription: *mut rcl_subscription_t,
        node: *mut rcl_node_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the default subscription options in a rcl_subscription_options_t."]
    #[doc = "* *"]
    #[doc = "* The defaults are:"]
    #[doc = "* "]
    #[doc = "* - qos = rmw_qos_profile_default"]
    #[doc = "* - allocator = rcl_get_default_allocator()"]
    #[doc = "* - rmw_subscription_options = rmw_get_default_subscription_options();"]
    #[doc = "* "]
    #[doc = "* \\return A structure containing the default options for a subscription."]
    #[doc = "* /"]
    pub fn rcl_subscription_get_default_options() -> rcl_subscription_options_t;
}
extern "C" {
    #[doc = " Take a ROS message from a topic using a rcl subscription."]
    #[doc = "* *"]
    #[doc = "* It is the job of the caller to ensure that the type of the ros_message"]
    #[doc = "* argument and the type associated with the subscription, via the type"]
    #[doc = "* support, match."]
    #[doc = "* Passing a different type to rcl_take produces undefined behavior and cannot"]
    #[doc = "* be checked by this function and therefore no deliberate error will occur."]
    #[doc = "* "]
    #[doc = "* TODO(wjwwood) blocking of take?"]
    #[doc = "* TODO(wjwwood) pre-, during-, and post-conditions for message ownership?"]
    #[doc = "* TODO(wjwwood) is rcl_take thread-safe?"]
    #[doc = "* TODO(wjwwood) Should there be an rcl_message_info_t?"]
    #[doc = "* "]
    #[doc = "* The ros_message pointer should point to an already allocated ROS message"]
    #[doc = "* struct of the correct type, into which the taken ROS message will be copied"]
    #[doc = "* if one is available."]
    #[doc = "* If taken is false after calling, then the ROS message will be unmodified."]
    #[doc = "* "]
    #[doc = "* The taken boolean may be false even if a wait set reports that the"]
    #[doc = "* subscription was ready to be taken from in some cases, e.g. when the"]
    #[doc = "* state of the subscription changes it may cause the wait set to wake up"]
    #[doc = "* but subsequent takes to fail to take anything."]
    #[doc = "* "]
    #[doc = "* If allocation is required when taking the message, e.g. if space needs to"]
    #[doc = "* be allocated for a dynamically sized array in the target message, then the"]
    #[doc = "* allocator given in the subscription options is used."]
    #[doc = "* "]
    #[doc = "* The rmw_message_info struct contains meta information about this particular"]
    #[doc = "* message instance, like what the GUID of the publisher which published it"]
    #[doc = "* originally or whether or not the message received from within the same"]
    #[doc = "* process."]
    #[doc = "* The message_info argument should be an already allocated rmw_message_info_t"]
    #[doc = "* structure."]
    #[doc = "* Passing `NULL` for message_info will result in the argument being ignored."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe [1]"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* <i>[1] only if required when filling the message, avoided for fixed sizes</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] subscription the handle to the subscription from which to take"]
    #[doc = "* \\param[inout] ros_message type-erased ptr to a allocated ROS message"]
    #[doc = "* \\param[out] message_info rmw struct which contains meta-data for the message"]
    #[doc = "* \\param[in] allocation structure pointer used for memory preallocation (may be NULL)"]
    #[doc = "* \\return #RCL_RET_OK if the message was taken, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_SUBSCRIPTION_INVALID if the subscription is invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_SUBSCRIPTION_TAKE_FAILED if take failed but no error"]
    #[doc = "* occurred in the middleware, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_take(
        subscription: *const rcl_subscription_t,
        ros_message: *mut ::std::os::raw::c_void,
        message_info: *mut rmw_message_info_t,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take a sequence of messages from a topic using a rcl subscription."]
    #[doc = "* *"]
    #[doc = "* In contrast to rcl_take(), this function can take multiple messages at"]
    #[doc = "* the same time."]
    #[doc = "* It is the job of the caller to ensure that the type of the message_sequence"]
    #[doc = "* argument and the type associated with the subscription, via the type"]
    #[doc = "* support, match."]
    #[doc = "* "]
    #[doc = "* The message_sequence pointer should point to an already allocated sequence"]
    #[doc = "* of ROS messages of the correct type, into which the taken ROS messages will"]
    #[doc = "* be copied if messages are available."]
    #[doc = "* The message_sequence `size` member will be set to the number of messages"]
    #[doc = "* correctly taken."]
    #[doc = "* "]
    #[doc = "* The rmw_message_info_sequence struct contains meta information about the"]
    #[doc = "* corresponding message instance index."]
    #[doc = "* The message_info_sequence argument should be an already allocated"]
    #[doc = "* rmw_message_info_sequence_t structure."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe [1]"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* <i>[1] only if storage in the serialized_message is insufficient</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] subscription the handle to the subscription from which to take."]
    #[doc = "* \\param[in] count number of messages to attempt to take."]
    #[doc = "* \\param[inout] message_sequence pointer to a (pre-allocated) message sequence."]
    #[doc = "* \\param[inout] message_info_sequence pointer to a (pre-allocated) message info sequence."]
    #[doc = "* \\param[in] allocation structure pointer used for memory preallocation (may be NULL)"]
    #[doc = "* \\return #RCL_RET_OK if one or more messages was taken, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_SUBSCRIPTION_INVALID if the subscription is invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_SUBSCRIPTION_TAKE_FAILED if take failed but no error"]
    #[doc = "* occurred in the middleware, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_take_sequence(
        subscription: *const rcl_subscription_t,
        count: size_t,
        message_sequence: *mut rmw_message_sequence_t,
        message_info_sequence: *mut rmw_message_info_sequence_t,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take a serialized raw message from a topic using a rcl subscription."]
    #[doc = "* *"]
    #[doc = "* In contrast to rcl_take(), this function stores the taken message in"]
    #[doc = "* its raw binary representation."]
    #[doc = "* It is the job of the caller to ensure that the type associate with the subscription"]
    #[doc = "* matches, and can optionally be deserialized into its ROS message via, the correct"]
    #[doc = "* type support."]
    #[doc = "* If the `serialized_message` parameter contains enough preallocated memory, the incoming"]
    #[doc = "* message can be taken without any additional memory allocation."]
    #[doc = "* If not, the function will dynamically allocate enough memory for the message."]
    #[doc = "* Passing a different type to rcl_take produces undefined behavior and cannot"]
    #[doc = "* be checked by this function and therefore no deliberate error will occur."]
    #[doc = "* "]
    #[doc = "* Apart from the differences above, this function behaves like rcl_take()."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe [1]"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* <i>[1] only if storage in the serialized_message is insufficient</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] subscription the handle to the subscription from which to take"]
    #[doc = "* \\param[inout] serialized_message pointer to a (pre-allocated) serialized message."]
    #[doc = "* \\param[out] message_info rmw struct which contains meta-data for the message"]
    #[doc = "* \\param[in] allocation structure pointer used for memory preallocation (may be NULL)"]
    #[doc = "* \\return #RCL_RET_OK if the message was published, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_SUBSCRIPTION_INVALID if the subscription is invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_SUBSCRIPTION_TAKE_FAILED if take failed but no error"]
    #[doc = "* occurred in the middleware, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_take_serialized_message(
        subscription: *const rcl_subscription_t,
        serialized_message: *mut rcl_serialized_message_t,
        message_info: *mut rmw_message_info_t,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take a loaned message from a topic using a rcl subscription."]
    #[doc = "* *"]
    #[doc = "* Depending on the middleware, incoming messages can be loaned to the user's callback"]
    #[doc = "* without further copying."]
    #[doc = "* The implicit contract here is that the middleware owns the memory allocated for this message."]
    #[doc = "* The user must not destroy the message, but rather has to return it with a call to"]
    #[doc = "* \\sa rcl_return_loaned_message to the middleware."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] subscription the handle to the subscription from which to take"]
    #[doc = "* \\param[inout] loaned_message a pointer to the loaned messages."]
    #[doc = "* \\param[out] message_info rmw struct which contains meta-data for the message."]
    #[doc = "* \\param[in] allocation structure pointer used for memory preallocation (may be NULL)"]
    #[doc = "* \\return #RCL_RET_OK if the loaned message sequence was taken, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_SUBSCRIPTION_INVALID if the subscription is invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_SUBSCRIPTION_TAKE_FAILED if take failed but no error"]
    #[doc = "* occurred in the middleware, or"]
    #[doc = "* \\return #RCL_RET_UNSUPPORTED if the middleware does not support that feature, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_take_loaned_message(
        subscription: *const rcl_subscription_t,
        loaned_message: *mut *mut ::std::os::raw::c_void,
        message_info: *mut rmw_message_info_t,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a loaned message from a topic using a rcl subscription."]
    #[doc = "* *"]
    #[doc = "* If a loaned message was previously obtained from the middleware with a call to"]
    #[doc = "* \\sa rcl_take_loaned_message, this message has to be returned to indicate to the middleware"]
    #[doc = "* that the user no longer needs that memory."]
    #[doc = "* The user must not delete the message."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] subscription the handle to the subscription from which to take"]
    #[doc = "* \\param[in] loaned_message a pointer to the loaned messages."]
    #[doc = "* \\return #RCL_RET_OK if the message was published, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_SUBSCRIPTION_INVALID if the subscription is invalid, or"]
    #[doc = "* \\return #RCL_RET_UNSUPPORTED if the middleware does not support that feature, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_return_loaned_message_from_subscription(
        subscription: *const rcl_subscription_t,
        loaned_message: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the topic name for the subscription."]
    #[doc = "* *"]
    #[doc = "* This function returns the subscription's internal topic name string."]
    #[doc = "* This function can fail, and therefore return `NULL`, if the:"]
    #[doc = "* - subscription is `NULL`"]
    #[doc = "* - subscription is invalid (never called init, called fini, or invalid)"]
    #[doc = "* "]
    #[doc = "* The returned string is only valid as long as the subscription is valid."]
    #[doc = "* The value of the string may change if the topic name changes, and therefore"]
    #[doc = "* copying the string is recommended if this is a concern."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] subscription the pointer to the subscription"]
    #[doc = "* \\return name string if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_subscription_get_topic_name(
        subscription: *const rcl_subscription_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the rcl subscription options."]
    #[doc = "* *"]
    #[doc = "* This function returns the subscription's internal options struct."]
    #[doc = "* This function can fail, and therefore return `NULL`, if the:"]
    #[doc = "* - subscription is `NULL`"]
    #[doc = "* - subscription is invalid (never called init, called fini, or invalid)"]
    #[doc = "* "]
    #[doc = "* The returned struct is only valid as long as the subscription is valid."]
    #[doc = "* The values in the struct may change if the subscription's options change,"]
    #[doc = "* and therefore copying the struct is recommended if this is a concern."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] subscription pointer to the subscription"]
    #[doc = "* \\return options struct if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_subscription_get_options(
        subscription: *const rcl_subscription_t,
    ) -> *const rcl_subscription_options_t;
}
extern "C" {
    #[doc = " Return the rmw subscription handle."]
    #[doc = "* *"]
    #[doc = "* The handle returned is a pointer to the internally held rmw handle."]
    #[doc = "* This function can fail, and therefore return `NULL`, if the:"]
    #[doc = "* - subscription is `NULL`"]
    #[doc = "* - subscription is invalid (never called init, called fini, or invalid)"]
    #[doc = "* "]
    #[doc = "* The returned handle is made invalid if the subscription is finalized or if"]
    #[doc = "* rcl_shutdown() is called."]
    #[doc = "* The returned handle is not guaranteed to be valid for the life time of the"]
    #[doc = "* subscription as it may be finalized and recreated itself."]
    #[doc = "* Therefore it is recommended to get the handle from the subscription using"]
    #[doc = "* this function each time it is needed and avoid use of the handle"]
    #[doc = "* concurrently with functions that might change it."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] subscription pointer to the rcl subscription"]
    #[doc = "* \\return rmw subscription handle if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_subscription_get_rmw_handle(
        subscription: *const rcl_subscription_t,
    ) -> *mut rmw_subscription_t;
}
extern "C" {
    #[doc = " Check that the subscription is valid."]
    #[doc = "* *"]
    #[doc = "* The bool returned is `false` if `subscription` is invalid."]
    #[doc = "* The bool returned is `true` otherwise."]
    #[doc = "* In the case where `false` is to be returned, an error message is set."]
    #[doc = "* This function cannot fail."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] subscription pointer to the rcl subscription"]
    #[doc = "* \\return `true` if `subscription` is valid, otherwise `false`"]
    #[doc = "* /"]
    pub fn rcl_subscription_is_valid(subscription: *const rcl_subscription_t) -> bool;
}
extern "C" {
    #[doc = " Get the number of publishers matched to a subscription."]
    #[doc = "* *"]
    #[doc = "* Used to get the internal count of publishers matched to a subscription."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] only if the underlying rmw doesn't make use of this feature </i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] subscription pointer to the rcl subscription"]
    #[doc = "* \\param[out] publisher_count number of matched publishers"]
    #[doc = "* \\return #RCL_RET_OK if the count was retrieved, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_SUBSCRIPTION_INVALID if the subscription is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_subscription_get_publisher_count(
        subscription: *const rcl_subscription_t,
        publisher_count: *mut size_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Get the actual qos settings of the subscription."]
    #[doc = "* *"]
    #[doc = "* Used to get the actual qos settings of the subscription."]
    #[doc = "* The actual configuration applied when using RMW_*_SYSTEM_DEFAULT"]
    #[doc = "* can only be resolved after the creation of the subscription, and it"]
    #[doc = "* depends on the underlying rmw implementation."]
    #[doc = "* If the underlying setting in use can't be represented in ROS terms,"]
    #[doc = "* it will be set to RMW_*_UNKNOWN."]
    #[doc = "* The returned struct is only valid as long as the rcl_subscription_t is valid."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] subscription pointer to the rcl subscription"]
    #[doc = "* \\return qos struct if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_subscription_get_actual_qos(
        subscription: *const rcl_subscription_t,
    ) -> *const rmw_qos_profile_t;
}
extern "C" {
    #[doc = " Check if subscription instance can loan messages."]
    #[doc = "* *"]
    #[doc = "* Depending on the middleware and the message type, this will return true if the middleware"]
    #[doc = "* can allocate a ROS message instance."]
    #[doc = "* "]
    #[doc = "* \\param[in] subscription The subscription instance to check for the ability to loan messages"]
    #[doc = "* \\return `true` if the subscription instance can loan messages, `false` otherwise."]
    #[doc = "* /"]
    pub fn rcl_subscription_can_loan_messages(subscription: *const rcl_subscription_t) -> bool;
}
pub type rosidl_service_typesupport_handle_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_service_type_support_t,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const rosidl_service_type_support_t,
>;
#[doc = " Contains rosidl service type support data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_service_type_support_t {
    #[doc = " String identifier for the type_support."]
    pub typesupport_identifier: *const ::std::os::raw::c_char,
    #[doc = " Pointer to the service type support library"]
    pub data: *const ::std::os::raw::c_void,
    #[doc = " Pointer to the service type support handler function"]
    pub func: rosidl_service_typesupport_handle_function,
}
#[test]
fn bindgen_test_layout_rosidl_service_type_support_t() {
    assert_eq!(
        ::std::mem::size_of::<rosidl_service_type_support_t>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_service_type_support_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_service_type_support_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rosidl_service_type_support_t))
    );
    fn test_field_typesupport_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rosidl_service_type_support_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).typesupport_identifier) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rosidl_service_type_support_t),
                "::",
                stringify!(typesupport_identifier)
            )
        );
    }
    test_field_typesupport_identifier();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rosidl_service_type_support_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rosidl_service_type_support_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rosidl_service_type_support_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rosidl_service_type_support_t),
                "::",
                stringify!(func)
            )
        );
    }
    test_field_func();
}
extern "C" {
    #[doc = " Get the service type support handle specific to this identifier."]
    #[doc = "* *"]
    #[doc = "* The handle's message typesupport identifier function is returned or if the parameters are NULL"]
    #[doc = "* then an assert will happen."]
    #[doc = "* "]
    #[doc = "* \\param handle Handle to service type support"]
    #[doc = "* \\param identifier The typesupport identifier to get the handle function for"]
    #[doc = "* \\return The associated service typesupport handle function."]
    #[doc = "* /"]
    pub fn get_service_typesupport_handle(
        handle: *const rosidl_service_type_support_t,
        identifier: *const ::std::os::raw::c_char,
    ) -> *const rosidl_service_type_support_t;
}
extern "C" {
    #[doc = " Get the service type support handle function specific to this identifier."]
    #[doc = "* *"]
    #[doc = "* If the identifier is the same as this handle's typesupport_identifier the handle is simply"]
    #[doc = "* returned or if the parameters are NULL then an assert will happen."]
    #[doc = "* "]
    #[doc = "* \\param handle Handle to service type support"]
    #[doc = "* \\param identifier The typesupport identifier to get the handle function for"]
    #[doc = "* \\return if the identifier match's the handle's identifier then the handle's function"]
    #[doc = "* is returned."]
    #[doc = "* /"]
    pub fn get_service_typesupport_handle_function(
        handle: *const rosidl_service_type_support_t,
        identifier: *const ::std::os::raw::c_char,
    ) -> *const rosidl_service_type_support_t;
}
#[doc = " Internal rcl client implementation struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_client_impl_t {
    _unused: [u8; 0],
}
#[doc = " Structure which encapsulates a ROS Client."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_client_t {
    #[doc = " Pointer to the client implementation"]
    pub impl_: *mut rcl_client_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_client_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_client_t>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_client_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_client_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_client_t))
    );
    fn test_field_impl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_client_t),
                "::",
                stringify!(impl_)
            )
        );
    }
    test_field_impl();
}
#[doc = " Options available for a rcl_client_t."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_client_options_t {
    #[doc = " Middleware quality of service settings for the client."]
    pub qos: rmw_qos_profile_t,
    #[doc = " Custom allocator for the client, used for incidental allocations."]
    #[doc = "* * For default behavior (malloc/free), use: rcl_get_default_allocator() */"]
    pub allocator: rcl_allocator_t,
}
#[test]
fn bindgen_test_layout_rcl_client_options_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_client_options_t>(),
        128usize,
        concat!("Size of: ", stringify!(rcl_client_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_client_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_client_options_t))
    );
    fn test_field_qos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_client_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).qos) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_client_options_t),
                "::",
                stringify!(qos)
            )
        );
    }
    test_field_qos();
    fn test_field_allocator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_client_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_client_options_t),
                "::",
                stringify!(allocator)
            )
        );
    }
    test_field_allocator();
}
extern "C" {
    #[doc = " Return a rcl_client_t struct with members set to `NULL`."]
    #[doc = "* *"]
    #[doc = "* Should be called to get a null rcl_client_t before passing to"]
    #[doc = "* rcl_client_init()."]
    #[doc = "* /"]
    pub fn rcl_get_zero_initialized_client() -> rcl_client_t;
}
extern "C" {
    #[doc = " Initialize a rcl client."]
    #[doc = "* *"]
    #[doc = "* After calling this function on a rcl_client_t, it can be used to send"]
    #[doc = "* requests of the given type by calling rcl_send_request()."]
    #[doc = "* If the request is received by a (possibly remote) service and if the service"]
    #[doc = "* sends a response, the client can access the response through"]
    #[doc = "* rcl_take_response() once the response is available to the client."]
    #[doc = "* "]
    #[doc = "* The given rcl_node_t must be valid and the resulting rcl_client_t is only"]
    #[doc = "* valid as long as the given rcl_node_t remains valid."]
    #[doc = "* "]
    #[doc = "* The rosidl_service_type_support_t is obtained on a per `.srv` type basis."]
    #[doc = "* When the user defines a ROS service, code is generated which provides the"]
    #[doc = "* required rosidl_service_type_support_t object."]
    #[doc = "* This object can be obtained using a language appropriate mechanism."]
    #[doc = "* \\todo TODO(wjwwood) write these instructions once and link to it instead"]
    #[doc = "* "]
    #[doc = "* For C, a macro can be used (for example `example_interfaces/AddTwoInts`):"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* #include <rosidl_runtime_c/service_type_support_struct.h>"]
    #[doc = "* #include <example_interfaces/srv/add_two_ints.h>"]
    #[doc = "* "]
    #[doc = "* const rosidl_service_type_support_t * ts ="]
    #[doc = "* ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* For C++, a template function is used:"]
    #[doc = "* "]
    #[doc = "* ```cpp"]
    #[doc = "* #include <rosidl_typesupport_cpp/service_type_support.hpp>"]
    #[doc = "* #include <example_interfaces/srv/add_two_ints.hpp>"]
    #[doc = "* "]
    #[doc = "* using rosidl_typesupport_cpp::get_service_type_support_handle;"]
    #[doc = "* const rosidl_service_type_support_t * ts ="]
    #[doc = "* get_service_type_support_handle<example_interfaces::srv::AddTwoInts>();"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* The rosidl_service_type_support_t object contains service type specific"]
    #[doc = "* information used to send or take requests and responses."]
    #[doc = "* "]
    #[doc = "* The topic name must be a c string which follows the topic and service name"]
    #[doc = "* format rules for unexpanded names, also known as non-fully qualified names:"]
    #[doc = "* "]
    #[doc = "* \\see rcl_expand_topic_name"]
    #[doc = "* "]
    #[doc = "* The options struct allows the user to set the quality of service settings as"]
    #[doc = "* well as a custom allocator which is used when initializing/finalizing the"]
    #[doc = "* client to allocate space for incidentals, e.g. the service name string."]
    #[doc = "* "]
    #[doc = "* Expected usage (for C services):"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* #include <rcl/rcl.h>"]
    #[doc = "* #include <rosidl_runtime_c/service_type_support_struct.h>"]
    #[doc = "* #include <example_interfaces/srv/add_two_ints.h>"]
    #[doc = "* "]
    #[doc = "* rcl_node_t node = rcl_get_zero_initialized_node();"]
    #[doc = "* rcl_node_options_t node_ops = rcl_node_get_default_options();"]
    #[doc = "* rcl_ret_t ret = rcl_node_init(&node, \"node_name\", \"/my_namespace\", &node_ops);"]
    #[doc = "* // ... error handling"]
    #[doc = "* const rosidl_service_type_support_t * ts ="]
    #[doc = "* ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);"]
    #[doc = "* rcl_client_t client = rcl_get_zero_initialized_client();"]
    #[doc = "* rcl_client_options_t client_ops = rcl_client_get_default_options();"]
    #[doc = "* ret = rcl_client_init(&client, &node, ts, \"add_two_ints\", &client_ops);"]
    #[doc = "* // ... error handling, and on shutdown do finalization:"]
    #[doc = "* ret = rcl_client_fini(&client, &node);"]
    #[doc = "* // ... error handling for rcl_client_fini()"]
    #[doc = "* ret = rcl_node_fini(&node);"]
    #[doc = "* // ... error handling for rcl_node_fini()"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] client preallocated rcl_client_t structure"]
    #[doc = "* \\param[in] node valid rcl_node_t"]
    #[doc = "* \\param[in] type_support type support object for the service's type"]
    #[doc = "* \\param[in] service_name the name of the service to request"]
    #[doc = "* \\param[in] options client options, including quality of service settings"]
    #[doc = "* \\return #RCL_RET_OK if the client was initialized successfully, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID if the node is invalid, or"]
    #[doc = "* \\return #RCL_RET_ALREADY_INIT if the client is already initialized, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory fails, or"]
    #[doc = "* \\return #RCL_RET_SERVICE_NAME_INVALID if the given service name is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_client_init(
        client: *mut rcl_client_t,
        node: *const rcl_node_t,
        type_support: *const rosidl_service_type_support_t,
        service_name: *const ::std::os::raw::c_char,
        options: *const rcl_client_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a rcl_client_t."]
    #[doc = "* *"]
    #[doc = "* After calling this function, calls to rcl_send_request() and"]
    #[doc = "* rcl_take_response() will fail when using this client."]
    #[doc = "* However, the given node handle is still valid."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] client handle to the client to be finalized"]
    #[doc = "* \\param[in] node a valid (not finalized) handle to the node used to create the client"]
    #[doc = "* \\return #RCL_RET_OK if client was finalized successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID if the node is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_client_fini(client: *mut rcl_client_t, node: *mut rcl_node_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the default client options in a rcl_client_options_t."]
    #[doc = "* *"]
    #[doc = "* The defaults are:"]
    #[doc = "* "]
    #[doc = "* - qos = rmw_qos_profile_services_default"]
    #[doc = "* - allocator = rcl_get_default_allocator()"]
    #[doc = "* /"]
    pub fn rcl_client_get_default_options() -> rcl_client_options_t;
}
extern "C" {
    #[doc = " Send a ROS request using a client."]
    #[doc = "* *"]
    #[doc = "* It is the job of the caller to ensure that the type of the `ros_request`"]
    #[doc = "* parameter and the type associate with the client (via the type support)"]
    #[doc = "* match."]
    #[doc = "* Passing a different type to `send_request` produces undefined behavior and"]
    #[doc = "* cannot be checked by this function and therefore no deliberate error will"]
    #[doc = "* occur."]
    #[doc = "* "]
    #[doc = "* rcl_send_request() is an non-blocking call."]
    #[doc = "* "]
    #[doc = "* The ROS request message given by the `ros_request` void pointer is always"]
    #[doc = "* owned by the calling code, but should remain constant during `send_request`."]
    #[doc = "* "]
    #[doc = "* This function is thread safe so long as access to both the client and the"]
    #[doc = "* `ros_request` is synchronized."]
    #[doc = "* That means that calling rcl_send_request() from multiple threads is allowed,"]
    #[doc = "* but calling rcl_send_request() at the same time as non-thread safe client"]
    #[doc = "* functions is not, e.g. calling rcl_send_request() and rcl_client_fini()"]
    #[doc = "* concurrently is not allowed."]
    #[doc = "* Before calling rcl_send_request() the message can change and after calling"]
    #[doc = "* rcl_send_request() the message can change, but it cannot be changed during"]
    #[doc = "* the `send_request` call."]
    #[doc = "* The same `ros_request`, however, can be passed to multiple calls of"]
    #[doc = "* rcl_send_request() simultaneously, even if the clients differ."]
    #[doc = "* The `ros_request` is unmodified by rcl_send_request()."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes [1]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* <i>[1] for unique pairs of clients and requests, see above for more</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] client handle to the client which will make the response"]
    #[doc = "* \\param[in] ros_request type-erased pointer to the ROS request message"]
    #[doc = "* \\param[out] sequence_number the sequence number"]
    #[doc = "* \\return #RCL_RET_OK if the request was sent successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_CLIENT_INVALID if the client is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_send_request(
        client: *const rcl_client_t,
        ros_request: *const ::std::os::raw::c_void,
        sequence_number: *mut i64,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take a ROS response using a client"]
    #[doc = "* *"]
    #[doc = "* It is the job of the caller to ensure that the type of the `ros_response`"]
    #[doc = "* parameter and the type associate with the client (via the type support)"]
    #[doc = "* match."]
    #[doc = "* Passing a different type to take_response produces undefined behavior and"]
    #[doc = "* cannot be checked by this function and therefore no deliberate error will"]
    #[doc = "* occur."]
    #[doc = "* The request_header is an rmw struct for meta-information about the request"]
    #[doc = "* sent (e.g. the sequence number)."]
    #[doc = "* The caller must provide a pointer to an allocated struct."]
    #[doc = "* This function will populate the struct's fields."]
    #[doc = "* `ros_response` should point to an already allocated ROS response message"]
    #[doc = "* struct of the correct type, into which the response from the service will be"]
    #[doc = "* copied."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe [1]"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* <i>[1] only if required when filling the message, avoided for fixed sizes</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] client handle to the client which will take the response"]
    #[doc = "* \\param[inout] request_header pointer to the request header"]
    #[doc = "* \\param[inout] ros_response type-erased pointer to the ROS response message"]
    #[doc = "* \\return #RCL_RET_OK if the response was taken successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_CLIENT_INVALID if the client is invalid, or"]
    #[doc = "* \\return #RCL_RET_CLIENT_TAKE_FAILED if take failed but no error occurred"]
    #[doc = "* in the middleware, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_take_response_with_info(
        client: *const rcl_client_t,
        request_header: *mut rmw_service_info_t,
        ros_response: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " backwards compatibility function that takes a rmw_request_id_t only"]
    pub fn rcl_take_response(
        client: *const rcl_client_t,
        request_header: *mut rmw_request_id_t,
        ros_response: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the name of the service that this client will request a response from."]
    #[doc = "* *"]
    #[doc = "* This function returns the client's internal service name string."]
    #[doc = "* This function can fail, and therefore return `NULL`, if the:"]
    #[doc = "* - client is `NULL`"]
    #[doc = "* - client is invalid (never called init, called fini, or invalid node)"]
    #[doc = "* "]
    #[doc = "* The returned string is only valid as long as the rcl_client_t is valid."]
    #[doc = "* The value of the string may change if the service name changes, and therefore"]
    #[doc = "* copying the string is recommended if this is a concern."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] client pointer to the client"]
    #[doc = "* \\return name string if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_client_get_service_name(
        client: *const rcl_client_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the rcl client options."]
    #[doc = "* *"]
    #[doc = "* This function returns the client's internal options struct."]
    #[doc = "* This function can fail, and therefore return `NULL`, if the:"]
    #[doc = "* - client is `NULL`"]
    #[doc = "* - client is invalid (never called init, called fini, or invalid node)"]
    #[doc = "* "]
    #[doc = "* The returned struct is only valid as long as the rcl_client_t is valid."]
    #[doc = "* The values in the struct may change if the options of the client change,"]
    #[doc = "* and therefore copying the struct is recommended if this is a concern."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] client pointer to the client"]
    #[doc = "* \\return options struct if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_client_get_options(client: *const rcl_client_t) -> *const rcl_client_options_t;
}
extern "C" {
    #[doc = " Return the rmw client handle."]
    #[doc = "* *"]
    #[doc = "* The handle returned is a pointer to the internally held rmw handle."]
    #[doc = "* This function can fail, and therefore return `NULL`, if the:"]
    #[doc = "* - client is `NULL`"]
    #[doc = "* - client is invalid (never called init, called fini, or invalid node)"]
    #[doc = "* "]
    #[doc = "* The returned handle is made invalid if the client is finalized or if"]
    #[doc = "* rcl_shutdown() is called."]
    #[doc = "* The returned handle is not guaranteed to be valid for the life time of the"]
    #[doc = "* client as it may be finalized and recreated itself."]
    #[doc = "* Therefore it is recommended to get the handle from the client using"]
    #[doc = "* this function each time it is needed and avoid use of the handle"]
    #[doc = "* concurrently with functions that might change it."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] client pointer to the rcl client"]
    #[doc = "* \\return rmw client handle if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_client_get_rmw_handle(client: *const rcl_client_t) -> *mut rmw_client_t;
}
extern "C" {
    #[doc = " Check that the client is valid."]
    #[doc = "* *"]
    #[doc = "* The bool returned is `false` if client is invalid."]
    #[doc = "* The bool returned is `true` otherwise."]
    #[doc = "* In the case where `false` is to be returned, an error message is set."]
    #[doc = "* This function cannot fail."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] client pointer to the rcl client"]
    #[doc = "* \\return `true` if `client` is valid, otherwise `false`"]
    #[doc = "* /"]
    pub fn rcl_client_is_valid(client: *const rcl_client_t) -> bool;
}
#[doc = " Internal rcl guard condition implementation struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_guard_condition_impl_t {
    _unused: [u8; 0],
}
#[doc = " Handle for a rcl guard condition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_guard_condition_t {
    #[doc = " Context associated with this guard condition."]
    pub context: *mut rcl_context_t,
    #[doc = " Pointer to the guard condition implementation"]
    pub impl_: *mut rcl_guard_condition_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_guard_condition_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_guard_condition_t>(),
        16usize,
        concat!("Size of: ", stringify!(rcl_guard_condition_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_guard_condition_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_guard_condition_t))
    );
    fn test_field_context() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_guard_condition_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_guard_condition_t),
                "::",
                stringify!(context)
            )
        );
    }
    test_field_context();
    fn test_field_impl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_guard_condition_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_guard_condition_t),
                "::",
                stringify!(impl_)
            )
        );
    }
    test_field_impl();
}
#[doc = " Options available for a rcl guard condition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_guard_condition_options_t {
    #[doc = " Custom allocator for the guard condition, used for internal allocations."]
    pub allocator: rcl_allocator_t,
}
#[test]
fn bindgen_test_layout_rcl_guard_condition_options_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_guard_condition_options_t>(),
        40usize,
        concat!("Size of: ", stringify!(rcl_guard_condition_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_guard_condition_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_guard_condition_options_t))
    );
    fn test_field_allocator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_guard_condition_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_guard_condition_options_t),
                "::",
                stringify!(allocator)
            )
        );
    }
    test_field_allocator();
}
extern "C" {
    #[doc = " Return a rcl_guard_condition_t struct with members set to `NULL`."]
    pub fn rcl_get_zero_initialized_guard_condition() -> rcl_guard_condition_t;
}
extern "C" {
    #[doc = " Initialize a rcl guard_condition."]
    #[doc = "* *"]
    #[doc = "* After calling this function on a rcl_guard_condition_t, it can be passed to"]
    #[doc = "* rcl_wait() and then concurrently it can be triggered to wake-up rcl_wait()."]
    #[doc = "* "]
    #[doc = "* Expected usage:"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* #include <rcl/rcl.h>"]
    #[doc = "* "]
    #[doc = "* // ... error handling"]
    #[doc = "* rcl_guard_condition_t guard_condition = rcl_get_zero_initialized_guard_condition();"]
    #[doc = "* // ... customize guard condition options"]
    #[doc = "* rcl_ret_t ret = rcl_guard_condition_init("]
    #[doc = "* &guard_condition, context, rcl_guard_condition_get_default_options());"]
    #[doc = "* // ... error handling, and on shutdown do deinitialization:"]
    #[doc = "* ret = rcl_guard_condition_fini(&guard_condition);"]
    #[doc = "* // ... error handling for rcl_guard_condition_fini()"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] guard_condition preallocated guard_condition structure"]
    #[doc = "* \\param[in] context the context instance with which the guard condition"]
    #[doc = "* should be associated"]
    #[doc = "* \\param[in] options the guard_condition's options"]
    #[doc = "* \\return #RCL_RET_OK if guard_condition was initialized successfully, or"]
    #[doc = "* \\return #RCL_RET_ALREADY_INIT if the guard condition is already initialized, or"]
    #[doc = "* \\return #RCL_RET_NOT_INIT if the given context is invalid, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_guard_condition_init(
        guard_condition: *mut rcl_guard_condition_t,
        context: *mut rcl_context_t,
        options: rcl_guard_condition_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Same as rcl_guard_condition_init(), but reusing an existing rmw handle."]
    #[doc = "* *"]
    #[doc = "* In addition to the documentation for rcl_guard_condition_init(), the"]
    #[doc = "* `rmw_guard_condition` parameter must not be `NULL` and must point to a valid"]
    #[doc = "* rmw guard condition."]
    #[doc = "* "]
    #[doc = "* Also the life time of the rcl guard condition is tied to the life time of"]
    #[doc = "* the rmw guard condition."]
    #[doc = "* So if the rmw guard condition is destroyed before the rcl guard condition,"]
    #[doc = "* the rcl guard condition becomes invalid."]
    #[doc = "* "]
    #[doc = "* Similarly if the resulting rcl guard condition is fini'ed before the rmw"]
    #[doc = "* guard condition, then the rmw guard condition is no longer valid."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] guard_condition preallocated guard_condition structure"]
    #[doc = "* \\param[in] rmw_guard_condition existing rmw guard condition to reuse"]
    #[doc = "* \\param[in] context the context instance with which the rmw guard condition"]
    #[doc = "* was initialized with, i.e. the rmw context inside rcl context needs to"]
    #[doc = "* match rmw context in rmw guard condition"]
    #[doc = "* \\param[in] options the guard_condition's options"]
    #[doc = "* \\return #RCL_RET_OK if guard_condition was initialized successfully, or"]
    #[doc = "* \\return #RCL_RET_ALREADY_INIT if the guard condition is already initialized, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_guard_condition_init_from_rmw(
        guard_condition: *mut rcl_guard_condition_t,
        rmw_guard_condition: *const rmw_guard_condition_t,
        context: *mut rcl_context_t,
        options: rcl_guard_condition_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a rcl_guard_condition_t."]
    #[doc = "* *"]
    #[doc = "* After calling, calls to rcl_trigger_guard_condition() will fail when using"]
    #[doc = "* this guard condition."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No [1]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* <i>[1] specifically not thread-safe with rcl_trigger_guard_condition()</i>"]
    #[doc = "* "]
    #[doc = "* \\param[inout] guard_condition handle to the guard_condition to be finalized"]
    #[doc = "* \\return #RCL_RET_OK if guard_condition was finalized successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_guard_condition_fini(guard_condition: *mut rcl_guard_condition_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the default options in a rcl_guard_condition_options_t struct."]
    #[doc = "* *"]
    #[doc = "* The defaults are:"]
    #[doc = "* "]
    #[doc = "* - allocator = rcl_get_default_allocator()"]
    #[doc = "* "]
    #[doc = "* \\return the default options in an rcl_guard_condition_options_t struct."]
    #[doc = "* /"]
    pub fn rcl_guard_condition_get_default_options() -> rcl_guard_condition_options_t;
}
extern "C" {
    #[doc = " Trigger a rcl guard condition."]
    #[doc = "* *"]
    #[doc = "* This function can fail, and return RCL_RET_INVALID_ARGUMENT, if the:"]
    #[doc = "* - guard condition is `NULL`"]
    #[doc = "* - guard condition is invalid (never called init or called fini)"]
    #[doc = "* "]
    #[doc = "* A guard condition can be triggered from any thread."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No [1]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* <i>[1] it can be called concurrently with itself, even on the same guard condition</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] guard_condition handle to the guard_condition to be triggered"]
    #[doc = "* \\return #RCL_RET_OK if the guard condition was triggered, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_trigger_guard_condition(guard_condition: *mut rcl_guard_condition_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the guard condition options."]
    #[doc = "* *"]
    #[doc = "* Returned is a pointer to the internally held rcl_guard_condition_options_t."]
    #[doc = "* This function can fail, and therefore return `NULL`, if the:"]
    #[doc = "* - guard_condition is `NULL`"]
    #[doc = "* - guard_condition is invalid (never called init, called fini, or invalid node)"]
    #[doc = "* "]
    #[doc = "* The returned pointer is made invalid if the guard condition is finalized."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] guard_condition pointer to the rcl guard_condition"]
    #[doc = "* \\return rcl guard condition options if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_guard_condition_get_options(
        guard_condition: *const rcl_guard_condition_t,
    ) -> *const rcl_guard_condition_options_t;
}
extern "C" {
    #[doc = " Return the rmw guard condition handle."]
    #[doc = "* *"]
    #[doc = "* The handle returned is a pointer to the internally held rmw handle."]
    #[doc = "* This function can fail, and therefore return `NULL`, if the:"]
    #[doc = "* - guard_condition is `NULL`"]
    #[doc = "* - guard_condition is invalid (never called init, called fini, or invalid node)"]
    #[doc = "* "]
    #[doc = "* The returned handle is made invalid if the guard condition is finalized or"]
    #[doc = "* if rcl_shutdown() is called."]
    #[doc = "* The returned handle is not guaranteed to be valid for the life time of the"]
    #[doc = "* guard condition as it may be finalized and recreated itself."]
    #[doc = "* Therefore it is recommended to get the handle from the guard condition using"]
    #[doc = "* this function each time it is needed and avoid use of the handle"]
    #[doc = "* concurrently with functions that might change it."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] guard_condition pointer to the rcl guard_condition"]
    #[doc = "* \\return rmw guard condition handle if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_guard_condition_get_rmw_handle(
        guard_condition: *const rcl_guard_condition_t,
    ) -> *mut rmw_guard_condition_t;
}
#[doc = " Internal rcl implementation struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_service_impl_t {
    _unused: [u8; 0],
}
#[doc = " Structure which encapsulates a ROS Service."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_service_t {
    #[doc = " Pointer to the service implementation"]
    pub impl_: *mut rcl_service_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_service_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_service_t>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_service_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_service_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_service_t))
    );
    fn test_field_impl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_service_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_service_t),
                "::",
                stringify!(impl_)
            )
        );
    }
    test_field_impl();
}
#[doc = " Options available for a rcl service."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_service_options_t {
    #[doc = " Middleware quality of service settings for the service."]
    pub qos: rmw_qos_profile_t,
    #[doc = " Custom allocator for the service, used for incidental allocations."]
    #[doc = "* * For default behavior (malloc/free), see: rcl_get_default_allocator() */"]
    pub allocator: rcl_allocator_t,
}
#[test]
fn bindgen_test_layout_rcl_service_options_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_service_options_t>(),
        128usize,
        concat!("Size of: ", stringify!(rcl_service_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_service_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_service_options_t))
    );
    fn test_field_qos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_service_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).qos) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_service_options_t),
                "::",
                stringify!(qos)
            )
        );
    }
    test_field_qos();
    fn test_field_allocator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_service_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_service_options_t),
                "::",
                stringify!(allocator)
            )
        );
    }
    test_field_allocator();
}
extern "C" {
    #[doc = " Return a rcl_service_t struct with members set to `NULL`."]
    #[doc = "* *"]
    #[doc = "* Should be called to get a null rcl_service_t before passing to"]
    #[doc = "* rcl_service_init()."]
    #[doc = "* "]
    #[doc = "* \\return A structure with a zero initialized service."]
    #[doc = "* /"]
    pub fn rcl_get_zero_initialized_service() -> rcl_service_t;
}
extern "C" {
    #[doc = " Initialize a rcl service."]
    #[doc = "* *"]
    #[doc = "* After calling this function on a rcl_service_t, it can be used to take"]
    #[doc = "* requests of the given type to the given topic using rcl_take_request()."]
    #[doc = "* It can also send a response to a request using rcl_send_response()."]
    #[doc = "* "]
    #[doc = "* The given rcl_node_t must be valid and the resulting rcl_service_t is"]
    #[doc = "* only valid as long as the given rcl_node_t remains valid."]
    #[doc = "* "]
    #[doc = "* The rosidl_service_type_support_t is obtained on a per .srv type basis."]
    #[doc = "* When the user defines a ROS service, code is generated which provides the"]
    #[doc = "* required rosidl_service_type_support_t object."]
    #[doc = "* This object can be obtained using a language appropriate mechanism."]
    #[doc = "* \\todo TODO(wjwwood) write these instructions once and link to it instead"]
    #[doc = "* "]
    #[doc = "* For C, a macro can be used (for example `example_interfaces/AddTwoInts`):"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* #include <rosidl_runtime_c/service_type_support_struct.h>"]
    #[doc = "* #include <example_interfaces/srv/add_two_ints.h>"]
    #[doc = "* const rosidl_service_type_support_t * ts ="]
    #[doc = "* ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* For C++, a template function is used:"]
    #[doc = "* "]
    #[doc = "* ```cpp"]
    #[doc = "* #include <rosidl_runtime_cpp/service_type_support.hpp>"]
    #[doc = "* #include <example_interfaces/srv/add_two_ints.h>"]
    #[doc = "* using rosidl_typesupport_cpp::get_service_type_support_handle;"]
    #[doc = "* const rosidl_service_type_support_t * ts ="]
    #[doc = "* get_service_type_support_handle<example_interfaces::srv::AddTwoInts>();"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* The rosidl_service_type_support_t object contains service type specific"]
    #[doc = "* information used to send or take requests and responses."]
    #[doc = "* "]
    #[doc = "* The topic name must be a c string which follows the topic and service name"]
    #[doc = "* format rules for unexpanded names, also known as non-fully qualified names:"]
    #[doc = "* "]
    #[doc = "* \\see rcl_expand_topic_name"]
    #[doc = "* "]
    #[doc = "* The options struct allows the user to set the quality of service settings as"]
    #[doc = "* well as a custom allocator which is used when initializing/finalizing the"]
    #[doc = "* client to allocate space for incidentals, e.g. the service name string."]
    #[doc = "* "]
    #[doc = "* Expected usage (for C services):"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* #include <rcl/rcl.h>"]
    #[doc = "* #include <rosidl_runtime_c/service_type_support_struct.h>"]
    #[doc = "* #include <example_interfaces/srv/add_two_ints.h>"]
    #[doc = "* "]
    #[doc = "* rcl_node_t node = rcl_get_zero_initialized_node();"]
    #[doc = "* rcl_node_options_t node_ops = rcl_node_get_default_options();"]
    #[doc = "* rcl_ret_t ret = rcl_node_init(&node, \"node_name\", \"/my_namespace\", &node_ops);"]
    #[doc = "* // ... error handling"]
    #[doc = "* const rosidl_service_type_support_t * ts ="]
    #[doc = "* ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);"]
    #[doc = "* rcl_service_t service = rcl_get_zero_initialized_service();"]
    #[doc = "* rcl_service_options_t service_ops = rcl_service_get_default_options();"]
    #[doc = "* ret = rcl_service_init(&service, &node, ts, \"add_two_ints\", &service_ops);"]
    #[doc = "* // ... error handling, and on shutdown do finalization:"]
    #[doc = "* ret = rcl_service_fini(&service, &node);"]
    #[doc = "* // ... error handling for rcl_service_fini()"]
    #[doc = "* ret = rcl_node_fini(&node);"]
    #[doc = "* // ... error handling for rcl_node_fini()"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[out] service preallocated service structure"]
    #[doc = "* \\param[in] node valid rcl node handle"]
    #[doc = "* \\param[in] type_support type support object for the service's type"]
    #[doc = "* \\param[in] service_name the name of the service"]
    #[doc = "* \\param[in] options service options, including quality of service settings"]
    #[doc = "* \\return #RCL_RET_OK if service was initialized successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ALREADY_INIT if the service is already initialized, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID if the node is invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_SERVICE_NAME_INVALID if the given service name is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_service_init(
        service: *mut rcl_service_t,
        node: *const rcl_node_t,
        type_support: *const rosidl_service_type_support_t,
        service_name: *const ::std::os::raw::c_char,
        options: *const rcl_service_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a rcl_service_t."]
    #[doc = "* *"]
    #[doc = "* After calling, the node will no longer listen for requests for this service."]
    #[doc = "* (assuming this is the only service of this type in this node)."]
    #[doc = "* "]
    #[doc = "* After calling, calls to rcl_wait(), rcl_take_request(), and"]
    #[doc = "* rcl_send_response() will fail when using this service."]
    #[doc = "* Additionally rcl_wait() will be interrupted if currently blocking."]
    #[doc = "* However, the given node handle is still valid."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] service handle to the service to be deinitialized"]
    #[doc = "* \\param[in] node a valid (not finalized) handle to the node used to create the service"]
    #[doc = "* \\return #RCL_RET_OK if service was deinitialized successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_SERVICE_INVALID if the service is invalid, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID if the node is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_service_fini(service: *mut rcl_service_t, node: *mut rcl_node_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the default service options in a rcl_service_options_t."]
    #[doc = "* *"]
    #[doc = "* The defaults are:"]
    #[doc = "* "]
    #[doc = "* - qos = rmw_qos_profile_services_default"]
    #[doc = "* - allocator = rcl_get_default_allocator()"]
    #[doc = "* /"]
    pub fn rcl_service_get_default_options() -> rcl_service_options_t;
}
extern "C" {
    #[doc = " Take a pending ROS request using a rcl service."]
    #[doc = "* *"]
    #[doc = "* It is the job of the caller to ensure that the type of the ros_request"]
    #[doc = "* argument and the type associate with the service, via the type"]
    #[doc = "* support, match."]
    #[doc = "* Passing a different type to rcl_take produces undefined behavior and cannot"]
    #[doc = "* be checked by this function and therefore no deliberate error will occur."]
    #[doc = "* "]
    #[doc = "* TODO(jacquelinekay) blocking of take?"]
    #[doc = "* TODO(jacquelinekay) pre-, during-, and post-conditions for message ownership?"]
    #[doc = "* TODO(jacquelinekay) is rcl_take_request thread-safe?"]
    #[doc = "* TODO(jacquelinekay) Should there be an rcl_request_id_t?"]
    #[doc = "* "]
    #[doc = "* The ros_request pointer should point to an already allocated ROS request message"]
    #[doc = "* struct of the correct type, into which the taken ROS request will be copied"]
    #[doc = "* if one is available."]
    #[doc = "* If taken is false after calling, then the ROS request will be unmodified."]
    #[doc = "* "]
    #[doc = "* If allocation is required when taking the request, e.g. if space needs to"]
    #[doc = "* be allocated for a dynamically sized array in the target message, then the"]
    #[doc = "* allocator given in the service options is used."]
    #[doc = "* "]
    #[doc = "* request_header is a pointer to pre-allocated a rmw struct containing"]
    #[doc = "* meta-information about the request (e.g. the sequence number)."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe [1]"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* <i>[1] only if required when filling the request, avoided for fixed sizes</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] service the handle to the service from which to take"]
    #[doc = "* \\param[inout] request_header ptr to the struct holding metadata about the request"]
    #[doc = "* \\param[inout] ros_request type-erased ptr to an allocated ROS request message"]
    #[doc = "* \\return #RCL_RET_OK if the request was taken, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_SERVICE_INVALID if the service is invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_SERVICE_TAKE_FAILED if take failed but no error occurred"]
    #[doc = "* in the middleware, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_take_request_with_info(
        service: *const rcl_service_t,
        request_header: *mut rmw_service_info_t,
        ros_request: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Backwards compatibility function to take a pending ROS request using a rcl service."]
    #[doc = "* *"]
    #[doc = "* This version takes a request ID only.  See rcl_take_request_with_info() for a full"]
    #[doc = "* explanation of what this does."]
    #[doc = "* "]
    #[doc = "* \\param[in] service the handle to the service from which to take"]
    #[doc = "* \\param[inout] request_header ptr to the struct holding the id of the request"]
    #[doc = "* \\param[inout] ros_request type-erased ptr to an allocated ROS request message"]
    #[doc = "* \\return #RCL_RET_OK if the request was taken, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_SERVICE_INVALID if the service is invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_SERVICE_TAKE_FAILED if take failed but no error occurred"]
    #[doc = "* in the middleware, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_take_request(
        service: *const rcl_service_t,
        request_header: *mut rmw_request_id_t,
        ros_request: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Send a ROS response to a client using a service."]
    #[doc = "* *"]
    #[doc = "* It is the job of the caller to ensure that the type of the `ros_response`"]
    #[doc = "* parameter and the type associate with the service (via the type support)"]
    #[doc = "* match."]
    #[doc = "* Passing a different type to send_response produces undefined behavior and"]
    #[doc = "* cannot be checked by this function and therefore no deliberate error will"]
    #[doc = "* occur."]
    #[doc = "* "]
    #[doc = "* send_response() is an non-blocking call."]
    #[doc = "* "]
    #[doc = "* The ROS response message given by the `ros_response` void pointer is always"]
    #[doc = "* owned by the calling code, but should remain constant during"]
    #[doc = "* rcl_send_response()."]
    #[doc = "* "]
    #[doc = "* This function is thread safe so long as access to both the service and the"]
    #[doc = "* `ros_response` is synchronized."]
    #[doc = "* That means that calling rcl_send_response() from multiple threads is"]
    #[doc = "* allowed, but calling rcl_send_response() at the same time as non-thread safe"]
    #[doc = "* service functions is not, e.g. calling rcl_send_response() and"]
    #[doc = "* rcl_service_fini() concurrently is not allowed."]
    #[doc = "* Before calling rcl_send_response() the message can change and after calling"]
    #[doc = "* rcl_send_response() the message can change, but it cannot be changed during"]
    #[doc = "* the rcl_send_response() call."]
    #[doc = "* The same `ros_response`, however, can be passed to multiple calls of"]
    #[doc = "* rcl_send_response() simultaneously, even if the services differ."]
    #[doc = "* The `ros_response` is unmodified by rcl_send_response()."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes [1]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* <i>[1] for unique pairs of services and responses, see above for more</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] service handle to the service which will make the response"]
    #[doc = "* \\param[inout] response_header ptr to the struct holding metadata about the request ID"]
    #[doc = "* \\param[in] ros_response type-erased pointer to the ROS response message"]
    #[doc = "* \\return #RCL_RET_OK if the response was sent successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_SERVICE_INVALID if the service is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_send_response(
        service: *const rcl_service_t,
        response_header: *mut rmw_request_id_t,
        ros_response: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the topic name for the service."]
    #[doc = "* *"]
    #[doc = "* This function returns the service's internal topic name string."]
    #[doc = "* This function can fail, and therefore return `NULL`, if the:"]
    #[doc = "* - service is `NULL`"]
    #[doc = "* - service is invalid (never called init, called fini, or invalid)"]
    #[doc = "* "]
    #[doc = "* The returned string is only valid as long as the service is valid."]
    #[doc = "* The value of the string may change if the topic name changes, and therefore"]
    #[doc = "* copying the string is recommended if this is a concern."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] service the pointer to the service"]
    #[doc = "* \\return name string if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_service_get_service_name(
        service: *const rcl_service_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the rcl service options."]
    #[doc = "* *"]
    #[doc = "* This function returns the service's internal options struct."]
    #[doc = "* This function can fail, and therefore return `NULL`, if the:"]
    #[doc = "* - service is `NULL`"]
    #[doc = "* - service is invalid (never called init, called fini, or invalid)"]
    #[doc = "* "]
    #[doc = "* The returned struct is only valid as long as the service is valid."]
    #[doc = "* The values in the struct may change if the service's options change,"]
    #[doc = "* and therefore copying the struct is recommended if this is a concern."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] service pointer to the service"]
    #[doc = "* \\return options struct if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_service_get_options(service: *const rcl_service_t) -> *const rcl_service_options_t;
}
extern "C" {
    #[doc = " Return the rmw service handle."]
    #[doc = "* *"]
    #[doc = "* The handle returned is a pointer to the internally held rmw handle."]
    #[doc = "* This function can fail, and therefore return `NULL`, if the:"]
    #[doc = "* - service is `NULL`"]
    #[doc = "* - service is invalid (never called init, called fini, or invalid)"]
    #[doc = "* "]
    #[doc = "* The returned handle is made invalid if the service is finalized or if"]
    #[doc = "* rcl_shutdown() is called."]
    #[doc = "* The returned handle is not guaranteed to be valid for the life time of the"]
    #[doc = "* service as it may be finalized and recreated itself."]
    #[doc = "* Therefore it is recommended to get the handle from the service using"]
    #[doc = "* this function each time it is needed and avoid use of the handle"]
    #[doc = "* concurrently with functions that might change it."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] service pointer to the rcl service"]
    #[doc = "* \\return rmw service handle if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_service_get_rmw_handle(service: *const rcl_service_t) -> *mut rmw_service_t;
}
extern "C" {
    #[doc = " Check that the service is valid."]
    #[doc = "* *"]
    #[doc = "* The bool returned is `false` if `service` is invalid."]
    #[doc = "* The bool returned is `true` otherwise."]
    #[doc = "* In the case where `false` is to be returned, an error message is set."]
    #[doc = "* This function cannot fail."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] service pointer to the rcl service"]
    #[doc = "* \\return `true` if `service` is valid, otherwise `false`"]
    #[doc = "* /"]
    pub fn rcl_service_is_valid(service: *const rcl_service_t) -> bool;
}
#[doc = " A single point in time, measured in nanoseconds since the Unix epoch."]
pub type rcl_time_point_value_t = rcutils_time_point_value_t;
#[doc = " A duration of time, measured in nanoseconds."]
pub type rcl_duration_value_t = rcutils_duration_value_t;
#[doc = " Clock uninitialized"]
pub const rcl_clock_type_t_RCL_CLOCK_UNINITIALIZED: rcl_clock_type_t = 0;
#[doc = " Use ROS time"]
pub const rcl_clock_type_t_RCL_ROS_TIME: rcl_clock_type_t = 1;
#[doc = " Use system time"]
pub const rcl_clock_type_t_RCL_SYSTEM_TIME: rcl_clock_type_t = 2;
#[doc = " Use a steady clock time"]
pub const rcl_clock_type_t_RCL_STEADY_TIME: rcl_clock_type_t = 3;
#[doc = " Time source type, used to indicate the source of a time measurement."]
#[doc = "* *"]
#[doc = "* RCL_ROS_TIME will report the latest value reported by a ROS time source, or"]
#[doc = "* if a ROS time source is not active it reports the same as RCL_SYSTEM_TIME."]
#[doc = "* For more information about ROS time sources, refer to the design document:"]
#[doc = "* http://design.ros2.org/articles/clock_and_time.html"]
#[doc = "* "]
#[doc = "* RCL_SYSTEM_TIME reports the same value as the system clock."]
#[doc = "* "]
#[doc = "* RCL_STEADY_TIME reports a value from a monotonically increasing clock."]
#[doc = "* /"]
pub type rcl_clock_type_t = ::std::os::raw::c_uint;
#[doc = " A duration of time, measured in nanoseconds and its source."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_duration_t {
    #[doc = " Duration in nanoseconds and its source."]
    pub nanoseconds: rcl_duration_value_t,
}
#[test]
fn bindgen_test_layout_rcl_duration_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_duration_t>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_duration_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_duration_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_duration_t))
    );
    fn test_field_nanoseconds() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_duration_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nanoseconds) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_duration_t),
                "::",
                stringify!(nanoseconds)
            )
        );
    }
    test_field_nanoseconds();
}
#[doc = " The source before and after the jump is ROS_TIME."]
pub const rcl_clock_change_t_RCL_ROS_TIME_NO_CHANGE: rcl_clock_change_t = 1;
#[doc = " The source switched to ROS_TIME from SYSTEM_TIME."]
pub const rcl_clock_change_t_RCL_ROS_TIME_ACTIVATED: rcl_clock_change_t = 2;
#[doc = " The source switched to SYSTEM_TIME from ROS_TIME."]
pub const rcl_clock_change_t_RCL_ROS_TIME_DEACTIVATED: rcl_clock_change_t = 3;
#[doc = " The source before and after the jump is SYSTEM_TIME."]
pub const rcl_clock_change_t_RCL_SYSTEM_TIME_NO_CHANGE: rcl_clock_change_t = 4;
#[doc = " Enumeration to describe the type of time jump."]
pub type rcl_clock_change_t = ::std::os::raw::c_uint;
#[doc = " Struct to describe a jump in time."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_time_jump_t {
    #[doc = " Indicate whether or not the source of time changed."]
    pub clock_change: rcl_clock_change_t,
    #[doc = " The new time minus the last time before the jump."]
    pub delta: rcl_duration_t,
}
#[test]
fn bindgen_test_layout_rcl_time_jump_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_time_jump_t>(),
        16usize,
        concat!("Size of: ", stringify!(rcl_time_jump_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_time_jump_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_time_jump_t))
    );
    fn test_field_clock_change() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_time_jump_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clock_change) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_time_jump_t),
                "::",
                stringify!(clock_change)
            )
        );
    }
    test_field_clock_change();
    fn test_field_delta() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_time_jump_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).delta) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_time_jump_t),
                "::",
                stringify!(delta)
            )
        );
    }
    test_field_delta();
}
#[doc = " Signature of a time jump callback."]
#[doc = " \\param[in] time_jump A description of the jump in time."]
#[doc = " \\param[in] before_jump Every jump callback is called twice: once before the clock changes and"]
#[doc = " once after. This is true the first call and false the second."]
#[doc = " \\param[in] user_data A pointer given at callback registration which is passed to the callback."]
pub type rcl_jump_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        time_jump: *const rcl_time_jump_t,
        before_jump: bool,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Describe the prerequisites for calling a time jump callback."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_jump_threshold_t {
    #[doc = " True to call callback when the clock type changes."]
    pub on_clock_change: bool,
    #[doc = " A positive duration indicating the minimum jump forwards to be considered exceeded, or zero"]
    #[doc = " to disable."]
    pub min_forward: rcl_duration_t,
    #[doc = " A negative duration indicating the minimum jump backwards to be considered exceeded, or zero"]
    #[doc = " to disable."]
    pub min_backward: rcl_duration_t,
}
#[test]
fn bindgen_test_layout_rcl_jump_threshold_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_jump_threshold_t>(),
        24usize,
        concat!("Size of: ", stringify!(rcl_jump_threshold_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_jump_threshold_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_jump_threshold_t))
    );
    fn test_field_on_clock_change() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_jump_threshold_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_clock_change) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_jump_threshold_t),
                "::",
                stringify!(on_clock_change)
            )
        );
    }
    test_field_on_clock_change();
    fn test_field_min_forward() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_jump_threshold_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).min_forward) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_jump_threshold_t),
                "::",
                stringify!(min_forward)
            )
        );
    }
    test_field_min_forward();
    fn test_field_min_backward() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_jump_threshold_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).min_backward) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_jump_threshold_t),
                "::",
                stringify!(min_backward)
            )
        );
    }
    test_field_min_backward();
}
#[doc = " Struct to describe an added callback."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_jump_callback_info_t {
    #[doc = " Callback to fucntion."]
    pub callback: rcl_jump_callback_t,
    #[doc = " Threshold to decide when to call the callback."]
    pub threshold: rcl_jump_threshold_t,
    #[doc = " Pointer passed to the callback."]
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rcl_jump_callback_info_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_jump_callback_info_t>(),
        40usize,
        concat!("Size of: ", stringify!(rcl_jump_callback_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_jump_callback_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_jump_callback_info_t))
    );
    fn test_field_callback() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_jump_callback_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_jump_callback_info_t),
                "::",
                stringify!(callback)
            )
        );
    }
    test_field_callback();
    fn test_field_threshold() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_jump_callback_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).threshold) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_jump_callback_info_t),
                "::",
                stringify!(threshold)
            )
        );
    }
    test_field_threshold();
    fn test_field_user_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_jump_callback_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_jump_callback_info_t),
                "::",
                stringify!(user_data)
            )
        );
    }
    test_field_user_data();
}
#[doc = " Encapsulation of a time source."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_clock_t {
    #[doc = " Clock type"]
    pub type_: rcl_clock_type_t,
    #[doc = " An array of added jump callbacks."]
    pub jump_callbacks: *mut rcl_jump_callback_info_t,
    #[doc = " Number of callbacks in jump_callbacks."]
    pub num_jump_callbacks: size_t,
    #[doc = " Pointer to get_now function"]
    pub get_now: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            now: *mut rcl_time_point_value_t,
        ) -> rcl_ret_t,
    >,
    #[doc = " Clock storage"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " Custom allocator used for internal allocations."]
    pub allocator: rcl_allocator_t,
}
#[test]
fn bindgen_test_layout_rcl_clock_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_clock_t>(),
        80usize,
        concat!("Size of: ", stringify!(rcl_clock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_clock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_clock_t))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_clock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_clock_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_jump_callbacks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_clock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).jump_callbacks) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_clock_t),
                "::",
                stringify!(jump_callbacks)
            )
        );
    }
    test_field_jump_callbacks();
    fn test_field_num_jump_callbacks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_clock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_jump_callbacks) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_clock_t),
                "::",
                stringify!(num_jump_callbacks)
            )
        );
    }
    test_field_num_jump_callbacks();
    fn test_field_get_now() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_clock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_now) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_clock_t),
                "::",
                stringify!(get_now)
            )
        );
    }
    test_field_get_now();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_clock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_clock_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_allocator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_clock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_clock_t),
                "::",
                stringify!(allocator)
            )
        );
    }
    test_field_allocator();
}
#[doc = " A single point in time, measured in nanoseconds, the reference point is based on the source."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_time_point_t {
    #[doc = " Nanoseconds of the point in time"]
    pub nanoseconds: rcl_time_point_value_t,
    #[doc = " Clock type of the point in time"]
    pub clock_type: rcl_clock_type_t,
}
#[test]
fn bindgen_test_layout_rcl_time_point_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_time_point_t>(),
        16usize,
        concat!("Size of: ", stringify!(rcl_time_point_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_time_point_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_time_point_t))
    );
    fn test_field_nanoseconds() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_time_point_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nanoseconds) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_time_point_t),
                "::",
                stringify!(nanoseconds)
            )
        );
    }
    test_field_nanoseconds();
    fn test_field_clock_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_time_point_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clock_type) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_time_point_t),
                "::",
                stringify!(clock_type)
            )
        );
    }
    test_field_clock_type();
}
extern "C" {
    #[doc = " Check if the clock has valid values."]
    #[doc = "* *"]
    #[doc = "* This function returns true if the time source appears to be valid."]
    #[doc = "* It will check that the type is not uninitialized, and that pointers"]
    #[doc = "* are not invalid."]
    #[doc = "* Note that if data is uninitialized it may give a false positive."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] clock the handle to the clock which is being queried"]
    #[doc = "* \\return true if the source is believed to be valid, otherwise return false."]
    #[doc = "* /"]
    pub fn rcl_clock_valid(clock: *mut rcl_clock_t) -> bool;
}
extern "C" {
    #[doc = " Initialize a clock based on the passed type."]
    #[doc = "* *"]
    #[doc = "* This will allocate all necessary internal structures, and initialize variables."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes [1]"]
    #[doc = "* Thread-Safe        | No [2]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* <i>[1] If `clock_type` is #RCL_ROS_TIME</i>"]
    #[doc = "* <i>[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe."]
    #[doc = "* Thread-safety is also affected by that of the `allocator` object.</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] clock_type the type identifying the time source to provide"]
    #[doc = "* \\param[in] clock the handle to the clock which is being initialized"]
    #[doc = "* \\param[in] allocator The allocator to use for allocations"]
    #[doc = "* \\return #RCL_RET_OK if the time source was successfully initialized, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_clock_init(
        clock_type: rcl_clock_type_t,
        clock: *mut rcl_clock_t,
        allocator: *mut rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a clock."]
    #[doc = "* *"]
    #[doc = "* This will deallocate all necessary internal structures, and clean up any variables."]
    #[doc = "* It can be combined with any of the init functions."]
    #[doc = "* "]
    #[doc = "* Passing a clock with type #RCL_CLOCK_UNINITIALIZED will result in"]
    #[doc = "* #RCL_RET_INVALID_ARGUMENT being returned."]
    #[doc = "* "]
    #[doc = "* This function is not thread-safe with any other function operating on the same"]
    #[doc = "* clock object."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No [1]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe."]
    #[doc = "* Thread-safety is also affected by that of the `allocator` object associated with the"]
    #[doc = "* `clock` object.</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] clock the handle to the clock which is being finalized"]
    #[doc = "* \\return #RCL_RET_OK if the time source was successfully finalized, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_clock_fini(clock: *mut rcl_clock_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Initialize a clock as a #RCL_ROS_TIME time source."]
    #[doc = "* *"]
    #[doc = "* This will allocate all necessary internal structures, and initialize variables."]
    #[doc = "* It is specifically setting up a #RCL_ROS_TIME time source."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No [1]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* <i>[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe."]
    #[doc = "* Thread-safety is also affected by that of the `allocator` object.</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] clock the handle to the clock which is being initialized"]
    #[doc = "* \\param[in] allocator The allocator to use for allocations"]
    #[doc = "* \\return #RCL_RET_OK if the time source was successfully initialized, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_ros_clock_init(
        clock: *mut rcl_clock_t,
        allocator: *mut rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a clock as a #RCL_ROS_TIME time source."]
    #[doc = "* *"]
    #[doc = "* This will deallocate all necessary internal structures, and clean up any variables."]
    #[doc = "* It is specifically setting up a #RCL_ROS_TIME time source. It is expected"]
    #[doc = "* to be paired with the init fuction."]
    #[doc = "* "]
    #[doc = "* This function is not thread-safe with any other function operating on the same"]
    #[doc = "* clock object."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No [1]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe."]
    #[doc = "* Thread-safety is also affected by that of the `allocator` object associated with the"]
    #[doc = "* `clock` object.</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] clock the handle to the clock which is being initialized"]
    #[doc = "* \\return #RCL_RET_OK if the time source was successfully finalized, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_ros_clock_fini(clock: *mut rcl_clock_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Initialize a clock as a #RCL_STEADY_TIME time source."]
    #[doc = "* *"]
    #[doc = "* This will allocate all necessary internal structures, and initialize variables."]
    #[doc = "* It is specifically setting up a #RCL_STEADY_TIME time source."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No [1]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe."]
    #[doc = "* Thread-safety is also affected by that of the `allocator` object.</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] clock the handle to the clock which is being initialized"]
    #[doc = "* \\param[in] allocator The allocator to use for allocations"]
    #[doc = "* \\return #RCL_RET_OK if the time source was successfully initialized, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_steady_clock_init(
        clock: *mut rcl_clock_t,
        allocator: *mut rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a clock as a #RCL_STEADY_TIME time source."]
    #[doc = "* *"]
    #[doc = "* Finalize the clock as a #RCL_STEADY_TIME time source."]
    #[doc = "* "]
    #[doc = "* This will deallocate all necessary internal structures, and clean up any variables."]
    #[doc = "* It is specifically setting up a steady time source. It is expected to be"]
    #[doc = "* paired with the init fuction."]
    #[doc = "* "]
    #[doc = "* This function is not thread-safe with any other function operating on the same"]
    #[doc = "* clock object."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No [1]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe."]
    #[doc = "* Thread-safety is also affected by that of the `allocator` object associated with the"]
    #[doc = "* `clock` object.</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] clock the handle to the clock which is being initialized"]
    #[doc = "* \\return #RCL_RET_OK if the time source was successfully finalized, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_steady_clock_fini(clock: *mut rcl_clock_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Initialize a clock as a #RCL_SYSTEM_TIME time source."]
    #[doc = "* *"]
    #[doc = "* Initialize the clock as a #RCL_SYSTEM_TIME time source."]
    #[doc = "* "]
    #[doc = "* This will allocate all necessary internal structures, and initialize variables."]
    #[doc = "* It is specifically setting up a system time source."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No [1]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe."]
    #[doc = "* Thread-safety is also affected by that of the `allocator` object associated with the"]
    #[doc = "* `clock` object.</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] clock the handle to the clock which is being initialized"]
    #[doc = "* \\param[in] allocator The allocator to use for allocations"]
    #[doc = "* \\return #RCL_RET_OK if the time source was successfully initialized, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_system_clock_init(
        clock: *mut rcl_clock_t,
        allocator: *mut rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a clock as a #RCL_SYSTEM_TIME time source."]
    #[doc = "* *"]
    #[doc = "* Finalize the clock as a #RCL_SYSTEM_TIME time source."]
    #[doc = "* "]
    #[doc = "* This will deallocate all necessary internal structures, and clean up any variables."]
    #[doc = "* It is specifically setting up a system time source. It is expected to be paired with"]
    #[doc = "* the init fuction."]
    #[doc = "* "]
    #[doc = "* This function is not thread-safe with any function operating on the same clock object."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No [1]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe."]
    #[doc = "* Thread-safety is also affected by that of the `allocator` object associated with the"]
    #[doc = "* `clock` object.</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] clock the handle to the clock which is being initialized."]
    #[doc = "* \\return #RCL_RET_OK if the time source was successfully finalized, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_system_clock_fini(clock: *mut rcl_clock_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Compute the difference between two time points"]
    #[doc = "* *"]
    #[doc = "* This function takes two time points and computes the duration between them."]
    #[doc = "* The two time points must be using the same time abstraction, and the"]
    #[doc = "* resultant duration will also be of the same abstraction."]
    #[doc = "* "]
    #[doc = "* The value will be computed as duration = finish - start. If start is after"]
    #[doc = "* finish the duration will be negative."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] start The time point for the start of the duration."]
    #[doc = "* \\param[in] finish The time point for the end of the duration."]
    #[doc = "* \\param[out] delta The duration between the start and finish."]
    #[doc = "* \\return #RCL_RET_OK if the difference was computed successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_difference_times(
        start: *mut rcl_time_point_t,
        finish: *mut rcl_time_point_t,
        delta: *mut rcl_duration_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Fill the time point value with the current value of the associated clock."]
    #[doc = "* *"]
    #[doc = "* This function will populate the data of the time_point_value object with the"]
    #[doc = "* current value from it's associated time abstraction."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Yes [1]"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* <i>[1] If `clock` is of #RCL_ROS_TIME type.</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] clock The time source from which to set the value."]
    #[doc = "* \\param[out] time_point_value The time_point value to populate."]
    #[doc = "* \\return #RCL_RET_OK if the last call time was retrieved successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_clock_get_now(
        clock: *mut rcl_clock_t,
        time_point_value: *mut rcl_time_point_value_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Enable the ROS time abstraction override."]
    #[doc = "* *"]
    #[doc = "* This method will enable the ROS time abstraction override values,"]
    #[doc = "* such that the time source will report the set value instead of falling"]
    #[doc = "* back to system time."]
    #[doc = "* "]
    #[doc = "* This function is not thread-safe with rcl_clock_add_jump_callback(),"]
    #[doc = "* nor rcl_clock_remove_jump_callback() functions when used on the same"]
    #[doc = "* clock object."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence [1]"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No [2]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* <i>[1] Only applies to the function itself, as jump callbacks may not abide to it.</i>"]
    #[doc = "* <i>[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe.</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] clock The clock to enable."]
    #[doc = "* \\return #RCL_RET_OK if the time source was enabled successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_enable_ros_time_override(clock: *mut rcl_clock_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Disable the ROS time abstraction override."]
    #[doc = "* *"]
    #[doc = "* This method will disable the #RCL_ROS_TIME time abstraction override values,"]
    #[doc = "* such that the time source will report the system time even if a custom"]
    #[doc = "* value has been set."]
    #[doc = "* "]
    #[doc = "* This function is not thread-safe with rcl_clock_add_jump_callback(),"]
    #[doc = "* nor rcl_clock_remove_jump_callback() functions when used on the same"]
    #[doc = "* clock object."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence [1]"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No [2]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* <i>[1] Only applies to the function itself, as jump callbacks may not abide to it.</i>"]
    #[doc = "* <i>[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe.</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] clock The clock to disable."]
    #[doc = "* \\return #RCL_RET_OK if the time source was disabled successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_disable_ros_time_override(clock: *mut rcl_clock_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Check if the #RCL_ROS_TIME time source has the override enabled."]
    #[doc = "* *"]
    #[doc = "* This will populate the is_enabled object to indicate if the"]
    #[doc = "* time overide is enabled. If it is enabled, the set value will be returned."]
    #[doc = "* Otherwise this time source will return the equivalent to system time abstraction."]
    #[doc = "* "]
    #[doc = "* This function is not thread-safe with rcl_enable_ros_time_override() nor"]
    #[doc = "* rcl_disable_ros_time_override() functions when used on the same clock object."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No [1]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] clock The clock to query."]
    #[doc = "* \\param[out] is_enabled Whether the override is enabled.."]
    #[doc = "* \\return #RCL_RET_OK if the time source was queried successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_is_enabled_ros_time_override(
        clock: *mut rcl_clock_t,
        is_enabled: *mut bool,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Set the current time for this #RCL_ROS_TIME time source."]
    #[doc = "* *"]
    #[doc = "* This function will update the internal storage for the #RCL_ROS_TIME"]
    #[doc = "* time source."]
    #[doc = "* If queried and override enabled the time source will return this value,"]
    #[doc = "* otherwise it will return the system time."]
    #[doc = "* "]
    #[doc = "* This function is not thread-safe with rcl_clock_add_jump_callback(),"]
    #[doc = "* nor rcl_clock_remove_jump_callback() functions when used on the same"]
    #[doc = "* clock object."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence [1]"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No [2]"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* <i>[1] Only applies to the function itself, as jump callbacks may not abide to it.</i>"]
    #[doc = "* <i>[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe.</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] clock The clock to update."]
    #[doc = "* \\param[in] time_value The new current time."]
    #[doc = "* \\return #RCL_RET_OK if the time source was set successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_set_ros_time_override(
        clock: *mut rcl_clock_t,
        time_value: rcl_time_point_value_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Add a callback to be called when a time jump exceeds a threshold."]
    #[doc = "* *"]
    #[doc = "* The callback is called twice when the threshold is exceeded: once before the clock is"]
    #[doc = "* updated, and once after."]
    #[doc = "* The user_data pointer is passed to the callback as the last argument."]
    #[doc = "* A callback and user_data pair must be unique among the callbacks added to a clock."]
    #[doc = "* "]
    #[doc = "* This function is not thread-safe with rcl_clock_remove_jump_callback(),"]
    #[doc = "* rcl_enable_ros_time_override(), rcl_disable_ros_time_override() nor"]
    #[doc = "* rcl_set_ros_time_override() functions when used on the same clock object."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No [1]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe."]
    #[doc = "* Thread-safety is also affected by that of the `allocator` object associated with the"]
    #[doc = "* `clock` object.</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] clock A clock to add a jump callback to."]
    #[doc = "* \\param[in] threshold Criteria indicating when to call the callback."]
    #[doc = "* \\param[in] callback A callback to call."]
    #[doc = "* \\param[in] user_data A pointer to be passed to the callback."]
    #[doc = "* \\return #RCL_RET_OK if the callback was added successfully, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if a memory allocation failed, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_clock_add_jump_callback(
        clock: *mut rcl_clock_t,
        threshold: rcl_jump_threshold_t,
        callback: rcl_jump_callback_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Remove a previously added time jump callback."]
    #[doc = "* *"]
    #[doc = "* This function is not thread-safe with rcl_clock_add_jump_callback()"]
    #[doc = "* rcl_enable_ros_time_override(), rcl_disable_ros_time_override() nor"]
    #[doc = "* rcl_set_ros_time_override() functions when used on the same clock object."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No [1]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe."]
    #[doc = "* Thread-safety is also affected by that of the `allocator` object associated with the"]
    #[doc = "* `clock` object.</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] clock The clock to remove a jump callback from."]
    #[doc = "* \\param[in] callback The callback to call."]
    #[doc = "* \\param[in] user_data A pointer to be passed to the callback."]
    #[doc = "* \\return #RCL_RET_OK if the callback was added successfully, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if a memory allocation failed, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR the callback was not found or an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_clock_remove_jump_callback(
        clock: *mut rcl_clock_t,
        callback: rcl_jump_callback_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
pub type rosidl_runtime_c__bound_handle_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_runtime_c__Sequence__bound,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const rosidl_runtime_c__Sequence__bound,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__Sequence__bound {
    #[doc = " String identifier for the type_support."]
    pub typesupport_identifier: *const ::std::os::raw::c_char,
    #[doc = " Pointer to type support handle function"]
    pub data: *const ::std::os::raw::c_void,
    pub func: rosidl_runtime_c__bound_handle_function,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__Sequence__bound() {
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__Sequence__bound>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__Sequence__bound))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__Sequence__bound>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__Sequence__bound)
        )
    );
    fn test_field_typesupport_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rosidl_runtime_c__Sequence__bound>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).typesupport_identifier) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rosidl_runtime_c__Sequence__bound),
                "::",
                stringify!(typesupport_identifier)
            )
        );
    }
    test_field_typesupport_identifier();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rosidl_runtime_c__Sequence__bound>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rosidl_runtime_c__Sequence__bound),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rosidl_runtime_c__Sequence__bound>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rosidl_runtime_c__Sequence__bound),
                "::",
                stringify!(func)
            )
        );
    }
    test_field_func();
}
extern "C" {
    #[doc = " Get the message bounds handle specific to this identifier."]
    #[doc = "* *"]
    #[doc = "* The handle's sequence bound is simply returned or if the parameters are NULL then an assert"]
    #[doc = "* will happen."]
    #[doc = "* "]
    #[doc = "* \\param handle Handle to service type support"]
    #[doc = "* \\param identifier The identifier to get the handle for"]
    #[doc = "* \\return The associated sequence bound handle function."]
    #[doc = "* /"]
    pub fn get_sequence_bound_handle(
        handle: *const rosidl_runtime_c__Sequence__bound,
        identifier: *const ::std::os::raw::c_char,
    ) -> *const rosidl_runtime_c__Sequence__bound;
}
extern "C" {
    #[doc = " Get the message bounds handle function specific to this identifier."]
    #[doc = "* *"]
    #[doc = "* If the identifier is the same as this handle function's identifier the handle is simply returned"]
    #[doc = "* or if the parameters are NULL then an assert will happen."]
    #[doc = "* "]
    #[doc = "* \\param handle Handle to service type support"]
    #[doc = "* \\param identifier The identifier to get the handle function for"]
    #[doc = "* \\return if the identifier match's the handle's identifier then the handle's function"]
    #[doc = "* is returned."]
    #[doc = "* /"]
    pub fn get_sequence_bound_handle_function(
        handle: *const rosidl_runtime_c__Sequence__bound,
        identifier: *const ::std::os::raw::c_char,
    ) -> *const rosidl_runtime_c__Sequence__bound;
}
extern "C" {
    pub static rmw_qos_profile_sensor_data: rmw_qos_profile_t;
}
extern "C" {
    pub static rmw_qos_profile_parameters: rmw_qos_profile_t;
}
extern "C" {
    pub static rmw_qos_profile_default: rmw_qos_profile_t;
}
extern "C" {
    pub static rmw_qos_profile_services_default: rmw_qos_profile_t;
}
extern "C" {
    pub static rmw_qos_profile_parameter_events: rmw_qos_profile_t;
}
extern "C" {
    pub static rmw_qos_profile_system_default: rmw_qos_profile_t;
}
extern "C" {
    pub static rmw_qos_profile_unknown: rmw_qos_profile_t;
}
#[doc = " QoS policies are compatible"]
pub const rmw_qos_compatibility_type_t_RMW_QOS_COMPATIBILITY_OK: rmw_qos_compatibility_type_t = 0;
#[doc = " QoS policies may not be compatible"]
pub const rmw_qos_compatibility_type_t_RMW_QOS_COMPATIBILITY_WARNING: rmw_qos_compatibility_type_t =
    1;
#[doc = " QoS policies are not compatible"]
pub const rmw_qos_compatibility_type_t_RMW_QOS_COMPATIBILITY_ERROR: rmw_qos_compatibility_type_t =
    2;
pub type rmw_qos_compatibility_type_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Check if two QoS profiles are compatible."]
    #[doc = "* *"]
    #[doc = "* Two QoS profiles are compatible if a publisher and subcription"]
    #[doc = "* using the QoS policies can communicate with each other."]
    #[doc = "* "]
    #[doc = "* If any of the profile policies has the value \"system default\" or \"unknown\", then it may not be"]
    #[doc = "* possible to determine the compatibilty."]
    #[doc = "* In this case, the output parameter `compatibility` is set to `RMW_QOS_COMPATIBILITY_WARNING`"]
    #[doc = "* and `reason` is populated."]
    #[doc = "* "]
    #[doc = "* If there is a compatibility warning or error, and a buffer is provided for `reason`, then an"]
    #[doc = "* explanation of all warnings and errors will be populated into the buffer, separated by"]
    #[doc = "* semi-colons (`;`)."]
    #[doc = "* Errors will appear before warnings in the string buffer."]
    #[doc = "* If the provided buffer is not large enough, this function will still write to the buffer, up to"]
    #[doc = "* the `reason_size` number of characters."]
    #[doc = "* Therefore, it is possible that not all errors and warnings are communicated if the buffer size limit"]
    #[doc = "* is reached."]
    #[doc = "* A buffer size of 2048 should be more than enough to capture all possible errors and warnings."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] publisher_profile: The QoS profile used for a publisher."]
    #[doc = "* \\param[in] subscription_profile: The QoS profile used for a subscription."]
    #[doc = "* \\param[out] compatibility: `RMW_QOS_COMPATIBILITY_OK` if the QoS profiles are compatible, or"]
    #[doc = "* `RMW_QOS_COMPATIBILITY_WARNING` if the QoS profiles might be compatible, or"]
    #[doc = "* `RMW_QOS_COMPATIBILITY_ERROR` if the QoS profiles are not compatible."]
    #[doc = "* \\param[out] reason: A detailed reason for a QoS incompatibility or potential incompatibility."]
    #[doc = "* Must be pre-allocated by the caller."]
    #[doc = "* This parameter is optional and may be set to `NULL` if the reason information is not"]
    #[doc = "* desired."]
    #[doc = "* \\param[in] reason_size: Size of the string buffer `reason`, if one is provided."]
    #[doc = "* If `reason` is `nullptr`, then this parameter must be zero."]
    #[doc = "* \\return `RMW_RET_OK` if the check was successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `compatiblity` is `nullptr`, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `reason` is `NULL` and  `reason_size` is not zero, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if there is an unexpected error."]
    #[doc = "* /"]
    pub fn rmw_qos_profile_check_compatible(
        publisher_profile: rmw_qos_profile_t,
        subscription_profile: rmw_qos_profile_t,
        compatibility: *mut rmw_qos_compatibility_type_t,
        reason: *mut ::std::os::raw::c_char,
        reason_size: size_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Return a rmw_subscription_options_t initialized with default values."]
    pub fn rmw_get_default_subscription_options() -> rmw_subscription_options_t;
}
extern "C" {
    #[doc = " Get the name of the rmw implementation being used"]
    #[doc = "* *"]
    #[doc = "* \\return Name of rmw implementation"]
    #[doc = "* /"]
    pub fn rmw_get_implementation_identifier() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the unique serialization format for this middleware."]
    #[doc = "* *"]
    #[doc = "* Return the format in which binary data is serialized."]
    #[doc = "* One middleware can only have one encoding."]
    #[doc = "* In contrast to the implementation identifier, the serialization format can be equal between"]
    #[doc = "* multiple RMW implementations."]
    #[doc = "* This means, that the same binary messages can be deserialized by RMW implementations with the"]
    #[doc = "* same format."]
    #[doc = "* \\sa rmw_serialize"]
    #[doc = "* \\sa rmw_deserialize"]
    #[doc = "* \\return serialization format"]
    #[doc = "* /"]
    pub fn rmw_get_serialization_format() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Create a node and return a handle to that node."]
    #[doc = "* *"]
    #[doc = "* This function can fail, and therefore return `NULL`, if:"]
    #[doc = "* - name is not a valid non-null node name"]
    #[doc = "* - namespace_ is not a valid non-null namespace"]
    #[doc = "* - context is not valid i.e. it is zero-initialized, or"]
    #[doc = "* its implementation identifier does not match that of"]
    #[doc = "* this API implementation, or has been invalidated by"]
    #[doc = "* `rmw_shutdown()`"]
    #[doc = "* - memory allocation fails during node creation"]
    #[doc = "* - an unspecified error occurs"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No [1]"]
    #[doc = "* Lock-Free          | No [1]"]
    #[doc = "* <i>[1] rmw implementation defined, check the implementation documentation</i>"]
    #[doc = "* "]
    #[doc = "* This should be defined by the rmw implementation."]
    #[doc = "* "]
    #[doc = "* \\param[in] context init context that this node should be associated with"]
    #[doc = "* \\param[in] name the node name"]
    #[doc = "* \\param[in] namespace_ the node namespace"]
    #[doc = "* \\return rmw node handle, or `NULL` if there was an error"]
    #[doc = "* /"]
    pub fn rmw_create_node(
        context: *mut rmw_context_t,
        name: *const ::std::os::raw::c_char,
        namespace_: *const ::std::os::raw::c_char,
    ) -> *mut rmw_node_t;
}
extern "C" {
    #[doc = " Finalize a given node handle, reclaim the resources, and deallocate the node handle."]
    #[doc = "* *"]
    #[doc = "* This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`"]
    #[doc = "* or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given node handle unchanged."]
    #[doc = "* Otherwise, it will proceed despite errors, freeing as many resources as it can, including"]
    #[doc = "* the node handle. Usage of a deallocated node handle is undefined behavior."]
    #[doc = "* "]
    #[doc = "* \\pre All publishers, subscribers, services, and clients created from this node must"]
    #[doc = "* have been destroyed prior to this call. Some rmw implementations may verify this,"]
    #[doc = "* returning `RMW_RET_ERROR` and setting a human readable error message if any entity"]
    #[doc = "* created from this node has not yet been destroyed. However, this is not guaranteed"]
    #[doc = "* and so callers should ensure that this is the case before calling this function."]
    #[doc = "* "]
    #[doc = "* \\param[in] node the node handle to be destroyed"]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if node is invalid, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation"]
    #[doc = "* identifier does not match, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_destroy_node(node: *mut rmw_node_t) -> rmw_ret_t;
}
extern "C" {
    pub fn rmw_node_assert_liveliness(node: *const rmw_node_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Return a guard condition which is triggered when the ROS graph changes."]
    #[doc = "* *"]
    #[doc = "* The guard condition will be triggered anytime a change to the ROS graph occurs."]
    #[doc = "* A ROS graph change occurs whenever:"]
    #[doc = "* - A node joins or leaves the ROS graph."]
    #[doc = "* This change will be reflected in rmw_get_node_names() and"]
    #[doc = "* rmw_get_node_names_with_enclaves() outcome."]
    #[doc = "* - A topic subscription joins or leaves the ROS graph."]
    #[doc = "* This change will be reflected in rmw_get_topic_names_and_types(),"]
    #[doc = "* rmw_get_subscriber_names_and_types_by_node(), and"]
    #[doc = "* rmw_get_subscriptions_info_by_topic() outcome."]
    #[doc = "* - A topic publisher joins or leaves the ROS graph."]
    #[doc = "* This change will be reflected in rmw_get_topic_names_and_types(),"]
    #[doc = "* rmw_get_publisher_names_and_types_by_node(), and"]
    #[doc = "* rmw_get_publishers_info_by_topic() outcome."]
    #[doc = "* - A topic subscription matches a topic publisher with compatible QoS policies."]
    #[doc = "* This change will be reflected in rmw_subscription_count_matched_publishers() outcome."]
    #[doc = "* - A topic publisher matches a topic subscription with compatible QoS policies."]
    #[doc = "* This change will be reflected in rmw_publisher_count_matched_subscriptions() outcome."]
    #[doc = "* - A service server joins or leaves the ROS graph."]
    #[doc = "* This change will be reflected in rmw_get_service_names_and_types() and"]
    #[doc = "* rmw_get_service_names_and_types_by_node() outcome."]
    #[doc = "* - A service client joins or leaves the ROS graph."]
    #[doc = "* This change will be reflected in rmw_get_service_names_and_types() and"]
    #[doc = "* rmw_get_client_names_and_types_by_node() outcome."]
    #[doc = "* - A service client matches a service server with compatible QoS policies."]
    #[doc = "* This change will be reflected in rmw_service_server_is_available() outcome."]
    #[doc = "* "]
    #[doc = "* \\note The state of the ROS graph, and any changes that may take place,"]
    #[doc = "* are reported as seen by the associated `node`."]
    #[doc = "* "]
    #[doc = "* The guard condition is owned and internally held by the `node`."]
    #[doc = "* It will be invalidated if `node` is finalized using rmw_destroy_node()."]
    #[doc = "* It is undefined behavior to use an invalidated guard condition."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\pre Given `node` must be a valid node handle, as returned by rmw_create_node()."]
    #[doc = "* "]
    #[doc = "* \\param[in] node Node to retrieve the guard condition from."]
    #[doc = "* \\return Guard condition if successful, or `NULL` if"]
    #[doc = "* `node` is `NULL`, or an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rmw_node_get_graph_guard_condition(
        node: *const rmw_node_t,
    ) -> *const rmw_guard_condition_t;
}
extern "C" {
    #[doc = " Initialize a publisher allocation to be used with later publications."]
    #[doc = "* *"]
    #[doc = "* This creates an allocation object that can be used in conjunction with"]
    #[doc = "* the rmw_publish method to perform more carefully control memory allocations."]
    #[doc = "* "]
    #[doc = "* This will allow the middleware to preallocate the correct amount of memory"]
    #[doc = "* for a given message type and message bounds."]
    #[doc = "* As allocation is performed in this method, it will not be necessary to allocate"]
    #[doc = "* in the `rmw_publish` method."]
    #[doc = "* "]
    #[doc = "* \\param[in] type_support Type support of the message to be preallocated."]
    #[doc = "* \\param[in] message_bounds Bounds structure of the message to be preallocated."]
    #[doc = "* \\param[out] allocation Allocation structure to be passed to `rmw_publish`."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_UNSUPPORTED` if it's unimplemented"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if an argument is null, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_init_publisher_allocation(
        type_support: *const rosidl_message_type_support_t,
        message_bounds: *const rosidl_runtime_c__Sequence__bound,
        allocation: *mut rmw_publisher_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Destroy a publisher allocation object."]
    #[doc = "* *"]
    #[doc = "* This deallocates any memory allocated by `rmw_init_publisher_allocation`."]
    #[doc = "* "]
    #[doc = "* \\param[in] allocation Allocation object to be destroyed."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_UNSUPPORTED` if it's unimplemented"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if argument is null, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_fini_publisher_allocation(allocation: *mut rmw_publisher_allocation_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Return a rmw_publisher_options_t initialized with default values."]
    pub fn rmw_get_default_publisher_options() -> rmw_publisher_options_t;
}
extern "C" {
    #[doc = " Create a publisher and return a handle to that publisher."]
    #[doc = "* *"]
    #[doc = "* This function can fail, and therefore return `NULL`, if:"]
    #[doc = "* - node is not a valid non-null handle for this rmw implementation,"]
    #[doc = "* as returned by `rmw_create_node()`"]
    #[doc = "* - type_support is a not valid non-null message type support, as returned by"]
    #[doc = "* `ROSIDL_GET_MSG_TYPE_SUPPORT()`"]
    #[doc = "* - topic_name is not a valid non-null topic name, according to"]
    #[doc = "* `rmw_validate_full_topic_name()`"]
    #[doc = "* - qos_profile is not a fully specified non-null profile i.e. no UNKNOWN policies"]
    #[doc = "* - publisher_options is not a valid non-null option set, as returned by"]
    #[doc = "* `rmw_get_default_publisher_options()`"]
    #[doc = "* - memory allocation fails during publisher creation"]
    #[doc = "* - an unspecified error occurs"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] rmw implementation defined, check the implementation documentation</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node Handle to node with which to register this publisher"]
    #[doc = "* \\param[in] type_support Type support for the messages to be published"]
    #[doc = "* \\param[in] topic_name Name of the topic to publish to, often a fully qualified"]
    #[doc = "* topic name unless `qos_profile` is configured to avoid ROS namespace conventions"]
    #[doc = "* i.e. to create a native topic publisher"]
    #[doc = "* \\param[in] qos_profile QoS policies for this publisher"]
    #[doc = "* \\param[in] publisher_options Options to configure this publisher"]
    #[doc = "* \\return rmw publisher handle, or `NULL` if there was an error"]
    #[doc = "* /"]
    pub fn rmw_create_publisher(
        node: *const rmw_node_t,
        type_support: *const rosidl_message_type_support_t,
        topic_name: *const ::std::os::raw::c_char,
        qos_profile: *const rmw_qos_profile_t,
        publisher_options: *const rmw_publisher_options_t,
    ) -> *mut rmw_publisher_t;
}
extern "C" {
    #[doc = " Finalize a given publisher handle, reclaim the resources, and deallocate the publisher handle."]
    #[doc = "* *"]
    #[doc = "* This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`"]
    #[doc = "* or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given publisher handle unchanged."]
    #[doc = "* Otherwise, it will proceed despite errors, freeing as many resources as it can, including"]
    #[doc = "* the publisher handle. Usage of a deallocated publisher handle is undefined behavior."]
    #[doc = "* "]
    #[doc = "* \\pre Given node must be the one the publisher was registered with."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] rmw implementation defined, check the implementation documentation</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node Handle to node with which the given publisher is registered"]
    #[doc = "* \\param[in] publisher Handle to publisher to be finalized"]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if node or publisher is `NULL`, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if node or publisher"]
    #[doc = "* implementation identifier does not match, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_destroy_publisher(
        node: *mut rmw_node_t,
        publisher: *mut rmw_publisher_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Borrow a loaned ROS message."]
    #[doc = "* *"]
    #[doc = "* This ROS message is owned by the middleware, that will keep it alive (i.e. in valid"]
    #[doc = "* memory space) until the caller publishes it using rmw_publish_loaned_message() or"]
    #[doc = "* returns it using rmw_return_loaned_message_from_publisher()."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* "]
    #[doc = "* <i>[1] implementation defined, check implementation documentation.</i>"]
    #[doc = "* "]
    #[doc = "* \\par Runtime behavior"]
    #[doc = "* To borrow a ROS message is a synchronous operation."]
    #[doc = "* It is also non-blocking, but it is not guaranteed to be lock-free."]
    #[doc = "* Generally speaking, implementations may synchronize access to internal resources using"]
    #[doc = "* locks but are not allowed to wait for events with no guaranteed time bound (barring"]
    #[doc = "* the effects of starvation due to OS scheduling)."]
    #[doc = "* "]
    #[doc = "* \\par Memory allocation"]
    #[doc = "* It is implementation defined whether memory will be allocated on borrow or not."]
    #[doc = "* Check the implementation documentation to learn about memory allocation"]
    #[doc = "* guarantees when using ROS message loaning support."]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Publishers are thread-safe objects, and so are all operations on them except for finalization."]
    #[doc = "* Therefore, it is safe to borrow ROS messages from the same publisher concurrently."]
    #[doc = "* "]
    #[doc = "* \\pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher()."]
    #[doc = "* \\pre Given `type_support` must be a valid `rosidl` message type support, matching the"]
    #[doc = "* one registered with the `publisher` on creation."]
    #[doc = "* "]
    #[doc = "* \\param[in] publisher Publisher to which the loaned ROS message will be associated."]
    #[doc = "* \\param[in] type_support Message type support of the loaned ROS message."]
    #[doc = "* \\param[out] ros_message Pointer to type erased ROS message loaned by the middleware."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `type_support` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `*ros_message` is not NULL (to prevent leaks), or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation identifier"]
    #[doc = "* does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_UNSUPPORTED` if the implementation does not support ROS message loaning, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occured."]
    #[doc = "* /"]
    pub fn rmw_borrow_loaned_message(
        publisher: *const rmw_publisher_t,
        type_support: *const rosidl_message_type_support_t,
        ros_message: *mut *mut ::std::os::raw::c_void,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Return a loaned message previously borrowed from a publisher."]
    #[doc = "* *"]
    #[doc = "* Tells the middleware that a borrowed ROS message is no longer needed by the caller."]
    #[doc = "* Ownership of the ROS message is given back to the middleware."]
    #[doc = "* If this function fails early due to a logical error, such as an invalid argument,"]
    #[doc = "* the loaned ROS message will be left unchanged."]
    #[doc = "* Otherwise, ownership of the ROS message will be given back to the middleware."]
    #[doc = "* It is up to the middleware what will be made of the returned ROS message."]
    #[doc = "* It is undefined behavior to use a loaned ROS message after returning it."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* "]
    #[doc = "* <i>[1] implementation defined, check implementation documentation.</i>"]
    #[doc = "* "]
    #[doc = "* \\par Runtime behavior"]
    #[doc = "* To return a ROS message is a synchronous operation."]
    #[doc = "* It is also non-blocking, but it is not guaranteed to be lock-free."]
    #[doc = "* Generally speaking, implementations may synchronize access to internal resources using"]
    #[doc = "* locks but are not allowed to wait for events with no guaranteed time bound (barring"]
    #[doc = "* the effects of starvation due to OS scheduling)."]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Publishers are thread-safe objects, and so are all operations on them except for finalization."]
    #[doc = "* Therefore, it is safe to return borrowed ROS messages to the same publisher concurrently."]
    #[doc = "* However, since ownership of the loaned ROS message is given back to the middleware and"]
    #[doc = "* this transfer is not synchronized, it is not safe to return the same loaned ROS message"]
    #[doc = "* concurrently."]
    #[doc = "* "]
    #[doc = "* \\pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher()."]
    #[doc = "* \\pre Given `loaned_message` must have been previously borrowed from the same publisher"]
    #[doc = "* using rmw_borrow_loaned_message()."]
    #[doc = "* "]
    #[doc = "* \\param[in] publisher Publisher to which the loaned ROS message is associated."]
    #[doc = "* \\param[in] loaned_message Type erased loaned ROS message to be returned."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `loaned_message` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation identifier"]
    #[doc = "* does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_UNSUPPORTED` if the implementation does not support ROS message loaning, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs and no message can be initialized."]
    #[doc = "* /"]
    pub fn rmw_return_loaned_message_from_publisher(
        publisher: *const rmw_publisher_t,
        loaned_message: *mut ::std::os::raw::c_void,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Publish a ROS message."]
    #[doc = "* *"]
    #[doc = "* Send a ROS message to all subscriptions with matching QoS policies using the given publisher."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* "]
    #[doc = "* <i>[1] implementation defined, check implementation documentation.</i>"]
    #[doc = "* "]
    #[doc = "* \\par Runtime behavior"]
    #[doc = "* It is implementation defined whether to publish a ROS message is a"]
    #[doc = "* synchronous or asynchronous, blocking or non-blocking operation."]
    #[doc = "* However, asynchronous implementations are not allowed to access the"]
    #[doc = "* given ROS message after this function returns."]
    #[doc = "* Check the implementation documentation to learn about publish behavior."]
    #[doc = "* "]
    #[doc = "* \\par Memory allocation"]
    #[doc = "* It is implementation defined whether memory will be allocated on publish or not."]
    #[doc = "* For instance, implementations that serialize ROS messages to send it over the"]
    #[doc = "* wire may need to perform additional memory allocations when dealing with"]
    #[doc = "* unbounded (dynamically-sized) fields."]
    #[doc = "* A publisher allocation, if provided, may or may not be used."]
    #[doc = "* Check the implementation documentation to learn about memory allocation"]
    #[doc = "* guarantees when publishing ROS messages with and without publisher allocations."]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Publishers are thread-safe objects, and so are all operations on them except for finalization."]
    #[doc = "* Therefore, it is safe to publish using the same publisher concurrently."]
    #[doc = "* However, when publishing regular ROS messages:"]
    #[doc = "* - Access to the ROS message is read-only but it is not synchronized."]
    #[doc = "* Concurrent `ros_message` reads are safe, but concurrent reads and writes are not."]
    #[doc = "* - Access to the publisher allocation is not synchronized, unless specifically stated"]
    #[doc = "* otherwise by the implementation."]
    #[doc = "* Thus, it is generally not safe to read or write `allocation` while rmw_publish() uses it."]
    #[doc = "* Check the implementation documentation to learn about publisher allocations' thread-safety."]
    #[doc = "* "]
    #[doc = "* \\pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher()."]
    #[doc = "* \\pre Given `ros_message` must be a valid message, whose type matches the message type"]
    #[doc = "* support the `publisher` was registered with on creation."]
    #[doc = "* \\pre If not NULL, given `allocation` must be a valid publisher allocation, initialized"]
    #[doc = "* with rmw_publisher_allocation_init() with a message type support that matches the"]
    #[doc = "* one registered with `publisher` on creation."]
    #[doc = "* "]
    #[doc = "* \\param[in] publisher Publisher to be used to send message."]
    #[doc = "* \\param[in] ros_message Type erased ROS message to be sent."]
    #[doc = "* \\param[in] allocation Pre-allocated memory to be used. May be NULL."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation"]
    #[doc = "* identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_publish(
        publisher: *const rmw_publisher_t,
        ros_message: *const ::std::os::raw::c_void,
        allocation: *mut rmw_publisher_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Publish a loaned ROS message."]
    #[doc = "* *"]
    #[doc = "* Send a previously borrowed ROS message to all subscriptions with matching QoS policies"]
    #[doc = "* using the given publisher, then return ROS message ownership to the middleware."]
    #[doc = "* "]
    #[doc = "* If this function fails early due to a logical error, such as an invalid argument,"]
    #[doc = "* the loaned ROS message will be left unchanged."]
    #[doc = "* Otherwise, ownership of the ROS message will be given back to the middleware."]
    #[doc = "* It is up to the middleware what will be made of the returned ROS message."]
    #[doc = "* It is undefined behavior to use a loaned ROS message after publishing it."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* "]
    #[doc = "* <i>[1] implementation defined, check the implementation documentation.</i>"]
    #[doc = "* "]
    #[doc = "* \\par Runtime behavior"]
    #[doc = "* It is implementation defined whether to publish a loaned ROS message is a"]
    #[doc = "* synchronous or asynchronous, blocking or non-blocking operation."]
    #[doc = "* Check the implementation documentation to learn about publish behavior."]
    #[doc = "* "]
    #[doc = "* \\par Memory allocation"]
    #[doc = "* It is implementation defined whether memory will be allocated on publish or not."]
    #[doc = "* For instance, implementations that serialize ROS messages to send it over the"]
    #[doc = "* wire may need to perform additional memory allocations when dealing with"]
    #[doc = "* unbounded (dynamically-sized) fields."]
    #[doc = "* A publisher allocation, if provided, may or may not be used."]
    #[doc = "* Check the implementation documentation to learn about memory allocation"]
    #[doc = "* guarantees when publishing loaned ROS messages with and without publisher allocations."]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Publishers are thread-safe objects, and so are all operations on them except for finalization."]
    #[doc = "* Therefore, it is safe to publish using the same publisher concurrently."]
    #[doc = "* However, when publishing loaned ROS messages:"]
    #[doc = "* - Ownership of the loaned ROS message is given back to the middleware."]
    #[doc = "* This transfer is not synchronized, and thus it is not safe to publish the"]
    #[doc = "* same loaned ROS message concurrently."]
    #[doc = "* - Access to the publisher allocation is not synchronized, unless specifically stated"]
    #[doc = "* otherwise by the implementation."]
    #[doc = "* Thus, it is generally not safe to read or write `allocation` while rmw_publish() uses it."]
    #[doc = "* Check the implementation documentation to learn about publisher allocations' thread-safety."]
    #[doc = "* "]
    #[doc = "* \\pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher()."]
    #[doc = "* \\pre Given `ros_message` must be a valid message, borrowed from the same publisher using"]
    #[doc = "* rmw_borrow_loaned_message()."]
    #[doc = "* \\pre If not NULL, given `allocation` must be a valid publisher allocation, initialized"]
    #[doc = "* with rmw_publisher_allocation_init() with a message type support that matches the"]
    #[doc = "* one registered with `publisher` on creation."]
    #[doc = "* "]
    #[doc = "* \\param[in] publisher Publisher to be used to send message."]
    #[doc = "* \\param[in] ros_message Loaned type erased ROS message to be sent."]
    #[doc = "* \\param[in] allocation Pre-allocated memory to be used. May be NULL."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation"]
    #[doc = "* identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_UNSUPPORTED` if the implementation does not support ROS message loaning, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_publish_loaned_message(
        publisher: *const rmw_publisher_t,
        ros_message: *mut ::std::os::raw::c_void,
        allocation: *mut rmw_publisher_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Retrieve the number of matched subscriptions to a publisher."]
    #[doc = "* *"]
    #[doc = "* Query the underlying middleware to determine how many subscriptions are"]
    #[doc = "* matched to a given publisher."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] rmw implementation defined, check the implementation documentation</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] publisher the publisher object to inspect"]
    #[doc = "* \\param[out] subscription_count the number of subscriptions matched"]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if publisher"]
    #[doc = "* implementation identifier does not match, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_publisher_count_matched_subscriptions(
        publisher: *const rmw_publisher_t,
        subscription_count: *mut size_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Retrieve the actual qos settings of the publisher."]
    #[doc = "* *"]
    #[doc = "* Query the underlying middleware to determine the qos settings"]
    #[doc = "* of the publisher."]
    #[doc = "* The actual configuration applied when using RMW_*_SYSTEM_DEFAULT"]
    #[doc = "* can only be resolved after the creation of the publisher, and it"]
    #[doc = "* depends on the underlying rmw implementation."]
    #[doc = "* If the underlying setting in use can't be represented in ROS terms,"]
    #[doc = "* it will be set to RMW_*_UNKNOWN."]
    #[doc = "* "]
    #[doc = "* \\note The value of avoid_ros_namespace_conventions field is not resolved"]
    #[doc = "* with this function. The rcl function `rcl_publisher_get_actual_qos()`"]
    #[doc = "* resolves it."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe [1]"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] rmw implementation defined, check the implementation documentation</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] publisher the publisher object to inspect"]
    #[doc = "* \\param[out] qos the actual qos settings"]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if publisher"]
    #[doc = "* implementation identifier does not match, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_publisher_get_actual_qos(
        publisher: *const rmw_publisher_t,
        qos: *mut rmw_qos_profile_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Publish a ROS message as a byte stream."]
    #[doc = "* *"]
    #[doc = "* Send a ROS message serialized as a byte stream to all subscriptions with"]
    #[doc = "* matching QoS policies using the given publisher."]
    #[doc = "* A ROS message can be serialized manually using rmw_serialize()."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* "]
    #[doc = "* <i>[1] implementation defined, check the implementation documentation.</i>"]
    #[doc = "* "]
    #[doc = "* \\par Runtime behavior"]
    #[doc = "* It is implementation defined whether to publish a loaned ROS message is a"]
    #[doc = "* synchronous or asynchronous, blocking or non-blocking operation."]
    #[doc = "* However, asynchronous implementations are not allowed to access the"]
    #[doc = "* given byte stream after this function returns."]
    #[doc = "* Check the implementation documentation to learn about publish behavior."]
    #[doc = "* "]
    #[doc = "* \\par Memory allocation"]
    #[doc = "* It is implementation defined whether memory will be allocated on publish or not."]
    #[doc = "* Even if a publisher allocation is provided, an implementation may ignore it."]
    #[doc = "* Check the implementation documentation to learn about memory allocation"]
    #[doc = "* guarantees when publishing serialized messages with and without publisher allocations."]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Publishers are thread-safe objects, and so are all operations on them except for finalization."]
    #[doc = "* Therefore, it is safe to publish using the same publisher concurrently."]
    #[doc = "* However, when publishing serialized ROS messages:"]
    #[doc = "* - Access to the byte stream is read-only but it is not synchronized."]
    #[doc = "* Concurrent `serialized_message` reads are safe, but concurrent reads and writes are not."]
    #[doc = "* - Access to the publisher allocation is not synchronized, unless specifically stated"]
    #[doc = "* otherwise by the implementation."]
    #[doc = "* Thus, it is generally not safe to read or write `allocation` while rmw_publish() uses it."]
    #[doc = "* Check the implementation documentation to learn about publisher allocations' thread-safety."]
    #[doc = "* "]
    #[doc = "* \\pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher()."]
    #[doc = "* \\pre Given `serialized_message` must be a valid serialized message, initialized by"]
    #[doc = "* rmw_serialized_message_init() and containing the serialization of a ROS message whose"]
    #[doc = "* type matches the message type support the `publisher` was registered with on creation."]
    #[doc = "* \\pre If not NULL, given `allocation` must be a valid publisher allocation, initialized"]
    #[doc = "* with rmw_publisher_allocation_init() with a message type support that matches the"]
    #[doc = "* one registered with `publisher` on creation."]
    #[doc = "* "]
    #[doc = "* \\param[in] publisher Publisher to be used to send message."]
    #[doc = "* \\param[in] ros_message Serialized ROS message to be sent."]
    #[doc = "* \\param[in] allocation Pre-allocated memory to be used. May be NULL."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `serialized_message` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation"]
    #[doc = "* identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_publish_serialized_message(
        publisher: *const rmw_publisher_t,
        serialized_message: *const rmw_serialized_message_t,
        allocation: *mut rmw_publisher_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Compute the size of a serialized message."]
    #[doc = "* *"]
    #[doc = "* Given a message definition and bounds, compute the serialized size."]
    #[doc = "* "]
    #[doc = "* \\param[in] type_support The type support of the message to compute."]
    #[doc = "* \\param[in] bounds Artifical bounds to use on unbounded fields."]
    #[doc = "* \\param[out] size The computed size of the serialized message."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or"]
    #[doc = "* \\return `RMW_RET_UNSUPPORTED` if it's unimplemented, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_get_serialized_message_size(
        type_support: *const rosidl_message_type_support_t,
        message_bounds: *const rosidl_runtime_c__Sequence__bound,
        size: *mut size_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Manually assert that this Publisher is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC)"]
    #[doc = "* *"]
    #[doc = "* If the rmw Liveliness policy is set to RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC, the creator of"]
    #[doc = "* this publisher may manually call `assert_liveliness` at some point in time to signal to the rest"]
    #[doc = "* of the system that this Node is still alive."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] publisher handle to the publisher that needs liveliness to be asserted"]
    #[doc = "* \\return `RMW_RET_OK` if the liveliness assertion was completed successfully, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unspecified error occurs, or"]
    #[doc = "* \\return `RMW_RET_UNSUPPORTED` if the rmw implementation does not support asserting liveliness."]
    #[doc = "* /"]
    pub fn rmw_publisher_assert_liveliness(publisher: *const rmw_publisher_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Serialize a ROS message into a rmw_serialized_message_t."]
    #[doc = "* *"]
    #[doc = "* The ROS message is serialized into a byte stream contained within the"]
    #[doc = "* rmw_serialized_message_t structure."]
    #[doc = "* The serialization format depends on the underlying implementation."]
    #[doc = "* "]
    #[doc = "* \\pre Given ROS message must be a valid non-null instance, initialized"]
    #[doc = "* by the caller and matching the provided typesupport."]
    #[doc = "* \\pre Given typesupport must be a valid non-null instance, as provided"]
    #[doc = "* by `rosidl` APIs."]
    #[doc = "* \\pre Given serialized message must be a valid non-null instance, initialized"]
    #[doc = "* by the caller."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe [1]"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Maybe [2]"]
    #[doc = "* Lock-Free          | Maybe [2]"]
    #[doc = "* <i>[1] if the given serialized message does not have enough capacity to hold"]
    #[doc = "* the ROS message serialization</i>"]
    #[doc = "* <i>[2] rmw implementation defined, check the implementation documentation</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] ros_message the typed ROS message"]
    #[doc = "* \\param[in] type_support the typesupport for the ROS message"]
    #[doc = "* \\param[out] serialized_message the destination for the serialize ROS message"]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_BAD_ALLOC` if memory allocation failed, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_serialize(
        ros_message: *const ::std::os::raw::c_void,
        type_support: *const rosidl_message_type_support_t,
        serialized_message: *mut rmw_serialized_message_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Deserialize a ROS message."]
    #[doc = "* *"]
    #[doc = "* The given rmw_serialized_message_t's internal byte stream buffer is deserialized"]
    #[doc = "* into the given ROS message."]
    #[doc = "* The serialization format expected in the rmw_serialized_message_t depends on the"]
    #[doc = "* underlying implementation."]
    #[doc = "* "]
    #[doc = "* \\pre Given serialized message must be a valid non-null instance, such"]
    #[doc = "* as that returned by `rmw_serialize()`, matching provided typesupport"]
    #[doc = "* and ROS message."]
    #[doc = "* \\pre Given typesupport must be a valid non-null instance, as provided"]
    #[doc = "* by `rosidl` APIs."]
    #[doc = "* \\pre Given ROS message must be a valid non-null instance, initialized"]
    #[doc = "* by the caller."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe [1]"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Maybe [2]"]
    #[doc = "* Lock-Free          | Maybe [2]"]
    #[doc = "* <i>[1] if the given ROS message contains unbounded fields</i>"]
    #[doc = "* <i>[2] rmw implementation defined, check the implementation documentation</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] serialized_message the serialized message holding the byte stream"]
    #[doc = "* \\param[in] type_support the typesupport for the typed ros message"]
    #[doc = "* \\param[out] ros_message destination for the deserialized ROS message"]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_BAD_ALLOC` if memory allocation failed, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_deserialize(
        serialized_message: *const rmw_serialized_message_t,
        type_support: *const rosidl_message_type_support_t,
        ros_message: *mut ::std::os::raw::c_void,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Initialize a subscription allocation to be used with later `take`s."]
    #[doc = "* *"]
    #[doc = "* This creates an allocation object that can be used in conjunction with"]
    #[doc = "* the rmw_take method to perform more carefully control memory allocations."]
    #[doc = "* "]
    #[doc = "* This will allow the middleware to preallocate the correct amount of memory"]
    #[doc = "* for a given message type and message bounds."]
    #[doc = "* As allocation is performed in this method, it will not be necessary to allocate"]
    #[doc = "* in the `rmw_take` method."]
    #[doc = "* "]
    #[doc = "* \\param[in] type_support Type support of the message to be preallocated."]
    #[doc = "* \\param[in] message_bounds Bounds structure of the message to be preallocated."]
    #[doc = "* \\param[out] allocation Allocation structure to be passed to `rmw_take`."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_UNSUPPORTED` if it's unimplemented"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if an argument is null, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_init_subscription_allocation(
        type_support: *const rosidl_message_type_support_t,
        message_bounds: *const rosidl_runtime_c__Sequence__bound,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Destroy a publisher allocation object."]
    #[doc = "* *"]
    #[doc = "* This deallocates memory allocated by `rmw_init_subscription_allocation`."]
    #[doc = "* "]
    #[doc = "* \\param[in] allocation Allocation object to be destroyed."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_UNSUPPORTED` if it's unimplemented"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if argument is null, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_fini_subscription_allocation(
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Create a subscription and return a handle to that subscription."]
    #[doc = "* *"]
    #[doc = "* This function can fail, and therefore return `NULL`, if:"]
    #[doc = "* - node is not a valid non-null handle for this rmw implementation,"]
    #[doc = "* as returned by `rmw_create_node()`"]
    #[doc = "* - type_support is a not valid non-null message type support, as returned by"]
    #[doc = "* `ROSIDL_GET_MSG_TYPE_SUPPORT()`"]
    #[doc = "* - topic_name is not a valid non-null topic name, according to"]
    #[doc = "* `rmw_validate_full_topic_name()` if ROS namespace conventions apply"]
    #[doc = "* - qos_profile is not a fully specified non-null profile i.e. no UNKNOWN policies"]
    #[doc = "* - subscription_options is not a valid non-null option set, such as the one"]
    #[doc = "* returned by `rmw_get_default_subscription_options()`"]
    #[doc = "* - memory allocation fails during subscription creation"]
    #[doc = "* - an unspecified error occurs"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] rmw implementation defined, check the implementation documentation</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node Handle to node with which to register this subscription"]
    #[doc = "* \\param[in] type_support Type support for the messages to be subscribed to"]
    #[doc = "* \\param[in] topic_name Name of the topic to subscribe to, often a fully qualified"]
    #[doc = "* topic name unless `qos_profile` is configured to avoid ROS namespace conventions"]
    #[doc = "* i.e. to create a native topic subscription"]
    #[doc = "* \\param[in] qos_profile QoS policies for this subscription"]
    #[doc = "* \\param[in] subscription_options Options for configuring this subscription"]
    #[doc = "* \\return rmw subscription handle, or `NULL` if there was an error"]
    #[doc = "* /"]
    pub fn rmw_create_subscription(
        node: *const rmw_node_t,
        type_support: *const rosidl_message_type_support_t,
        topic_name: *const ::std::os::raw::c_char,
        qos_policies: *const rmw_qos_profile_t,
        subscription_options: *const rmw_subscription_options_t,
    ) -> *mut rmw_subscription_t;
}
extern "C" {
    #[doc = " Finalize a given subscription handle, reclaim the resources, and deallocate the subscription"]
    #[doc = " handle."]
    #[doc = "* *"]
    #[doc = "* This function will return early if a logical error, namely `RMW_RET_INVALID_ARGUMENT`"]
    #[doc = "* or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given subscription handle"]
    #[doc = "* unchanged."]
    #[doc = "* Otherwise, it will proceed despite errors, freeing as many resources as it can, including"]
    #[doc = "* the subscription handle, and return `RMW_RET_ERROR`. Usage of a deallocated subscription"]
    #[doc = "* handle is undefined behavior."]
    #[doc = "* "]
    #[doc = "* \\pre Given node must be the one the subscription was registered with."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] rmw implementation defined, check the implementation documentation</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node Handle to node with which the given subscription is registered"]
    #[doc = "* \\param[in] subscription Handle to subscription to be finalized"]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if node or subscription is `NULL`, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if node or subscription"]
    #[doc = "* implementation identifier does not match, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_destroy_subscription(
        node: *mut rmw_node_t,
        subscription: *mut rmw_subscription_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Retrieve the number of matched publishers to a subscription."]
    #[doc = "* *"]
    #[doc = "* Query the underlying middleware to determine how many publishers are"]
    #[doc = "* matched to a given subscription."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] rmw implementation defined, check the implementation documentation</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] subscription the subscription object to inspect"]
    #[doc = "* \\param[out] publisher_count the number of publishers matched"]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if subscription"]
    #[doc = "* implementation identifier does not match, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_subscription_count_matched_publishers(
        subscription: *const rmw_subscription_t,
        publisher_count: *mut size_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Retrieve the actual qos settings of the subscription."]
    #[doc = "* *"]
    #[doc = "* Query the underlying middleware to determine the qos settings"]
    #[doc = "* of the subscription."]
    #[doc = "* The actual configuration applied when using RMW_*_SYSTEM_DEFAULT"]
    #[doc = "* can only be resolved after the creation of the subscription, and it"]
    #[doc = "* depends on the underlying rmw implementation."]
    #[doc = "* If the underlying setting in use can't be represented in ROS terms,"]
    #[doc = "* it will be set to RMW_*_UNKNOWN."]
    #[doc = "* "]
    #[doc = "* \\note The value of avoid_ros_namespace_conventions field is not resolved"]
    #[doc = "* with this function. The rcl function `rcl_subscription_get_actual_qos()`"]
    #[doc = "* resolves it."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe [1]"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] rmw implementation defined, check the implementation documentation</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] subscription the subscription object to inspect"]
    #[doc = "* \\param[out] qos the actual qos settings"]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if subscription"]
    #[doc = "* implementation identifier does not match, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_subscription_get_actual_qos(
        subscription: *const rmw_subscription_t,
        qos: *mut rmw_qos_profile_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Take an incoming ROS message."]
    #[doc = "* *"]
    #[doc = "* Take a ROS message already received by the given subscription, removing it from internal queues."]
    #[doc = "* This function will succeed even if no ROS message was received, but `taken` will be false."]
    #[doc = "* "]
    #[doc = "* \\remarks The same ROS message cannot be taken twice."]
    #[doc = "* Callers do not have to deal with duplicates."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* "]
    #[doc = "* <i>[1] implementation defined, check implementation documentation.</i>"]
    #[doc = "* "]
    #[doc = "* \\par Runtime behavior"]
    #[doc = "* To take a ROS message is a synchronous operation."]
    #[doc = "* It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,"]
    #[doc = "* but it is not guaranteed to be lock-free."]
    #[doc = "* Generally speaking, implementations may synchronize access to internal resources using"]
    #[doc = "* locks but are not allowed to wait for events with no guaranteed time bound (barring"]
    #[doc = "* the effects of starvation due to OS scheduling)."]
    #[doc = "* "]
    #[doc = "* \\par Memory allocation"]
    #[doc = "* It is implementation defined whether memory will be allocated on take or not."]
    #[doc = "* For instance, implementations that deserialize ROS messages received over"]
    #[doc = "* the wire may need to perform additional memory allocations when dealing with"]
    #[doc = "* unbounded (dynamically-sized) fields."]
    #[doc = "* A subscription allocation, if provided, may or may not be used."]
    #[doc = "* Check the implementation documentation to learn about memory allocation"]
    #[doc = "* guarantees when taking ROS messages with and without subscription allocations."]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Subscriptions are thread-safe objects, and so are all operations on them except for"]
    #[doc = "* finalization."]
    #[doc = "* Therefore, it is safe to take from the same subscription concurrently."]
    #[doc = "* However, when taking regular ROS messages:"]
    #[doc = "* - Access to the given ROS message is not synchronized."]
    #[doc = "* It is not safe to read or write `ros_message` while rmw_take() uses it."]
    #[doc = "* - Access to given primitive data-type arguments is not synchronized."]
    #[doc = "* It is not safe to read or write `taken` while rmw_take() uses it."]
    #[doc = "* - Access to the given subscription allocation is not synchronized,"]
    #[doc = "* unless specifically stated otherwise by the implementation."]
    #[doc = "* Thus, it is generally not safe to read or write `allocation` while rmw_take() uses it."]
    #[doc = "* Check the implementation documentation to learn about subscription allocations'"]
    #[doc = "* thread-safety."]
    #[doc = "* "]
    #[doc = "* \\pre Given `subscription` must be a valid subscription, as returned"]
    #[doc = "* by rmw_create_subscription()."]
    #[doc = "* \\pre Given `ros_message` must be a valid message, whose type matches the message type support"]
    #[doc = "* registered with the `subscription` on creation."]
    #[doc = "* \\pre If not NULL, given `allocation` must be a valid subscription allocation initialized"]
    #[doc = "* with rmw_subscription_allocation_init() with a message type support that matches the"]
    #[doc = "* one registered with the `subscription` on creation."]
    #[doc = "* \\post Given `ros_message` will remain a valid message."]
    #[doc = "* It will be left unchanged if this function fails early due to a logical error, such as an"]
    #[doc = "* invalid argument, or in an unknown yet valid state if it fails due to a runtime error."]
    #[doc = "* It will also be left unchanged if this function succeeds but `taken` is false."]
    #[doc = "* "]
    #[doc = "* \\param[in] subscription Subscription to take message from."]
    #[doc = "* \\param[out] ros_message Type erased ROS message to write to."]
    #[doc = "* \\param[out] taken Boolean flag indicating if a ROS message was taken or not."]
    #[doc = "* \\param[in] allocation Pre-allocated memory to be used. May be NULL."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription`"]
    #[doc = "* implementation identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_take(
        subscription: *const rmw_subscription_t,
        ros_message: *mut ::std::os::raw::c_void,
        taken: *mut bool,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Take an incoming ROS message with its metadata."]
    #[doc = "* *"]
    #[doc = "* Same as rmw_take(), except it also takes ROS message metadata."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* "]
    #[doc = "* <i>[1] implementation defined, check implementation documentation.</i>"]
    #[doc = "* "]
    #[doc = "* \\par Runtime behavior"]
    #[doc = "* To take a ROS message with its metadata is a synchronous operation."]
    #[doc = "* It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,"]
    #[doc = "* but it is not guaranteed to be lock-free."]
    #[doc = "* Generally speaking, implementations may synchronize access to internal resources using"]
    #[doc = "* locks but are not allowed to wait for events with no guaranteed time bound (barring"]
    #[doc = "* the effects of starvation due to OS scheduling)."]
    #[doc = "* "]
    #[doc = "* \\par Memory allocation"]
    #[doc = "* It is implementation defined whether memory will be allocated on take or not."]
    #[doc = "* For instance, implementations that deserialize ROS messages received over"]
    #[doc = "* the wire may need to perform additional memory allocations when dealing with"]
    #[doc = "* unbounded (dynamically-sized) fields."]
    #[doc = "* A subscription allocation, if provided, may or may not be used."]
    #[doc = "* Check the implementation documentation to learn about memory allocation"]
    #[doc = "* guarantees when taking ROS messages with and without subscription allocations."]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Subscriptions are thread-safe objects, and so are all operations on them except for"]
    #[doc = "* finalization."]
    #[doc = "* Therefore, it is safe to take from the same subscription concurrently."]
    #[doc = "* However, when taking regular ROS messages with metadata:"]
    #[doc = "* - Access to the given ROS message is not synchronized."]
    #[doc = "* It is not safe to read or write `ros_message` while rmw_take_with_info() uses it."]
    #[doc = "* - Access to given primitive data-type arguments is not synchronized."]
    #[doc = "* It is not safe to read or write `taken` while rmw_take_with_info() uses it."]
    #[doc = "* - Access to the given ROS message metadata is not synchronized."]
    #[doc = "* It is not safe to read or write `message_info` while rmw_take_with_info() uses it."]
    #[doc = "* - Access to the given subscription allocation is not synchronized,"]
    #[doc = "* unless specifically stated otherwise by the implementation."]
    #[doc = "* Thus, it is generally not safe to read or write `allocation` while rmw_take_with_info()"]
    #[doc = "* uses it."]
    #[doc = "* Check the implementation documentation to learn about subscription allocations'"]
    #[doc = "* thread-safety."]
    #[doc = "* "]
    #[doc = "* \\pre Given `subscription` must be a valid subscription, as returned"]
    #[doc = "* by rmw_create_subscription()."]
    #[doc = "* \\pre Given `ros_message` must be a valid message, whose type matches"]
    #[doc = "* the message type support registered with the `subscription` on creation."]
    #[doc = "* \\pre If not NULL, given `allocation` must be a valid subscription allocation"]
    #[doc = "* initialized with rmw_subscription_allocation_init() with a message type support"]
    #[doc = "* that matches the one registered with the `subscription` on creation."]
    #[doc = "* \\post Given `ros_message` will remain a valid message, and"]
    #[doc = "* `message_info`, valid message metadata."]
    #[doc = "* Both will be left unchanged if this function fails early due to a logical error, such as"]
    #[doc = "* an invalid argument, or in an unknown yet valid state if it fails due to a runtime error."]
    #[doc = "* Both will also be left unchanged if this function succeeds but `taken` is false."]
    #[doc = "* "]
    #[doc = "* \\param[in] subscription Subscription to take ROS message from."]
    #[doc = "* \\param[out] ros_message Type erased ROS message to write to."]
    #[doc = "* \\param[out] taken Boolean flag indicating if a ROS message was taken or not."]
    #[doc = "* \\param[out] message_info Taken ROS message metadata."]
    #[doc = "* \\param[in] allocation Pre-allocated memory to be used. May be NULL."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `message_info` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription`"]
    #[doc = "* implementation identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_take_with_info(
        subscription: *const rmw_subscription_t,
        ros_message: *mut ::std::os::raw::c_void,
        taken: *mut bool,
        message_info: *mut rmw_message_info_t,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Take multiple incoming ROS messages with their metadata."]
    #[doc = "* *"]
    #[doc = "* Take a sequence of consecutive ROS messages already received by the given"]
    #[doc = "* subscription, removing them from internal queues."]
    #[doc = "* While `count` ROS messages may be requested, fewer messages may have been"]
    #[doc = "* received by the subscription."]
    #[doc = "* This function will only take what has been already received, and it will"]
    #[doc = "* succeed even if fewer (or zero) messages were received."]
    #[doc = "* In this case, only currently available messages will be returned."]
    #[doc = "* The `taken` output variable indicates the number of ROS messages actually taken."]
    #[doc = "* "]
    #[doc = "* \\remarks Once taken, ROS messages in the sequence cannot be taken again."]
    #[doc = "* Callers do not have to deal with duplicates."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* "]
    #[doc = "* <i>[1] implementation defined, check implementation documentation.</i>"]
    #[doc = "* "]
    #[doc = "* \\par Runtime behavior"]
    #[doc = "* To take a sequence of ROS messages is a synchronous operation."]
    #[doc = "* It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,"]
    #[doc = "* but it is not guaranteed to be lock-free."]
    #[doc = "* Generally speaking, implementations may synchronize access to internal resources using"]
    #[doc = "* locks but are not allowed to wait for events with no guaranteed time bound (barring"]
    #[doc = "* the effects of starvation due to OS scheduling)."]
    #[doc = "* "]
    #[doc = "* \\par Memory allocation"]
    #[doc = "* It is implementation defined whether memory will be allocated on take or not."]
    #[doc = "* For instance, implementations that deserialize ROS messages received over"]
    #[doc = "* the wire may need to perform additional memory allocations when dealing with"]
    #[doc = "* unbounded (dynamically-sized) fields."]
    #[doc = "* A subscription allocation, if provided, may or may not be used."]
    #[doc = "* Check the implementation documentation to learn about memory allocation"]
    #[doc = "* guarantees when taking ROS messages with and without subscription allocations."]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Subscriptions are thread-safe objects, and so are all operations on them except for"]
    #[doc = "* finalization."]
    #[doc = "* Therefore, it is safe to take from the same subscription concurrently."]
    #[doc = "* Moreover, the sequence of ROS messages taken is guaranteed to be consecutive and to"]
    #[doc = "* preserve the order in the subscription queues, despite any concurrent takes."]
    #[doc = "* However, when taking a sequence of ROS messages with metadata:"]
    #[doc = "* - Access to the given ROS message sequence is not synchronized."]
    #[doc = "* It is not safe to read or write `message_sequence` while rmw_take_sequence() uses it."]
    #[doc = "* - Access to the given ROS message metadata sequence is not synchronized."]
    #[doc = "* It is not safe to read or write `message_info_sequence` while rmw_take_sequence() uses it."]
    #[doc = "* - Access to given primitive data-type arguments is not synchronized."]
    #[doc = "* It is not safe to read or write `taken` while rmw_take_sequence() uses it."]
    #[doc = "* - Access to the given subscription allocation is not synchronized,"]
    #[doc = "* unless specifically stated otherwise by the implementation."]
    #[doc = "* Thus, it is generally not safe to read or write `allocation` while rmw_take_sequence()"]
    #[doc = "* uses it."]
    #[doc = "* Check the implementation documentation to learn about subscription allocations'"]
    #[doc = "* thread-safety."]
    #[doc = "* "]
    #[doc = "* \\pre Given `subscription` must be a valid subscription, as returned"]
    #[doc = "* by rmw_create_subscription()."]
    #[doc = "* \\pre Given `message_sequence` must be a valid message sequence, initialized"]
    #[doc = "* by rmw_message_sequence_init() and populated with ROS messages whose"]
    #[doc = "* type matches the message type support registered with the `subscription`"]
    #[doc = "* on creation."]
    #[doc = "* \\pre Given `message_info_sequence` must be a valid message metadata sequence,"]
    #[doc = "* initialized by rmw_message_info_sequence_init()."]
    #[doc = "* \\pre If not NULL, given `allocation` must be a valid subscription allocation initialized"]
    #[doc = "* with rmw_subscription_allocation_init() with a message type support that matches the"]
    #[doc = "* one registered with `subscription` on creation."]
    #[doc = "* \\post Given `message_sequence` will remain a valid message sequence, and"]
    #[doc = "* `message_info_sequence`, a valid message metadata sequence."]
    #[doc = "* Both will be left unchanged if this function fails early due to a logical error, such as"]
    #[doc = "* an invalid argument, or in an unknown yet valid state if it fails due to a runtime error."]
    #[doc = "* Both will also be left unchanged if this function succeeds but `taken` is zero."]
    #[doc = "* "]
    #[doc = "* \\param[in] subscription Subscription to take ROS message from."]
    #[doc = "* \\param[in] count Number of messages to attempt to take."]
    #[doc = "* \\param[out] message_sequence Sequence of type erase ROS messages to write to."]
    #[doc = "* Message sequence capacity has to be enough to hold all requested messages"]
    #[doc = "* i.e. capacity has to be equal or greater than `count`."]
    #[doc = "* It does not have to match that of `message_info_sequence`."]
    #[doc = "* \\param[out] message_info_sequence Sequence of additional message metadata."]
    #[doc = "* Message info sequence capacity has to be enough to hold all requested messages"]
    #[doc = "* metadata i.e. capacity has to be equal or greater than `count`."]
    #[doc = "* It does not have to match that of `message_sequence`."]
    #[doc = "* \\param[out] taken Number of messages actually taken from subscription."]
    #[doc = "* \\param[in] allocation Pre-allocated memory to use. May be NULL."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `message_sequence` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `message_info_sequence` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `count` is 0, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `message_sequence` capacity is less than `count`, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `message_info_sequence` capacity is less than `count`, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation"]
    #[doc = "* identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_take_sequence(
        subscription: *const rmw_subscription_t,
        count: size_t,
        message_sequence: *mut rmw_message_sequence_t,
        message_info_sequence: *mut rmw_message_info_sequence_t,
        taken: *mut size_t,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Take an incoming ROS message as a byte stream."]
    #[doc = "* *"]
    #[doc = "* Take a ROS message already received by the given subscription, removing it from internal queues."]
    #[doc = "* This function will succeed even if no ROS message was received, but `taken` will be false."]
    #[doc = "* Unlike rmw_take(), the ROS message is taken in its serialized form, as a byte stream."]
    #[doc = "* If needed, this byte stream can then be deserialized into a ROS message with rmw_deserialize()."]
    #[doc = "* "]
    #[doc = "* \\remarks The same ROS message, serialized or not, cannot be taken twice."]
    #[doc = "* Callers do not have to deal with duplicates."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* "]
    #[doc = "* <i>[1] implementation defined, check implementation documentation.</i>"]
    #[doc = "* "]
    #[doc = "* \\par Runtime behavior"]
    #[doc = "* To take a ROS message a byte stream is a synchronous operation."]
    #[doc = "* It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,"]
    #[doc = "* but it is not guaranteed to be lock-free."]
    #[doc = "* Generally speaking, implementations may synchronize access to internal resources using"]
    #[doc = "* locks but are not allowed to wait for events with no guaranteed time bound (barring"]
    #[doc = "* the effects of starvation due to OS scheduling)."]
    #[doc = "* "]
    #[doc = "* \\par Memory allocation"]
    #[doc = "* It is implementation defined whether memory will be allocated on take or not."]
    #[doc = "* For instance, implementations may have to perform additional memory allocations"]
    #[doc = "* when dealing with ROS messages that contain unbounded (dynamically-sized) fields"]
    #[doc = "* i.e. these implementations may have to resize the given byte stream."]
    #[doc = "* A subscription allocation, if provided, may or may not be used."]
    #[doc = "* Check the implementation documentation to learn about memory allocation guarantees"]
    #[doc = "* when taking serialized ROS messages with and without subscription allocations."]
    #[doc = "* \\par"]
    #[doc = "* For ROS messages that only contain bounded (fixed-size) fields, callers can query"]
    #[doc = "* their size using rmw_get_serialized_message_size() and resize `serialized_message`"]
    #[doc = "* using rmw_serialized_message_resize() accordingly to prevent byte stream resizing"]
    #[doc = "* on take."]
    #[doc = "* Nonetheless, byte stream resizing is not guaranteed to be the sole memory operation."]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Subscriptions are thread-safe objects, and so are all operations on them except for"]
    #[doc = "* finalization."]
    #[doc = "* Therefore, it is safe to take from the same subscription concurrently."]
    #[doc = "* However, when taking serialized ROS messages:"]
    #[doc = "* - Access to the given byte stream for serialized ROS messages is not synchronized."]
    #[doc = "* It is not safe to read or write `serialized_message` while"]
    #[doc = "* rmw_take_serialized_message() uses it."]
    #[doc = "* - Access to given primitive data-type arguments is not synchronized."]
    #[doc = "* It is not safe to read or write `taken` while rmw_take_serialized_message() uses it."]
    #[doc = "* - Access to the given subscription allocation is not synchronized,"]
    #[doc = "* unless specifically stated otherwise by the implementation."]
    #[doc = "* Thus, it is generally not safe to read or write `allocation` while"]
    #[doc = "* rmw_take_serialized_message() uses it."]
    #[doc = "* Check the implementation documentation to learn about subscription allocations'"]
    #[doc = "* thread-safety."]
    #[doc = "* "]
    #[doc = "* \\pre Given `subscription` must be a valid subscription, as returned by"]
    #[doc = "* rmw_create_subscription()."]
    #[doc = "* \\pre Given `serialized_message` must be a valid serialized message, initialized by"]
    #[doc = "* rmw_serialized_message_init()."]
    #[doc = "* \\pre If not NULL, given `allocation` must be a valid subscription allocation initialized"]
    #[doc = "* with rmw_subscription_allocation_init() with a message type support that matches the"]
    #[doc = "* one registered with `subscription` on creation."]
    #[doc = "* \\post Given `serialized_message` will remain a valid serialized message."]
    #[doc = "* It will be left unchanged if this function fails early due to a logical error,"]
    #[doc = "* such as an invalid argument, or in an unknown yet valid state if it fails due to a"]
    #[doc = "* runtime error."]
    #[doc = "* It will also be left unchanged if this function succeeds but `taken` is false."]
    #[doc = "* "]
    #[doc = "* \\param[in] subscription Subscription to take ROS message from."]
    #[doc = "* \\param[out] serialized_message Byte stream to write to."]
    #[doc = "* \\param[out] taken Boolean flag indicating if a ROS message was taken or not."]
    #[doc = "* \\param[in] allocation Pre-allocated memory to use. May be NULL."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `serialized_message` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation"]
    #[doc = "* identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_take_serialized_message(
        subscription: *const rmw_subscription_t,
        serialized_message: *mut rmw_serialized_message_t,
        taken: *mut bool,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Take an incoming ROS message as a byte stream with its metadata."]
    #[doc = "* *"]
    #[doc = "* Same as rmw_take_serialized_message(), except it also takes ROS message metadata."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* "]
    #[doc = "* <i>[1] implementation defined, check implementation documentation.</i>"]
    #[doc = "* "]
    #[doc = "* \\par Runtime behavior"]
    #[doc = "* To take a ROS message a byte stream with its metadata is a synchronous operation."]
    #[doc = "* It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,"]
    #[doc = "* but it is not guaranteed to be lock-free."]
    #[doc = "* Generally speaking, implementations may synchronize access to internal resources using"]
    #[doc = "* locks but are not allowed to wait for events with no guaranteed time bound (barring"]
    #[doc = "* the effects of starvation due to OS scheduling)."]
    #[doc = "* "]
    #[doc = "* \\par Memory allocation"]
    #[doc = "* It is implementation defined whether memory will be allocated on take or not."]
    #[doc = "* For instance, implementations may have to perform additional memory allocations"]
    #[doc = "* when dealing with ROS messages that contain unbounded (dynamically-sized) fields"]
    #[doc = "* i.e. these implementations may have to resize the given byte stream."]
    #[doc = "* A subscription allocation, if provided, may or may not be used."]
    #[doc = "* Check the implementation documentation to learn about memory allocation guarantees"]
    #[doc = "* when taking serialized ROS messages with and without subscription allocations."]
    #[doc = "* \\par"]
    #[doc = "* For ROS messages that only contain bounded (fixed-size) fields, callers can query"]
    #[doc = "* their size using rmw_get_serialized_message_size() and resize `serialized_message`"]
    #[doc = "* using rmw_serialized_message_resize() accordingly to prevent byte stream resizing"]
    #[doc = "* on take."]
    #[doc = "* Nonetheless, byte stream resizing is not guaranteed to be the sole memory operation."]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Subscriptions are thread-safe objects, and so are all operations on them except for"]
    #[doc = "* finalization."]
    #[doc = "* Therefore, it is safe to take from the same subscription concurrently."]
    #[doc = "* However, when taking serialized ROS messages with metadata:"]
    #[doc = "* - Access to the given byte stream for serialized ROS messages is not synchronized."]
    #[doc = "* It is not safe to read or write `serialized_message` while"]
    #[doc = "* rmw_take_serialized_message_with_info() uses it."]
    #[doc = "* - Access to the given ROS message metadata is not synchronized."]
    #[doc = "* It is not safe to read or write `message_info` while"]
    #[doc = "* rmw_take_serialized_message_with_info() uses it."]
    #[doc = "* - Access to given primitive data-type arguments is not synchronized."]
    #[doc = "* It is not safe to read or write `taken` while rmw_take_serialized_message_with_info()"]
    #[doc = "* uses it."]
    #[doc = "* - Access to the given subscription allocation is not synchronized,"]
    #[doc = "* unless specifically stated otherwise by the implementation."]
    #[doc = "* Thus, it is generally not safe to read or write `allocation` while"]
    #[doc = "* rmw_take_serialized_message_with_info() uses it."]
    #[doc = "* Check the implementation documentation to learn about subscription allocations'"]
    #[doc = "* thread-safety."]
    #[doc = "* "]
    #[doc = "* \\pre Given `serialized_message` must be a valid serialized message, initialized by"]
    #[doc = "* rmw_serialized_message_init()."]
    #[doc = "* \\pre If not NULL, given `allocation` must be a valid subscription allocation initialized"]
    #[doc = "* with rmw_subscription_allocation_init() with a message type support that matches the"]
    #[doc = "* one registered with `subscription` on creation."]
    #[doc = "* \\post Given `serialized_message` will remain a valid serialized message, and `message_info`,"]
    #[doc = "* valid message metadata."]
    #[doc = "* Both will be left unchanged if this function fails early due to a logical error,"]
    #[doc = "* such as an invalid argument, or in an unknown yet valid state if it fails due to a"]
    #[doc = "* runtime error."]
    #[doc = "* It will also be left unchanged if this function succeeds but `taken` is false."]
    #[doc = "* "]
    #[doc = "* \\param[in] subscription Subscription to take ROS message from."]
    #[doc = "* \\param[out] serialized_message Byte stream to write to."]
    #[doc = "* \\param[out] taken Boolean flag indicating if a ROS message was taken or not."]
    #[doc = "* \\param[out] message_info Taken ROS message metadata."]
    #[doc = "* \\param[in] allocation Pre-allocated memory to use. May be NULL."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `serialized_message` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `message_info` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation"]
    #[doc = "* identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_take_serialized_message_with_info(
        subscription: *const rmw_subscription_t,
        serialized_message: *mut rmw_serialized_message_t,
        taken: *mut bool,
        message_info: *mut rmw_message_info_t,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Take an incoming ROS message, loaned by the middleware."]
    #[doc = "* *"]
    #[doc = "* Take a ROS message already received by the given subscription, removing it from internal queues."]
    #[doc = "* This function will succeed even if no ROS message was received, but `taken` will be false."]
    #[doc = "* The loaned ROS message is owned by the middleware, which will keep it alive (i.e. in valid"]
    #[doc = "* memory space) until the caller returns it using rmw_return_loaned_message_from_subscription()."]
    #[doc = "* "]
    #[doc = "* \\remarks The same ROS message, loaned or not, cannot be taken twice."]
    #[doc = "* Callers do not have to deal with duplicates."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* "]
    #[doc = "* <i>[1] implementation defined, check implementation documentation.</i>"]
    #[doc = "* "]
    #[doc = "* \\par Runtime behavior"]
    #[doc = "* To take a loaned ROS message is a synchronous operation."]
    #[doc = "* It is also non-blocking, to the extent it will not wait for new ROS messages to arrive"]
    #[doc = "* nor for internal memory loaning pools, if any, to be replenished, but it is not"]
    #[doc = "* guaranteed to be lock-free."]
    #[doc = "* Generally speaking, implementations may synchronize access to internal resources using"]
    #[doc = "* locks but are not allowed to wait for events with no guaranteed time bound (barring"]
    #[doc = "* the effects of starvation due to OS scheduling)."]
    #[doc = "* "]
    #[doc = "* \\par Memory allocation"]
    #[doc = "* It is implementation defined whether memory will be allocated on take or not."]
    #[doc = "* For instance, implementations that deserialize ROS messages received over"]
    #[doc = "* the wire may need to perform additional memory allocations when dealing with"]
    #[doc = "* unbounded (dynamically-sized) fields."]
    #[doc = "* A subscription allocation, if provided, may or may not be used."]
    #[doc = "* Check the implementation documentation to learn about memory allocation"]
    #[doc = "* guarantees when taking loaned ROS messages with and without subscription allocations."]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Subscriptions are thread-safe objects, and so are all operations on them except for"]
    #[doc = "* finalization."]
    #[doc = "* Therefore, it is safe to take from the same subscription concurrently."]
    #[doc = "* However, when taking loaned ROS messages:"]
    #[doc = "* - Access to given primitive data-type arguments is not synchronized."]
    #[doc = "* It is not safe to read or write `taken` nor `loaned_message`"]
    #[doc = "* while rmw_take_loaned_message() uses them."]
    #[doc = "* - Access to the given subscription allocation is not synchronized,"]
    #[doc = "* unless specifically stated otherwise by the implementation."]
    #[doc = "* Thus, it is generally not safe to read or write `allocation` while"]
    #[doc = "* rmw_take_loaned_message() uses it."]
    #[doc = "* Check the implementation documentation to learn about subscription allocations'"]
    #[doc = "* thread-safety."]
    #[doc = "* "]
    #[doc = "* \\pre Given `subscription` must be a valid subscription, as returned"]
    #[doc = "* by rmw_create_subscription()."]
    #[doc = "* \\pre If not NULL, given `allocation` must be a valid subscription allocation initialized"]
    #[doc = "* with rmw_subscription_allocation_init() with a message type support that matches the"]
    #[doc = "* one registered with `subscription` on creation."]
    #[doc = "* \\post Given `loaned_message` will remain unchanged, or point to a valid message if"]
    #[doc = "* this function was successful and `taken` is true."]
    #[doc = "* "]
    #[doc = "* \\param[in] subscription Subscription to take ROS message from."]
    #[doc = "* \\param[inout] loaned_message Pointer to type erased ROS message taken"]
    #[doc = "* and loaned by the middleware."]
    #[doc = "* \\param[out] taken Boolean flag indicating if a ROS message was taken or not."]
    #[doc = "* \\param[in] allocation Pre-allocated memory to use. May be NULL."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `loaned_message` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `*loaned_message` is not NULL (to prevent leaks), or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation"]
    #[doc = "* identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_UNSUPPORTED` if the implementation does not support loaned ROS messages, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_take_loaned_message(
        subscription: *const rmw_subscription_t,
        loaned_message: *mut *mut ::std::os::raw::c_void,
        taken: *mut bool,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Take a loaned message and with its additional message information."]
    #[doc = "* *"]
    #[doc = "* Same as rmw_take_loaned_message(), except it also takes ROS message metadata."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* "]
    #[doc = "* <i>[1] implementation defined, check implementation documentation.</i>"]
    #[doc = "* "]
    #[doc = "* \\par Runtime behavior"]
    #[doc = "* To take a loaned ROS message with its metadata is a synchronous operation."]
    #[doc = "* It is also non-blocking, to the extent it will not wait for new ROS messages to arrive"]
    #[doc = "* nor for internal memory loaning pools, if any, to be replenished, but it is not"]
    #[doc = "* guaranteed to be lock-free."]
    #[doc = "* Generally speaking, implementations may synchronize access to internal resources using"]
    #[doc = "* locks but are not allowed to wait for events with no guaranteed time bound (barring"]
    #[doc = "* the effects of starvation due to OS scheduling)."]
    #[doc = "* "]
    #[doc = "* \\par Memory allocation"]
    #[doc = "* It is implementation defined whether memory will be allocated on take or not."]
    #[doc = "* For instance, implementations that deserialize ROS messages received over"]
    #[doc = "* the wire may need to perform additional memory allocations when dealing with"]
    #[doc = "* unbounded (dynamically-sized) fields."]
    #[doc = "* A subscription allocation, if provided, may or may not be used."]
    #[doc = "* Check the implementation documentation to learn about memory allocation"]
    #[doc = "* guarantees when taking loaned ROS messages with and without subscription allocations."]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Subscriptions are thread-safe objects, and so are all operations on them except for"]
    #[doc = "* finalization."]
    #[doc = "* Therefore, it is safe to take from the same subscription concurrently."]
    #[doc = "* However, when taking loaned ROS messages with metadata:"]
    #[doc = "* - Access to given primitive data-type arguments is not synchronized."]
    #[doc = "* It is not safe to read or write `taken` nor `loaned_message`"]
    #[doc = "* while rmw_take_loaned_message_with_info() uses them."]
    #[doc = "* - Access to the given ROS message metadata is not synchronized."]
    #[doc = "* It is not safe to read or write `message_info` while"]
    #[doc = "* rmw_take_loaned_message_with_info() uses it."]
    #[doc = "* - Access to the given subscription allocation is not synchronized,"]
    #[doc = "* unless specifically stated otherwise by the implementation."]
    #[doc = "* Thus, it is generally not safe to read or write `allocation` while"]
    #[doc = "* rmw_take_loaned_message_with_info() uses it."]
    #[doc = "* Check the implementation documentation to learn about subscription allocations'"]
    #[doc = "* thread-safety."]
    #[doc = "* "]
    #[doc = "* \\pre Given `subscription` must be a valid subscription, as returned"]
    #[doc = "* by rmw_create_subscription()."]
    #[doc = "* \\pre If not NULL, given `allocation` must be a valid subscription allocation initialized"]
    #[doc = "* with rmw_subscription_allocation_init() with a message type support that matches the"]
    #[doc = "* one registered with `subscription` on creation."]
    #[doc = "* \\post Given `loaned_message` will remain unchanged, or point to a valid message if"]
    #[doc = "* this function was successful and `taken` is true."]
    #[doc = "* \\post Given `message_info` will remain valid message metadata."]
    #[doc = "* It will be left unchanged if this function fails early due to a logical error,"]
    #[doc = "* such as an invalid argument, or in an unknown yet valid state if it fails due to a"]
    #[doc = "* runtime error."]
    #[doc = "* It will also be left unchanged if this function succeeds but `taken` is false."]
    #[doc = "* "]
    #[doc = "* \\param[in] subscription Subscription to take ROS message from."]
    #[doc = "* \\param[inout] loaned_message Pointer to type erased ROS message taken"]
    #[doc = "* and loaned by the middleware."]
    #[doc = "* \\param[out] taken Boolean flag indicating if a ROS message was taken or not."]
    #[doc = "* \\param[out] message_info Taken ROS message metadata."]
    #[doc = "* \\param[in] allocation Pre-allocated memory to use. May be NULL."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `loaned_message` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `*loaned_message` is not NULL to prevent leaks, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `message_info` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation"]
    #[doc = "* identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_UNSUPPORTED` if the implementation does not support loaned ROS messages, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_take_loaned_message_with_info(
        subscription: *const rmw_subscription_t,
        loaned_message: *mut *mut ::std::os::raw::c_void,
        taken: *mut bool,
        message_info: *mut rmw_message_info_t,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Return a loaned ROS message previously taken from a subscription."]
    #[doc = "* *"]
    #[doc = "* Tells the middleware that previously loaned ROS message is no longer needed by the caller."]
    #[doc = "* If this function fails early due to a logical error, such as an invalid argument,"]
    #[doc = "* the loaned ROS message will be left unchanged."]
    #[doc = "* Otherwise, ownership of the ROS message will be given back to the middleware."]
    #[doc = "* It is up to the middleware what will be made of the returned ROS message."]
    #[doc = "* It is undefined behavior to use a loaned ROS message after returning it."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* "]
    #[doc = "* <i>[1] implementation defined, check implementation documentation.</i>"]
    #[doc = "* "]
    #[doc = "* \\par Runtime behavior"]
    #[doc = "* To return a loaned ROS message is a synchronous operation."]
    #[doc = "* It is also non-blocking, but it is not guaranteed to be lock-free."]
    #[doc = "* Generally speaking, implementations may synchronize access to internal resources using"]
    #[doc = "* locks but are not allowed to wait for events with no guaranteed time bound (barring"]
    #[doc = "* the effects of starvation due to OS scheduling)."]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Subscriptions are thread-safe objects, and so are all operations on them except for"]
    #[doc = "* finalization."]
    #[doc = "* Therefore, it is safe to return loaned ROS messages to the same subscription concurrently."]
    #[doc = "* However, since ownership of the loaned ROS message is given back to middleware and this"]
    #[doc = "* transfer is not synchronized, it is not safe to return the same loaned ROS message"]
    #[doc = "* concurrently."]
    #[doc = "* "]
    #[doc = "* \\pre Given `subscription` must be a valid subscription, as returned"]
    #[doc = "* by rmw_create_subscription()."]
    #[doc = "* \\pre Given `loaned_message` must be a loaned ROS message, previously taken from"]
    #[doc = "* `subscription` using rmw_take_loaned_message() or rmw_take_loaned_message_with_info()."]
    #[doc = "* "]
    #[doc = "* \\param[in] subscription Subscription the ROS message was taken and loaned from."]
    #[doc = "* \\param[in] loaned_message Loaned type erased ROS message to be returned to the middleware."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `loaned_message` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation"]
    #[doc = "* identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_UNSUPPORTED` if the implementation does not support loaned ROS messages, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_return_loaned_message_from_subscription(
        subscription: *const rmw_subscription_t,
        loaned_message: *mut ::std::os::raw::c_void,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Create a service client that can send requests to and receive replies from a service server."]
    #[doc = "* *"]
    #[doc = "* This function can fail, and therefore return `NULL`, if:"]
    #[doc = "* - `node` is `NULL`, or"]
    #[doc = "* - `node` does not belong to this implementation"]
    #[doc = "* i.e. it does not have a matching implementation identifier, or"]
    #[doc = "* - `type_support` is `NULL`, or"]
    #[doc = "* - `service_name` is `NULL`, or"]
    #[doc = "* - `service_name` is an empty string, or"]
    #[doc = "* - (if ROS namespace conventions apply) `service_name` is invalid by"]
    #[doc = "* rmw_validate_full_topic_name() definition, or"]
    #[doc = "* - `qos_profile` is `NULL`, or"]
    #[doc = "* - `qos_profile` has invalid or unknown policies, or"]
    #[doc = "* - memory allocation fails during service client creation, or"]
    #[doc = "* - an unspecified error occurs."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] rmw implementation defined, check the implementation documentation</i>"]
    #[doc = "* "]
    #[doc = "* \\pre Given `node` must be a valid node, as returned by rmw_create_node()."]
    #[doc = "* \\pre Given `type_support` must be a valid `rosidl` service type support, as"]
    #[doc = "* returned by ROSIDL_GET_SRV_TYPE_SUPPORT()."]
    #[doc = "* "]
    #[doc = "* \\param[in] node Node with which to register this service client."]
    #[doc = "* \\param[in] type_support Type support of the service to be used."]
    #[doc = "* \\param[in] service_name Name of the service to be used, often a fully qualified"]
    #[doc = "* service name unless `qos_profile` is configured to avoid ROS namespace conventions"]
    #[doc = "* i.e. to create a native service client."]
    #[doc = "* \\param[in] qos_profile QoS policies for this service client's connections."]
    #[doc = "* \\return rmw service client handle, or `NULL` if there was an error."]
    #[doc = "* /"]
    pub fn rmw_create_client(
        node: *const rmw_node_t,
        type_support: *const rosidl_service_type_support_t,
        service_name: *const ::std::os::raw::c_char,
        qos_policies: *const rmw_qos_profile_t,
    ) -> *mut rmw_client_t;
}
extern "C" {
    #[doc = " Destroy and unregister a service client from its node."]
    #[doc = "* *"]
    #[doc = "* This function will reclaim all associated resources, including the service client itself."]
    #[doc = "* Use of a destroyed service client is undefined behavior."]
    #[doc = "* This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`"]
    #[doc = "* or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given service client unchanged."]
    #[doc = "* Otherwise, it will proceed despite errors."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] rmw implementation defined, check the implementation documentation</i>"]
    #[doc = "* "]
    #[doc = "* \\pre Given `node` must be the one the service client was registered with."]
    #[doc = "* \\pre Given `client` must be a valid service client, as returned by rmw_create_service()."]
    #[doc = "* "]
    #[doc = "* \\param[in] node Node with which the given service client is registered."]
    #[doc = "* \\param[in] client Service client to be destroyed."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `node` is `NULL`, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `client` is `NULL`, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node`"]
    #[doc = "* implementation identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `client`"]
    #[doc = "* implementation identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rmw_destroy_client(node: *mut rmw_node_t, client: *mut rmw_client_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Send a ROS service request."]
    #[doc = "* *"]
    #[doc = "* Send a ROS service request to one or more service servers, with matching QoS policies,"]
    #[doc = "* using the given client."]
    #[doc = "* "]
    #[doc = "* \\note It is implementation defined how many service servers may get, and potentially react to,"]
    #[doc = "* the same request, considering there may be more than one server for the same service"]
    #[doc = "* in the ROS graph."]
    #[doc = "* "]
    #[doc = "* On success, this function will return a sequence number."]
    #[doc = "* It is up to callers to save the returned sequence number to pair the ROS service request"]
    #[doc = "* just sent with future ROS service responses (taken using rmw_take_response())."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* "]
    #[doc = "* <i>[1] implementation defined, check implementation documentation.</i>"]
    #[doc = "* "]
    #[doc = "* \\par Runtime behavior"]
    #[doc = "* It is implementation defined whether sending a ROS service request is a"]
    #[doc = "* synchronous or asynchronous, and blocking or non-blocking, operation."]
    #[doc = "* However, asynchronous implementations are not allowed to access the"]
    #[doc = "* given ROS service request after this function returns."]
    #[doc = "* Check the implementation documentation to learn about request behavior."]
    #[doc = "* "]
    #[doc = "* \\par Memory allocation"]
    #[doc = "* It is implementation defined whether memory will be allocated on send or not."]
    #[doc = "* For instance, implementations that serialize ROS service requests may need to"]
    #[doc = "* perform additional memory allocations when dealing with unbounded (dynamically-sized)"]
    #[doc = "* fields."]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Service clients are thread-safe objects, and so are all operations on them except for"]
    #[doc = "* finalization."]
    #[doc = "* Therefore, it is safe to send requests using the same service client concurrently."]
    #[doc = "* However:"]
    #[doc = "* - Access to the given ROS service request is read-only but it is not synchronized."]
    #[doc = "* Concurrent `ros_request` reads are safe, but concurrent reads and writes are not."]
    #[doc = "* - Access to given primitive data-type arguments is not synchronized."]
    #[doc = "* It is not safe to read or write `sequence_id` while rmw_send_request() uses it."]
    #[doc = "* "]
    #[doc = "* \\pre Given `client` must be a valid client, as returned by rmw_create_client()."]
    #[doc = "* \\pre Given `ros_request` must be a valid service request, whose type matches the"]
    #[doc = "* service type support registered with the `client` on creation."]
    #[doc = "* "]
    #[doc = "* \\param[in] client Service client to send a request with."]
    #[doc = "* \\param[in] ros_request ROS service request to be sent."]
    #[doc = "* \\param[out] sequence_id Sequence number for the `ros_request` just sent"]
    #[doc = "* i.e. a unique identification number for it, populated on success."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `client` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `ros_request` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `sequence_id` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `client`"]
    #[doc = "* implementation identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_send_request(
        client: *const rmw_client_t,
        ros_request: *const ::std::os::raw::c_void,
        sequence_id: *mut i64,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Take an incoming ROS service response."]
    #[doc = "* *"]
    #[doc = "* Take a ROS service response already received by the given service server, removing"]
    #[doc = "* it from internal queues."]
    #[doc = "* The response header (i.e. its metadata), containing at least the writer guid and"]
    #[doc = "* sequence number, is also retrieved."]
    #[doc = "* Both writer guid and sequence number allow callers to pair, potentially for each"]
    #[doc = "* remote service server, a ROS service response with its corresponding ROS service"]
    #[doc = "* request, previously sent using rmw_send_request()."]
    #[doc = "* "]
    #[doc = "* \\note It is implementation defined how many responses a given request may get,"]
    #[doc = "* considering there may be more than one server for the same service in the ROS graph."]
    #[doc = "* "]
    #[doc = "* This function will succeed even if no ROS service request was received,"]
    #[doc = "* but `taken` will be false."]
    #[doc = "* "]
    #[doc = "* \\remarks The same ROS service response cannot be taken twice."]
    #[doc = "* Callers do not have to deal with duplicates."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* "]
    #[doc = "* <i>[1] implementation defined, check implementation documentation.</i>"]
    #[doc = "* "]
    #[doc = "* \\par Runtime behavior"]
    #[doc = "* Taking a ROS service response is a synchronous operation."]
    #[doc = "* It is also non-blocking, to the extent it will not wait for new ROS service responses"]
    #[doc = "* to arrive, but it is not guaranteed to be lock-free."]
    #[doc = "* Generally speaking, implementations may synchronize access to internal resources using"]
    #[doc = "* locks but are not allowed to wait for events with no guaranteed time bound (barring"]
    #[doc = "* the effects of starvation due to OS scheduling)."]
    #[doc = "* "]
    #[doc = "* \\par Memory allocation"]
    #[doc = "* It is implementation defined whether memory will be allocated on take or not."]
    #[doc = "* For instance, implementations that deserialize ROS service responses received over"]
    #[doc = "* the wire may need to perform additional memory allocations when dealing with"]
    #[doc = "* unbounded (dynamically-sized) fields."]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Service clients are thread-safe objects, and so are all operations on them except for"]
    #[doc = "* finalization."]
    #[doc = "* Therefore, it is safe to take responses from the same service client concurrently."]
    #[doc = "* However:"]
    #[doc = "* - Access to the given ROS service response is not synchronized."]
    #[doc = "* It is not safe to read or write `ros_response` while rmw_take_request() uses it."]
    #[doc = "* - Access to the given ROS service response header is not synchronized."]
    #[doc = "* It is not safe to read or write `response_header` while rmw_take_response() uses it."]
    #[doc = "* - Access to given primitive data-type arguments is not synchronized."]
    #[doc = "* It is not safe to read or write `taken` while rmw_take_response() uses it."]
    #[doc = "* "]
    #[doc = "* \\pre Given `client` must be a valid client, as returned by rmw_create_client()."]
    #[doc = "* \\pre Given `ros_response` must be a valid service response, whose type matches the"]
    #[doc = "* service type support registered with the `client` on creation."]
    #[doc = "* \\post Given `ros_response` will remain a valid service response."]
    #[doc = "* It will be left unchanged if this function fails early due to a logical error, such as an"]
    #[doc = "* invalid argument, or in an unknown yet valid state if it fails due to a runtime error."]
    #[doc = "* It will also be left unchanged if this function succeeds but `taken` is false."]
    #[doc = "* "]
    #[doc = "* \\param[in] client Service client to take response from."]
    #[doc = "* \\param[out] response_header Service response header to write to."]
    #[doc = "* \\param[out] ros_request Type erased ROS service response to write to."]
    #[doc = "* \\param[out] taken Boolean flag indicating if a ROS service response was taken or not."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `client` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `response_header` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `ros_response` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `client`"]
    #[doc = "* implementation identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_take_response(
        client: *const rmw_client_t,
        request_header: *mut rmw_service_info_t,
        ros_response: *mut ::std::os::raw::c_void,
        taken: *mut bool,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Create a service server that can receive requests from and send replies to a service client."]
    #[doc = "* *"]
    #[doc = "* This function can fail, and therefore return `NULL`, if:"]
    #[doc = "* - `node` is `NULL`, or"]
    #[doc = "* - `node` does not belong to this implementation"]
    #[doc = "* i.e. it does not have a matching implementation identifier, or"]
    #[doc = "* - `type_support` is `NULL`, or"]
    #[doc = "* - `service_name` is `NULL`, or"]
    #[doc = "* - `service_name` is an empty string, or"]
    #[doc = "* - (if ROS namespace conventions apply) `service_name` is invalid by"]
    #[doc = "* rmw_validate_full_topic_name() definition, or"]
    #[doc = "* - `qos_profile` is `NULL`, or"]
    #[doc = "* - `qos_profile` has invalid or unknown policies, or"]
    #[doc = "* - memory allocation fails during service server creation, or"]
    #[doc = "* - an unspecified error occurs"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] rmw implementation defined, check the implementation documentation</i>"]
    #[doc = "* "]
    #[doc = "* \\pre Given `node` must be a valid node, as returned by rmw_create_node()."]
    #[doc = "* \\pre Given `type_support` must be a valid `rosidl` service type support, as"]
    #[doc = "* returned by ROSIDL_GET_SRV_TYPE_SUPPORT()."]
    #[doc = "* "]
    #[doc = "* \\param[in] node Node with which to register this service server."]
    #[doc = "* \\param[in] type_support Type support of the service to be served."]
    #[doc = "* \\param[in] service_name Name of the service to be served, often a fully qualified"]
    #[doc = "* service name unless `qos_profile` is configured to avoid ROS namespace conventions"]
    #[doc = "* i.e. to create a native service server."]
    #[doc = "* \\param[in] qos_profile QoS policies for this service server's connections."]
    #[doc = "* \\return rmw service handle, or `NULL` if there was an error."]
    #[doc = "* /"]
    pub fn rmw_create_service(
        node: *const rmw_node_t,
        type_support: *const rosidl_service_type_support_t,
        service_name: *const ::std::os::raw::c_char,
        qos_profile: *const rmw_qos_profile_t,
    ) -> *mut rmw_service_t;
}
extern "C" {
    #[doc = " Destroy and unregister a service server from its node."]
    #[doc = "* *"]
    #[doc = "* This function will reclaim all associated resources, including the service server itself."]
    #[doc = "* Use of a destroyed service server is undefined behavior."]
    #[doc = "* This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`"]
    #[doc = "* or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given service server unchanged."]
    #[doc = "* Otherwise, it will proceed despite errors."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] rmw implementation defined, check the implementation documentation</i>"]
    #[doc = "* "]
    #[doc = "* \\pre Given `node` must be the one the service server was registered with."]
    #[doc = "* \\pre Given `service` must be a valid service server, as returned by rmw_create_service()."]
    #[doc = "* "]
    #[doc = "* \\param[in] node Node with which the given service server is registered."]
    #[doc = "* \\param[in] service Service server to be destroyed."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `node` is `NULL`, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `service` is `NULL`, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node`"]
    #[doc = "* implementation identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `service`"]
    #[doc = "* implementation identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rmw_destroy_service(node: *mut rmw_node_t, service: *mut rmw_service_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Take an incoming ROS service request."]
    #[doc = "* *"]
    #[doc = "* Take a ROS service request already received by the given service server, removing"]
    #[doc = "* it from internal queues."]
    #[doc = "* The request header (i.e. its metadata), containing at least the writer guid and"]
    #[doc = "* sequence number, is also retrieved."]
    #[doc = "* Both writer guid and sequence number allow callers to pair, for each remote service"]
    #[doc = "* client, a ROS service request with its corresponding ROS service response, to be later"]
    #[doc = "* sent using rmw_send_response()."]
    #[doc = "* "]
    #[doc = "* This function will succeed even if no ROS service request was received,"]
    #[doc = "* but `taken` will be false."]
    #[doc = "* "]
    #[doc = "* \\remarks The same ROS service request cannot be taken twice."]
    #[doc = "* Callers do not have to deal with duplicates."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* "]
    #[doc = "* <i>[1] implementation defined, check implementation documentation.</i>"]
    #[doc = "* "]
    #[doc = "* \\par Runtime behavior"]
    #[doc = "* Taking a ROS service request is a synchronous operation."]
    #[doc = "* It is also non-blocking, to the extent it will not wait for new ROS service requests"]
    #[doc = "* to arrive, but it is not guaranteed to be lock-free."]
    #[doc = "* Generally speaking, implementations may synchronize access to internal resources using"]
    #[doc = "* locks but are not allowed to wait for events with no guaranteed time bound (barring"]
    #[doc = "* the effects of starvation due to OS scheduling)."]
    #[doc = "* "]
    #[doc = "* \\par Memory allocation"]
    #[doc = "* It is implementation defined whether memory will be allocated on take or not."]
    #[doc = "* For instance, implementations that deserialize ROS service requests received over"]
    #[doc = "* the wire may need to perform additional memory allocations when dealing with"]
    #[doc = "* unbounded (dynamically-sized) fields."]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Service servers are thread-safe objects, and so are all operations on them except for"]
    #[doc = "* finalization."]
    #[doc = "* Therefore, it is safe to take requests from the same service server concurrently."]
    #[doc = "* However:"]
    #[doc = "* - Access to the given ROS service request is not synchronized."]
    #[doc = "* It is not safe to read or write `ros_request` while rmw_take_request() uses it."]
    #[doc = "* - Access to the given ROS service request header is not synchronized."]
    #[doc = "* It is not safe to read or write `request_header` while rmw_take_request() uses it."]
    #[doc = "* - Access to given primitive data-type arguments is not synchronized."]
    #[doc = "* It is not safe to read or write `taken` while rmw_take_request() uses it."]
    #[doc = "* "]
    #[doc = "* \\pre Given `service` must be a valid service, as returned by rmw_create_service()."]
    #[doc = "* \\pre Given `ros_request` must be a valid service request, whose type matches the"]
    #[doc = "* service type support registered with the `service` on creation."]
    #[doc = "* \\post Given `ros_request` will remain a valid service request."]
    #[doc = "* It will be left unchanged if this function fails early due to a logical error, such as an"]
    #[doc = "* invalid argument, or in an unknown yet valid state if it fails due to a runtime error."]
    #[doc = "* It will also be left unchanged if this function succeeds but `taken` is false."]
    #[doc = "* "]
    #[doc = "* \\param[in] service Service server to take request from."]
    #[doc = "* \\param[out] request_header Service request header to write to."]
    #[doc = "* \\param[out] ros_request Type erased ROS service request to write to."]
    #[doc = "* \\param[out] taken Boolean flag indicating if a ROS service request was taken or not."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `service` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `request_header` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `ros_request` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `service`"]
    #[doc = "* implementation identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_take_request(
        service: *const rmw_service_t,
        request_header: *mut rmw_service_info_t,
        ros_request: *mut ::std::os::raw::c_void,
        taken: *mut bool,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Send a ROS service response."]
    #[doc = "* *"]
    #[doc = "* Send a ROS service response to the service client, with matching QoS policies,"]
    #[doc = "* from which the previously taken ROS service request was originally sent."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* "]
    #[doc = "* <i>[1] implementation defined, check implementation documentation.</i>"]
    #[doc = "* "]
    #[doc = "* \\par Runtime behavior"]
    #[doc = "* It is implementation defined whether sending a ROS service response is a"]
    #[doc = "* synchronous or asynchronous, and blocking or non-blocking, operation."]
    #[doc = "* However, asynchronous implementations are not allowed to access the"]
    #[doc = "* given ROS service request after this function returns."]
    #[doc = "* Check the implementation documentation to learn about request behavior."]
    #[doc = "* "]
    #[doc = "* \\par Memory allocation"]
    #[doc = "* It is implementation defined whether memory will be allocated on send or not."]
    #[doc = "* For instance, implementations that serialize ROS service responses may need to"]
    #[doc = "* perform additional memory allocations when dealing with unbounded (dynamically-sized)"]
    #[doc = "* fields."]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Service servers are thread-safe objects, and so are all operations on them except for"]
    #[doc = "* finalization."]
    #[doc = "* Therefore, it is safe to send responses using the same service server concurrently."]
    #[doc = "* However:"]
    #[doc = "* - Access to the given ROS service request header is read-only but it is not synchronized."]
    #[doc = "* Concurrent `request_header` reads are safe, but concurrent reads and writes are not."]
    #[doc = "* - Access to the given ROS service response is read-only but it is not synchronized."]
    #[doc = "* Concurrent `ros_request` reads are safe, but concurrent reads and writes are not."]
    #[doc = "* "]
    #[doc = "* \\pre Given `service` must be a valid service server, as returned by rmw_create_service()."]
    #[doc = "* \\pre Given `request_header` must be the one previously taken along with the ROS service"]
    #[doc = "* request to which we reply."]
    #[doc = "* \\pre Given `ros_response` must be a valid service response, whose type matches the"]
    #[doc = "* service type support registered with the `service` on creation."]
    #[doc = "* "]
    #[doc = "* \\param[in] client Service server to send a response with."]
    #[doc = "* \\param[in] request_header Service response header, same as the one taken"]
    #[doc = "* with the corresponding ROS service request."]
    #[doc = "* \\param[in] ros_response ROS service response to be sent."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `service` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `request_header` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `ros_response` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `service`"]
    #[doc = "* implementation identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_send_response(
        service: *const rmw_service_t,
        request_header: *mut rmw_request_id_t,
        ros_response: *mut ::std::os::raw::c_void,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Create a guard condition and return a handle to that guard condition."]
    #[doc = "* *"]
    #[doc = "* This function can fail, and therefore return `NULL`, if:"]
    #[doc = "* - context is `NULL`"]
    #[doc = "* - context is invalid"]
    #[doc = "* - memory allocation fails during guard condition creation"]
    #[doc = "* - an unspecified error occurs"]
    #[doc = "* "]
    #[doc = "* The context must be non-null and valid, i.e. it has been initialized"]
    #[doc = "* by `rmw_init()` and has not been finalized by `rmw_shutdown()`."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No [1]"]
    #[doc = "* Lock-Free          | No [1]"]
    #[doc = "* <i>[1] rmw implementation defined, check the implementation documentation</i>"]
    #[doc = "* "]
    #[doc = "* This should be defined by the rmw implementation."]
    #[doc = "* "]
    #[doc = "* \\param[in] context init context that this node should be associated with"]
    #[doc = "* \\return rmw guard condition handle or `NULL` if there was an error"]
    #[doc = "* /"]
    pub fn rmw_create_guard_condition(context: *mut rmw_context_t) -> *mut rmw_guard_condition_t;
}
extern "C" {
    #[doc = " Finalize a given guard condition handle, reclaim the resources, and deallocate the handle."]
    #[doc = "* *"]
    #[doc = "* \\param[in] guard_condition the guard condition handle to be destroyed"]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if guard_condition is null, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unexpected error occurs."]
    #[doc = "* /"]
    pub fn rmw_destroy_guard_condition(guard_condition: *mut rmw_guard_condition_t) -> rmw_ret_t;
}
extern "C" {
    pub fn rmw_trigger_guard_condition(guard_condition: *const rmw_guard_condition_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Create a wait set to store conditions that the middleware can wait on."]
    #[doc = "* *"]
    #[doc = "* This function can fail, and therefore return `NULL`, if:"]
    #[doc = "* - context is `NULL`"]
    #[doc = "* - context is zero initialized, as provided by rmw_get_zero_initialized_context()"]
    #[doc = "* - context does not belong to this implementation i.e. does not have a matching"]
    #[doc = "* implementation identifier"]
    #[doc = "* - memory allocation fails during wait set creation"]
    #[doc = "* - an unspecified error occurs"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] rmw implementation defined, check the implementation documentation</i>"]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Contexts are thread-safe objects, and so are all operations on them except for finalization."]
    #[doc = "* Therefore, it is safe to create multiple wait sets in the same context concurrently."]
    #[doc = "* "]
    #[doc = "* \\pre Given `context` must be a valid context, initialized by rmw_init()."]
    #[doc = "* "]
    #[doc = "* \\param[in] context Context to associate the wait set with."]
    #[doc = "* \\param[in] max_conditions"]
    #[doc = "* The maximum number of conditions that can be attached to, and stored by, the wait set."]
    #[doc = "* Can be set to zero (0) for the wait set to support an unbounded number of conditions."]
    #[doc = "* \\return An rmw wait set, or `NULL` if an error occurred."]
    #[doc = "* /"]
    pub fn rmw_create_wait_set(
        context: *mut rmw_context_t,
        max_conditions: size_t,
    ) -> *mut rmw_wait_set_t;
}
extern "C" {
    #[doc = " Destroy a wait set."]
    #[doc = "* *"]
    #[doc = "* This function will reclaim all associated resources, including the wait set."]
    #[doc = "* Use of a wait set after destruction is undefined behavior."]
    #[doc = "* This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`"]
    #[doc = "* or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given wait set unchanged."]
    #[doc = "* Otherwise, it will proceed despite errors."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] rmw implementation defined, check the implementation documentation</i>"]
    #[doc = "* "]
    #[doc = "* \\pre Given `wait_set` must be a valid wait set, as returned by rmw_create_wait_set()."]
    #[doc = "* "]
    #[doc = "* \\param[in] wait_set Wait set to be finalized."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `wait_set` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `wait_set` implementation"]
    #[doc = "* identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rmw_destroy_wait_set(wait_set: *mut rmw_wait_set_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Waits on sets of different entities and returns when one is ready."]
    #[doc = "* *"]
    #[doc = "* This function adds middleware-specific conditions to the wait set and waits"]
    #[doc = "* until one or more become ready, or until the timeout is reached."]
    #[doc = "* "]
    #[doc = "* \\remark Elapsed time is measured against the system clock."]
    #[doc = "* Timeout granularity is thus bound to that of the aforementioned clock and,"]
    #[doc = "* depending on the underlying implementation, to that of platform-specific"]
    #[doc = "* APIs to sleep and/or wait."]
    #[doc = "* "]
    #[doc = "* \\remark"]
    #[doc = "* The amount of time this function actually waits may be either above or"]
    #[doc = "* below the specified timeout."]
    #[doc = "* "]
    #[doc = "* Arrays contain type-erased, middleware-specific conditions associated with"]
    #[doc = "* waitable entities, which this function casts and adds to the wait set."]
    #[doc = "* `NULL` entries in arrays prior to wait are considered invalid."]
    #[doc = "* When the wait is over, entries in each array that correspond to"]
    #[doc = "* conditions that were \\b not triggered are set to `NULL`."]
    #[doc = "* "]
    #[doc = "* \\remark Arrays' memory management is external to this function."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe [1]"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] rmw implementation defined, check the implementation documentation</i>"]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* To wait is a reentrant procedure, but:"]
    #[doc = "* - It is not safe to use the same wait set to wait in two or more threads concurrently."]
    #[doc = "* - It is not safe to wait for the same entity using different wait sets in two or"]
    #[doc = "* more threads concurrently."]
    #[doc = "* - Access to the given timeout is read-only but it is not synchronized."]
    #[doc = "* Concurrent `wait_timeout` reads are safe, but concurrent reads and writes are not."]
    #[doc = "* "]
    #[doc = "* \\pre Given `wait_set` must be a valid wait set, as returned by rmw_create_wait_set()."]
    #[doc = "* \\pre All given entities must be associated with nodes that, in turn, were registered"]
    #[doc = "* with the same context the given `wait_set` was registered with on creation."]
    #[doc = "* "]
    #[doc = "* \\param[inout] subscriptions Array of subscriptions to wait on."]
    #[doc = "* Can be `NULL` if there are no subscriptions to wait on."]
    #[doc = "* \\param[inout] guard_conditions Array of guard conditions to wait on"]
    #[doc = "* Can be `NULL` if there are no guard conditions to wait on."]
    #[doc = "* \\param[inout] services Array of services to wait on."]
    #[doc = "* Can be `NULL` if there are no services to wait on."]
    #[doc = "* \\param[inout] clients Array of clients to wait on."]
    #[doc = "* Can be `NULL` if there are no clients to wait on."]
    #[doc = "* \\param[inout] events Array of events to wait on."]
    #[doc = "* Can be `NULL` if there are no events to wait on."]
    #[doc = "* \\param[in] wait_set Wait set to use for waiting."]
    #[doc = "* \\param[in] wait_timeout If `NULL`, block indefinitely until an entity becomes ready."]
    #[doc = "* If zero, do not block -- check only for immediately available entities."]
    #[doc = "* Else, this represents the maximum amount of time to wait for an entity to become ready."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_TIMEOUT` if wait timed out, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `wait_set` is `NULL`, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if an array entry is `NULL`, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `wait_set` implementation"]
    #[doc = "* identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rmw_wait(
        subscriptions: *mut rmw_subscriptions_t,
        guard_conditions: *mut rmw_guard_conditions_t,
        services: *mut rmw_services_t,
        clients: *mut rmw_clients_t,
        events: *mut rmw_events_t,
        wait_set: *mut rmw_wait_set_t,
        wait_timeout: *const rmw_time_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Return the name and namespace of all nodes in the ROS graph."]
    #[doc = "* *"]
    #[doc = "* This function will return an array of node names and an array of node namespaces,"]
    #[doc = "* as discovered so far by the given node."]
    #[doc = "* The two arrays represent name and namespace pairs for each discovered node."]
    #[doc = "* Both arrays will be the same length and the same index will refer to the same node."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] implementation defined, check the implementation documentation</i>"]
    #[doc = "* "]
    #[doc = "* \\par Runtime behavior"]
    #[doc = "* To query the ROS graph is a synchronous operation."]
    #[doc = "* It is also non-blocking, but it is not guaranteed to be lock-free."]
    #[doc = "* Generally speaking, implementations may synchronize access to internal resources using"]
    #[doc = "* locks but are not allowed to wait for events with no guaranteed time bound (barring"]
    #[doc = "* the effects of starvation due to OS scheduling)."]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Nodes are thread-safe objects, and so are all operations on them except for finalization."]
    #[doc = "* Therefore, it is safe to query the ROS graph using the same node concurrently."]
    #[doc = "* However, access to string arrays is not synchronized."]
    #[doc = "* It is not safe to read or write `node_names` nor `node_namespaces`"]
    #[doc = "* while rmw_get_node_names() uses them."]
    #[doc = "* "]
    #[doc = "* \\pre Given `node` must be a valid node handle, as returned by rmw_create_node()."]
    #[doc = "* \\pre Given `node_names` must be a valid string array, zero-initialized"]
    #[doc = "* as returned by rcutils_get_zero_initialized_string_array()."]
    #[doc = "* \\pre Given `node_namespaces` must be a valid string array, zero-initialized"]
    #[doc = "* as returned by rcutils_get_zero_initialized_string_array()."]
    #[doc = "* \\post Given `node_names` and `node_namespaces` will remain valid arrays."]
    #[doc = "* These will be left unchanged if this function fails early due to a logical error,"]
    #[doc = "* such as an invalid argument, or in an unknown yet valid state if it fails due to"]
    #[doc = "* a runtime error."]
    #[doc = "* "]
    #[doc = "* \\param[in] node Node to query the ROS graph."]
    #[doc = "* \\param[out] node_names Array of discovered node names, populated on success."]
    #[doc = "* It is up to the caller to finalize this array later on, using rcutils_string_array_fini()."]
    #[doc = "* \\param[out] node_namespaces Array of discovered node namespaces, populated on success."]
    #[doc = "* It is up to the caller to finalize this array later on, using rcutils_string_array_fini()."]
    #[doc = "* \\return `RMW_RET_OK` if the query was successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `node_names` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `node_names` is not a zero-initialized array, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `node_namespaces` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `node_namespaces` is not a zero-initialized array, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation"]
    #[doc = "* identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rmw_get_node_names(
        node: *const rmw_node_t,
        node_names: *mut rcutils_string_array_t,
        node_namespaces: *mut rcutils_string_array_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Return the name, namespae, and enclave name of all nodes in the ROS graph."]
    #[doc = "* *"]
    #[doc = "* This is similar to rmw_get_node_names(), but it also provides enclave names."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] implementation defined, check the implementation documentation</i>"]
    #[doc = "* "]
    #[doc = "* \\par Runtime behavior"]
    #[doc = "* To query the ROS graph is a synchronous operation."]
    #[doc = "* It is also non-blocking, but it is not guaranteed to be lock-free."]
    #[doc = "* Generally speaking, implementations may synchronize access to internal resources using"]
    #[doc = "* locks but are not allowed to wait for events with no guaranteed time bound (barring"]
    #[doc = "* the effects of starvation due to OS scheduling)."]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Nodes are thread-safe objects, and so are all operations on them except for finalization."]
    #[doc = "* Therefore, it is safe to query the ROS graph using the same node concurrently."]
    #[doc = "* However, access to string arrays is not synchronized."]
    #[doc = "* It is not safe to read or write `node_names`, `node_namespaces`, nor `enclaves`"]
    #[doc = "* while rmw_get_node_names_with_enclaves() uses them."]
    #[doc = "* "]
    #[doc = "* \\pre Given `node` must be a valid node handle, as returned by rmw_create_node()."]
    #[doc = "* \\pre Given `node_names` must be a valid string array, zero-initialized"]
    #[doc = "* as returned by rcutils_get_zero_initialized_string_array()."]
    #[doc = "* \\pre Given `node_namespaces` must be a valid string array, zero-initialized"]
    #[doc = "* as returned by rcutils_get_zero_initialized_string_array()."]
    #[doc = "* \\pre Given `enclaves` must be a zero-initialized string array,"]
    #[doc = "* as returned by rcutils_get_zero_initialized_string_array()."]
    #[doc = "* \\post Given `node_names`, `node_namespaces`, and `enclaves` will remain valid arrays."]
    #[doc = "* These will be left unchanged if this function fails early due to a logical error,"]
    #[doc = "* such as an invalid argument, or in an unknown yet valid state if it fails due to"]
    #[doc = "* a runtime error."]
    #[doc = "* "]
    #[doc = "* \\param[in] node Node to query the ROS graph."]
    #[doc = "* \\param[out] node_names Array of discovered node names, populated on success."]
    #[doc = "* It is up to the caller to finalize this array later on, using rcutils_string_array_fini()."]
    #[doc = "* \\param[out] node_namespaces Array of discovered node namespaces, populated on success."]
    #[doc = "* It is up to the caller to finalize this array later on, using rcutils_string_array_fini()."]
    #[doc = "* \\param[out] enclaves Array of discovered node enclave names, populated on success."]
    #[doc = "* It is up to the caller to finalize this array later on, using rcutils_string_array_fini()."]
    #[doc = "* \\return `RMW_RET_OK` if the query was successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `node_names` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `node_names` is not a zero-initialized array, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `node_namespaces` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `node_namespaces` is not a zero-initialized array, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `enclaves` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `enclaves` is not a zero-initialized array, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation"]
    #[doc = "* identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rmw_get_node_names_with_enclaves(
        node: *const rmw_node_t,
        node_names: *mut rcutils_string_array_t,
        node_namespaces: *mut rcutils_string_array_t,
        enclaves: *mut rcutils_string_array_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Count the number of known publishers matching a topic name."]
    #[doc = "* *"]
    #[doc = "* This function returns the numbers of publishers of a given topic in the ROS graph,"]
    #[doc = "* as discovered so far by the given node."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] implementation defined, check the implementation documentation</i>"]
    #[doc = "* "]
    #[doc = "* \\par Runtime behavior"]
    #[doc = "* To query the ROS graph is a synchronous operation."]
    #[doc = "* It is also non-blocking, but it is not guaranteed to be lock-free."]
    #[doc = "* Generally speaking, implementations may synchronize access to internal resources using"]
    #[doc = "* locks but are not allowed to wait for events with no guaranteed time bound (barring"]
    #[doc = "* the effects of starvation due to OS scheduling)."]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Nodes are thread-safe objects, and so are all operations on them except for finalization."]
    #[doc = "* Therefore, it is to query the ROS graph using the same node concurrently."]
    #[doc = "* However, access to primitive data-type arguments is not synchronized."]
    #[doc = "* It is not safe to read or write `topic_name` or `count` while rmw_count_publishers()"]
    #[doc = "* uses them."]
    #[doc = "* "]
    #[doc = "* \\pre Given `node` must be a valid node handle, as returned by rmw_create_node()."]
    #[doc = "* "]
    #[doc = "* \\param[in] node Handle to node to use to query the ROS graph."]
    #[doc = "* \\param[in] topic_name Fully qualified ROS topic name."]
    #[doc = "* \\param[out] count Number of publishers matching the given topic name."]
    #[doc = "* \\return `RMW_RET_OK` if the query was successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `topic_name` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `topic_name` is not a fully qualified topic name,"]
    #[doc = "* by rmw_validate_full_topic_name() definition, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `count` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation"]
    #[doc = "* identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rmw_count_publishers(
        node: *const rmw_node_t,
        topic_name: *const ::std::os::raw::c_char,
        count: *mut size_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Count the number of known subscribers matching a topic name."]
    #[doc = "* *"]
    #[doc = "* This function returns the numbers of subscribers of a given topic in the ROS graph,"]
    #[doc = "* as discovered so far by the given node."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] implementation defined, check the implementation documentation</i>"]
    #[doc = "* "]
    #[doc = "* \\par Runtime behavior"]
    #[doc = "* To query the ROS graph is a synchronous operation."]
    #[doc = "* It is also non-blocking, but it is not guaranteed to be lock-free."]
    #[doc = "* Generally speaking, implementations may synchronize access to internal resources using"]
    #[doc = "* locks but are not allowed to wait for events with no guaranteed time bound (barring"]
    #[doc = "* the effects of starvation due to OS scheduling)."]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Nodes are thread-safe objects, and so are all operations on them except for finalization."]
    #[doc = "* Therefore, it is to query the ROS graph using the same node concurrently."]
    #[doc = "* However, access to primitive data-type arguments is not synchronized."]
    #[doc = "* It is not safe to read or write `topic_name` or `count` while rmw_count_subscribers()"]
    #[doc = "* uses them."]
    #[doc = "* "]
    #[doc = "* \\pre Given `node` must be a valid node handle, as returned by rmw_create_node()."]
    #[doc = "* "]
    #[doc = "* \\param[in] node Handle to node to use to query the ROS graph."]
    #[doc = "* \\param[in] topic_name Fully qualified ROS topic name."]
    #[doc = "* \\param[out] count Number of subscribers matching the given topic name."]
    #[doc = "* \\return `RMW_RET_OK` if the query was successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `topic_name` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `topic_name` is not a fully qualified topic name,"]
    #[doc = "* by rmw_validate_full_topic_name() definition, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `count` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation"]
    #[doc = "* identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rmw_count_subscribers(
        node: *const rmw_node_t,
        topic_name: *const ::std::os::raw::c_char,
        count: *mut size_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Get the unique identifier (gid) of a publisher."]
    #[doc = "* *"]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* "]
    #[doc = "* <i>[1] implementation defined, check implementation documentation.</i>"]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Publishers are thread-safe objects, and so are all operations on them except for"]
    #[doc = "* finalization."]
    #[doc = "* Therefore, it is safe to get the unique identifier from the same publisher concurrently."]
    #[doc = "* However, access to the gid is not synchronized."]
    #[doc = "* It is not safe to read or write `gid` while rmw_get_gid_for_publisher() uses it."]
    #[doc = "* "]
    #[doc = "* \\pre Given `publisher` must be a valid subscription, as returned by rmw_create_publisher()."]
    #[doc = "* "]
    #[doc = "* \\param[in] publisher Publisher to get a gid from."]
    #[doc = "* \\param[out] gid Publisher's unique identifier, populated on success"]
    #[doc = "* but left unchanged on failure."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `gid` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `publisher` implementation"]
    #[doc = "* identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rmw_get_gid_for_publisher(
        publisher: *const rmw_publisher_t,
        gid: *mut rmw_gid_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Check if two unique identifiers (gids) are equal."]
    #[doc = "* *"]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* "]
    #[doc = "* <i>[1] implementation defined, check implementation documentation.</i>"]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Unique identifier comparison is a reentrant function, but:"]
    #[doc = "* - Access to both gids is read-only but it is not synchronized."]
    #[doc = "* Concurrent `gid1` and `gid2` reads are safe, but concurrent reads and writes are not."]
    #[doc = "* - Access to primitive data-type arguments is not synchronized."]
    #[doc = "* It is not safe to read or write `result` while rmw_compare_gids_equal() uses it."]
    #[doc = "* "]
    #[doc = "* \\param[in] gid1 First unique identifier to compare."]
    #[doc = "* \\param[in] gid2 Second unique identifier to compare."]
    #[doc = "* \\param[out] bool true if both gids are equal, false otherwise."]
    #[doc = "* \\return `RMW_RET_OK` if successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `gid1` or `gid2` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation"]
    #[doc = "* identifier of `gid1` or `gid2` does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rmw_compare_gids_equal(
        gid1: *const rmw_gid_t,
        gid2: *const rmw_gid_t,
        result: *mut bool,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Check if a service server is available for the given service client."]
    #[doc = "* *"]
    #[doc = "* This function will return true for `is_available` if there is a service"]
    #[doc = "* server available for the given client."]
    #[doc = "* "]
    #[doc = "* The node parameter must not be `NULL`, and must point to a valid node."]
    #[doc = "* "]
    #[doc = "* The client parameter must not be `NULL`, and must point to a valid client."]
    #[doc = "* "]
    #[doc = "* The given client and node must match, i.e. the client must have been created"]
    #[doc = "* using the given node."]
    #[doc = "* "]
    #[doc = "* The is_available parameter must not be `NULL`, and must point to a bool"]
    #[doc = "* variable."]
    #[doc = "* The result of the check will be stored in the is_available parameter."]
    #[doc = "* "]
    #[doc = "* This function does manipulate heap memory."]
    #[doc = "* This function is not thread-safe."]
    #[doc = "* This function is lock-free."]
    #[doc = "* "]
    #[doc = "* \\param[in] node the handle to the node being used to query the ROS graph"]
    #[doc = "* \\param[in] client the handle to the service client being queried"]
    #[doc = "* \\param[out] is_available"]
    #[doc = "* set to true if there is a service server available, else false"]
    #[doc = "* \\return `RMW_RET_OK` if node the check was made successfully, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `publisher` implementation"]
    #[doc = "* identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rmw_service_server_is_available(
        node: *const rmw_node_t,
        client: *const rmw_client_t,
        is_available: *mut bool,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Set the current log severity"]
    #[doc = "* *"]
    #[doc = "* \\param[in] severity The log severity to set"]
    #[doc = "* \\return RMW_RET_OK if successful, otherwise an appropriate error code"]
    #[doc = "* /"]
    pub fn rmw_set_log_severity(severity: rmw_log_severity_t) -> rmw_ret_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_timer_impl_t {
    _unused: [u8; 0],
}
#[doc = " Structure which encapsulates a ROS Timer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_timer_t {
    #[doc = " Private implementation pointer."]
    pub impl_: *mut rcl_timer_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_timer_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_timer_t>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_timer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_timer_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_timer_t))
    );
    fn test_field_impl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_timer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_timer_t),
                "::",
                stringify!(impl_)
            )
        );
    }
    test_field_impl();
}
#[doc = " User callback signature for timers."]
#[doc = "* *"]
#[doc = "* The first argument the callback gets is a pointer to the timer."]
#[doc = "* This can be used to cancel the timer, query the time until the next"]
#[doc = "* timer callback, exchange the callback with a different one, etc."]
#[doc = "* "]
#[doc = "* The only caveat is that the function rcl_timer_get_time_since_last_call()"]
#[doc = "* will return the time since just before this callback was called, not the"]
#[doc = "* previous call."]
#[doc = "* Therefore the second argument given is the time since the previous callback"]
#[doc = "* was called, because that information is no longer accessible via the timer."]
#[doc = "* The time since the last callback call is given in nanoseconds."]
#[doc = "* /"]
pub type rcl_timer_callback_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut rcl_timer_t, arg2: i64)>;
extern "C" {
    #[doc = " Return a zero initialized timer."]
    pub fn rcl_get_zero_initialized_timer() -> rcl_timer_t;
}
extern "C" {
    #[doc = " Initialize a timer."]
    #[doc = "* *"]
    #[doc = "* A timer consists of a clock, a callback function and a period."]
    #[doc = "* A timer can be added to a wait set and waited on, such that the wait set"]
    #[doc = "* will wake up when a timer is ready to be executed."]
    #[doc = "* "]
    #[doc = "* A timer simply holds state and does not automatically call callbacks."]
    #[doc = "* It does not create any threads, register interrupts, or consume signals."]
    #[doc = "* For blocking behavior it can be used in conjunction with a wait set and"]
    #[doc = "* rcl_wait()."]
    #[doc = "* When rcl_timer_is_ready() returns true, the timer must still be called"]
    #[doc = "* explicitly using rcl_timer_call()."]
    #[doc = "* "]
    #[doc = "* The timer handle must be a pointer to an allocated and zero initialized"]
    #[doc = "* rcl_timer_t struct."]
    #[doc = "* Calling this function on an already initialized timer will fail."]
    #[doc = "* Calling this function on a timer struct which has been allocated but not"]
    #[doc = "* zero initialized is undefined behavior."]
    #[doc = "* "]
    #[doc = "* The clock handle must be a pointer to an initialized rcl_clock_t struct."]
    #[doc = "* The life time of the clock must exceed the life time of the timer."]
    #[doc = "* "]
    #[doc = "* The period is a non-negative duration (rather an absolute time in the"]
    #[doc = "* future)."]
    #[doc = "* If the period is `0` then it will always be ready."]
    #[doc = "* "]
    #[doc = "* The callback is an optional argument."]
    #[doc = "* Valid inputs are either a pointer to the function callback, or `NULL` to"]
    #[doc = "* indicate that no callback will be stored in rcl."]
    #[doc = "* If the callback is `NULL`, the caller client library is responsible for"]
    #[doc = "* firing the timer callback."]
    #[doc = "* Else, it must be a function which returns void and takes two arguments,"]
    #[doc = "* the first being a pointer to the associated timer, and the second a int64_t"]
    #[doc = "* which is the time since the previous call, or since the timer was created"]
    #[doc = "* if it is the first call to the callback."]
    #[doc = "* "]
    #[doc = "* Expected usage:"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* #include <rcl/rcl.h>"]
    #[doc = "* "]
    #[doc = "* void my_timer_callback(rcl_timer_t * timer, int64_t last_call_time)"]
    #[doc = "* {"]
    #[doc = "* // Do timer work..."]
    #[doc = "* // Optionally reconfigure, cancel, or reset the timer..."]
    #[doc = "* }"]
    #[doc = "* "]
    #[doc = "* rcl_context_t * context;  // initialized previously by rcl_init()..."]
    #[doc = "* rcl_clock_t clock;"]
    #[doc = "* rcl_allocator_t allocator = rcl_get_default_allocator();"]
    #[doc = "* rcl_ret_t ret = rcl_clock_init(RCL_STEADY_TIME, &clock, &allocator);"]
    #[doc = "* // ... error handling"]
    #[doc = "* "]
    #[doc = "* rcl_timer_t timer = rcl_get_zero_initialized_timer();"]
    #[doc = "* ret = rcl_timer_init("]
    #[doc = "* &timer, &clock, context, RCL_MS_TO_NS(100), my_timer_callback, allocator);"]
    #[doc = "* // ... error handling, use the timer with a wait set, or poll it manually, then cleanup"]
    #[doc = "* ret = rcl_timer_fini(&timer);"]
    #[doc = "* // ... error handling"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes [1][2][3]"]
    #[doc = "* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uintptr_t`</i>"]
    #[doc = "* "]
    #[doc = "* <i>[2] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>"]
    #[doc = "* "]
    #[doc = "* <i>[3] if `atomic_is_lock_free()` returns true for `atomic_bool`</i>"]
    #[doc = "* "]
    #[doc = "* \\param[inout] timer the timer handle to be initialized"]
    #[doc = "* \\param[in] clock the clock providing the current time"]
    #[doc = "* \\param[in] context the context that this timer is to be associated with"]
    #[doc = "* \\param[in] period the duration between calls to the callback in nanoseconds"]
    #[doc = "* \\param[in] callback the user defined function to be called every period"]
    #[doc = "* \\param[in] allocator the allocator to use for allocations"]
    #[doc = "* \\return #RCL_RET_OK if the timer was initialized successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ALREADY_INIT if the timer was already initialized, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_timer_init(
        timer: *mut rcl_timer_t,
        clock: *mut rcl_clock_t,
        context: *mut rcl_context_t,
        period: i64,
        callback: rcl_timer_callback_t,
        allocator: rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a timer."]
    #[doc = "* *"]
    #[doc = "* This function will deallocate any memory and make the timer invalid."]
    #[doc = "* "]
    #[doc = "* A timer that is already invalid (zero initialized) or `NULL` will not fail."]
    #[doc = "* "]
    #[doc = "* This function is not thread-safe with any rcl_timer_* functions used on the"]
    #[doc = "* same timer object."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes [1][2][3]"]
    #[doc = "* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uintptr_t`</i>"]
    #[doc = "* "]
    #[doc = "* <i>[2] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>"]
    #[doc = "* "]
    #[doc = "* <i>[3] if `atomic_is_lock_free()` returns true for `atomic_bool`</i>"]
    #[doc = "* "]
    #[doc = "* \\param[inout] timer the handle to the timer to be finalized."]
    #[doc = "* \\return #RCL_RET_OK if the timer was finalized successfully, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_timer_fini(timer: *mut rcl_timer_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Call the timer's callback and set the last call time."]
    #[doc = "* *"]
    #[doc = "* This function will call the callback and change the last call time even if"]
    #[doc = "* the timer's period has not yet elapsed."]
    #[doc = "* It is up to the calling code to make sure the period has elapsed by first"]
    #[doc = "* calling rcl_timer_is_ready()."]
    #[doc = "* If the callback pointer is `NULL` (either set in init or exchanged after"]
    #[doc = "* initialized), no callback is fired."]
    #[doc = "* However, this function should still be called by the client library to"]
    #[doc = "* update the state of the timer."]
    #[doc = "* The order of operations in this command are as follows:"]
    #[doc = "* "]
    #[doc = "* - Ensure the timer has not been canceled."]
    #[doc = "* - Get the current time into a temporary rcl_steady_time_point_t."]
    #[doc = "* - Exchange the current time with the last call time of the timer."]
    #[doc = "* - Call the callback, passing this timer and the time since the last call."]
    #[doc = "* - Return after the callback has completed."]
    #[doc = "* "]
    #[doc = "* During the callback the timer can be canceled or have its period and/or"]
    #[doc = "* callback modified."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes [1]"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes [2]"]
    #[doc = "* <i>[1] user callback might not be thread-safe</i>"]
    #[doc = "* "]
    #[doc = "* <i>[2] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>"]
    #[doc = "* "]
    #[doc = "* \\param[inout] timer the handle to the timer to call"]
    #[doc = "* \\return #RCL_RET_OK if the timer was called successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_TIMER_INVALID if the timer is invalid, or"]
    #[doc = "* \\return #RCL_RET_TIMER_CANCELED if the timer has been canceled, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_timer_call(timer: *mut rcl_timer_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Retrieve the clock of the timer."]
    #[doc = "* *"]
    #[doc = "* This function retrieves the clock pointer and copies it into the given variable."]
    #[doc = "* "]
    #[doc = "* The clock argument must be a pointer to an already allocated rcl_clock_t *."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] timer the handle to the timer which is being queried"]
    #[doc = "* \\param[out] clock the rcl_clock_t * in which the clock is stored"]
    #[doc = "* \\return #RCL_RET_OK if the period was retrieved successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_TIMER_INVALID if the timer is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_timer_clock(timer: *mut rcl_timer_t, clock: *mut *mut rcl_clock_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Calculates whether or not the timer should be called."]
    #[doc = "* *"]
    #[doc = "* The result is true if the time until next call is less than, or equal to, 0"]
    #[doc = "* and the timer has not been canceled."]
    #[doc = "* Otherwise the result is false, indicating the timer should not be called."]
    #[doc = "* "]
    #[doc = "* The is_ready argument must point to an allocated bool object, as the result"]
    #[doc = "* is copied into it."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes [1]"]
    #[doc = "* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] timer the handle to the timer which is being checked"]
    #[doc = "* \\param[out] is_ready the bool used to store the result of the calculation"]
    #[doc = "* \\return #RCL_RET_OK if the last call time was retrieved successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_TIMER_INVALID if the timer is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_timer_is_ready(timer: *const rcl_timer_t, is_ready: *mut bool) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Calculate and retrieve the time until the next call in nanoseconds."]
    #[doc = "* *"]
    #[doc = "* This function calculates the time until the next call by adding the timer's"]
    #[doc = "* period to the last call time and subtracting that sum from the current time."]
    #[doc = "* The calculated time until the next call can be positive, indicating that it"]
    #[doc = "* is not ready to be called as the period has not elapsed since the last call."]
    #[doc = "* The calculated time until the next call can also be 0 or negative,"]
    #[doc = "* indicating that the period has elapsed since the last call and the timer"]
    #[doc = "* should be called."]
    #[doc = "* A negative value indicates the timer call is overdue by that amount."]
    #[doc = "* "]
    #[doc = "* The `time_until_next_call` argument must point to an allocated int64_t, as"]
    #[doc = "* the time until is copied into that instance."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes [1]"]
    #[doc = "* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] timer the handle to the timer that is being queried"]
    #[doc = "* \\param[out] time_until_next_call the output variable for the result"]
    #[doc = "* \\return #RCL_RET_OK if the timer until next call was successfully calculated, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_TIMER_INVALID if the timer is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_timer_get_time_until_next_call(
        timer: *const rcl_timer_t,
        time_until_next_call: *mut i64,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Retrieve the time since the previous call to rcl_timer_call() occurred."]
    #[doc = "* *"]
    #[doc = "* This function calculates the time since the last call and copies it into"]
    #[doc = "* the given int64_t variable."]
    #[doc = "* "]
    #[doc = "* Calling this function within a callback will not return the time since the"]
    #[doc = "* previous call but instead the time since the current callback was called."]
    #[doc = "* "]
    #[doc = "* The time_since_last_call argument must be a pointer to an already allocated"]
    #[doc = "* int64_t."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes [1]"]
    #[doc = "* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] timer the handle to the timer which is being queried"]
    #[doc = "* \\param[out] time_since_last_call the struct in which the time is stored"]
    #[doc = "* \\return #RCL_RET_OK if the last call time was retrieved successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_TIMER_INVALID if the timer is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_timer_get_time_since_last_call(
        timer: *const rcl_timer_t,
        time_since_last_call: *mut i64,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Retrieve the period of the timer."]
    #[doc = "* *"]
    #[doc = "* This function retrieves the period and copies it into the given variable."]
    #[doc = "* "]
    #[doc = "* The period argument must be a pointer to an already allocated int64_t."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes [1]"]
    #[doc = "* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] timer the handle to the timer which is being queried"]
    #[doc = "* \\param[out] period the int64_t in which the period is stored"]
    #[doc = "* \\return #RCL_RET_OK if the period was retrieved successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_timer_get_period(timer: *const rcl_timer_t, period: *mut i64) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Exchange the period of the timer and return the previous period."]
    #[doc = "* *"]
    #[doc = "* This function exchanges the period in the timer and copies the old one into"]
    #[doc = "* the given variable."]
    #[doc = "* "]
    #[doc = "* Exchanging (changing) the period will not affect already waiting wait sets."]
    #[doc = "* "]
    #[doc = "* The old_period argument must be a pointer to an already allocated int64_t."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes [1]"]
    #[doc = "* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] timer the handle to the timer which is being modified"]
    #[doc = "* \\param[out] new_period the int64_t to exchange into the timer"]
    #[doc = "* \\param[out] old_period the int64_t in which the previous period is stored"]
    #[doc = "* \\return #RCL_RET_OK if the period was retrieved successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_timer_exchange_period(
        timer: *const rcl_timer_t,
        new_period: i64,
        old_period: *mut i64,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the current timer callback."]
    #[doc = "* *"]
    #[doc = "* This function can fail, and therefore return `NULL`, if:"]
    #[doc = "* - timer is `NULL`"]
    #[doc = "* - timer has not been initialized (the implementation is invalid)"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes [1]"]
    #[doc = "* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] timer handle to the timer from the callback should be returned"]
    #[doc = "* \\return function pointer to the callback, or `NULL` if an error occurred"]
    #[doc = "* /"]
    pub fn rcl_timer_get_callback(timer: *const rcl_timer_t) -> rcl_timer_callback_t;
}
extern "C" {
    #[doc = " Exchange the current timer callback and return the current callback."]
    #[doc = "* *"]
    #[doc = "* This function can fail, and therefore return `NULL`, if:"]
    #[doc = "* - timer is `NULL`"]
    #[doc = "* - timer has not been initialized (the implementation is invalid)"]
    #[doc = "* "]
    #[doc = "* This function can set callback to `NULL`, in which case the callback is"]
    #[doc = "* ignored when rcl_timer_call is called."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes [1]"]
    #[doc = "* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>"]
    #[doc = "* "]
    #[doc = "* \\param[inout] timer handle to the timer from the callback should be exchanged"]
    #[doc = "* \\param[in] new_callback the callback to be exchanged into the timer"]
    #[doc = "* \\return function pointer to the old callback, or `NULL` if an error occurred"]
    #[doc = "* /"]
    pub fn rcl_timer_exchange_callback(
        timer: *mut rcl_timer_t,
        new_callback: rcl_timer_callback_t,
    ) -> rcl_timer_callback_t;
}
extern "C" {
    #[doc = " Cancel a timer."]
    #[doc = "* *"]
    #[doc = "* When a timer is canceled, rcl_timer_is_ready() will return false for that"]
    #[doc = "* timer, and rcl_timer_call() will fail with RCL_RET_TIMER_CANCELED."]
    #[doc = "* "]
    #[doc = "* A canceled timer can be reset with rcl_timer_reset(), and then used again."]
    #[doc = "* Calling this function on an already canceled timer will succeed."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes [1]"]
    #[doc = "* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>"]
    #[doc = "* "]
    #[doc = "* \\param[inout] timer the timer to be canceled"]
    #[doc = "* \\return #RCL_RET_OK if the last call time was retrieved successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_TIMER_INVALID if the timer is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_timer_cancel(timer: *mut rcl_timer_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Retrieve the canceled state of a timer."]
    #[doc = "* *"]
    #[doc = "* If the timer is canceled true will be stored in the is_canceled argument."]
    #[doc = "* Otherwise false will be stored in the is_canceled argument."]
    #[doc = "* "]
    #[doc = "* The is_canceled argument must point to an allocated bool, as the result is"]
    #[doc = "* copied into this variable."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes [1]"]
    #[doc = "* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_bool`</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] timer the timer to be queried"]
    #[doc = "* \\param[out] is_canceled storage for the is canceled bool"]
    #[doc = "* \\return #RCL_RET_OK if the last call time was retrieved successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_timer_is_canceled(timer: *const rcl_timer_t, is_canceled: *mut bool) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Reset a timer."]
    #[doc = "* *"]
    #[doc = "* This function can be called on a timer, canceled or not."]
    #[doc = "* For all timers it will reset the last call time to now."]
    #[doc = "* For canceled timers it will additionally make the timer not canceled."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Yes"]
    #[doc = "* Lock-Free          | Yes [1]"]
    #[doc = "* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>"]
    #[doc = "* "]
    #[doc = "* \\param[inout] timer the timer to be reset"]
    #[doc = "* \\return #RCL_RET_OK if the last call time was retrieved successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_TIMER_INVALID if the timer is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_timer_reset(timer: *mut rcl_timer_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the allocator for the timer."]
    #[doc = "* *"]
    #[doc = "* This function can fail, and therefore return `NULL`, if:"]
    #[doc = "* - timer is `NULL`"]
    #[doc = "* - timer has not been initialized (the implementation is invalid)"]
    #[doc = "* "]
    #[doc = "* The returned pointer is only valid as long as the timer object is valid."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] timer handle to the timer object"]
    #[doc = "* \\return pointer to the allocator, or `NULL` if an error occurred"]
    #[doc = "* /"]
    pub fn rcl_timer_get_allocator(timer: *const rcl_timer_t) -> *const rcl_allocator_t;
}
extern "C" {
    #[doc = " Retrieve a guard condition used by the timer to wake the waitset when using ROSTime."]
    #[doc = "* *"]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] timer the timer to be queried"]
    #[doc = "* \\return `NULL` if the timer is invalid or does not have a guard condition, or"]
    #[doc = "* \\return a guard condition pointer."]
    #[doc = "* /"]
    pub fn rcl_timer_get_guard_condition(timer: *const rcl_timer_t) -> *mut rcl_guard_condition_t;
}
pub const rcl_publisher_event_type_t_RCL_PUBLISHER_OFFERED_DEADLINE_MISSED:
    rcl_publisher_event_type_t = 0;
pub const rcl_publisher_event_type_t_RCL_PUBLISHER_LIVELINESS_LOST: rcl_publisher_event_type_t = 1;
pub const rcl_publisher_event_type_t_RCL_PUBLISHER_OFFERED_INCOMPATIBLE_QOS:
    rcl_publisher_event_type_t = 2;
#[doc = " Enumeration of all of the publisher events that may fire."]
pub type rcl_publisher_event_type_t = ::std::os::raw::c_uint;
pub const rcl_subscription_event_type_t_RCL_SUBSCRIPTION_REQUESTED_DEADLINE_MISSED:
    rcl_subscription_event_type_t = 0;
pub const rcl_subscription_event_type_t_RCL_SUBSCRIPTION_LIVELINESS_CHANGED:
    rcl_subscription_event_type_t = 1;
pub const rcl_subscription_event_type_t_RCL_SUBSCRIPTION_REQUESTED_INCOMPATIBLE_QOS:
    rcl_subscription_event_type_t = 2;
pub const rcl_subscription_event_type_t_RCL_SUBSCRIPTION_MESSAGE_LOST:
    rcl_subscription_event_type_t = 3;
#[doc = " Enumeration of all of the subscription events that may fire."]
pub type rcl_subscription_event_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_event_t {
    _unused: [u8; 0],
}
#[doc = " Internal rcl implementation struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_event_impl_t {
    _unused: [u8; 0],
}
#[doc = " Structure which encapsulates a ROS QoS event handle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_event_t {
    #[doc = " Pointer to the event implementation"]
    pub impl_: *mut rcl_event_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_event_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_event_t>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_event_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_event_t))
    );
    fn test_field_impl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_event_t),
                "::",
                stringify!(impl_)
            )
        );
    }
    test_field_impl();
}
extern "C" {
    #[doc = " Return a rcl_event_t struct with members set to `NULL`."]
    #[doc = "* *"]
    #[doc = "* Should be called to get a null rcl_event_t before passing to"]
    #[doc = "* rcl_event_init()."]
    #[doc = "* "]
    #[doc = "* \\return Zero initialized rcl_event_t."]
    #[doc = "* /"]
    pub fn rcl_get_zero_initialized_event() -> rcl_event_t;
}
extern "C" {
    #[doc = " Initialize an rcl_event_t with a publisher."]
    #[doc = "* *"]
    #[doc = "* Fill the rcl_event_t with the publisher and desired event_type."]
    #[doc = "* "]
    #[doc = "* \\param[in,out] event pointer to fill"]
    #[doc = "* \\param[in] publisher to get events from"]
    #[doc = "* \\param[in] event_type to listen for"]
    #[doc = "* \\return #RCL_RET_OK if the rcl_event_t is filled, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory fails, or"]
    #[doc = "* \\return #RCL_RET_UNSUPPORTED if event_type is not supported, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_publisher_event_init(
        event: *mut rcl_event_t,
        publisher: *const rcl_publisher_t,
        event_type: rcl_publisher_event_type_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Initialize an rcl_event_t with a subscription."]
    #[doc = "* *"]
    #[doc = "* Fill the rcl_event_t with the subscription and desired event_type."]
    #[doc = "* "]
    #[doc = "* \\param[in,out] event pointer to fill"]
    #[doc = "* \\param[in] subscription to get events from"]
    #[doc = "* \\param[in] event_type to listen for"]
    #[doc = "* \\return #RCL_RET_OK if the rcl_event_t is filled, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory fails, or"]
    #[doc = "* \\return #RCL_RET_UNSUPPORTED if event_type is not supported, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_subscription_event_init(
        event: *mut rcl_event_t,
        subscription: *const rcl_subscription_t,
        event_type: rcl_subscription_event_type_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take an event from the event handle."]
    #[doc = ""]
    #[doc = " \\param[in] event event object to take from"]
    #[doc = " \\param[in, out] event_info event info object to write taken data into"]
    #[doc = " \\return #RCL_RET_OK if successful, or"]
    #[doc = " \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = " \\return #RCL_RET_BAD_ALLOC if memory allocation failed, or"]
    #[doc = " \\return #RCL_RET_EVENT_TAKE_FAILED if the take event failed, or"]
    #[doc = " \\return #RCL_RET_ERROR if an unexpected error occurs."]
    pub fn rcl_take_event(
        event: *const rcl_event_t,
        event_info: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize an event."]
    #[doc = ""]
    #[doc = " \\param[in] event to finalize"]
    #[doc = " \\return #RCL_RET_OK if successful, or"]
    #[doc = " \\return #RCL_RET_EVENT_INVALID if event is null, or"]
    #[doc = " \\return #RCL_RET_ERROR if an unexpected error occurs."]
    pub fn rcl_event_fini(event: *mut rcl_event_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the rmw event handle."]
    #[doc = "* *"]
    #[doc = "* The handle returned is a pointer to the internally held rmw handle."]
    #[doc = "* This function can fail, and therefore return `NULL`, if the:"]
    #[doc = "* - event is `NULL`"]
    #[doc = "* - event is invalid (never called init, called fini, or invalid node)"]
    #[doc = "* "]
    #[doc = "* The returned handle is made invalid if the event is finalized or if"]
    #[doc = "* rcl_shutdown() is called."]
    #[doc = "* The returned handle is not guaranteed to be valid for the life time of the"]
    #[doc = "* event as it may be finalized and recreated itself."]
    #[doc = "* Therefore it is recommended to get the handle from the event using"]
    #[doc = "* this function each time it is needed and avoid use of the handle"]
    #[doc = "* concurrently with functions that might change it."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] event pointer to the rcl event"]
    #[doc = "* \\return rmw event handle if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_event_get_rmw_handle(event: *const rcl_event_t) -> *mut rmw_event_t;
}
extern "C" {
    #[doc = " Check that the event is valid."]
    #[doc = "* *"]
    #[doc = "* The bool returned is `false` if `event` is invalid."]
    #[doc = "* The bool returned is `true` otherwise."]
    #[doc = "* In the case where `false` is to be returned, an error message is set."]
    #[doc = "* This function cannot fail."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] event pointer to the rcl event"]
    #[doc = "* \\return `true` if `event` is valid, otherwise `false`"]
    #[doc = "* /"]
    pub fn rcl_event_is_valid(event: *const rcl_event_t) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_wait_set_impl_t {
    _unused: [u8; 0],
}
#[doc = " Container for subscription's, guard condition's, etc to be waited on."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_wait_set_t {
    #[doc = " Storage for subscription pointers."]
    pub subscriptions: *mut *const rcl_subscription_t,
    #[doc = " Number of subscriptions"]
    pub size_of_subscriptions: size_t,
    #[doc = " Storage for guard condition pointers."]
    pub guard_conditions: *mut *const rcl_guard_condition_t,
    #[doc = " Number of guard_conditions"]
    pub size_of_guard_conditions: size_t,
    #[doc = " Storage for timer pointers."]
    pub timers: *mut *const rcl_timer_t,
    #[doc = " Number of timers"]
    pub size_of_timers: size_t,
    #[doc = " Storage for client pointers."]
    pub clients: *mut *const rcl_client_t,
    #[doc = " Number of clients"]
    pub size_of_clients: size_t,
    #[doc = " Storage for service pointers."]
    pub services: *mut *const rcl_service_t,
    #[doc = " Number of services"]
    pub size_of_services: size_t,
    #[doc = " Storage for event pointers."]
    pub events: *mut *const rcl_event_t,
    #[doc = " Number of events"]
    pub size_of_events: size_t,
    #[doc = " Implementation specific storage."]
    pub impl_: *mut rcl_wait_set_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_wait_set_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_wait_set_t>(),
        104usize,
        concat!("Size of: ", stringify!(rcl_wait_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_wait_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_wait_set_t))
    );
    fn test_field_subscriptions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_wait_set_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subscriptions) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_wait_set_t),
                "::",
                stringify!(subscriptions)
            )
        );
    }
    test_field_subscriptions();
    fn test_field_size_of_subscriptions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_wait_set_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size_of_subscriptions) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_wait_set_t),
                "::",
                stringify!(size_of_subscriptions)
            )
        );
    }
    test_field_size_of_subscriptions();
    fn test_field_guard_conditions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_wait_set_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).guard_conditions) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_wait_set_t),
                "::",
                stringify!(guard_conditions)
            )
        );
    }
    test_field_guard_conditions();
    fn test_field_size_of_guard_conditions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_wait_set_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size_of_guard_conditions) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_wait_set_t),
                "::",
                stringify!(size_of_guard_conditions)
            )
        );
    }
    test_field_size_of_guard_conditions();
    fn test_field_timers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_wait_set_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timers) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_wait_set_t),
                "::",
                stringify!(timers)
            )
        );
    }
    test_field_timers();
    fn test_field_size_of_timers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_wait_set_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size_of_timers) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_wait_set_t),
                "::",
                stringify!(size_of_timers)
            )
        );
    }
    test_field_size_of_timers();
    fn test_field_clients() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_wait_set_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clients) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_wait_set_t),
                "::",
                stringify!(clients)
            )
        );
    }
    test_field_clients();
    fn test_field_size_of_clients() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_wait_set_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size_of_clients) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_wait_set_t),
                "::",
                stringify!(size_of_clients)
            )
        );
    }
    test_field_size_of_clients();
    fn test_field_services() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_wait_set_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).services) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_wait_set_t),
                "::",
                stringify!(services)
            )
        );
    }
    test_field_services();
    fn test_field_size_of_services() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_wait_set_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size_of_services) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_wait_set_t),
                "::",
                stringify!(size_of_services)
            )
        );
    }
    test_field_size_of_services();
    fn test_field_events() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_wait_set_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_wait_set_t),
                "::",
                stringify!(events)
            )
        );
    }
    test_field_events();
    fn test_field_size_of_events() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_wait_set_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size_of_events) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_wait_set_t),
                "::",
                stringify!(size_of_events)
            )
        );
    }
    test_field_size_of_events();
    fn test_field_impl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_wait_set_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_wait_set_t),
                "::",
                stringify!(impl_)
            )
        );
    }
    test_field_impl();
}
extern "C" {
    #[doc = " Return a rcl_wait_set_t struct with members set to `NULL`."]
    pub fn rcl_get_zero_initialized_wait_set() -> rcl_wait_set_t;
}
extern "C" {
    #[doc = " Initialize a rcl wait set with space for items to be waited on."]
    #[doc = "* *"]
    #[doc = "* This function allocates space for the subscriptions and other wait-able"]
    #[doc = "* entities that can be stored in the wait set."]
    #[doc = "* It also sets the allocator to the given allocator and initializes the pruned"]
    #[doc = "* member to be false."]
    #[doc = "* "]
    #[doc = "* The wait_set struct should be allocated and initialized to `NULL`."]
    #[doc = "* If the wait_set is allocated but the memory is uninitialized the behavior is"]
    #[doc = "* undefined."]
    #[doc = "* Calling this function on a wait set that has already been initialized will"]
    #[doc = "* result in an error."]
    #[doc = "* A wait set can be reinitialized if rcl_wait_set_fini() was called on it."]
    #[doc = "* "]
    #[doc = "* To use the default allocator use rcl_get_default_allocator()."]
    #[doc = "* "]
    #[doc = "* Expected usage:"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* #include <rcl/wait.h>"]
    #[doc = "* "]
    #[doc = "* rcl_wait_set_t wait_set = rcl_get_zero_initialized_wait_set();"]
    #[doc = "* rcl_ret_t ret ="]
    #[doc = "* rcl_wait_set_init(&wait_set, 42, 42, 42, 42, 42, &context, rcl_get_default_allocator());"]
    #[doc = "* // ... error handling, then use it, then call the matching fini:"]
    #[doc = "* ret = rcl_wait_set_fini(&wait_set);"]
    #[doc = "* // ... error handling"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] wait_set the wait set struct to be initialized"]
    #[doc = "* \\param[in] number_of_subscriptions non-zero size of the subscriptions set"]
    #[doc = "* \\param[in] number_of_guard_conditions non-zero size of the guard conditions set"]
    #[doc = "* \\param[in] number_of_timers non-zero size of the timers set"]
    #[doc = "* \\param[in] number_of_clients non-zero size of the clients set"]
    #[doc = "* \\param[in] number_of_services non-zero size of the services set"]
    #[doc = "* \\param[in] number_of_events non-zero size of the events set"]
    #[doc = "* \\param[in] context the context that the wait set should be associated with"]
    #[doc = "* \\param[in] allocator the allocator to use when allocating space in the sets"]
    #[doc = "* \\return #RCL_RET_OK if the wait set is initialized successfully, or"]
    #[doc = "* \\return #RCL_RET_ALREADY_INIT if the wait set is not zero initialized, or"]
    #[doc = "* \\return #RCL_RET_NOT_INIT if the given context is invalid, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_WAIT_SET_INVALID if the wait set is not destroyed properly, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_wait_set_init(
        wait_set: *mut rcl_wait_set_t,
        number_of_subscriptions: size_t,
        number_of_guard_conditions: size_t,
        number_of_timers: size_t,
        number_of_clients: size_t,
        number_of_services: size_t,
        number_of_events: size_t,
        context: *mut rcl_context_t,
        allocator: rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a rcl wait set."]
    #[doc = "* *"]
    #[doc = "* Deallocates any memory in the wait set that was allocated in"]
    #[doc = "* rcl_wait_set_init() using the allocator given in the initialization."]
    #[doc = "* "]
    #[doc = "* Calling this function on a zero initialized wait set will do nothing and"]
    #[doc = "* return RCL_RET_OK."]
    #[doc = "* Calling this function on uninitialized memory results in undefined behavior."]
    #[doc = "* After calling this function the wait set will once again be zero initialized"]
    #[doc = "* and so calling this function or rcl_wait_set_init() immediately after will"]
    #[doc = "* succeed."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] wait_set the wait set struct to be finalized."]
    #[doc = "* \\return #RCL_RET_OK if the finalization was successful, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_WAIT_SET_INVALID if the wait set is not destroyed properly, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_wait_set_fini(wait_set: *mut rcl_wait_set_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Retrieve the wait set's allocator."]
    #[doc = "* *"]
    #[doc = "* The allocator must be an allocated rcl_allocator_t struct, as the result is"]
    #[doc = "* copied into this variable."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] wait_set the handle to the wait set"]
    #[doc = "* \\param[out] allocator the rcl_allocator_t struct to which the result is copied"]
    #[doc = "* \\return #RCL_RET_OK if the allocator was successfully retrieved, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_WAIT_SET_INVALID if the wait set is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_wait_set_get_allocator(
        wait_set: *const rcl_wait_set_t,
        allocator: *mut rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Store a pointer to the given subscription in the next empty spot in the set."]
    #[doc = "* *"]
    #[doc = "* This function does not guarantee that the subscription is not already in the"]
    #[doc = "* wait set."]
    #[doc = "* "]
    #[doc = "* Also add the rmw representation to the underlying rmw array and increment"]
    #[doc = "* the rmw array count."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] wait_set struct in which the subscription is to be stored"]
    #[doc = "* \\param[in] subscription the subscription to be added to the wait set"]
    #[doc = "* \\param[out] index the index of the added subscription in the storage container."]
    #[doc = "* This parameter is optional and can be set to `NULL` to be ignored."]
    #[doc = "* \\return #RCL_RET_OK if added successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_WAIT_SET_INVALID if the wait set is zero initialized, or"]
    #[doc = "* \\return #RCL_RET_WAIT_SET_FULL if the subscription set is full, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_wait_set_add_subscription(
        wait_set: *mut rcl_wait_set_t,
        subscription: *const rcl_subscription_t,
        index: *mut size_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Remove (sets to `NULL`) all entities in the wait set."]
    #[doc = "* *"]
    #[doc = "* This function should be used after passing using rcl_wait, but before"]
    #[doc = "* adding new entities to the set."]
    #[doc = "* Sets all of the entries in the underlying rmw array to `NULL`, and sets the"]
    #[doc = "* count in the rmw array to `0`."]
    #[doc = "* "]
    #[doc = "* Calling this on an uninitialized (zero initialized) wait set will fail."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] wait_set struct to have its entities cleared"]
    #[doc = "* \\return #RCL_RET_OK if cleared successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_WAIT_SET_INVALID if the wait set is zero initialized, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_wait_set_clear(wait_set: *mut rcl_wait_set_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Reallocate space for entities in the wait set."]
    #[doc = "* *"]
    #[doc = "* This function will deallocate and reallocate the memory for all entity sets."]
    #[doc = "* "]
    #[doc = "* A size of 0 will just deallocate the memory and assign `NULL` to the array."]
    #[doc = "* "]
    #[doc = "* Allocation and deallocation is done with the allocator given during the"]
    #[doc = "* wait set's initialization."]
    #[doc = "* "]
    #[doc = "* After calling this function all values in the set will be set to `NULL`,"]
    #[doc = "* effectively the same as calling rcl_wait_set_clear()."]
    #[doc = "* Similarly, the underlying rmw representation is reallocated and reset:"]
    #[doc = "* all entries are set to `NULL` and the count is set to zero."]
    #[doc = "* "]
    #[doc = "* If the requested size matches the current size, no allocation will be done."]
    #[doc = "* "]
    #[doc = "* This can be called on an uninitialized (zero initialized) wait set."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] wait_set struct to be resized"]
    #[doc = "* \\param[in] subscriptions_size a size for the new subscriptions set"]
    #[doc = "* \\param[in] guard_conditions_size a size for the new guard conditions set"]
    #[doc = "* \\param[in] timers_size a size for the new timers set"]
    #[doc = "* \\param[in] clients_size a size for the new clients set"]
    #[doc = "* \\param[in] services_size a size for the new services set"]
    #[doc = "* \\param[in] events_size a size for the new events set"]
    #[doc = "* \\return #RCL_RET_OK if resized successfully, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_wait_set_resize(
        wait_set: *mut rcl_wait_set_t,
        subscriptions_size: size_t,
        guard_conditions_size: size_t,
        timers_size: size_t,
        clients_size: size_t,
        services_size: size_t,
        events_size: size_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Store a pointer to the guard condition in the next empty spot in the set."]
    #[doc = "* *"]
    #[doc = "* This function behaves exactly the same as for subscriptions."]
    #[doc = "* \\see rcl_wait_set_add_subscription"]
    #[doc = "* /"]
    pub fn rcl_wait_set_add_guard_condition(
        wait_set: *mut rcl_wait_set_t,
        guard_condition: *const rcl_guard_condition_t,
        index: *mut size_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Store a pointer to the timer in the next empty spot in the set."]
    #[doc = "* *"]
    #[doc = "* This function behaves exactly the same as for subscriptions."]
    #[doc = "* \\see rcl_wait_set_add_subscription"]
    #[doc = "* /"]
    pub fn rcl_wait_set_add_timer(
        wait_set: *mut rcl_wait_set_t,
        timer: *const rcl_timer_t,
        index: *mut size_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Store a pointer to the client in the next empty spot in the set."]
    #[doc = "* *"]
    #[doc = "* This function behaves exactly the same as for subscriptions."]
    #[doc = "* \\see rcl_wait_set_add_subscription"]
    #[doc = "* /"]
    pub fn rcl_wait_set_add_client(
        wait_set: *mut rcl_wait_set_t,
        client: *const rcl_client_t,
        index: *mut size_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Store a pointer to the service in the next empty spot in the set."]
    #[doc = "* *"]
    #[doc = "* This function behaves exactly the same as for subscriptions."]
    #[doc = "* \\see rcl_wait_set_add_subscription"]
    #[doc = "* /"]
    pub fn rcl_wait_set_add_service(
        wait_set: *mut rcl_wait_set_t,
        service: *const rcl_service_t,
        index: *mut size_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Store a pointer to the event in the next empty spot in the set."]
    #[doc = "* *"]
    #[doc = "* This function behaves exactly the same as for subscriptions."]
    #[doc = "* \\see rcl_wait_set_add_subscription"]
    #[doc = "* /"]
    pub fn rcl_wait_set_add_event(
        wait_set: *mut rcl_wait_set_t,
        event: *const rcl_event_t,
        index: *mut size_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Block until the wait set is ready or until the timeout has been exceeded."]
    #[doc = "* *"]
    #[doc = "* This function will collect the items in the rcl_wait_set_t and pass them"]
    #[doc = "* to the underlying rmw_wait function."]
    #[doc = "* "]
    #[doc = "* The items in the wait set will be either left untouched or set to `NULL` after"]
    #[doc = "* this function returns."]
    #[doc = "* Items that are not `NULL` are ready, where ready means different things based"]
    #[doc = "* on the type of the item."]
    #[doc = "* For subscriptions this means there may be messages that can be taken, or"]
    #[doc = "* perhaps that the state of the subscriptions has changed, in which case"]
    #[doc = "* rcl_take may succeed but return with taken == false."]
    #[doc = "* For guard conditions this means the guard condition was triggered."]
    #[doc = "* "]
    #[doc = "* Expected usage:"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* #include <rcl/rcl.h>"]
    #[doc = "* "]
    #[doc = "* // rcl_init() called successfully before here..."]
    #[doc = "* rcl_node_t node;  // initialize this, see rcl_node_init()"]
    #[doc = "* rcl_subscription_t sub1;  // initialize this, see rcl_subscription_init()"]
    #[doc = "* rcl_subscription_t sub2;  // initialize this, see rcl_subscription_init()"]
    #[doc = "* rcl_guard_condition_t gc1;  // initialize this, see rcl_guard_condition_init()"]
    #[doc = "* rcl_wait_set_t wait_set = rcl_get_zero_initialized_wait_set();"]
    #[doc = "* rcl_ret_t ret = rcl_wait_set_init(&wait_set, 2, 1, 0, 0, 0, rcl_get_default_allocator());"]
    #[doc = "* // ... error handling"]
    #[doc = "* do {"]
    #[doc = "* ret = rcl_wait_set_clear(&wait_set);"]
    #[doc = "* // ... error handling"]
    #[doc = "* ret = rcl_wait_set_add_subscription(&wait_set, &sub1);"]
    #[doc = "* // ... error handling"]
    #[doc = "* ret = rcl_wait_set_add_subscription(&wait_set, &sub2);"]
    #[doc = "* // ... error handling"]
    #[doc = "* ret = rcl_wait_set_add_guard_condition(&wait_set, &gc1);"]
    #[doc = "* // ... error handling"]
    #[doc = "* ret = rcl_wait(&wait_set, RCL_MS_TO_NS(1000));  // 1000ms == 1s, passed as ns"]
    #[doc = "* if (ret == RCL_RET_TIMEOUT) {"]
    #[doc = "* continue;"]
    #[doc = "* }"]
    #[doc = "* for (int i = 0; i < wait_set.size_of_subscriptions; ++i) {"]
    #[doc = "* if (wait_set.subscriptions[i]) {"]
    #[doc = "* // The subscription is ready..."]
    #[doc = "* }"]
    #[doc = "* }"]
    #[doc = "* for (int i = 0; i < wait_set.size_of_guard_conditions; ++i) {"]
    #[doc = "* if (wait_set.guard_conditions[i]) {"]
    #[doc = "* // The subscription is ready..."]
    #[doc = "* }"]
    #[doc = "* }"]
    #[doc = "* } while(check_some_condition());"]
    #[doc = "* // ... fini node, and subscriptions and guard conditions..."]
    #[doc = "* ret = rcl_wait_set_fini(&wait_set);"]
    #[doc = "* // ... error handling"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* The wait set struct must be allocated, initialized, and should have been"]
    #[doc = "* cleared and then filled with items, e.g. subscriptions and guard conditions."]
    #[doc = "* Passing a wait set with no wait-able items in it will fail."]
    #[doc = "* `NULL` items in the sets are ignored, e.g. it is valid to have as input:"]
    #[doc = "* - `subscriptions[0]` = valid pointer"]
    #[doc = "* - `subscriptions[1]` = `NULL`"]
    #[doc = "* - `subscriptions[2]` = valid pointer"]
    #[doc = "* - `size_of_subscriptions` = 3"]
    #[doc = "* Passing an uninitialized (zero initialized) wait set struct will fail."]
    #[doc = "* Passing a wait set struct with uninitialized memory is undefined behavior."]
    #[doc = "* "]
    #[doc = "* The unit of timeout is nanoseconds."]
    #[doc = "* If the timeout is negative then this function will block indefinitely until"]
    #[doc = "* something in the wait set is valid or it is interrupted."]
    #[doc = "* If the timeout is 0 then this function will be non-blocking; checking what's"]
    #[doc = "* ready now, but not waiting if nothing is ready yet."]
    #[doc = "* If the timeout is greater than 0 then this function will return after"]
    #[doc = "* that period of time has elapsed or the wait set becomes ready, which ever"]
    #[doc = "* comes first."]
    #[doc = "* Passing a timeout struct with uninitialized memory is undefined behavior."]
    #[doc = "* "]
    #[doc = "* This function is thread-safe for unique wait sets with unique contents."]
    #[doc = "* This function cannot operate on the same wait set in multiple threads, and"]
    #[doc = "* the wait sets may not share content."]
    #[doc = "* For example, calling rcl_wait() in two threads on two different wait sets"]
    #[doc = "* that both contain a single, shared guard condition is undefined behavior."]
    #[doc = "* "]
    #[doc = "* \\param[inout] wait_set the set of things to be waited on and to be pruned if not ready"]
    #[doc = "* \\param[in] timeout the duration to wait for the wait set to be ready, in nanoseconds"]
    #[doc = "* \\return #RCL_RET_OK something in the wait set became ready, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_WAIT_SET_INVALID if the wait set is zero initialized, or"]
    #[doc = "* \\return #RCL_RET_WAIT_SET_EMPTY if the wait set contains no items, or"]
    #[doc = "* \\return #RCL_RET_TIMEOUT if the timeout expired before something was ready, or"]
    #[doc = "* \\return #RCL_RET_ERROR an unspecified error occur."]
    #[doc = "* /"]
    pub fn rcl_wait(wait_set: *mut rcl_wait_set_t, timeout: i64) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return `true` if the wait set is valid, else `false`."]
    #[doc = "* *"]
    #[doc = "* A wait set is invalid if:"]
    #[doc = "* - the implementation is `NULL` (rcl_wait_set_init not called or failed)"]
    #[doc = "* - the wait set has been finalized with rcl_wait_set_fini"]
    #[doc = "* "]
    #[doc = "* Also return `false` if the wait set pointer is `NULL`."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] wait_set the rcl_wait_set_t to be validated"]
    #[doc = "* \\return `true` if the wait_set is valid, otherwise `false`."]
    #[doc = "* /"]
    pub fn rcl_wait_set_is_valid(wait_set: *const rcl_wait_set_t) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unique_identifier_msgs__msg__UUID {
    pub uuid: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_unique_identifier_msgs__msg__UUID() {
    assert_eq!(
        ::std::mem::size_of::<unique_identifier_msgs__msg__UUID>(),
        16usize,
        concat!("Size of: ", stringify!(unique_identifier_msgs__msg__UUID))
    );
    assert_eq!(
        ::std::mem::align_of::<unique_identifier_msgs__msg__UUID>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(unique_identifier_msgs__msg__UUID)
        )
    );
    fn test_field_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<unique_identifier_msgs__msg__UUID>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uuid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(unique_identifier_msgs__msg__UUID),
                "::",
                stringify!(uuid)
            )
        );
    }
    test_field_uuid();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unique_identifier_msgs__msg__UUID__Sequence {
    pub data: *mut unique_identifier_msgs__msg__UUID,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_unique_identifier_msgs__msg__UUID__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<unique_identifier_msgs__msg__UUID__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(unique_identifier_msgs__msg__UUID__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<unique_identifier_msgs__msg__UUID__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(unique_identifier_msgs__msg__UUID__Sequence)
        )
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<unique_identifier_msgs__msg__UUID__Sequence>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(unique_identifier_msgs__msg__UUID__Sequence),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<unique_identifier_msgs__msg__UUID__Sequence>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(unique_identifier_msgs__msg__UUID__Sequence),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_capacity() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<unique_identifier_msgs__msg__UUID__Sequence>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(unique_identifier_msgs__msg__UUID__Sequence),
                "::",
                stringify!(capacity)
            )
        );
    }
    test_field_capacity();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct builtin_interfaces__msg__Time {
    pub sec: i32,
    pub nanosec: u32,
}
#[test]
fn bindgen_test_layout_builtin_interfaces__msg__Time() {
    assert_eq!(
        ::std::mem::size_of::<builtin_interfaces__msg__Time>(),
        8usize,
        concat!("Size of: ", stringify!(builtin_interfaces__msg__Time))
    );
    assert_eq!(
        ::std::mem::align_of::<builtin_interfaces__msg__Time>(),
        4usize,
        concat!("Alignment of ", stringify!(builtin_interfaces__msg__Time))
    );
    fn test_field_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<builtin_interfaces__msg__Time>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(builtin_interfaces__msg__Time),
                "::",
                stringify!(sec)
            )
        );
    }
    test_field_sec();
    fn test_field_nanosec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<builtin_interfaces__msg__Time>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nanosec) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(builtin_interfaces__msg__Time),
                "::",
                stringify!(nanosec)
            )
        );
    }
    test_field_nanosec();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct builtin_interfaces__msg__Time__Sequence {
    pub data: *mut builtin_interfaces__msg__Time,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_builtin_interfaces__msg__Time__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<builtin_interfaces__msg__Time__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(builtin_interfaces__msg__Time__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<builtin_interfaces__msg__Time__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(builtin_interfaces__msg__Time__Sequence)
        )
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<builtin_interfaces__msg__Time__Sequence>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(builtin_interfaces__msg__Time__Sequence),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<builtin_interfaces__msg__Time__Sequence>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(builtin_interfaces__msg__Time__Sequence),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_capacity() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<builtin_interfaces__msg__Time__Sequence>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(builtin_interfaces__msg__Time__Sequence),
                "::",
                stringify!(capacity)
            )
        );
    }
    test_field_capacity();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_msgs__msg__GoalInfo {
    pub goal_id: unique_identifier_msgs__msg__UUID,
    pub stamp: builtin_interfaces__msg__Time,
}
#[test]
fn bindgen_test_layout_action_msgs__msg__GoalInfo() {
    assert_eq!(
        ::std::mem::size_of::<action_msgs__msg__GoalInfo>(),
        24usize,
        concat!("Size of: ", stringify!(action_msgs__msg__GoalInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<action_msgs__msg__GoalInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(action_msgs__msg__GoalInfo))
    );
    fn test_field_goal_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<action_msgs__msg__GoalInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).goal_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(action_msgs__msg__GoalInfo),
                "::",
                stringify!(goal_id)
            )
        );
    }
    test_field_goal_id();
    fn test_field_stamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<action_msgs__msg__GoalInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stamp) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(action_msgs__msg__GoalInfo),
                "::",
                stringify!(stamp)
            )
        );
    }
    test_field_stamp();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_msgs__msg__GoalInfo__Sequence {
    pub data: *mut action_msgs__msg__GoalInfo,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_action_msgs__msg__GoalInfo__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<action_msgs__msg__GoalInfo__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(action_msgs__msg__GoalInfo__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<action_msgs__msg__GoalInfo__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(action_msgs__msg__GoalInfo__Sequence)
        )
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<action_msgs__msg__GoalInfo__Sequence>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(action_msgs__msg__GoalInfo__Sequence),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<action_msgs__msg__GoalInfo__Sequence>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(action_msgs__msg__GoalInfo__Sequence),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_capacity() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<action_msgs__msg__GoalInfo__Sequence>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(action_msgs__msg__GoalInfo__Sequence),
                "::",
                stringify!(capacity)
            )
        );
    }
    test_field_capacity();
}
extern "C" {
    #[doc = " Initialize msg/GoalInfo message."]
    #[doc = "* *"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* action_msgs__msg__GoalInfo"]
    #[doc = "* )) before or use"]
    #[doc = "* action_msgs__msg__GoalInfo__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalInfo__init(msg: *mut action_msgs__msg__GoalInfo) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/GoalInfo message."]
    #[doc = "* *"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalInfo__fini(msg: *mut action_msgs__msg__GoalInfo);
}
extern "C" {
    #[doc = " Create msg/GoalInfo message."]
    #[doc = "* *"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* action_msgs__msg__GoalInfo__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalInfo__create() -> *mut action_msgs__msg__GoalInfo;
}
extern "C" {
    #[doc = " Destroy msg/GoalInfo message."]
    #[doc = "* *"]
    #[doc = "* It calls"]
    #[doc = "* action_msgs__msg__GoalInfo__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalInfo__destroy(msg: *mut action_msgs__msg__GoalInfo);
}
extern "C" {
    #[doc = " Check for msg/GoalInfo message equality."]
    #[doc = "* *"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalInfo__are_equal(
        lhs: *const action_msgs__msg__GoalInfo,
        rhs: *const action_msgs__msg__GoalInfo,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/GoalInfo message."]
    #[doc = "* *"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "* "]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "* have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "* or memory allocation fails."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalInfo__copy(
        input: *const action_msgs__msg__GoalInfo,
        output: *mut action_msgs__msg__GoalInfo,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/GoalInfo messages."]
    #[doc = "* *"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* action_msgs__msg__GoalInfo__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalInfo__Sequence__init(
        array: *mut action_msgs__msg__GoalInfo__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/GoalInfo messages."]
    #[doc = "* *"]
    #[doc = "* It calls"]
    #[doc = "* action_msgs__msg__GoalInfo__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalInfo__Sequence__fini(
        array: *mut action_msgs__msg__GoalInfo__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/GoalInfo messages."]
    #[doc = "* *"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* action_msgs__msg__GoalInfo__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalInfo__Sequence__create(
        size: size_t,
    ) -> *mut action_msgs__msg__GoalInfo__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/GoalInfo messages."]
    #[doc = "* *"]
    #[doc = "* It calls"]
    #[doc = "* action_msgs__msg__GoalInfo__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalInfo__Sequence__destroy(
        array: *mut action_msgs__msg__GoalInfo__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/GoalInfo message array equality."]
    #[doc = "* *"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalInfo__Sequence__are_equal(
        lhs: *const action_msgs__msg__GoalInfo__Sequence,
        rhs: *const action_msgs__msg__GoalInfo__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/GoalInfo messages."]
    #[doc = "* *"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "* "]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "* have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "* is null or memory allocation fails."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalInfo__Sequence__copy(
        input: *const action_msgs__msg__GoalInfo__Sequence,
        output: *mut action_msgs__msg__GoalInfo__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__action_msgs__msg__GoalInfo(
    ) -> *const rosidl_message_type_support_t;
}
pub const action_msgs__msg__GoalStatus__STATUS_UNKNOWN: _bindgen_ty_2 = 0;
#[doc = " Constant 'STATUS_UNKNOWN'."]
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const action_msgs__msg__GoalStatus__STATUS_ACCEPTED: _bindgen_ty_3 = 1;
#[doc = " Constant 'STATUS_ACCEPTED'."]
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const action_msgs__msg__GoalStatus__STATUS_EXECUTING: _bindgen_ty_4 = 2;
#[doc = " Constant 'STATUS_EXECUTING'."]
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const action_msgs__msg__GoalStatus__STATUS_CANCELING: _bindgen_ty_5 = 3;
#[doc = " Constant 'STATUS_CANCELING'."]
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const action_msgs__msg__GoalStatus__STATUS_SUCCEEDED: _bindgen_ty_6 = 4;
#[doc = " Constant 'STATUS_SUCCEEDED'."]
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const action_msgs__msg__GoalStatus__STATUS_CANCELED: _bindgen_ty_7 = 5;
#[doc = " Constant 'STATUS_CANCELED'."]
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const action_msgs__msg__GoalStatus__STATUS_ABORTED: _bindgen_ty_8 = 6;
#[doc = " Constant 'STATUS_ABORTED'."]
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_msgs__msg__GoalStatus {
    pub goal_info: action_msgs__msg__GoalInfo,
    pub status: i8,
}
#[test]
fn bindgen_test_layout_action_msgs__msg__GoalStatus() {
    assert_eq!(
        ::std::mem::size_of::<action_msgs__msg__GoalStatus>(),
        28usize,
        concat!("Size of: ", stringify!(action_msgs__msg__GoalStatus))
    );
    assert_eq!(
        ::std::mem::align_of::<action_msgs__msg__GoalStatus>(),
        4usize,
        concat!("Alignment of ", stringify!(action_msgs__msg__GoalStatus))
    );
    fn test_field_goal_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<action_msgs__msg__GoalStatus>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).goal_info) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(action_msgs__msg__GoalStatus),
                "::",
                stringify!(goal_info)
            )
        );
    }
    test_field_goal_info();
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<action_msgs__msg__GoalStatus>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(action_msgs__msg__GoalStatus),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_msgs__msg__GoalStatus__Sequence {
    pub data: *mut action_msgs__msg__GoalStatus,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_action_msgs__msg__GoalStatus__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<action_msgs__msg__GoalStatus__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(action_msgs__msg__GoalStatus__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<action_msgs__msg__GoalStatus__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(action_msgs__msg__GoalStatus__Sequence)
        )
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<action_msgs__msg__GoalStatus__Sequence>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(action_msgs__msg__GoalStatus__Sequence),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<action_msgs__msg__GoalStatus__Sequence>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(action_msgs__msg__GoalStatus__Sequence),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_capacity() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<action_msgs__msg__GoalStatus__Sequence>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(action_msgs__msg__GoalStatus__Sequence),
                "::",
                stringify!(capacity)
            )
        );
    }
    test_field_capacity();
}
extern "C" {
    #[doc = " Initialize msg/GoalStatus message."]
    #[doc = "* *"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* action_msgs__msg__GoalStatus"]
    #[doc = "* )) before or use"]
    #[doc = "* action_msgs__msg__GoalStatus__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalStatus__init(msg: *mut action_msgs__msg__GoalStatus) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/GoalStatus message."]
    #[doc = "* *"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalStatus__fini(msg: *mut action_msgs__msg__GoalStatus);
}
extern "C" {
    #[doc = " Create msg/GoalStatus message."]
    #[doc = "* *"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* action_msgs__msg__GoalStatus__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalStatus__create() -> *mut action_msgs__msg__GoalStatus;
}
extern "C" {
    #[doc = " Destroy msg/GoalStatus message."]
    #[doc = "* *"]
    #[doc = "* It calls"]
    #[doc = "* action_msgs__msg__GoalStatus__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalStatus__destroy(msg: *mut action_msgs__msg__GoalStatus);
}
extern "C" {
    #[doc = " Check for msg/GoalStatus message equality."]
    #[doc = "* *"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalStatus__are_equal(
        lhs: *const action_msgs__msg__GoalStatus,
        rhs: *const action_msgs__msg__GoalStatus,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/GoalStatus message."]
    #[doc = "* *"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "* "]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "* have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "* or memory allocation fails."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalStatus__copy(
        input: *const action_msgs__msg__GoalStatus,
        output: *mut action_msgs__msg__GoalStatus,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/GoalStatus messages."]
    #[doc = "* *"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* action_msgs__msg__GoalStatus__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalStatus__Sequence__init(
        array: *mut action_msgs__msg__GoalStatus__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/GoalStatus messages."]
    #[doc = "* *"]
    #[doc = "* It calls"]
    #[doc = "* action_msgs__msg__GoalStatus__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalStatus__Sequence__fini(
        array: *mut action_msgs__msg__GoalStatus__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/GoalStatus messages."]
    #[doc = "* *"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* action_msgs__msg__GoalStatus__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalStatus__Sequence__create(
        size: size_t,
    ) -> *mut action_msgs__msg__GoalStatus__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/GoalStatus messages."]
    #[doc = "* *"]
    #[doc = "* It calls"]
    #[doc = "* action_msgs__msg__GoalStatus__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalStatus__Sequence__destroy(
        array: *mut action_msgs__msg__GoalStatus__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/GoalStatus message array equality."]
    #[doc = "* *"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalStatus__Sequence__are_equal(
        lhs: *const action_msgs__msg__GoalStatus__Sequence,
        rhs: *const action_msgs__msg__GoalStatus__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/GoalStatus messages."]
    #[doc = "* *"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "* "]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "* have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "* is null or memory allocation fails."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalStatus__Sequence__copy(
        input: *const action_msgs__msg__GoalStatus__Sequence,
        output: *mut action_msgs__msg__GoalStatus__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__action_msgs__msg__GoalStatus(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_msgs__msg__GoalStatusArray {
    pub status_list: action_msgs__msg__GoalStatus__Sequence,
}
#[test]
fn bindgen_test_layout_action_msgs__msg__GoalStatusArray() {
    assert_eq!(
        ::std::mem::size_of::<action_msgs__msg__GoalStatusArray>(),
        24usize,
        concat!("Size of: ", stringify!(action_msgs__msg__GoalStatusArray))
    );
    assert_eq!(
        ::std::mem::align_of::<action_msgs__msg__GoalStatusArray>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(action_msgs__msg__GoalStatusArray)
        )
    );
    fn test_field_status_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<action_msgs__msg__GoalStatusArray>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status_list) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(action_msgs__msg__GoalStatusArray),
                "::",
                stringify!(status_list)
            )
        );
    }
    test_field_status_list();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_msgs__msg__GoalStatusArray__Sequence {
    pub data: *mut action_msgs__msg__GoalStatusArray,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_action_msgs__msg__GoalStatusArray__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<action_msgs__msg__GoalStatusArray__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(action_msgs__msg__GoalStatusArray__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<action_msgs__msg__GoalStatusArray__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(action_msgs__msg__GoalStatusArray__Sequence)
        )
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<action_msgs__msg__GoalStatusArray__Sequence>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(action_msgs__msg__GoalStatusArray__Sequence),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<action_msgs__msg__GoalStatusArray__Sequence>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(action_msgs__msg__GoalStatusArray__Sequence),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_capacity() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<action_msgs__msg__GoalStatusArray__Sequence>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(action_msgs__msg__GoalStatusArray__Sequence),
                "::",
                stringify!(capacity)
            )
        );
    }
    test_field_capacity();
}
extern "C" {
    #[doc = " Initialize msg/GoalStatusArray message."]
    #[doc = "* *"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* action_msgs__msg__GoalStatusArray"]
    #[doc = "* )) before or use"]
    #[doc = "* action_msgs__msg__GoalStatusArray__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalStatusArray__init(
        msg: *mut action_msgs__msg__GoalStatusArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/GoalStatusArray message."]
    #[doc = "* *"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalStatusArray__fini(msg: *mut action_msgs__msg__GoalStatusArray);
}
extern "C" {
    #[doc = " Create msg/GoalStatusArray message."]
    #[doc = "* *"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* action_msgs__msg__GoalStatusArray__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalStatusArray__create() -> *mut action_msgs__msg__GoalStatusArray;
}
extern "C" {
    #[doc = " Destroy msg/GoalStatusArray message."]
    #[doc = "* *"]
    #[doc = "* It calls"]
    #[doc = "* action_msgs__msg__GoalStatusArray__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalStatusArray__destroy(msg: *mut action_msgs__msg__GoalStatusArray);
}
extern "C" {
    #[doc = " Check for msg/GoalStatusArray message equality."]
    #[doc = "* *"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalStatusArray__are_equal(
        lhs: *const action_msgs__msg__GoalStatusArray,
        rhs: *const action_msgs__msg__GoalStatusArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/GoalStatusArray message."]
    #[doc = "* *"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "* "]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "* have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "* or memory allocation fails."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalStatusArray__copy(
        input: *const action_msgs__msg__GoalStatusArray,
        output: *mut action_msgs__msg__GoalStatusArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/GoalStatusArray messages."]
    #[doc = "* *"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* action_msgs__msg__GoalStatusArray__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalStatusArray__Sequence__init(
        array: *mut action_msgs__msg__GoalStatusArray__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/GoalStatusArray messages."]
    #[doc = "* *"]
    #[doc = "* It calls"]
    #[doc = "* action_msgs__msg__GoalStatusArray__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalStatusArray__Sequence__fini(
        array: *mut action_msgs__msg__GoalStatusArray__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/GoalStatusArray messages."]
    #[doc = "* *"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* action_msgs__msg__GoalStatusArray__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalStatusArray__Sequence__create(
        size: size_t,
    ) -> *mut action_msgs__msg__GoalStatusArray__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/GoalStatusArray messages."]
    #[doc = "* *"]
    #[doc = "* It calls"]
    #[doc = "* action_msgs__msg__GoalStatusArray__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalStatusArray__Sequence__destroy(
        array: *mut action_msgs__msg__GoalStatusArray__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/GoalStatusArray message array equality."]
    #[doc = "* *"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalStatusArray__Sequence__are_equal(
        lhs: *const action_msgs__msg__GoalStatusArray__Sequence,
        rhs: *const action_msgs__msg__GoalStatusArray__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/GoalStatusArray messages."]
    #[doc = "* *"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "* "]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "* have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "* is null or memory allocation fails."]
    #[doc = "* /"]
    pub fn action_msgs__msg__GoalStatusArray__Sequence__copy(
        input: *const action_msgs__msg__GoalStatusArray__Sequence,
        output: *mut action_msgs__msg__GoalStatusArray__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__action_msgs__msg__GoalStatusArray(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_msgs__srv__CancelGoal_Request {
    pub goal_info: action_msgs__msg__GoalInfo,
}
#[test]
fn bindgen_test_layout_action_msgs__srv__CancelGoal_Request() {
    assert_eq!(
        ::std::mem::size_of::<action_msgs__srv__CancelGoal_Request>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(action_msgs__srv__CancelGoal_Request)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<action_msgs__srv__CancelGoal_Request>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(action_msgs__srv__CancelGoal_Request)
        )
    );
    fn test_field_goal_info() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<action_msgs__srv__CancelGoal_Request>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).goal_info) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(action_msgs__srv__CancelGoal_Request),
                "::",
                stringify!(goal_info)
            )
        );
    }
    test_field_goal_info();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_msgs__srv__CancelGoal_Request__Sequence {
    pub data: *mut action_msgs__srv__CancelGoal_Request,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_action_msgs__srv__CancelGoal_Request__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<action_msgs__srv__CancelGoal_Request__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(action_msgs__srv__CancelGoal_Request__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<action_msgs__srv__CancelGoal_Request__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(action_msgs__srv__CancelGoal_Request__Sequence)
        )
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    action_msgs__srv__CancelGoal_Request__Sequence,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(action_msgs__srv__CancelGoal_Request__Sequence),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    action_msgs__srv__CancelGoal_Request__Sequence,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(action_msgs__srv__CancelGoal_Request__Sequence),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_capacity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    action_msgs__srv__CancelGoal_Request__Sequence,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(action_msgs__srv__CancelGoal_Request__Sequence),
                "::",
                stringify!(capacity)
            )
        );
    }
    test_field_capacity();
}
pub const action_msgs__srv__CancelGoal_Response__ERROR_NONE: _bindgen_ty_9 = 0;
#[doc = " Constant 'ERROR_NONE'."]
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub const action_msgs__srv__CancelGoal_Response__ERROR_REJECTED: _bindgen_ty_10 = 1;
#[doc = " Constant 'ERROR_REJECTED'."]
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
pub const action_msgs__srv__CancelGoal_Response__ERROR_UNKNOWN_GOAL_ID: _bindgen_ty_11 = 2;
#[doc = " Constant 'ERROR_UNKNOWN_GOAL_ID'."]
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub const action_msgs__srv__CancelGoal_Response__ERROR_GOAL_TERMINATED: _bindgen_ty_12 = 3;
#[doc = " Constant 'ERROR_GOAL_TERMINATED'."]
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_msgs__srv__CancelGoal_Response {
    pub return_code: i8,
    pub goals_canceling: action_msgs__msg__GoalInfo__Sequence,
}
#[test]
fn bindgen_test_layout_action_msgs__srv__CancelGoal_Response() {
    assert_eq!(
        ::std::mem::size_of::<action_msgs__srv__CancelGoal_Response>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(action_msgs__srv__CancelGoal_Response)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<action_msgs__srv__CancelGoal_Response>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(action_msgs__srv__CancelGoal_Response)
        )
    );
    fn test_field_return_code() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<action_msgs__srv__CancelGoal_Response>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).return_code) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(action_msgs__srv__CancelGoal_Response),
                "::",
                stringify!(return_code)
            )
        );
    }
    test_field_return_code();
    fn test_field_goals_canceling() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<action_msgs__srv__CancelGoal_Response>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).goals_canceling) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(action_msgs__srv__CancelGoal_Response),
                "::",
                stringify!(goals_canceling)
            )
        );
    }
    test_field_goals_canceling();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_msgs__srv__CancelGoal_Response__Sequence {
    pub data: *mut action_msgs__srv__CancelGoal_Response,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_action_msgs__srv__CancelGoal_Response__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<action_msgs__srv__CancelGoal_Response__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(action_msgs__srv__CancelGoal_Response__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<action_msgs__srv__CancelGoal_Response__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(action_msgs__srv__CancelGoal_Response__Sequence)
        )
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    action_msgs__srv__CancelGoal_Response__Sequence,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(action_msgs__srv__CancelGoal_Response__Sequence),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    action_msgs__srv__CancelGoal_Response__Sequence,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(action_msgs__srv__CancelGoal_Response__Sequence),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_capacity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    action_msgs__srv__CancelGoal_Response__Sequence,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(action_msgs__srv__CancelGoal_Response__Sequence),
                "::",
                stringify!(capacity)
            )
        );
    }
    test_field_capacity();
}
extern "C" {
    #[doc = " Initialize srv/CancelGoal message."]
    #[doc = "* *"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* action_msgs__srv__CancelGoal_Request"]
    #[doc = "* )) before or use"]
    #[doc = "* action_msgs__srv__CancelGoal_Request__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* /"]
    pub fn action_msgs__srv__CancelGoal_Request__init(
        msg: *mut action_msgs__srv__CancelGoal_Request,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize srv/CancelGoal message."]
    #[doc = "* *"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "* /"]
    pub fn action_msgs__srv__CancelGoal_Request__fini(
        msg: *mut action_msgs__srv__CancelGoal_Request,
    );
}
extern "C" {
    #[doc = " Create srv/CancelGoal message."]
    #[doc = "* *"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* action_msgs__srv__CancelGoal_Request__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "* /"]
    pub fn action_msgs__srv__CancelGoal_Request__create(
    ) -> *mut action_msgs__srv__CancelGoal_Request;
}
extern "C" {
    #[doc = " Destroy srv/CancelGoal message."]
    #[doc = "* *"]
    #[doc = "* It calls"]
    #[doc = "* action_msgs__srv__CancelGoal_Request__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "* /"]
    pub fn action_msgs__srv__CancelGoal_Request__destroy(
        msg: *mut action_msgs__srv__CancelGoal_Request,
    );
}
extern "C" {
    #[doc = " Check for srv/CancelGoal message equality."]
    #[doc = "* *"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "* /"]
    pub fn action_msgs__srv__CancelGoal_Request__are_equal(
        lhs: *const action_msgs__srv__CancelGoal_Request,
        rhs: *const action_msgs__srv__CancelGoal_Request,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a srv/CancelGoal message."]
    #[doc = "* *"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "* "]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "* have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "* or memory allocation fails."]
    #[doc = "* /"]
    pub fn action_msgs__srv__CancelGoal_Request__copy(
        input: *const action_msgs__srv__CancelGoal_Request,
        output: *mut action_msgs__srv__CancelGoal_Request,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of srv/CancelGoal messages."]
    #[doc = "* *"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* action_msgs__srv__CancelGoal_Request__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "* /"]
    pub fn action_msgs__srv__CancelGoal_Request__Sequence__init(
        array: *mut action_msgs__srv__CancelGoal_Request__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of srv/CancelGoal messages."]
    #[doc = "* *"]
    #[doc = "* It calls"]
    #[doc = "* action_msgs__srv__CancelGoal_Request__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "* /"]
    pub fn action_msgs__srv__CancelGoal_Request__Sequence__fini(
        array: *mut action_msgs__srv__CancelGoal_Request__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of srv/CancelGoal messages."]
    #[doc = "* *"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* action_msgs__srv__CancelGoal_Request__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "* /"]
    pub fn action_msgs__srv__CancelGoal_Request__Sequence__create(
        size: size_t,
    ) -> *mut action_msgs__srv__CancelGoal_Request__Sequence;
}
extern "C" {
    #[doc = " Destroy array of srv/CancelGoal messages."]
    #[doc = "* *"]
    #[doc = "* It calls"]
    #[doc = "* action_msgs__srv__CancelGoal_Request__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "* /"]
    pub fn action_msgs__srv__CancelGoal_Request__Sequence__destroy(
        array: *mut action_msgs__srv__CancelGoal_Request__Sequence,
    );
}
extern "C" {
    #[doc = " Check for srv/CancelGoal message array equality."]
    #[doc = "* *"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "* /"]
    pub fn action_msgs__srv__CancelGoal_Request__Sequence__are_equal(
        lhs: *const action_msgs__srv__CancelGoal_Request__Sequence,
        rhs: *const action_msgs__srv__CancelGoal_Request__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of srv/CancelGoal messages."]
    #[doc = "* *"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "* "]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "* have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "* is null or memory allocation fails."]
    #[doc = "* /"]
    pub fn action_msgs__srv__CancelGoal_Request__Sequence__copy(
        input: *const action_msgs__srv__CancelGoal_Request__Sequence,
        output: *mut action_msgs__srv__CancelGoal_Request__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize srv/CancelGoal message."]
    #[doc = "* *"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* action_msgs__srv__CancelGoal_Response"]
    #[doc = "* )) before or use"]
    #[doc = "* action_msgs__srv__CancelGoal_Response__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* /"]
    pub fn action_msgs__srv__CancelGoal_Response__init(
        msg: *mut action_msgs__srv__CancelGoal_Response,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize srv/CancelGoal message."]
    #[doc = "* *"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "* /"]
    pub fn action_msgs__srv__CancelGoal_Response__fini(
        msg: *mut action_msgs__srv__CancelGoal_Response,
    );
}
extern "C" {
    #[doc = " Create srv/CancelGoal message."]
    #[doc = "* *"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* action_msgs__srv__CancelGoal_Response__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "* /"]
    pub fn action_msgs__srv__CancelGoal_Response__create(
    ) -> *mut action_msgs__srv__CancelGoal_Response;
}
extern "C" {
    #[doc = " Destroy srv/CancelGoal message."]
    #[doc = "* *"]
    #[doc = "* It calls"]
    #[doc = "* action_msgs__srv__CancelGoal_Response__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "* /"]
    pub fn action_msgs__srv__CancelGoal_Response__destroy(
        msg: *mut action_msgs__srv__CancelGoal_Response,
    );
}
extern "C" {
    #[doc = " Check for srv/CancelGoal message equality."]
    #[doc = "* *"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "* /"]
    pub fn action_msgs__srv__CancelGoal_Response__are_equal(
        lhs: *const action_msgs__srv__CancelGoal_Response,
        rhs: *const action_msgs__srv__CancelGoal_Response,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a srv/CancelGoal message."]
    #[doc = "* *"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "* "]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "* have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "* or memory allocation fails."]
    #[doc = "* /"]
    pub fn action_msgs__srv__CancelGoal_Response__copy(
        input: *const action_msgs__srv__CancelGoal_Response,
        output: *mut action_msgs__srv__CancelGoal_Response,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of srv/CancelGoal messages."]
    #[doc = "* *"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* action_msgs__srv__CancelGoal_Response__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "* /"]
    pub fn action_msgs__srv__CancelGoal_Response__Sequence__init(
        array: *mut action_msgs__srv__CancelGoal_Response__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of srv/CancelGoal messages."]
    #[doc = "* *"]
    #[doc = "* It calls"]
    #[doc = "* action_msgs__srv__CancelGoal_Response__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "* /"]
    pub fn action_msgs__srv__CancelGoal_Response__Sequence__fini(
        array: *mut action_msgs__srv__CancelGoal_Response__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of srv/CancelGoal messages."]
    #[doc = "* *"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* action_msgs__srv__CancelGoal_Response__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "* /"]
    pub fn action_msgs__srv__CancelGoal_Response__Sequence__create(
        size: size_t,
    ) -> *mut action_msgs__srv__CancelGoal_Response__Sequence;
}
extern "C" {
    #[doc = " Destroy array of srv/CancelGoal messages."]
    #[doc = "* *"]
    #[doc = "* It calls"]
    #[doc = "* action_msgs__srv__CancelGoal_Response__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "* /"]
    pub fn action_msgs__srv__CancelGoal_Response__Sequence__destroy(
        array: *mut action_msgs__srv__CancelGoal_Response__Sequence,
    );
}
extern "C" {
    #[doc = " Check for srv/CancelGoal message array equality."]
    #[doc = "* *"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "* /"]
    pub fn action_msgs__srv__CancelGoal_Response__Sequence__are_equal(
        lhs: *const action_msgs__srv__CancelGoal_Response__Sequence,
        rhs: *const action_msgs__srv__CancelGoal_Response__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of srv/CancelGoal messages."]
    #[doc = "* *"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "* "]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "* have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "* is null or memory allocation fails."]
    #[doc = "* /"]
    pub fn action_msgs__srv__CancelGoal_Response__Sequence__copy(
        input: *const action_msgs__srv__CancelGoal_Response__Sequence,
        output: *mut action_msgs__srv__CancelGoal_Response__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__action_msgs__srv__CancelGoal_Request(
    ) -> *const rosidl_message_type_support_t;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__action_msgs__srv__CancelGoal_Response(
    ) -> *const rosidl_message_type_support_t;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_service_type_support_handle__action_msgs__srv__CancelGoal(
    ) -> *const rosidl_service_type_support_t;
}
#[doc = " Contains rosidl action type support data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_action_type_support_t {
    pub goal_service_type_support: *const rosidl_service_type_support_t,
    pub result_service_type_support: *const rosidl_service_type_support_t,
    pub cancel_service_type_support: *const rosidl_service_type_support_t,
    pub feedback_message_type_support: *const rosidl_message_type_support_t,
    pub status_message_type_support: *const rosidl_message_type_support_t,
}
#[test]
fn bindgen_test_layout_rosidl_action_type_support_t() {
    assert_eq!(
        ::std::mem::size_of::<rosidl_action_type_support_t>(),
        40usize,
        concat!("Size of: ", stringify!(rosidl_action_type_support_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_action_type_support_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rosidl_action_type_support_t))
    );
    fn test_field_goal_service_type_support() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rosidl_action_type_support_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).goal_service_type_support) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rosidl_action_type_support_t),
                "::",
                stringify!(goal_service_type_support)
            )
        );
    }
    test_field_goal_service_type_support();
    fn test_field_result_service_type_support() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rosidl_action_type_support_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result_service_type_support) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rosidl_action_type_support_t),
                "::",
                stringify!(result_service_type_support)
            )
        );
    }
    test_field_result_service_type_support();
    fn test_field_cancel_service_type_support() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rosidl_action_type_support_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cancel_service_type_support) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rosidl_action_type_support_t),
                "::",
                stringify!(cancel_service_type_support)
            )
        );
    }
    test_field_cancel_service_type_support();
    fn test_field_feedback_message_type_support() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rosidl_action_type_support_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).feedback_message_type_support) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rosidl_action_type_support_t),
                "::",
                stringify!(feedback_message_type_support)
            )
        );
    }
    test_field_feedback_message_type_support();
    fn test_field_status_message_type_support() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rosidl_action_type_support_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status_message_type_support) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rosidl_action_type_support_t),
                "::",
                stringify!(status_message_type_support)
            )
        );
    }
    test_field_status_message_type_support();
}
pub type rcl_action_goal_info_t = action_msgs__msg__GoalInfo;
pub type rcl_action_goal_status_t = action_msgs__msg__GoalStatus;
#[doc = " Struct with the action goal status array"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_action_goal_status_array_t {
    #[doc = " Goal status array message"]
    pub msg: action_msgs__msg__GoalStatusArray,
    #[doc = " Allocator used to initialize this struct."]
    pub allocator: rcl_allocator_t,
}
#[test]
fn bindgen_test_layout_rcl_action_goal_status_array_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_action_goal_status_array_t>(),
        64usize,
        concat!("Size of: ", stringify!(rcl_action_goal_status_array_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_action_goal_status_array_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_action_goal_status_array_t))
    );
    fn test_field_msg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_action_goal_status_array_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msg) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_action_goal_status_array_t),
                "::",
                stringify!(msg)
            )
        );
    }
    test_field_msg();
    fn test_field_allocator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_action_goal_status_array_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_action_goal_status_array_t),
                "::",
                stringify!(allocator)
            )
        );
    }
    test_field_allocator();
}
pub type rcl_action_cancel_request_t = action_msgs__srv__CancelGoal_Request;
#[doc = " Struct with the action cancel response"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_action_cancel_response_t {
    #[doc = " Cancel goal response message"]
    pub msg: action_msgs__srv__CancelGoal_Response,
    #[doc = " Allocator used to initialize this struct."]
    pub allocator: rcl_allocator_t,
}
#[test]
fn bindgen_test_layout_rcl_action_cancel_response_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_action_cancel_response_t>(),
        72usize,
        concat!("Size of: ", stringify!(rcl_action_cancel_response_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_action_cancel_response_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_action_cancel_response_t))
    );
    fn test_field_msg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_action_cancel_response_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msg) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_action_cancel_response_t),
                "::",
                stringify!(msg)
            )
        );
    }
    test_field_msg();
    fn test_field_allocator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_action_cancel_response_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_action_cancel_response_t),
                "::",
                stringify!(allocator)
            )
        );
    }
    test_field_allocator();
}
#[doc = " Goal states"]
pub type rcl_action_goal_state_t = i8;
extern "C" {
    #[doc = " User friendly error messages for invalid trasntions"]
    pub static mut goal_state_descriptions: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut goal_event_descriptions: [*const ::std::os::raw::c_char; 0usize];
}
pub const rcl_action_goal_event_t_GOAL_EVENT_EXECUTE: rcl_action_goal_event_t = 0;
pub const rcl_action_goal_event_t_GOAL_EVENT_CANCEL_GOAL: rcl_action_goal_event_t = 1;
pub const rcl_action_goal_event_t_GOAL_EVENT_SUCCEED: rcl_action_goal_event_t = 2;
pub const rcl_action_goal_event_t_GOAL_EVENT_ABORT: rcl_action_goal_event_t = 3;
pub const rcl_action_goal_event_t_GOAL_EVENT_CANCELED: rcl_action_goal_event_t = 4;
pub const rcl_action_goal_event_t_GOAL_EVENT_NUM_EVENTS: rcl_action_goal_event_t = 5;
#[doc = " Goal state transition events"]
pub type rcl_action_goal_event_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Return a rcl_action_goal_info_t with members set to zero values."]
    pub fn rcl_action_get_zero_initialized_goal_info() -> rcl_action_goal_info_t;
}
extern "C" {
    #[doc = " Return a rcl_action_goal_status_array_t with members set to `NULL`."]
    #[doc = "* *"]
    #[doc = "* Should be called to get a null rcl_action_goal_status_array_t before passing to"]
    #[doc = "* rcl_action_server_get_goal_status_array()."]
    #[doc = "* /"]
    pub fn rcl_action_get_zero_initialized_goal_status_array() -> rcl_action_goal_status_array_t;
}
extern "C" {
    #[doc = " Return a rcl_action_cancel_request_t with members set to `NULL`."]
    #[doc = "* *"]
    #[doc = "* Should be called to get a null rcl_action_cancel_request_t before passing to"]
    #[doc = "* "]
    #[doc = "* rcl_action_cancel_request_init()."]
    #[doc = "* /"]
    pub fn rcl_action_get_zero_initialized_cancel_request() -> rcl_action_cancel_request_t;
}
extern "C" {
    #[doc = " Return a rcl_action_cancel_response_t with members set to `NULL`."]
    #[doc = "* *"]
    #[doc = "* Should be called to get a null rcl_action_cancel_response_t before passing to"]
    #[doc = "* rcl_action_cancel_response_init()."]
    #[doc = "* /"]
    pub fn rcl_action_get_zero_initialized_cancel_response() -> rcl_action_cancel_response_t;
}
extern "C" {
    #[doc = " Initialize a rcl_action_goal_status_array_t."]
    #[doc = "* *"]
    #[doc = "* After calling this function on a rcl_action_goal_status_array_t, it can be populated"]
    #[doc = "* and used to get and send status array messages with an action server using"]
    #[doc = "* rcl_action_get_goal_status_array() and rcl_action_publish_status() respectively."]
    #[doc = "* "]
    #[doc = "* Example usage:"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* #include <rcl/rcl.h>"]
    #[doc = "* #include <rcl_action/rcl_action.h>"]
    #[doc = "* "]
    #[doc = "* rcl_action_goal_status_array_t goal_status_array ="]
    #[doc = "* rcl_action_get_zero_initialized_goal_status_array();"]
    #[doc = "* size_t num_status = 42;"]
    #[doc = "* ret = rcl_action_goal_status_array_init("]
    #[doc = "* &goal_status_array,"]
    #[doc = "* num_status,"]
    #[doc = "* rcl_get_default_allocator());"]
    #[doc = "* // ... error handling, and when done with message, finalize"]
    #[doc = "* ret = rcl_action_goal_status_array_fini(&goal_status_array, rcl_get_default_allocator());"]
    #[doc = "* // ... error handling"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[out] status_array a preallocated, zero-initialized, goal status array message"]
    #[doc = "* to be initialized."]
    #[doc = "* \\param[in] num_status the number of status messages to allocate space for."]
    #[doc = "* Must be greater than zero"]
    #[doc = "* \\param[in] allocator a valid allocator"]
    #[doc = "* \\return `RCL_RET_OK` if cancel response was initialized successfully, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ALREADY_INIT` if the status array has already been initialized, or"]
    #[doc = "* \\return `RCL_RET_BAD_ALLOC` if allocating memory failed, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_goal_status_array_init(
        status_array: *mut rcl_action_goal_status_array_t,
        num_status: size_t,
        allocator: rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a rcl_action_goal_status_array_t."]
    #[doc = "* *"]
    #[doc = "* After calling, the goal status array message will no longer be valid."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] status_array the goal status array message to be deinitialized"]
    #[doc = "* \\return `RCL_RET_OK` if the goal status array was deinitialized successfully, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_goal_status_array_fini(
        status_array: *mut rcl_action_goal_status_array_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Initialize a rcl_action_cancel_response_t."]
    #[doc = "* *"]
    #[doc = "* After calling this function on a rcl_action_cancel_response_t, it can be populated"]
    #[doc = "* and used to process cancel requests with an action server using"]
    #[doc = "* rcl_action_process_cancel_request()."]
    #[doc = "* "]
    #[doc = "* Example usage:"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* #include <rcl/rcl.h>"]
    #[doc = "* #include <rcl_action/rcl_action.h>"]
    #[doc = "* "]
    #[doc = "* rcl_action_cancel_response_t cancel_response ="]
    #[doc = "* rcl_action_get_zero_initialized_cancel_response();"]
    #[doc = "* size_t num_goals_canceling = 10;"]
    #[doc = "* ret = rcl_action_cancel_response_init("]
    #[doc = "* &cancel_response,"]
    #[doc = "* num_goals_canceling,"]
    #[doc = "* rcl_get_default_allocator());"]
    #[doc = "* // ... error handling, and when done processing response, finalize"]
    #[doc = "* ret = rcl_action_cancel_response_fini(&cancel_response, rcl_get_default_allocator());"]
    #[doc = "* // ... error handling"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[out] cancel_response a preallocated, zero-initialized, cancel response message"]
    #[doc = "* to be initialized."]
    #[doc = "* \\param[in] num_goals_canceling the number of goals that are canceling to add to the response"]
    #[doc = "* Must be greater than zero"]
    #[doc = "* \\param[in] allocator a valid allocator"]
    #[doc = "* \\return `RCL_RET_OK` if cancel response was initialized successfully, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ALREADY_INIT` if the cancel response has already been initialized, or"]
    #[doc = "* \\return `RCL_RET_BAD_ALLOC` if allocating memory failed, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_cancel_response_init(
        cancel_response: *mut rcl_action_cancel_response_t,
        num_goals_canceling: size_t,
        allocator: rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a rcl_action_cancel_response_t."]
    #[doc = "* *"]
    #[doc = "* After calling, the cancel response message will no longer be valid."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] cancel_response the cancel response message to be deinitialized"]
    #[doc = "* \\return `RCL_RET_OK` if the cancel response was deinitialized successfully, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_cancel_response_fini(
        cancel_response: *mut rcl_action_cancel_response_t,
    ) -> rcl_ret_t;
}
#[doc = " Internal action client implementation struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_action_client_impl_t {
    _unused: [u8; 0],
}
#[doc = " Structure which encapsulates a ROS action client."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_action_client_t {
    #[doc = " Pointer to the action client implementation"]
    pub impl_: *mut rcl_action_client_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_action_client_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_action_client_t>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_action_client_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_action_client_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_action_client_t))
    );
    fn test_field_impl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_action_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_action_client_t),
                "::",
                stringify!(impl_)
            )
        );
    }
    test_field_impl();
}
#[doc = " Options available for a rcl_action_client_t."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_action_client_options_t {
    #[doc = " Middleware quality of service settings for the action client."]
    #[doc = " Goal service quality of service"]
    pub goal_service_qos: rmw_qos_profile_t,
    #[doc = " Result service quality of service"]
    pub result_service_qos: rmw_qos_profile_t,
    #[doc = " Cancel service quality of service"]
    pub cancel_service_qos: rmw_qos_profile_t,
    #[doc = " Feedback topic quality of service"]
    pub feedback_topic_qos: rmw_qos_profile_t,
    #[doc = " Status topic quality of service"]
    pub status_topic_qos: rmw_qos_profile_t,
    #[doc = " Custom allocator for the action client, used for incidental allocations."]
    #[doc = "* * For default behavior (malloc/free), see: rcl_get_default_allocator() */"]
    pub allocator: rcl_allocator_t,
}
#[test]
fn bindgen_test_layout_rcl_action_client_options_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_action_client_options_t>(),
        480usize,
        concat!("Size of: ", stringify!(rcl_action_client_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_action_client_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_action_client_options_t))
    );
    fn test_field_goal_service_qos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_action_client_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).goal_service_qos) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_action_client_options_t),
                "::",
                stringify!(goal_service_qos)
            )
        );
    }
    test_field_goal_service_qos();
    fn test_field_result_service_qos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_action_client_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result_service_qos) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_action_client_options_t),
                "::",
                stringify!(result_service_qos)
            )
        );
    }
    test_field_result_service_qos();
    fn test_field_cancel_service_qos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_action_client_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cancel_service_qos) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_action_client_options_t),
                "::",
                stringify!(cancel_service_qos)
            )
        );
    }
    test_field_cancel_service_qos();
    fn test_field_feedback_topic_qos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_action_client_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).feedback_topic_qos) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_action_client_options_t),
                "::",
                stringify!(feedback_topic_qos)
            )
        );
    }
    test_field_feedback_topic_qos();
    fn test_field_status_topic_qos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_action_client_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status_topic_qos) as usize - ptr as usize
            },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_action_client_options_t),
                "::",
                stringify!(status_topic_qos)
            )
        );
    }
    test_field_status_topic_qos();
    fn test_field_allocator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_action_client_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize
            },
            440usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_action_client_options_t),
                "::",
                stringify!(allocator)
            )
        );
    }
    test_field_allocator();
}
extern "C" {
    #[doc = " Return a rcl_action_client_t struct with members set to `NULL`."]
    #[doc = "* *"]
    #[doc = "* Should be called to get a null rcl_action_client_t before passing to"]
    #[doc = "* rcl_action_client_init()."]
    #[doc = "* /"]
    pub fn rcl_action_get_zero_initialized_client() -> rcl_action_client_t;
}
extern "C" {
    #[doc = " Initialize a rcl_action_client_t."]
    #[doc = "* *"]
    #[doc = "* After calling this function on a rcl_action_client_t, it can be used to send"]
    #[doc = "* goals of the given type to the given topic using rcl_action_send_goal_request()."]
    #[doc = "* If a goal request is sent to a (possibly remote) server and if the server"]
    #[doc = "* sends a response, the client can access the response with"]
    #[doc = "* rcl_take_goal_response() once the response is available."]
    #[doc = "* "]
    #[doc = "* After a goal request has been accepted, the rcl_action_client_t associated with the"]
    #[doc = "* goal can perform the following operations:"]
    #[doc = "* "]
    #[doc = "* - Send a request for the result with rcl_action_send_result_request()."]
    #[doc = "* If the server sends a response when the goal terminates, the result can be accessed"]
    #[doc = "* with rcl_action_take_result_response(), once the response is available."]
    #[doc = "* - Send a cancel request for the goal with rcl_action_send_cancel_request()."]
    #[doc = "* If the server sends a response to a cancel request, the client can access the"]
    #[doc = "* response with rcl_action_take_cancel_response() once the response is available."]
    #[doc = "* - Take feedback about the goal with rcl_action_take_feedback()."]
    #[doc = "* "]
    #[doc = "* A rcl_action_client_t can be used to access the current status of all accepted goals"]
    #[doc = "* communicated by the action server with rcl_action_take_status()."]
    #[doc = "* "]
    #[doc = "* The given rcl_node_t must be valid and the resulting rcl_action_client_t is"]
    #[doc = "* only valid as long as the given rcl_node_t remains valid."]
    #[doc = "* "]
    #[doc = "* The rosidl_action_type_support_t is obtained on a per .action type basis."]
    #[doc = "* When the user defines a ROS action, code is generated which provides the"]
    #[doc = "* required rosidl_action_type_support_t object."]
    #[doc = "* This object can be obtained using a language appropriate mechanism."]
    #[doc = "* "]
    #[doc = "* \\todo TODO(jacobperron) write these instructions once and link to it instead"]
    #[doc = "* "]
    #[doc = "* For C, a macro can be used (for example `example_interfaces/Fibonacci`):"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* #include <rosidl_runtime_c/action_type_support_struct.h>"]
    #[doc = "* #include <example_interfaces/action/fibonacci.h>"]
    #[doc = "* const rosidl_action_type_support_t * ts ="]
    #[doc = "* ROSIDL_GET_ACTION_TYPE_SUPPORT(example_interfaces, Fibonacci);"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* For C++, a template function is used:"]
    #[doc = "* "]
    #[doc = "* ```cpp"]
    #[doc = "* #include <rosidl_runtime_cpp/action_type_support.hpp>"]
    #[doc = "* #include <example_interfaces/action/fibonacci.h>"]
    #[doc = "* using rosidl_typesupport_cpp::get_action_type_support_handle;"]
    #[doc = "* const rosidl_action_type_support_t * ts ="]
    #[doc = "* get_action_type_support_handle<example_interfaces::action::Fibonacci>();"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* The rosidl_action_type_support_t object contains action type specific"]
    #[doc = "* information used to send or take goals, results, and feedback."]
    #[doc = "* "]
    #[doc = "* The topic name must be a c string that follows the topic and service name"]
    #[doc = "* format rules for unexpanded names, also known as non-fully qualified names:"]
    #[doc = "* "]
    #[doc = "* \\see rcl_expand_topic_name"]
    #[doc = "* "]
    #[doc = "* The options struct allows the user to set the quality of service settings as"]
    #[doc = "* well as a custom allocator that is used when initializing/finalizing the"]
    #[doc = "* client to allocate space for incidentals, e.g. the action client name string."]
    #[doc = "* "]
    #[doc = "* Expected usage (for C action clients):"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* #include <rcl/rcl.h>"]
    #[doc = "* #include <rcl_action/action_client.h>"]
    #[doc = "* #include <rosidl_runtime_c/action_type_support_struct.h>"]
    #[doc = "* #include <example_interfaces/action/fibonacci.h>"]
    #[doc = "* "]
    #[doc = "* rcl_node_t node = rcl_get_zero_initialized_node();"]
    #[doc = "* rcl_node_options_t node_ops = rcl_node_get_default_options();"]
    #[doc = "* rcl_ret_t ret = rcl_node_init(&node, \"node_name\", \"/my_namespace\", &node_ops);"]
    #[doc = "* // ... error handling"]
    #[doc = "* const rosidl_action_type_support_t * ts ="]
    #[doc = "* ROSIDL_GET_ACTION_TYPE_SUPPORT(example_interfaces, Fibonacci);"]
    #[doc = "* rcl_action_client_t action_client = rcl_action_get_zero_initialized_client();"]
    #[doc = "* rcl_action_client_options_t action_client_ops = rcl_action_client_get_default_options();"]
    #[doc = "* ret = rcl_action_client_init(&action_client, &node, ts, \"fibonacci\", &action_client_ops);"]
    #[doc = "* // ... error handling, and on shutdown do finalization:"]
    #[doc = "* ret = rcl_action_client_fini(&action_client, &node);"]
    #[doc = "* // ... error handling for rcl_action_client_fini()"]
    #[doc = "* ret = rcl_node_fini(&node);"]
    #[doc = "* // ... error handling for rcl_node_fini()"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[out] action_client a preallocated, zero-initialized action client structure"]
    #[doc = "* to be initialized"]
    #[doc = "* \\param[in] node valid rcl node handle"]
    #[doc = "* \\param[in] type_support type support object for the action's type"]
    #[doc = "* \\param[in] action_name the name of the action"]
    #[doc = "* \\param[in] options action_client options, including quality of service settings"]
    #[doc = "* \\return `RCL_RET_OK` if action_client was initialized successfully, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_NODE_INVALID` if the node is invalid, or"]
    #[doc = "* \\return `RCL_RET_ALREADY_INIT` if the action client is already initialized, or"]
    #[doc = "* \\return `RCL_RET_BAD_ALLOC` if allocating memory failed, or"]
    #[doc = "* \\return `RCL_RET_ACTION_NAME_INVALID` if the given action name is invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_client_init(
        action_client: *mut rcl_action_client_t,
        node: *mut rcl_node_t,
        type_support: *const rosidl_action_type_support_t,
        action_name: *const ::std::os::raw::c_char,
        options: *const rcl_action_client_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a rcl_action_client_t."]
    #[doc = "* *"]
    #[doc = "* After calling, the node will no longer listen for goals for this action client"]
    #[doc = "* (assuming this is the only action client of this type in this node)."]
    #[doc = "* "]
    #[doc = "* After calling, calls to rcl_wait(), rcl_action_send_goal_request(),"]
    #[doc = "* rcl_action_take_goal_response(), rcl_action_send_cancel_request(),"]
    #[doc = "* rcl_action_take_cancel_response(), rcl_action_send_result_request(),"]
    #[doc = "* rcl_action_take_result_response(), rcl_action_take_feedback(), and"]
    #[doc = "* rcl_action_take_status(), will fail when using this action client."]
    #[doc = "* "]
    #[doc = "* Additionally, rcl_wait() will be interrupted if currently blocking."]
    #[doc = "* "]
    #[doc = "* The given node handle is still valid."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] action_client handle to the action_client to be deinitialized"]
    #[doc = "* \\param[in] node handle to the node used to create the action client"]
    #[doc = "* \\return `RCL_RET_OK` if the action client was deinitialized successfully, or"]
    #[doc = "* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action client is invalid, or"]
    #[doc = "* \\return `RCL_RET_NODE_INVALID` if the node is invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_client_fini(
        action_client: *mut rcl_action_client_t,
        node: *mut rcl_node_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the default action client options in a rcl_action_client_options_t."]
    #[doc = "* *"]
    #[doc = "* The defaults are:"]
    #[doc = "* "]
    #[doc = "* - goal_service_qos = rmw_qos_profile_services_default;"]
    #[doc = "* - result_service_qos = rmw_qos_profile_services_default;"]
    #[doc = "* - cancel_service_qos = rmw_qos_profile_services_default;"]
    #[doc = "* - feedback_topic_qos = rmw_qos_profile_default;"]
    #[doc = "* - status_topic_qos = rcl_action_qos_profile_status_default;"]
    #[doc = "* - allocator = rcl_get_default_allocator()"]
    #[doc = "* /"]
    pub fn rcl_action_client_get_default_options() -> rcl_action_client_options_t;
}
extern "C" {
    #[doc = " Check if an action server is available for the given action client."]
    #[doc = "* *"]
    #[doc = "* This function will return true for is_available if there is an action server"]
    #[doc = "* available for the given action client."]
    #[doc = "* "]
    #[doc = "* The node parameter must not be `NULL`, and must point to a valid node."]
    #[doc = "* "]
    #[doc = "* The client parameter must not be `NULL`, and must point to a valid client."]
    #[doc = "* "]
    #[doc = "* The given client and node must match, i.e. the client must have been created"]
    #[doc = "* using the given node."]
    #[doc = "* "]
    #[doc = "* The is_available parameter must not be `NULL`, and must point a bool variable."]
    #[doc = "* The result of the check will be stored in the is_available parameter."]
    #[doc = "* "]
    #[doc = "* In the event that error handling needs to allocate memory, this function"]
    #[doc = "* will try to use the node's allocator."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] implementation may need to protect the data structure with a lock</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node the handle to the node being used to query the ROS graph"]
    #[doc = "* \\param[in] client the handle to the action client being queried"]
    #[doc = "* \\param[out] is_available set to true if there is an action server available, else false"]
    #[doc = "* \\return `RCL_RET_OK` if successful (regardless of the action server availability), or"]
    #[doc = "* \\return `RCL_RET_NODE_INVALID` if the node is invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action client is invalid, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_server_is_available(
        node: *const rcl_node_t,
        client: *const rcl_action_client_t,
        is_available: *mut bool,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Send a ROS goal using a rcl_action_client_t."]
    #[doc = "* *"]
    #[doc = "* This is a non-blocking call."]
    #[doc = "* "]
    #[doc = "* The caller is responsible for ensuring that the type of `ros_goal_request`"]
    #[doc = "* and the type associate with the client (via the type support) match."]
    #[doc = "* Passing a different type produces undefined behavior and cannot be checked"]
    #[doc = "* by this function and therefore no deliberate error will occur."]
    #[doc = "* "]
    #[doc = "* The ROS goal message given by the `ros_goal_request` void pointer is always"]
    #[doc = "* owned by the calling code, but should remain constant during execution of this"]
    #[doc = "* function. i.e. Before and after calling rcl_action_send_goal_request() the"]
    #[doc = "* `ros_goal_request` message can change, but it cannot be changed during the call to"]
    #[doc = "* rcl_action_send_goal_request()."]
    #[doc = "* The same `ros_goal_request` can be passed to multiple calls of this function"]
    #[doc = "* simultaneously, even if the action clients differ."]
    #[doc = "* "]
    #[doc = "* This function is thread safe so long as access to both the rcl_action_client_t"]
    #[doc = "* and the `ros_goal_request` are synchronized."]
    #[doc = "* That means that calling rcl_action_send_goal_request() from multiple threads is allowed,"]
    #[doc = "* but calling rcl_action_send_goal_request() at the same time as non-thread safe action"]
    #[doc = "* client functions is not, e.g. calling rcl_action_send_goal_request() and"]
    #[doc = "* rcl_action_client_fini() concurrently is not allowed."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes [1]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* <i>[1] for unique pairs of clients and goals, see above for more</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_client handle to the client that will make the goal request"]
    #[doc = "* \\param[in] ros_goal_request pointer to the ROS goal message"]
    #[doc = "* \\param[out] sequence_number pointer to the goal request sequence number"]
    #[doc = "* \\return `RCL_RET_OK` if the request was sent successfully, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the client is invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_send_goal_request(
        action_client: *const rcl_action_client_t,
        ros_goal_request: *const ::std::os::raw::c_void,
        sequence_number: *mut i64,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take a response for a goal request from an action server using a rcl_action_client_t."]
    #[doc = "* *"]
    #[doc = "* \\todo TODO(jacobperron) blocking of take?"]
    #[doc = "* "]
    #[doc = "* \\todo TODO(jacobperron) pre-, during-, and post-conditions for message ownership?"]
    #[doc = "* "]
    #[doc = "* \\todo TODO(jacobperron) is this thread-safe?"]
    #[doc = "* "]
    #[doc = "* The caller is responsible for ensuring that the type of `ros_goal_response`"]
    #[doc = "* and the type associate with the client (via the type support) match."]
    #[doc = "* Passing a different type produces undefined behavior and cannot be checked"]
    #[doc = "* by this function and therefore no deliberate error will occur."]
    #[doc = "* "]
    #[doc = "* The caller must provide a pointer to an allocated message for the `ros_goal_response`."]
    #[doc = "* If the take is successful, this function will populate the fields of `ros_goal_response`."]
    #[doc = "* The ROS message given by the `ros_goal_response` void pointer is always"]
    #[doc = "* owned by the calling code, but should remain constant during execution of this"]
    #[doc = "* function. i.e. Before and after calling rcl_action_send_goal_response() the"]
    #[doc = "* `ros_goal_response` message can change, but it cannot be changed during the call to"]
    #[doc = "* rcl_action_send_goal_response()."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_client handle to the client that will take the goal response"]
    #[doc = "* \\param[out] response_header pointer to the goal response header"]
    #[doc = "* \\param[out] ros_goal_response pointer to the response of a goal request"]
    #[doc = "* \\return `RCL_RET_OK` if the response was taken successfully, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action client is invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_CLIENT_TAKE_FAILED` if take failed but no error occurred"]
    #[doc = "* in the middleware, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_take_goal_response(
        action_client: *const rcl_action_client_t,
        response_header: *mut rmw_request_id_t,
        ros_goal_response: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take a ROS feedback message for an active goal associated with a rcl_action_client_t."]
    #[doc = "* *"]
    #[doc = "* The caller is responsible for ensuring that the type of `ros_feedback`"]
    #[doc = "* and the type associate with the client (via the type support) match."]
    #[doc = "* Passing a different type produces undefined behavior and cannot be checked"]
    #[doc = "* by this function and therefore no deliberate error will occur."]
    #[doc = "* "]
    #[doc = "* \\todo TODO(jacobperron) blocking of take?"]
    #[doc = "* "]
    #[doc = "* \\todo TODO(jacobperron) pre-, during-, and post-conditions for message ownership?"]
    #[doc = "* "]
    #[doc = "* \\todo TODO(jacobperron) is this thread-safe?"]
    #[doc = "* "]
    #[doc = "* `ros_feedback` should point to a preallocated ROS message struct of the"]
    #[doc = "* correct type."]
    #[doc = "* If feedback is successfully taken, the feedback message is copied to into the"]
    #[doc = "* `ros_feedback` struct."]
    #[doc = "* "]
    #[doc = "* If allocation is required when taking the feedback, e.g. if space needs to"]
    #[doc = "* be allocated for a dynamically sized array in the target message, then the"]
    #[doc = "* allocator given in the action client options is used."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe [1]"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* <i>[1] only if required when filling the feedback message, avoided for fixed sizes</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_client handle to the client that will take action feedback"]
    #[doc = "* \\param[out] ros_feedback pointer to the ROS feedback message."]
    #[doc = "* \\return `RCL_RET_OK` if the response was taken successfully, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action client is invalid, or"]
    #[doc = "* \\return `RCL_RET_BAD_ALLOC` if allocating memory failed, or"]
    #[doc = "* \\return `RCL_RET_ACTION_CLIENT_TAKE_FAILED` if take failed but no error occurred"]
    #[doc = "* in the middleware, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_take_feedback(
        action_client: *const rcl_action_client_t,
        ros_feedback: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take a ROS status message using a rcl_action_client_t."]
    #[doc = "* *"]
    #[doc = "* The caller is responsible for ensuring that the type of `ros_status_array`"]
    #[doc = "* and the type associate with the client (via the type support) match."]
    #[doc = "* Passing a different type produces undefined behavior and cannot be checked"]
    #[doc = "* by this function and therefore no deliberate error will occur."]
    #[doc = "* "]
    #[doc = "* \\todo TODO(jacobperron) blocking of take?"]
    #[doc = "* "]
    #[doc = "* \\todo TODO(jacobperron) pre-, during-, and post-conditions for message ownership?"]
    #[doc = "* "]
    #[doc = "* \\todo TODO(jacobperron) is this thread-safe?"]
    #[doc = "* "]
    #[doc = "* The caller is responsible for allocating the `ros_status_array` struct with a"]
    #[doc = "* zero-initialization (the internal array should not be allocated)."]
    #[doc = "* If there is a successful take, then `ros_status_array` is populated"]
    #[doc = "* with the allocator given in the action client options."]
    #[doc = "* It is the callers responsibility to deallocate the `ros_status_array` struct using"]
    #[doc = "* the allocator given in the action client options."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_client handle to the client that will take status message"]
    #[doc = "* \\param[out] ros_status_array pointer to ROS aciton_msgs/StatusArray message that"]
    #[doc = "* will be populated with information about goals that have accepted the cancel request."]
    #[doc = "* \\return `RCL_RET_OK` if the response was taken successfully, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action client is invalid, or"]
    #[doc = "* \\return `RCL_RET_BAD_ALLOC` if allocating memory failed, or"]
    #[doc = "* \\return `RCL_RET_ACTION_CLIENT_TAKE_FAILED` if take failed but no error occurred"]
    #[doc = "* in the middleware, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_take_status(
        action_client: *const rcl_action_client_t,
        ros_status_array: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Send a request for the result of a completed goal associated with a rcl_action_client_t."]
    #[doc = "* *"]
    #[doc = "* This is a non-blocking call."]
    #[doc = "* "]
    #[doc = "* The caller is responsible for ensuring that the type of `ros_result_request`"]
    #[doc = "* and the type associate with the client (via the type support) match."]
    #[doc = "* Passing a different type produces undefined behavior and cannot be checked"]
    #[doc = "* by this function and therefore no deliberate error will occur."]
    #[doc = "* "]
    #[doc = "* The ROS message given by the `ros_result_request` void pointer is always"]
    #[doc = "* owned by the calling code, but should remain constant during execution of this"]
    #[doc = "* function. i.e. Before and after calling rcl_action_send_result_request() the"]
    #[doc = "* `ros_result_request` message can change, but it cannot be changed during the call to"]
    #[doc = "* rcl_action_send_result_request()."]
    #[doc = "* The same `ros_result_request` can be passed to multiple calls of this function"]
    #[doc = "* simultaneously, even if the action clients differ."]
    #[doc = "* "]
    #[doc = "* This function is thread safe so long as access to both the rcl_action_client_t"]
    #[doc = "* and the `ros_result_request` are synchronized."]
    #[doc = "* That means that calling rcl_action_send_result_request() from multiple threads is allowed,"]
    #[doc = "* but calling rcl_action_send_result_request() at the same time as non-thread safe action"]
    #[doc = "* client functions is not, e.g. calling rcl_action_send_result_request() and"]
    #[doc = "* rcl_action_client_fini() concurrently is not allowed."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes [1]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* <i>[1] for unique pairs of clients and result requests, see above for more</i>"]
    #[doc = ""]
    #[doc = "* \\param[in] action_client handle to the client that will send the result request"]
    #[doc = "* \\param[in] ros_result_request pointer to a ROS result request message"]
    #[doc = "* \\param[out] sequence_number pointer to the result request sequence number"]
    #[doc = "* \\return `RCL_RET_OK` if the request was sent successfully, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action client is invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_send_result_request(
        action_client: *const rcl_action_client_t,
        ros_result_request: *const ::std::os::raw::c_void,
        sequence_number: *mut i64,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take a ROS result message for a completed goal associated with a rcl_action_client_t."]
    #[doc = "* *"]
    #[doc = "* \\todo TODO(jacobperron) blocking of take?"]
    #[doc = "* "]
    #[doc = "* \\todo TODO(jacobperron) pre-, during-, and post-conditions for message ownership?"]
    #[doc = "* "]
    #[doc = "* \\todo TODO(jacobperron) is this thread-safe?"]
    #[doc = "* "]
    #[doc = "* The caller is responsible for ensuring that the type of `ros_result_response`"]
    #[doc = "* and the type associate with the client (via the type support) match."]
    #[doc = "* Passing a different type produces undefined behavior and cannot be checked"]
    #[doc = "* by this function and therefore no deliberate error will occur."]
    #[doc = "* "]
    #[doc = "* The caller must provide a pointer to an allocated message for the `ros_result_response`."]
    #[doc = "* If the take is successful, this function will populate the fields of `ros_result_response`."]
    #[doc = "* The ROS message given by the `ros_result_response` void pointer is always"]
    #[doc = "* owned by the calling code, but should remain constant during execution of this"]
    #[doc = "* function. i.e. Before and after calling rcl_action_take_result_response() the"]
    #[doc = "* `ros_result_response` message can change, but it cannot be changed during the call to"]
    #[doc = "* rcl_action_take_result_response()."]
    #[doc = "* "]
    #[doc = "* If allocation is required when taking the result, e.g. if space needs to"]
    #[doc = "* be allocated for a dynamically sized array in the target message, then the"]
    #[doc = "* allocator given in the action client options is used."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe [1]"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* <i>[1] only if required when filling the result response message, avoided for fixed sizes</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_client handle to the client that will take the result response"]
    #[doc = "* \\param[out] response_header pointer to the result response header"]
    #[doc = "* \\param[out] ros_result preallocated, zero-initialized, struct where the ROS"]
    #[doc = "* result message is copied."]
    #[doc = "* \\return `RCL_RET_OK` if the response was taken successfully, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action client is invalid, or"]
    #[doc = "* \\return `RCL_RET_BAD_ALLOC` if allocating memory failed, or"]
    #[doc = "* \\return `RCL_RET_ACTION_CLIENT_TAKE_FAILED` if take failed but no error occurred"]
    #[doc = "* in the middleware, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_take_result_response(
        action_client: *const rcl_action_client_t,
        response_header: *mut rmw_request_id_t,
        ros_result: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Send a cancel request for a goal using a rcl_action_client_t."]
    #[doc = "* *"]
    #[doc = "* This is a non-blocking call."]
    #[doc = "* "]
    #[doc = "* The caller is responsible for ensuring that the type of `ros_cancel_request`"]
    #[doc = "* and the type associate with the client (via the type support) match."]
    #[doc = "* Passing a different type produces undefined behavior and cannot be checked"]
    #[doc = "* by this function and therefore no deliberate error will occur."]
    #[doc = "* "]
    #[doc = "* The following cancel policy applies based on the goal ID and the timestamp provided"]
    #[doc = "* by the `ros_cancel_request` message:"]
    #[doc = "* "]
    #[doc = "* - If the goal ID is zero and timestamp is zero, cancel all goals."]
    #[doc = "* - If the goal ID is zero and timestamp is not zero, cancel all goals accepted"]
    #[doc = "* at or before the timestamp."]
    #[doc = "* - If the goal ID is not zero and timestamp is zero, cancel the goal with the"]
    #[doc = "* given ID regardless of the time it was accepted."]
    #[doc = "* - If the goal ID is not zero and timestamp is not zero, cancel the goal with the"]
    #[doc = "* given ID and all goals accepted at or before the timestamp."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_client handle to the client that will make the cancel request"]
    #[doc = "* \\param[in] ros_cancel_request pointer the ROS cancel request message"]
    #[doc = "* \\param[out] sequence_number pointer to the cancel request sequence number"]
    #[doc = "* \\return `RCL_RET_OK` if the response was taken successfully, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action client is invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_send_cancel_request(
        action_client: *const rcl_action_client_t,
        ros_cancel_request: *const ::std::os::raw::c_void,
        sequence_number: *mut i64,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take a cancel response using a rcl_action_client_t."]
    #[doc = "* *"]
    #[doc = "* \\todo TODO(jacobperron) blocking of take?"]
    #[doc = "* "]
    #[doc = "* \\todo TODO(jacobperron) pre-, during-, and post-conditions for message ownership?"]
    #[doc = "* "]
    #[doc = "* \\todo TODO(jacobperron) is this thread-safe?"]
    #[doc = "* "]
    #[doc = "* The caller is responsible for ensuring that the type of `ros_cancel_response`"]
    #[doc = "* and the type associate with the client (via the type support) match."]
    #[doc = "* Passing a different type produces undefined behavior and cannot be checked"]
    #[doc = "* by this function and therefore no deliberate error will occur."]
    #[doc = ""]
    #[doc = "* The caller is responsible for allocating the `ros_cancel_response` message"]
    #[doc = "* with a zero-initialization (the internal array should not be allocated)."]
    #[doc = "* If a successful response is taken, then `ros_cancel_response` is populated"]
    #[doc = "* using the allocator given in the action client options."]
    #[doc = "* It is the callers responsibility to deallocate `ros_cancel_response` using"]
    #[doc = "* the allocator given in the action client options."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_client handle to the client that will take the cancel response"]
    #[doc = "* \\param[out] response_header pointer to the cancel response header"]
    #[doc = "* \\param[out] ros_cancel_response a zero-initialized ROS cancel response message where"]
    #[doc = "* the cancel response is copied."]
    #[doc = "* \\return `RCL_RET_OK` if the response was taken successfully, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action client is invalid, or"]
    #[doc = "* \\return `RCL_RET_BAD_ALLOC` if allocating memory failed, or"]
    #[doc = "* \\return `RCL_RET_ACTION_CLIENT_TAKE_FAILED` if take failed but no error occurred"]
    #[doc = "* in the middleware, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_take_cancel_response(
        action_client: *const rcl_action_client_t,
        response_header: *mut rmw_request_id_t,
        ros_cancel_response: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the name of the action for a rcl_action_client_t."]
    #[doc = "* *"]
    #[doc = "* This function returns the action client's name string."]
    #[doc = "* This function can fail, and therefore return `NULL`, if the:"]
    #[doc = "* - action client is `NULL`"]
    #[doc = "* - action client is invalid (never called init, called fini, or invalid)"]
    #[doc = "* "]
    #[doc = "* The returned string is only valid as long as the action client is valid."]
    #[doc = "* The value of the string may change if the topic name changes, and therefore"]
    #[doc = "* copying the string is recommended if this is a concern."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_client the pointer to the action client"]
    #[doc = "* \\return name string if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_action_client_get_action_name(
        action_client: *const rcl_action_client_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the options for a rcl_action_client_t."]
    #[doc = "* *"]
    #[doc = "* This function returns the action client's internal options struct."]
    #[doc = "* This function can fail, and therefore return `NULL`, if the:"]
    #[doc = "* - action client is `NULL`"]
    #[doc = "* - action client is invalid (never called init, called fini, or invalid)"]
    #[doc = "* "]
    #[doc = "* The returned struct is only valid as long as the action client is valid."]
    #[doc = "* The values in the struct may change if the action client's options change,"]
    #[doc = "* and therefore copying the struct is recommended if this is a concern."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_client pointer to the action client"]
    #[doc = "* \\return options struct if successful, otherwise `NULL`"]
    #[doc = "* /"]
    pub fn rcl_action_client_get_options(
        action_client: *const rcl_action_client_t,
    ) -> *const rcl_action_client_options_t;
}
extern "C" {
    #[doc = " Check that a rcl_action_client_t is valid."]
    #[doc = "* *"]
    #[doc = "* The bool returned is `false` if `action_client` is invalid."]
    #[doc = "* The bool returned is `true` otherwise."]
    #[doc = "* In the case where `false` is to be returned, an error message is set."]
    #[doc = "* This function cannot fail."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_client pointer to the rcl action client"]
    #[doc = "* \\return `true` if `action_client` is valid, otherwise `false`"]
    #[doc = "* /"]
    pub fn rcl_action_client_is_valid(action_client: *const rcl_action_client_t) -> bool;
}
extern "C" {
    #[doc = " Transition a goal from one state to the next."]
    #[doc = "* *"]
    #[doc = "* Given a goal state and a goal event, return the next state."]
    #[doc = "* "]
    #[doc = "* \\param[in] state the state to transition from"]
    #[doc = "* \\param[in] event the event triggering a transition"]
    #[doc = "* \\return the next goal state if the transition is valid, or"]
    #[doc = "* \\return `GOAL_STATE_UNKNOWN` if the transition is invalid or an error occured"]
    #[doc = "* /"]
    pub fn rcl_action_transition_goal_state(
        state: rcl_action_goal_state_t,
        event: rcl_action_goal_event_t,
    ) -> rcl_action_goal_state_t;
}
#[doc = " Internal rcl action goal implementation struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_action_goal_handle_impl_t {
    _unused: [u8; 0],
}
#[doc = " Goal handle for an action."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_action_goal_handle_t {
    #[doc = " Pointer to the action goal handle implementation"]
    pub impl_: *mut rcl_action_goal_handle_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_action_goal_handle_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_action_goal_handle_t>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_action_goal_handle_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_action_goal_handle_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_action_goal_handle_t))
    );
    fn test_field_impl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_action_goal_handle_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_action_goal_handle_t),
                "::",
                stringify!(impl_)
            )
        );
    }
    test_field_impl();
}
extern "C" {
    #[doc = " Return a rcl_action_goal_handle_t struct with members set to `NULL`."]
    #[doc = "* *"]
    #[doc = "* Should be called to get a null rcl_action_goal_handle_t before passing to"]
    #[doc = "* rcl_action_goal_handle_init()."]
    #[doc = "* /"]
    pub fn rcl_action_get_zero_initialized_goal_handle() -> rcl_action_goal_handle_t;
}
extern "C" {
    #[doc = " Initialize a rcl_action_goal_handle_t."]
    #[doc = "* *"]
    #[doc = "* After calling this function on a rcl_action_goal_handle_t, it can be used to update the"]
    #[doc = "* goals state with rcl_action_update_goal_state()."]
    #[doc = "* It can also be used to query the state of the goal with"]
    #[doc = "* rcl_action_goal_handle_get_message() and rcl_action_goal_handle_is_active()."]
    #[doc = "* Goal information can be accessed with rcl_action_goal_handle_get_message() and"]
    #[doc = "* rcl_action_goal_handle_get_info()."]
    #[doc = "* "]
    #[doc = "* Goal handles are typically initialized and finalized by action servers."]
    #[doc = "* I.e. The allocator should be provided by the action server."]
    #[doc = "* Goal handles are created with rcl_action_accept_new_goal() and destroyed with"]
    #[doc = "* rcl_action_clear_expired_goals() or rcl_action_server_fini()."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[out] goal_handle preallocated, zero-initialized, goal handle structure"]
    #[doc = "* to be initialized"]
    #[doc = "* \\param[in] goal_info information about the goal to be copied to the goal handle"]
    #[doc = "* \\param[in] allocator a valid allocator used to initialized the goal handle"]
    #[doc = "* \\return `RCL_RET_OK` if goal_handle was initialized successfully, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if the allocator is invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_GOAL_HANDLE_INVALID` if the goal handle is invalid, or"]
    #[doc = "* \\return `RCL_RET_ALREADY_INIT` if the goal handle has already been initialized, or"]
    #[doc = "* \\return `RCL_RET_BAD_ALLOC` if allocating memory failed"]
    #[doc = "* /"]
    pub fn rcl_action_goal_handle_init(
        goal_handle: *mut rcl_action_goal_handle_t,
        goal_info: *const rcl_action_goal_info_t,
        allocator: rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a rcl_action_goal_handle_t."]
    #[doc = "* *"]
    #[doc = "* After calling, rcl_action_goal_handle_t will no longer be valid and"]
    #[doc = "* rcl_action_server_t will no longer track the goal associated with the goal handle."]
    #[doc = "* "]
    #[doc = "* After calling, calls to rcl_action_publish_feedback(), rcl_action_publish_status(),"]
    #[doc = "* rcl_action_update_goal_state(), rcl_action_goal_handle_get_status(),"]
    #[doc = "* rcl_action_goal_handle_is_active(), rcl_action_goal_handle_get_message(), and"]
    #[doc = "* rcl_action_goal_handle_get_info() will fail when using this goal handle."]
    #[doc = "* "]
    #[doc = "* However, the given action server is still valid."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] goal_handle struct to be deinitialized"]
    #[doc = "* \\return `RCL_RET_OK` if the goal handle was deinitialized successfully, or"]
    #[doc = "* \\return `RCL_RET_ACTION_GOAL_HANDLE_INVALID` if the goal handle is invalid, or"]
    #[doc = "* /"]
    pub fn rcl_action_goal_handle_fini(goal_handle: *mut rcl_action_goal_handle_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Update a goal state with a rcl_action_goal_handle_t and an event."]
    #[doc = "* *"]
    #[doc = "* This is a non-blocking call."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] goal_handle struct containing goal state to transition"]
    #[doc = "* \\param[in] goal_event the event used to transition the goal state"]
    #[doc = "* \\return `RCL_RET_OK` if the goal state was updated successfully, or"]
    #[doc = "* \\return `RCL_RET_ACTION_GOAL_EVENT_INVALID` if the goal event is invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_GOAL_HANDLE_INVALID` if the goal handle is invalid, or"]
    #[doc = "* /"]
    pub fn rcl_action_update_goal_state(
        goal_handle: *mut rcl_action_goal_handle_t,
        goal_event: rcl_action_goal_event_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the ID of a goal using a rcl_action_goal_handle_t."]
    #[doc = "* *"]
    #[doc = "* This is a non-blocking call."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] goal_handle struct containing the goal and meta"]
    #[doc = "* \\param[out] goal_info a preallocated struct where the goal info is copied"]
    #[doc = "* \\return `RCL_RET_OK` if the goal ID was accessed successfully, or"]
    #[doc = "* \\return `RCL_RET_ACTION_GOAL_HANDLE_INVALID` if the goal handle is invalid, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if the goal_info argument is invalid"]
    #[doc = "* /"]
    pub fn rcl_action_goal_handle_get_info(
        goal_handle: *const rcl_action_goal_handle_t,
        goal_info: *mut rcl_action_goal_info_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the status of a goal."]
    #[doc = "* *"]
    #[doc = "* This is a non-blocking call."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] goal_handle struct containing the goal and metadata"]
    #[doc = "* \\param[out] status a preallocated struct where the goal status is copied"]
    #[doc = "* \\return `RCL_RET_OK` if the goal ID was accessed successfully, or"]
    #[doc = "* \\return `RCL_RET_ACTION_GOAL_HANDLE_INVALID` if the goal handle is invalid, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if the status argument is invalid"]
    #[doc = "* /"]
    pub fn rcl_action_goal_handle_get_status(
        goal_handle: *const rcl_action_goal_handle_t,
        status: *mut rcl_action_goal_state_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Check if a goal is active using a rcl_action_goal_handle_t."]
    #[doc = "* *"]
    #[doc = "* This is a non-blocking call."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] goal_handle struct containing the goal and metadata"]
    #[doc = "* \\return `true` if the goal is in one of the following states: ACCEPTED, EXECUTING, or CANCELING, or"]
    #[doc = "* \\return `false` if the goal handle pointer is invalid, or"]
    #[doc = "* \\return `false` otherwise"]
    #[doc = "* /"]
    pub fn rcl_action_goal_handle_is_active(goal_handle: *const rcl_action_goal_handle_t) -> bool;
}
extern "C" {
    #[doc = " Check if a goal can be transitioned to CANCELING in its current state."]
    #[doc = "* *"]
    #[doc = "* This is a non-blocking call."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] goal_handle struct containing the goal and metadata"]
    #[doc = "* \\return `true` if the goal can be transitioned to CANCELING from its current state, or"]
    #[doc = "* \\return `false` if the goal handle pointer is invalid, or"]
    #[doc = "* \\return `false` otherwise"]
    #[doc = "* /"]
    pub fn rcl_action_goal_handle_is_cancelable(
        goal_handle: *const rcl_action_goal_handle_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Check if a rcl_action_goal_handle_t is valid."]
    #[doc = "* *"]
    #[doc = "* This is a non-blocking call."]
    #[doc = "* "]
    #[doc = "* A goal handle is invalid if:"]
    #[doc = "* - the implementation is `NULL` (rcl_action_goal_handle_init() not called or failed)"]
    #[doc = "* - rcl_shutdown() has been called since the goal handle has been initialized"]
    #[doc = "* - the goal handle has been finalized with rcl_action_goal_handle_fini()"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] goal_handle struct to evaluate as valid or not"]
    #[doc = "* \\return `true` if the goal handle is valid, or"]
    #[doc = "* \\return `false` if the goal handle pointer is null, or"]
    #[doc = "* \\return `false` otherwise"]
    #[doc = "* /"]
    pub fn rcl_action_goal_handle_is_valid(goal_handle: *const rcl_action_goal_handle_t) -> bool;
}
#[doc = " Internal rcl_action implementation struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_action_server_impl_t {
    _unused: [u8; 0],
}
#[doc = " Structure which encapsulates a ROS Action Server."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_action_server_t {
    #[doc = " Pointer to the action server implementation"]
    pub impl_: *mut rcl_action_server_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_action_server_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_action_server_t>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_action_server_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_action_server_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_action_server_t))
    );
    fn test_field_impl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_action_server_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_action_server_t),
                "::",
                stringify!(impl_)
            )
        );
    }
    test_field_impl();
}
#[doc = " Options available for a rcl_action_server_t."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_action_server_options_t {
    #[doc = " Middleware quality of service settings for the action server."]
    #[doc = " Goal service quality of service"]
    pub goal_service_qos: rmw_qos_profile_t,
    #[doc = " Cancel service quality of service"]
    pub cancel_service_qos: rmw_qos_profile_t,
    #[doc = " Result service quality of service"]
    pub result_service_qos: rmw_qos_profile_t,
    #[doc = " Feedback topic quality of service"]
    pub feedback_topic_qos: rmw_qos_profile_t,
    #[doc = " Status topic quality of service"]
    pub status_topic_qos: rmw_qos_profile_t,
    #[doc = " Custom allocator for the action server, used for incidental allocations."]
    #[doc = "* * For default behavior (malloc/free), see: rcl_get_default_allocator() */"]
    pub allocator: rcl_allocator_t,
    #[doc = " Goal handles that have results longer than this time are deallocated."]
    pub result_timeout: rcl_duration_t,
}
#[test]
fn bindgen_test_layout_rcl_action_server_options_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_action_server_options_t>(),
        488usize,
        concat!("Size of: ", stringify!(rcl_action_server_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_action_server_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_action_server_options_t))
    );
    fn test_field_goal_service_qos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_action_server_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).goal_service_qos) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_action_server_options_t),
                "::",
                stringify!(goal_service_qos)
            )
        );
    }
    test_field_goal_service_qos();
    fn test_field_cancel_service_qos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_action_server_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cancel_service_qos) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_action_server_options_t),
                "::",
                stringify!(cancel_service_qos)
            )
        );
    }
    test_field_cancel_service_qos();
    fn test_field_result_service_qos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_action_server_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result_service_qos) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_action_server_options_t),
                "::",
                stringify!(result_service_qos)
            )
        );
    }
    test_field_result_service_qos();
    fn test_field_feedback_topic_qos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_action_server_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).feedback_topic_qos) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_action_server_options_t),
                "::",
                stringify!(feedback_topic_qos)
            )
        );
    }
    test_field_feedback_topic_qos();
    fn test_field_status_topic_qos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_action_server_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status_topic_qos) as usize - ptr as usize
            },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_action_server_options_t),
                "::",
                stringify!(status_topic_qos)
            )
        );
    }
    test_field_status_topic_qos();
    fn test_field_allocator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_action_server_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize
            },
            440usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_action_server_options_t),
                "::",
                stringify!(allocator)
            )
        );
    }
    test_field_allocator();
    fn test_field_result_timeout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rcl_action_server_options_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result_timeout) as usize - ptr as usize
            },
            480usize,
            concat!(
                "Offset of field: ",
                stringify!(rcl_action_server_options_t),
                "::",
                stringify!(result_timeout)
            )
        );
    }
    test_field_result_timeout();
}
extern "C" {
    #[doc = " Return a rcl_action_server_t struct with members set to `NULL`."]
    #[doc = "* *"]
    #[doc = "* Should be called to get a null rcl_action_server_t before passing to"]
    #[doc = "* rcl_action_server_init()."]
    #[doc = "* /"]
    pub fn rcl_action_get_zero_initialized_server() -> rcl_action_server_t;
}
extern "C" {
    #[doc = " Initialize an action server."]
    #[doc = "* *"]
    #[doc = "* After calling this function on a rcl_action_server_t, it can be used to take"]
    #[doc = "* goals of the given type for the given action name using rcl_action_take_goal_request()"]
    #[doc = "* and take cancel requests with rcl_action_take_cancel_request()."]
    #[doc = "* It can also send a result for a request using rcl_action_send_result() or"]
    #[doc = "* rcl_action_send_cancel_response()."]
    #[doc = "* "]
    #[doc = "* After accepting a goal with rcl_action_take_goal_request(), the action server can"]
    #[doc = "* be used to send feedback with rcl_action_publish_feedback() and send status"]
    #[doc = "* messages with rcl_action_publish_status()."]
    #[doc = "* "]
    #[doc = "* The given rcl_node_t must be valid and the resulting rcl_action_server_t is"]
    #[doc = "* only valid as long as the given rcl_node_t remains valid."]
    #[doc = "* "]
    #[doc = "* The give rcl_clock_t must be valid and the resulting rcl_ction_server_t is"]
    #[doc = "* only valid as long ast he given rcl_clock_t remains valid."]
    #[doc = "* "]
    #[doc = "* The rosidl_action_type_support_t is obtained on a per .action type basis."]
    #[doc = "* When the user defines a ROS action, code is generated which provides the"]
    #[doc = "* required rosidl_action_type_support_t object."]
    #[doc = "* This object can be obtained using a language appropriate mechanism."]
    #[doc = "* \\todo TODO(jacobperron) write these instructions once and link to it instead"]
    #[doc = "* "]
    #[doc = "* For C, a macro can be used (for example `example_interfaces/Fibonacci`):"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* #include <rosidl_runtime_c/action_type_support_struct.h>"]
    #[doc = "* #include <example_interfaces/action/fibonacci.h>"]
    #[doc = "* const rosidl_action_type_support_t * ts ="]
    #[doc = "* ROSIDL_GET_ACTION_TYPE_SUPPORT(example_interfaces, Fibonacci);"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* For C++, a template function is used:"]
    #[doc = "* "]
    #[doc = "* ```cpp"]
    #[doc = "* #include <rosidl_runtime_cpp/action_type_support.hpp>"]
    #[doc = "* #include <example_interfaces/action/fibonacci.h>"]
    #[doc = "* using rosidl_typesupport_cpp::get_action_type_support_handle;"]
    #[doc = "* const rosidl_action_type_support_t * ts ="]
    #[doc = "* get_action_type_support_handle<example_interfaces::action::Fibonacci>();"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* The rosidl_action_type_support_t object contains action type specific"]
    #[doc = "* information used to send or take goals, results, and feedback."]
    #[doc = "* "]
    #[doc = "* The topic name must be a c string that follows the topic and service name"]
    #[doc = "* format rules for unexpanded names, also known as non-fully qualified names:"]
    #[doc = "* "]
    #[doc = "* \\see rcl_expand_topic_name"]
    #[doc = "* "]
    #[doc = "* The options struct allows the user to set the quality of service settings as"]
    #[doc = "* well as a custom allocator that is used when initializing/finalizing the"]
    #[doc = "* client to allocate space for incidentals, e.g. the action server name string."]
    #[doc = "* "]
    #[doc = "* Expected usage (for C action servers):"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* #include <rcl/rcl.h>"]
    #[doc = "* #include <rcl_action/rcl_action.h>"]
    #[doc = "* #include <rosidl_runtime_c/action_type_support_struct.h>"]
    #[doc = "* #include <example_interfaces/action/fibonacci.h>"]
    #[doc = "* "]
    #[doc = "* rcl_node_t node = rcl_get_zero_initialized_node();"]
    #[doc = "* rcl_node_options_t node_ops = rcl_node_get_default_options();"]
    #[doc = "* rcl_ret_t ret = rcl_node_init(&node, \"node_name\", \"/my_namespace\", &node_ops);"]
    #[doc = "* // ... error handling"]
    #[doc = "* const rosidl_action_type_support_t * ts ="]
    #[doc = "* ROSIDL_GET_ACTION_TYPE_SUPPORT(example_interfaces, Fibonacci);"]
    #[doc = "* rcl_action_server_t action_server = rcl_action_get_zero_initialized_server();"]
    #[doc = "* rcl_action_server_options_t action_server_ops = rcl_action_server_get_default_options();"]
    #[doc = "* ret = rcl_action_server_init(&action_server, &node, ts, \"fibonacci\", &action_server_ops);"]
    #[doc = "* // ... error handling, and on shutdown do finalization:"]
    #[doc = "* ret = rcl_action_server_fini(&action_server, &node);"]
    #[doc = "* // ... error handling for rcl_action_server_fini()"]
    #[doc = "* ret = rcl_node_fini(&node);"]
    #[doc = "* // ... error handling for rcl_node_fini()"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[out] action_server handle to a preallocated, zero-initialized action server structure"]
    #[doc = "* to be initialized."]
    #[doc = "* \\param[in] node valid node handle"]
    #[doc = "* \\param[in] clock valid clock handle"]
    #[doc = "* \\param[in] type_support type support object for the action's type"]
    #[doc = "* \\param[in] action_name the name of the action"]
    #[doc = "* \\param[in] options action_server options, including quality of service settings"]
    #[doc = "* \\return `RCL_RET_OK` if action_server was initialized successfully, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_NODE_INVALID` if the node is invalid, or"]
    #[doc = "* \\return `RCL_RET_BAD_ALLOC` if allocating memory failed, or"]
    #[doc = "* \\return `RCL_RET_ACTION_NAME_INVALID` if the given action name is invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_server_init(
        action_server: *mut rcl_action_server_t,
        node: *mut rcl_node_t,
        clock: *mut rcl_clock_t,
        type_support: *const rosidl_action_type_support_t,
        action_name: *const ::std::os::raw::c_char,
        options: *const rcl_action_server_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize an action server."]
    #[doc = "* *"]
    #[doc = "* After calling, the node will no longer listen to services and topics for this action server."]
    #[doc = "* (assuming this is the only action server of this type in this node)."]
    #[doc = "* "]
    #[doc = "* After calling, calls to rcl_wait(), rcl_action_take_goal_request(),"]
    #[doc = "* rcl_action_take_cancel_request(), rcl_action_publish_feedback(),"]
    #[doc = "* rcl_action_publish_status(), rcl_action_send_result(), and"]
    #[doc = "* rcl_action_send_cancel_response() will fail when using this action server."]
    #[doc = "* Additionally, rcl_wait() will be interrupted if currently blocking."]
    #[doc = "* However, the given node handle is still valid."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] action_server handle to the action_server to be deinitialized"]
    #[doc = "* \\param[in] node handle to the node used to create the action server"]
    #[doc = "* \\return `RCL_RET_OK` if the action server was deinitialized successfully, or"]
    #[doc = "* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server pointer is null, or"]
    #[doc = "* \\return `RCL_RET_NODE_INVALID` if the node is invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_server_fini(
        action_server: *mut rcl_action_server_t,
        node: *mut rcl_node_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the default action server options in a rcl_action_server_options_t."]
    #[doc = "* *"]
    #[doc = "* The defaults are:"]
    #[doc = "* "]
    #[doc = "* - goal_service_qos = rmw_qos_profile_services_default;"]
    #[doc = "* - cancel_service_qos = rmw_qos_profile_services_default;"]
    #[doc = "* - result_service_qos = rmw_qos_profile_services_default;"]
    #[doc = "* - feedback_topic_qos = rmw_qos_profile_default;"]
    #[doc = "* - status_topic_qos = rcl_action_qos_profile_status_default;"]
    #[doc = "* - allocator = rcl_get_default_allocator();"]
    #[doc = "* - result_timeout = RCUTILS_S_TO_NS(15 * 60);  // 15 minutes"]
    #[doc = "* /"]
    pub fn rcl_action_server_get_default_options() -> rcl_action_server_options_t;
}
extern "C" {
    #[doc = " Take a pending ROS goal using an action server."]
    #[doc = "* *"]
    #[doc = "* \\todo TODO(jacobperron) blocking of take?"]
    #[doc = "* "]
    #[doc = "* \\todo TODO(jacobperron) pre-, during-, and post-conditions for message ownership?"]
    #[doc = "* "]
    #[doc = "* \\todo TODO(jacobperron) is this thread-safe?"]
    #[doc = "* "]
    #[doc = "* The caller is responsible for ensuring that the type of `ros_goal_request`"]
    #[doc = "* and the type associate with the client (via the type support) match."]
    #[doc = "* Passing a different type produces undefined behavior and cannot be checked"]
    #[doc = "* by this function and therefore no deliberate error will occur."]
    #[doc = "* "]
    #[doc = "* `ros_goal_request` should point to a preallocated, zero-initialized,"]
    #[doc = "* ROS goal message."]
    #[doc = "* If a goal request is taken successfully, it will be copied into `ros_goal_request`."]
    #[doc = "* "]
    #[doc = "* If allocation is required when taking the request, e.g. if space needs to"]
    #[doc = "* be allocated for a dynamically sized array in the target message, then the"]
    #[doc = "* allocator given in the action server options is used."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe [1]"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* <i>[1] only if required when filling the request, avoided for fixed sizes</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_server handle to the action server that will take the request"]
    #[doc = "* \\param[out] request_header pointer to the goal request header"]
    #[doc = "* \\param[out] ros_goal_request a preallocated, zero-initialized, ROS goal request message"]
    #[doc = "* where the request is copied"]
    #[doc = "* \\return `RCL_RET_OK` if the request was taken, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or"]
    #[doc = "* \\return `RCL_RET_BAD_ALLOC` if allocating memory failed, or"]
    #[doc = "* \\return `RCL_RET_ACTION_SERVER_TAKE_FAILED` if take failed but no error occurred"]
    #[doc = "* in the middleware, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_take_goal_request(
        action_server: *const rcl_action_server_t,
        request_header: *mut rmw_request_id_t,
        ros_goal_request: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Send a response for a goal request to an action client using an action server."]
    #[doc = "* *"]
    #[doc = "* This is a non-blocking call."]
    #[doc = "* "]
    #[doc = "* The caller is responsible for ensuring that the type of `ros_goal_response`"]
    #[doc = "* and the type associate with the client (via the type support) match."]
    #[doc = "* Passing a different type produces undefined behavior and cannot be checked"]
    #[doc = "* by this function and therefore no deliberate error will occur."]
    #[doc = "* "]
    #[doc = "* If the caller intends to send an 'accepted' response, before calling this function"]
    #[doc = "* the caller should use rcl_action_accept_new_goal() to get a rcl_action_goal_handle_t"]
    #[doc = "* for future interaction with the goal (e.g. publishing feedback and canceling the goal)."]
    #[doc = "* "]
    #[doc = "* This function is thread safe so long as access to both the action server and the"]
    #[doc = "* `ros_goal_response` are synchronized."]
    #[doc = "* That means that calling rcl_action_send_goal_response() from multiple threads is"]
    #[doc = "* allowed, but calling rcl_action_send_goal_response() at the same time as non-thread safe"]
    #[doc = "* action server functions is not, e.g. calling rcl_action_send_goal_response() and"]
    #[doc = "* rcl_action_server_fini() concurrently is not allowed."]
    #[doc = "* Before calling rcl_action_send_goal_response() the `ros_goal_request` can change and"]
    #[doc = "* after calling rcl_action_send_goal_response() the `ros_goal_request` can change, but it"]
    #[doc = "* cannot be changed during the rcl_action_send_goal_response() call."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes [1]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* <i>[1] for unique pairs of action servers and responses, see above for more</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_server handle to the action server that will make the goal response"]
    #[doc = "* \\param[in] response_header pointer to the goal response header"]
    #[doc = "* \\param[in] ros_goal_response a ROS goal response message to send"]
    #[doc = "* \\return `RCL_RET_OK` if the response was sent successfully, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_send_goal_response(
        action_server: *const rcl_action_server_t,
        response_header: *mut rmw_request_id_t,
        ros_goal_response: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Accept a new goal using an action server."]
    #[doc = "* *"]
    #[doc = "* This is a non-blocking call."]
    #[doc = "* "]
    #[doc = "* Creates and returns a new goal handle."]
    #[doc = "* The action server starts tracking it internally."]
    #[doc = "* If a failure occurs, `NULL` is returned and an error message is set."]
    #[doc = "* Possible reasons for failure:"]
    #[doc = "* - action server is invalid"]
    #[doc = "* - goal info is invalid"]
    #[doc = "* - goal ID is already being tracked by the action server"]
    #[doc = "* - memory allocation failure"]
    #[doc = "* "]
    #[doc = "* This function should be called after receiving a new goal request with"]
    #[doc = "* rcl_action_take_goal_request() and before sending a response with"]
    #[doc = "* rcl_action_send_goal_response()."]
    #[doc = "* "]
    #[doc = "* After calling this function, the action server will start tracking the goal."]
    #[doc = "* The pointer to the goal handle becomes invalid after `rcl_action_server_fini()` is called."]
    #[doc = "* The caller becomes responsible for finalizing the goal handle later."]
    #[doc = "* "]
    #[doc = "* Example usage:"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* #include <rcl/rcl_action.h>"]
    #[doc = "* "]
    #[doc = "* // ... init an action server"]
    #[doc = "* // Take a goal request (client library type)"]
    #[doc = "* rcl_ret_t ret = rcl_action_take_goal_request(&action_server, &goal_request);"]
    #[doc = "* // ... error handling"]
    #[doc = "* // If the goal is accepted, then tell the action server"]
    #[doc = "* // First, create a goal info message"]
    #[doc = "* rcl_action_goal_info_t goal_info = rcl_action_get_zero_initialized_goal_info();"]
    #[doc = "* // ... populate goal_info.uuid (unique_identifier_msgs/UUID)"]
    #[doc = "* // ... populate goal_info.stamp (builtin_interfaces/Time)"]
    #[doc = "* rcl_action_goal_handle_t * goal_handle = rcl_action_accept_new_goal(&action_server, &goal_info);"]
    #[doc = "* // ... error_handling"]
    #[doc = "* // ... Populate goal response (client library type)"]
    #[doc = "* ret = rcl_action_send_goal_response(&action_server, &goal_response);"]
    #[doc = "* // ... error handling, and sometime before shutdown finalize goal info message"]
    #[doc = "* ret = rcl_action_goal_info_fini(&goal_info, &action_server);"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_server handle to the action server that is accepting the goal"]
    #[doc = "* \\param[in] goal_info a message containing info about the goal being accepted"]
    #[doc = "* \\return a pointer to a new goal handle representing the accepted goal, or"]
    #[doc = "* \\return `NULL` if a failure occured."]
    #[doc = "* /"]
    pub fn rcl_action_accept_new_goal(
        action_server: *mut rcl_action_server_t,
        goal_info: *const rcl_action_goal_info_t,
    ) -> *mut rcl_action_goal_handle_t;
}
extern "C" {
    #[doc = " Publish a ROS feedback message for an active goal using an action server."]
    #[doc = "* *"]
    #[doc = "* The caller is responsible for ensuring that the type of `ros_feedback`"]
    #[doc = "* and the type associate with the client (via the type support) match."]
    #[doc = "* Passing a different type produces undefined behavior and cannot be checked"]
    #[doc = "* by this function and therefore no deliberate error will occur."]
    #[doc = "* "]
    #[doc = "* This function acts like a ROS publisher and is potentially a blocking call."]
    #[doc = "* \\see rcl_publish()"]
    #[doc = "* "]
    #[doc = "* This function is thread safe so long as access to both the action server and"]
    #[doc = "* `ros_feedback` is synchronized."]
    #[doc = "* That means that calling rcl_action_publish_feedback() from multiple threads"]
    #[doc = "* is allowed, but calling rcl_action_publish_feedback() at the same time as"]
    #[doc = "* non-thread safe action server functions is not, e.g. calling"]
    #[doc = "* rcl_action_publish_feedback() and rcl_action_server_fini() concurrently is not"]
    #[doc = "* allowed."]
    #[doc = "* "]
    #[doc = "* Before calling rcl_action_publish_feedback() the `ros_feedback` message ca"]
    #[doc = "* change and after calling rcl_action_publish_feedback() the `ros_feedback` message"]
    #[doc = "* can change, but it cannot be changed during the publish call."]
    #[doc = "* The same `ros_feedback` can be passed to multiple calls of"]
    #[doc = "* rcl_action_publish_feedback() simultaneously, even if the action servers differ."]
    #[doc = "* `ros_feedback` is unmodified by rcl_action_publish_feedback()."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes [1]"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* <i>[1] for unique pairs of action servers and feedback, see above for more</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_server handle to the action server that will publish the feedback"]
    #[doc = "* \\param[in] ros_feedback a ROS message containing the goal feedback"]
    #[doc = "* \\return `RCL_RET_OK` if the response was sent successfully, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs. *"]
    #[doc = "* /"]
    pub fn rcl_action_publish_feedback(
        action_server: *const rcl_action_server_t,
        ros_feedback: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get a status array message for accepted goals associated with an action server."]
    #[doc = "* *"]
    #[doc = "* The provided `status_message` should be zero-initialized with"]
    #[doc = "* rcl_action_get_zero_initialized_goal_status_array() before calling this function."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_server handle to the action server that will publish the status message"]
    #[doc = "* \\param[out] status_message an action_msgs/StatusArray ROS message"]
    #[doc = "* \\return `RCL_RET_OK` if the response was sent successfully, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_get_goal_status_array(
        action_server: *const rcl_action_server_t,
        status_message: *mut rcl_action_goal_status_array_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Publish a status array message for accepted goals associated with an action server."]
    #[doc = "* *"]
    #[doc = "* This function acts like a ROS publisher and is potentially a blocking call."]
    #[doc = "* \\see rcl_publish()"]
    #[doc = "* "]
    #[doc = "* A status array message associated with the action server can be created with"]
    #[doc = "* rcl_action_get_goal_status_array()."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_server handle to the action server that will publish the status message"]
    #[doc = "* \\param[in] status_message an action_msgs/StatusArray ROS message to publish"]
    #[doc = "* \\return `RCL_RET_OK` if the response was sent successfully, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_publish_status(
        action_server: *const rcl_action_server_t,
        status_message: *const ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take a pending result request using an action server."]
    #[doc = "* *"]
    #[doc = "* \\todo TODO(jacobperron) blocking of take?"]
    #[doc = "* "]
    #[doc = "* \\todo TODO(jacobperron) pre-, during-, and post-conditions for message ownership?"]
    #[doc = "* "]
    #[doc = "* \\todo TODO(jacobperron) is this thread-safe?"]
    #[doc = "* "]
    #[doc = "* The caller is responsible for ensuring that the type of `ros_result_request`"]
    #[doc = "* and the type associate with the client (via the type support) match."]
    #[doc = "* Passing a different type produces undefined behavior and cannot be checked"]
    #[doc = "* by this function and therefore no deliberate error will occur."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_server handle to the action server that will take the result request"]
    #[doc = "* \\param[out] request_header pointer to the result request header"]
    #[doc = "* \\param[out] ros_result_request a preallocated ROS result request message where the"]
    #[doc = "* request is copied."]
    #[doc = "* \\return `RCL_RET_OK` if the response was sent successfully, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_SERVER_TAKE_FAILED` if take failed but no error occurred"]
    #[doc = "* in the middleware, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_take_result_request(
        action_server: *const rcl_action_server_t,
        request_header: *mut rmw_request_id_t,
        ros_result_request: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Send a result response using an action server."]
    #[doc = "* *"]
    #[doc = "* This is a non-blocking call."]
    #[doc = "* "]
    #[doc = "* The caller is responsible for ensuring that the type of `ros_result_response`"]
    #[doc = "* and the type associate with the client (via the type support) match."]
    #[doc = "* Passing a different type produces undefined behavior and cannot be checked"]
    #[doc = "* by this function and therefore no deliberate error will occur."]
    #[doc = "* "]
    #[doc = "* Before calling this function, the caller should use rcl_action_update_goal_state()"]
    #[doc = "* to update the goals state to the appropriate terminal state."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_server handle to the action server that will send the result response"]
    #[doc = "* \\param[in] response_header pointer to the result response header"]
    #[doc = "* \\param[in] ros_result_response a ROS result response message to send"]
    #[doc = "* \\return `RCL_RET_OK` if the response was sent successfully, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_send_result_response(
        action_server: *const rcl_action_server_t,
        response_header: *mut rmw_request_id_t,
        ros_result_response: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Expires goals associated with an action server."]
    #[doc = "* *"]
    #[doc = "* A goal is 'expired' if it has been in a terminal state (has a result) for longer"]
    #[doc = "* than some duration."]
    #[doc = "* The timeout duration is set as part of the action server options."]
    #[doc = "* "]
    #[doc = "* If a negative timeout value if provided, then goal results never expire (kept forever)."]
    #[doc = "* If a timeout of zero is set, then goal results are discarded immediately (ie. goal"]
    #[doc = "* results are discarded whenever this function is called)."]
    #[doc = "* "]
    #[doc = "* Expired goals are removed from the internal array of goal handles."]
    #[doc = "* rcl_action_server_goal_exists() will return false for any goals that have expired."]
    #[doc = "* "]
    #[doc = "* \\attention If one or more goals are expired then a previously returned goal handle"]
    #[doc = "* array from rcl_action_server_get_goal_handles() becomes invalid."]
    #[doc = "* "]
    #[doc = "* `expired_goals`, `expired_goals_capacity` and `num_expired` are optional arguments."]
    #[doc = "* If set to (`NULL`, 0u, `NULL`) then they are not used."]
    #[doc = "* To use them allocate an array with size equal to the maximum number of goals that you want to"]
    #[doc = "* expire."]
    #[doc = "* Pass the number of goals the array can hold in as `expired_goals_capacity`."]
    #[doc = "* This function will set `num_expired` to the number of goals that were expired."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Maybe[1]"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* <i>[1] if one or more goals expires, then the internal goal handle array may be"]
    #[doc = "* resized or deallocated</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_server handle to the action server from which expired goals"]
    #[doc = "* will be cleared."]
    #[doc = "* \\param[inout] expired_goals the identifiers of goals that expired, or set to `NULL` if unused"]
    #[doc = "* \\param[inout] expired_goals_capacity the allocated size of `expired_goals`, or 0 if unused"]
    #[doc = "* \\param[out] num_expired the number of expired goals, or set to `NULL` if unused"]
    #[doc = "* \\return `RCL_RET_OK` if the response was sent successfully, or"]
    #[doc = "* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_BAD_ALLOC` if allocating memory failed, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_expire_goals(
        action_server: *const rcl_action_server_t,
        expired_goals: *mut rcl_action_goal_info_t,
        expired_goals_capacity: size_t,
        num_expired: *mut size_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Notifies action server that a goal handle reached a terminal state."]
    #[doc = "* *"]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_server handle to the action server"]
    #[doc = "* \\return `RCL_RET_OK` if everything is ok, or"]
    #[doc = "* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_notify_goal_done(action_server: *const rcl_action_server_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take a pending cancel request using an action server."]
    #[doc = "* *"]
    #[doc = "* \\todo TODO(jacobperron) blocking of take?"]
    #[doc = "* "]
    #[doc = "* \\todo TODO(jacobperron) pre-, during-, and post-conditions for message ownership?"]
    #[doc = "* "]
    #[doc = "* \\todo TODO(jacobperron) is this thread-safe?"]
    #[doc = "* "]
    #[doc = "* The caller is responsible for ensuring that the type of `ros_cancel_request`_"]
    #[doc = "* and the type associate with the client (via the type support) match."]
    #[doc = "* Passing a different type produces undefined behavior and cannot be checked"]
    #[doc = "* by this function and therefore no deliberate error will occur."]
    #[doc = "* "]
    #[doc = "* After receiving a successful cancel request, the appropriate goals can be"]
    #[doc = "* transitioned to the state CANCELING using rcl_action_process_cancel_request()."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_server handle to the action server that will take the cancel request"]
    #[doc = "* \\param[out] request_header pointer to the cancel request header"]
    #[doc = "* \\param[out] ros_cancel_request a preallocated ROS cancel request where the request"]
    #[doc = "* message is copied"]
    #[doc = "* \\return `RCL_RET_OK` if the response was sent successfully, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_SERVER_TAKE_FAILED` if take failed but no error occurred"]
    #[doc = "* in the middleware, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_take_cancel_request(
        action_server: *const rcl_action_server_t,
        request_header: *mut rmw_request_id_t,
        ros_cancel_request: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Process a cancel request using an action server."]
    #[doc = "* *"]
    #[doc = "* This is a non-blocking call."]
    #[doc = "* "]
    #[doc = "* This function will compute a list of goals that a cancelation request is attempting to cancel."]
    #[doc = "* It does not change the state of any goal."]
    #[doc = "* The following cancel policy applies based on the goal ID and the timestamp"]
    #[doc = "* contained in the cancel request:"]
    #[doc = "* "]
    #[doc = "* - If the goal ID is zero and timestamp is zero, cancel all goals."]
    #[doc = "* - If the goal ID is zero and timestamp is not zero, cancel all goals accepted"]
    #[doc = "* at or before the timestamp."]
    #[doc = "* - If the goal ID is not zero and timestamp is zero, cancel the goal with the"]
    #[doc = "* given ID regardless of the time it was accepted."]
    #[doc = "* - If the goal ID is not zero and timestamp is not zero, cancel the goal with the"]
    #[doc = "* given ID and all goals accepted at or before the timestamp."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_server handle to the action server that will process the cancel request"]
    #[doc = "* \\param[in] cancel_request a C-typed ROS cancel request to process"]
    #[doc = "* \\param[out] cancel_response a zero-initialized cancel response struct"]
    #[doc = "* where the goal info of goals which should be cancelled are copied"]
    #[doc = "* \\return `RCL_RET_OK` if the response was sent successfully, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or"]
    #[doc = "* \\return `RCL_RET_BAD_ALLOC` if allocating memory failed, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_process_cancel_request(
        action_server: *const rcl_action_server_t,
        cancel_request: *const rcl_action_cancel_request_t,
        cancel_response: *mut rcl_action_cancel_response_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Send a cancel response using an action server."]
    #[doc = "* *"]
    #[doc = "* This is a non-blocking call."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_server handle to the action server that will send the cancel response"]
    #[doc = "* \\param[in] response_header pointer to the cancel response header"]
    #[doc = "* \\param[in] ros_cancel_response a ROS cancel response to send"]
    #[doc = "* \\return `RCL_RET_OK` if the request was taken, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_send_cancel_response(
        action_server: *const rcl_action_server_t,
        response_header: *mut rmw_request_id_t,
        ros_cancel_response: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the action name for an action server."]
    #[doc = "* *"]
    #[doc = "* This function returns the action server's internal topic name string."]
    #[doc = "* This function can fail, and therefore return `NULL`, if the:"]
    #[doc = "* - action server is `NULL`"]
    #[doc = "* - action server is invalid (e.g. never called init or called fini)"]
    #[doc = "* "]
    #[doc = "* The returned string is only valid as long as the action server is valid."]
    #[doc = "* The value of the string may change if the topic name changes, and therefore"]
    #[doc = "* copying the string is recommended if this is a concern."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_server pointer to the action server"]
    #[doc = "* \\return name string if successful, or"]
    #[doc = "* \\return `NULL` otherwise."]
    #[doc = "* /"]
    pub fn rcl_action_server_get_action_name(
        action_server: *const rcl_action_server_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the rcl_action_server_options_t for an action server."]
    #[doc = "* *"]
    #[doc = "* This function returns the action server's internal options struct."]
    #[doc = "* This function can fail, and therefore return `NULL`, if the:"]
    #[doc = "* - action server is `NULL`"]
    #[doc = "* - action server is invalid (e.g. never called init or called fini)"]
    #[doc = "* "]
    #[doc = "* The returned struct is only valid as long as the action server is valid."]
    #[doc = "* The values in the struct may change if the action server's options change,"]
    #[doc = "* and therefore copying the struct is recommended if this is a concern."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_server handle to the action server"]
    #[doc = "* \\return options struct if successful, or"]
    #[doc = "* \\return `NULL` otherwise."]
    #[doc = "* /"]
    pub fn rcl_action_server_get_options(
        action_server: *const rcl_action_server_t,
    ) -> *const rcl_action_server_options_t;
}
extern "C" {
    #[doc = " Get the goal handles for all goals an action server is tracking."]
    #[doc = "* *"]
    #[doc = "* A pointer to the internally held array of pointers to goal handle structs is returned"]
    #[doc = "* along with the number of items in the array."]
    #[doc = "* "]
    #[doc = "* The returned handle is made invalid if the action server is finalized, if"]
    #[doc = "* rcl_shutdown() is called, or if rcl_action_expire_goals() is called and one or more"]
    #[doc = "* goals are expired."]
    #[doc = "* The returned handle is not guaranteed to be valid for the life time of the"]
    #[doc = "* action server as it may be finalized and recreated itself."]
    #[doc = "* Therefore, it is recommended to get the handle from the action server using"]
    #[doc = "* this function each time it is needed and avoid use of the handle"]
    #[doc = "* concurrently with functions that might change it."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_server handle to the action server"]
    #[doc = "* \\param[out] goal_handles is set to the array of pointers to goal handles if successful."]
    #[doc = "* \\param[out] num_goals is set to the number of goals in the returned array if successful,"]
    #[doc = "* not set otherwise."]
    #[doc = "* \\return `RCL_RET_OK` if successful, or"]
    #[doc = "* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_server_get_goal_handles(
        action_server: *const rcl_action_server_t,
        goal_handles: *mut *mut *mut rcl_action_goal_handle_t,
        num_goals: *mut size_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Check if a goal is already being tracked by an action server."]
    #[doc = "* *"]
    #[doc = "* Checks whether or not a goal is being tracked in the internal goal array."]
    #[doc = "* The goal state has no effect on the return value."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_server handle to the action server"]
    #[doc = "* \\param[in] goal_info handle to a struct containing the goal ID to check for"]
    #[doc = "* \\return `true` if `action_server` is currently tracking a goal with the provided goal ID, or"]
    #[doc = "* \\return `false` otherwise."]
    #[doc = "* /"]
    pub fn rcl_action_server_goal_exists(
        action_server: *const rcl_action_server_t,
        goal_info: *const rcl_action_goal_info_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Check if an action server is valid."]
    #[doc = "* *"]
    #[doc = "* In the case where `false` is returned (ie. the action server is invalid),"]
    #[doc = "* an error message is set."]
    #[doc = "* "]
    #[doc = "* This function cannot fail."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_server handle to the action server"]
    #[doc = "* \\return `true` if `action_server` is valid, or"]
    #[doc = "* \\return `false` otherwise."]
    #[doc = "* /"]
    pub fn rcl_action_server_is_valid(action_server: *const rcl_action_server_t) -> bool;
}
extern "C" {
    #[doc = " Check if an action server is valid without erroring if the library is shutting down."]
    #[doc = "* *"]
    #[doc = "* In the case where `false` is returned (ie. the action server is invalid),"]
    #[doc = "* an error message is set."]
    #[doc = "* "]
    #[doc = "* This function cannot fail."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_server handle to the action server"]
    #[doc = "* \\return `true` if `action_server` is valid, or"]
    #[doc = "* \\return `false` otherwise."]
    #[doc = "* /"]
    pub fn rcl_action_server_is_valid_except_context(
        action_server: *const rcl_action_server_t,
    ) -> bool;
}
extern "C" {
    pub static rcl_action_qos_profile_status_default: rmw_qos_profile_t;
}
#[doc = " Associative array of topic or service names and types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_names_and_types_t {
    #[doc = " Array of names"]
    pub names: rcutils_string_array_t,
    #[doc = " Dynamic array of arrays of type names, with the same length as `names`"]
    pub types: *mut rcutils_string_array_t,
}
#[test]
fn bindgen_test_layout_rmw_names_and_types_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_names_and_types_t>(),
        64usize,
        concat!("Size of: ", stringify!(rmw_names_and_types_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_names_and_types_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_names_and_types_t))
    );
    fn test_field_names() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_names_and_types_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).names) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_names_and_types_t),
                "::",
                stringify!(names)
            )
        );
    }
    test_field_names();
    fn test_field_types() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_names_and_types_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).types) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_names_and_types_t),
                "::",
                stringify!(types)
            )
        );
    }
    test_field_types();
}
extern "C" {
    #[doc = " Return a zero initialized array of names and types."]
    pub fn rmw_get_zero_initialized_names_and_types() -> rmw_names_and_types_t;
}
extern "C" {
    #[doc = " Check that the given `names_and_types` array is zero initialized."]
    #[doc = "* *"]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Access to the array of names and types is read-only, but it is not synchronized."]
    #[doc = "* Concurrent `names_and_types` reads are safe, but concurrent reads and writes are not."]
    #[doc = "* "]
    #[doc = "* \\param[in] names_and_types Array to be checked."]
    #[doc = "* \\return RMW_RET_OK if array is zero initialized, RMW_RET_INVALID_ARGUMENT otherwise."]
    #[doc = "* \\remark This function sets the RMW error state on failure."]
    #[doc = "* /"]
    pub fn rmw_names_and_types_check_zero(names_and_types: *mut rmw_names_and_types_t)
        -> rmw_ret_t;
}
extern "C" {
    #[doc = " Initialize an array of names and types."]
    #[doc = "* *"]
    #[doc = "* This function initializes the string array for the names and allocates space"]
    #[doc = "* for all the string arrays for the types according to the given size, but"]
    #[doc = "* it does not initialize the string array for each setup of types."]
    #[doc = "* However, the string arrays for each set of types is zero initialized."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Initialization is a reentrant procedure, but:"]
    #[doc = "* - Access to arrays of names and types is not synchronized."]
    #[doc = "* It is not safe to read or write `names_and_types` during initialization."]
    #[doc = "* - The default allocators are thread-safe objects, but any custom `allocator` may not be."]
    #[doc = "* Check your allocator documentation for further reference."]
    #[doc = "* "]
    #[doc = "* \\param[inout] names_and_types Array to be initialized on success,"]
    #[doc = "* but left unchanged on failure."]
    #[doc = "* \\param[in] size Size of the array."]
    #[doc = "* \\param[in] allocator Allocator to be used to populate `names_and_types`."]
    #[doc = "* \\returns `RMW_RET_OK` if successful, or"]
    #[doc = "* \\returns `RMW_RET_INVALID_ARGUMENT` if `names_and_types` is NULL, or"]
    #[doc = "* \\returns `RMW_RET_INVALID_ARGUMENT` if `names_and_types` is not"]
    #[doc = "* a zero initialized array, or"]
    #[doc = "* \\returns `RMW_RET_INVALID_ARGUMENT` if `allocator` is invalid,"]
    #[doc = "* by rcutils_allocator_is_valid() definition, or"]
    #[doc = "* \\returns `RMW_BAD_ALLOC` if memory allocation fails, or"]
    #[doc = "* \\returns `RMW_RET_ERROR` when an unspecified error occurs."]
    #[doc = "* \\remark This function sets the RMW error state on failure."]
    #[doc = "* /"]
    pub fn rmw_names_and_types_init(
        names_and_types: *mut rmw_names_and_types_t,
        size: size_t,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Finalize an array of names and types."]
    #[doc = "* *"]
    #[doc = "* This function deallocates the string array of names and the array of string arrays of types,"]
    #[doc = "* and zero initializes the given array."]
    #[doc = "* If a logical error, such as `RMW_RET_INVALID_ARGUMENT`, ensues, this function will return"]
    #[doc = "* early, leaving the given array unchanged."]
    #[doc = "* Otherwise, it will proceed despite errors."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Finalization is a reentrant procedure, but access to arrays of names and types"]
    #[doc = "* is not synchronized."]
    #[doc = "* It is not safe to read or write `names_and_types` during initialization."]
    #[doc = "* "]
    #[doc = "* \\param[inout] names_and_types Array to be finalized."]
    #[doc = "* \\returns `RMW_RET_OK` if successful, or"]
    #[doc = "* \\returns `RMW_RET_INVALID_ARGUMENT` if `names_and_types` is NULL, or"]
    #[doc = "* \\returns `RMW_RET_ERROR` when an unspecified error occurs."]
    #[doc = "* \\remark This function sets the RMW error state on failure."]
    #[doc = "* /"]
    pub fn rmw_names_and_types_fini(names_and_types: *mut rmw_names_and_types_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Return all topic names and types in the ROS graph."]
    #[doc = "* *"]
    #[doc = "* This function returns an array of all topic names and types in the ROS graph"]
    #[doc = "* i.e. for which a publisher and/or a subscription exists, as discovered so far"]
    #[doc = "* by the given local node."]
    #[doc = "* "]
    #[doc = "* Unless `no_demangle` is true, some demangling and filtering may take place when"]
    #[doc = "* listing topics as implemented by the middleware."]
    #[doc = "* Whether demangling applies or not, and how it applies, depends on the underlying"]
    #[doc = "* implementation."]
    #[doc = "* See http://design.ros2.org/articles/topic_and_service_names.html for an example"]
    #[doc = "* on how it is used in DDS and RTPS based implementations."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | Maybe [1]"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] rmw implementation defined, check the implementation documentation</i>"]
    #[doc = "* "]
    #[doc = "* \\par Runtime behavior"]
    #[doc = "* To query the ROS graph is a synchronous operation."]
    #[doc = "* It is also non-blocking, but it is not guaranteed to be lock-free."]
    #[doc = "* Generally speaking, implementations may synchronize access to internal resources using"]
    #[doc = "* locks but are not allowed to wait for events with no guaranteed time bound (barring"]
    #[doc = "* the effects of starvation due to OS scheduling)."]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Nodes are thread-safe objects, and so are all operations on them except for finalization."]
    #[doc = "* Therefore, it is safe to query the ROS graph using the same node concurrently."]
    #[doc = "* However, when querying topic names and types:"]
    #[doc = "* - Access to the array of names and types is not synchronized."]
    #[doc = "* It is not safe to read or write `topic_names_and_types`"]
    #[doc = "* while rmw_get_topic_names_and_types() uses it."]
    #[doc = "* - The default allocators are thread-safe objects, but any custom `allocator` may not be."]
    #[doc = "* Check your allocator documentation for further reference."]
    #[doc = "* "]
    #[doc = "* \\pre Given `node` must be a valid node handle, as returned by rmw_create_node()."]
    #[doc = "* \\pre Given `topic_names_and_types` must be a zero-initialized array of names and types,"]
    #[doc = "* as returned by rmw_get_zero_initialized_names_and_types()."]
    #[doc = "* "]
    #[doc = "* \\param[in] node Node to query the ROS graph."]
    #[doc = "* \\param[in] allocator Allocator to be used when populating the `topic_names_and_types` array."]
    #[doc = "* \\param[in] no_demangle Whether to demangle all topic names following ROS conventions or not."]
    #[doc = "* \\param[out] topic_names_and_types Array of topic names and their types,"]
    #[doc = "* populated on success but left unchanged on failure."]
    #[doc = "* If populated, it is up to the caller to finalize this array later on"]
    #[doc = "* using rmw_names_and_types_fini()."]
    #[doc = "* \\return `RMW_RET_OK` if the query was successful, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `allocator` is not valid, by rcutils_allocator_is_valid()"]
    #[doc = "* definition, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `topic_names_and_types` is NULL, or"]
    #[doc = "* \\return `RMW_RET_INVALID_ARGUMENT` if `topic_names_and_types` is not a"]
    #[doc = "* zero-initialized array, or"]
    #[doc = "* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation"]
    #[doc = "* identifier does not match this implementation, or"]
    #[doc = "* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or"]
    #[doc = "* \\return `RMW_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rmw_get_topic_names_and_types(
        node: *const rmw_node_t,
        allocator: *mut rcutils_allocator_t,
        no_demangle: bool,
        topic_names_and_types: *mut rmw_names_and_types_t,
    ) -> rmw_ret_t;
}
#[doc = " A data structure that encapsulates the node name, node namespace,"]
#[doc = " topic_type, gid, and qos_profile of publishers and subscriptions"]
#[doc = " for a topic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_topic_endpoint_info_t {
    #[doc = " Name of the node"]
    pub node_name: *const ::std::os::raw::c_char,
    #[doc = " Namespace of the node"]
    pub node_namespace: *const ::std::os::raw::c_char,
    #[doc = " The associated topic type"]
    pub topic_type: *const ::std::os::raw::c_char,
    #[doc = " The endpoint type"]
    pub endpoint_type: rmw_endpoint_type_t,
    #[doc = " The GID of the endpoint"]
    pub endpoint_gid: [u8; 24usize],
    #[doc = " QoS profile of the endpoint"]
    pub qos_profile: rmw_qos_profile_t,
}
#[test]
fn bindgen_test_layout_rmw_topic_endpoint_info_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_topic_endpoint_info_t>(),
        144usize,
        concat!("Size of: ", stringify!(rmw_topic_endpoint_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_topic_endpoint_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_topic_endpoint_info_t))
    );
    fn test_field_node_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_topic_endpoint_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).node_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_topic_endpoint_info_t),
                "::",
                stringify!(node_name)
            )
        );
    }
    test_field_node_name();
    fn test_field_node_namespace() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_topic_endpoint_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).node_namespace) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_topic_endpoint_info_t),
                "::",
                stringify!(node_namespace)
            )
        );
    }
    test_field_node_namespace();
    fn test_field_topic_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_topic_endpoint_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).topic_type) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_topic_endpoint_info_t),
                "::",
                stringify!(topic_type)
            )
        );
    }
    test_field_topic_type();
    fn test_field_endpoint_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_topic_endpoint_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).endpoint_type) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_topic_endpoint_info_t),
                "::",
                stringify!(endpoint_type)
            )
        );
    }
    test_field_endpoint_type();
    fn test_field_endpoint_gid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_topic_endpoint_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).endpoint_gid) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_topic_endpoint_info_t),
                "::",
                stringify!(endpoint_gid)
            )
        );
    }
    test_field_endpoint_gid();
    fn test_field_qos_profile() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_topic_endpoint_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).qos_profile) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_topic_endpoint_info_t),
                "::",
                stringify!(qos_profile)
            )
        );
    }
    test_field_qos_profile();
}
extern "C" {
    #[doc = " Return zero initialized topic endpoint info data structure."]
    #[doc = "* *"]
    #[doc = "* Endpoint type will be invalid."]
    #[doc = "* Endpoint QoS profile will be the system default."]
    #[doc = "* /"]
    pub fn rmw_get_zero_initialized_topic_endpoint_info() -> rmw_topic_endpoint_info_t;
}
extern "C" {
    #[doc = " Finalize a topic endpoint info data structure."]
    #[doc = "* *"]
    #[doc = "* This function deallocates all allocated members of the given data structure,"]
    #[doc = "* and then zero initializes it."]
    #[doc = "* If a logical error, such as `RMW_RET_INVALID_ARGUMENT`, ensues, this function"]
    #[doc = "* will return early, leaving the given data structure unchanged."]
    #[doc = "* Otherwise, it will proceed despite errors."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Finalization is a reentrant procedure, but:"]
    #[doc = "* - Access to the topic endpoint info data structure is not synchronized."]
    #[doc = "* It is not safe to read or write `topic_endpoint` during finalization."]
    #[doc = "* - The default allocators are thread-safe objects, but any custom `allocator` may not be."]
    #[doc = "* Check your allocator documentation for further reference."]
    #[doc = "* "]
    #[doc = "* \\param[inout] topic_endpoint_info Data structure to be finalized."]
    #[doc = "* \\param[in] allocator Allocator used to populate the given `topic_endpoint_info`."]
    #[doc = "* \\returns `RMW_RET_OK` if successful, or"]
    #[doc = "* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or"]
    #[doc = "* \\returns `RMW_RET_INVALID_ARGUMENT` if `allocator` is invalid,"]
    #[doc = "* by rcutils_allocator_is_valid() definition, or"]
    #[doc = "* \\returns `RMW_RET_ERROR` when an unspecified error occurs."]
    #[doc = "* \\remark This function sets the RMW error state on failure."]
    #[doc = "* /"]
    pub fn rmw_topic_endpoint_info_fini(
        topic_endpoint_info: *mut rmw_topic_endpoint_info_t,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Set the topic type in the given topic endpoint info data structure."]
    #[doc = "* *"]
    #[doc = "* This functions allocates memory and copies the value of the `topic_type`"]
    #[doc = "* argument to set the data structure `topic_type` member."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Setting a member is a reentrant procedure, but:"]
    #[doc = "* - Access to the topic endpoint info data structure is not synchronized."]
    #[doc = "* It is not safe to read or write the `topic_type` member of the given `topic_endpoint`"]
    #[doc = "* while setting it."]
    #[doc = "* - Access to C-style string arguments is read-only but it is not synchronized."]
    #[doc = "* Concurrent `topic_type` reads are safe, but concurrent reads and writes are not."]
    #[doc = "* - The default allocators are thread-safe objects, but any custom `allocator` may not be."]
    #[doc = "* Check your allocator documentation for further reference."]
    #[doc = "* "]
    #[doc = "* \\pre Given `topic_type` is a valid C-style string i.e. NULL terminated."]
    #[doc = "* "]
    #[doc = "* \\param[inout] topic_endpoint_info Data structure to be populated."]
    #[doc = "* \\param[in] topic_type Type name to be set."]
    #[doc = "* \\param[in] allocator Allocator to be used."]
    #[doc = "* \\returns `RMW_RET_OK` if successful, or"]
    #[doc = "* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or"]
    #[doc = "* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_type` is NULL, or"]
    #[doc = "* \\returns `RMW_RET_BAD_ALLOC` if memory allocation fails, or"]
    #[doc = "* \\returns `RMW_RET_ERROR` when an unspecified error occurs."]
    #[doc = "* \\remark This function sets the RMW error state on failure."]
    #[doc = "* /"]
    pub fn rmw_topic_endpoint_info_set_topic_type(
        topic_endpoint_info: *mut rmw_topic_endpoint_info_t,
        topic_type: *const ::std::os::raw::c_char,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Set the node name in the given topic endpoint info data structure."]
    #[doc = "* *"]
    #[doc = "* This functions allocates memory and copies the value of the `node_name`"]
    #[doc = "* argument to set the data structure `node_name` member."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Setting a member is a reentrant procedure, but:"]
    #[doc = "* - Access to the topic endpoint info data structure is not synchronized."]
    #[doc = "* It is not safe to read or write the `node_name` member of the given `topic_endpoint`"]
    #[doc = "* while setting it."]
    #[doc = "* - Access to C-style string arguments is read-only but it is not synchronized."]
    #[doc = "* Concurrent `node_name` reads are safe, but concurrent reads and writes are not."]
    #[doc = "* - The default allocators are thread-safe objects, but any custom `allocator` may not be."]
    #[doc = "* Check your allocator documentation for further reference."]
    #[doc = "* "]
    #[doc = "* \\pre Given `node_name` is a valid C-style string i.e. NULL terminated."]
    #[doc = "* "]
    #[doc = "* \\param[inout] topic_endpoint_info Data structure to be populated."]
    #[doc = "* \\param[in] node_name Node name to be set."]
    #[doc = "* \\param[in] allocator Allocator to be used."]
    #[doc = "* \\returns `RMW_RET_OK` if successful, or"]
    #[doc = "* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or"]
    #[doc = "* \\returns `RMW_RET_INVALID_ARGUMENT` if `node_name` is NULL, or"]
    #[doc = "* \\returns `RMW_RET_BAD_ALLOC` if memory allocation fails, or"]
    #[doc = "* \\returns `RMW_RET_ERROR` when an unspecified error occurs."]
    #[doc = "* \\remark This function sets the RMW error state on failure."]
    #[doc = "* /"]
    pub fn rmw_topic_endpoint_info_set_node_name(
        topic_endpoint_info: *mut rmw_topic_endpoint_info_t,
        node_name: *const ::std::os::raw::c_char,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Set the node namespace in the given topic endpoint info data structure."]
    #[doc = "* *"]
    #[doc = "* This functions allocates memory and copies the value of the `node_namespace`"]
    #[doc = "* argument to set the data structure `node_namespace` member."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Setting a member is a reentrant procedure, but:"]
    #[doc = "* - Access to the topic endpoint info data structure is not synchronized."]
    #[doc = "* It is not safe to read or write the `node_namespace` member of the given `topic_endpoint`"]
    #[doc = "* while setting it."]
    #[doc = "* - Access to C-style string arguments is read-only but it is not synchronized."]
    #[doc = "* Concurrent `node_namespace` reads are safe, but concurrent reads and writes are not."]
    #[doc = "* - The default allocators are thread-safe objects, but any custom `allocator` may not be."]
    #[doc = "* Check your allocator documentation for further reference."]
    #[doc = "* "]
    #[doc = "* \\pre Given `node_namespace` is a valid C-style string i.e. NULL terminated."]
    #[doc = "* "]
    #[doc = "* \\param[inout] topic_endpoint_info Data structure to be populated."]
    #[doc = "* \\param[in] node_namespace Node namespace to be set."]
    #[doc = "* \\param[in] allocator Allocator to be used."]
    #[doc = "* \\returns `RMW_RET_OK` if successful, or"]
    #[doc = "* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or"]
    #[doc = "* \\returns `RMW_RET_INVALID_ARGUMENT` if `node_namespace` is NULL, or"]
    #[doc = "* \\returns `RMW_RET_BAD_ALLOC` if memory allocation fails, or"]
    #[doc = "* \\returns `RMW_RET_ERROR` when an unspecified error occurs."]
    #[doc = "* \\remark This function sets the RMW error state on failure."]
    #[doc = "* /"]
    pub fn rmw_topic_endpoint_info_set_node_namespace(
        topic_endpoint_info: *mut rmw_topic_endpoint_info_t,
        node_namespace: *const ::std::os::raw::c_char,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Set the endpoint type in the given topic endpoint info data structure."]
    #[doc = "* *"]
    #[doc = "* This functions assigns the value of the `type` argument to the data structure"]
    #[doc = "* `endpoint_type` member."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Setting a member is a reentrant procedure, but access to the"]
    #[doc = "* topic endpoint info data structure is not synchronized."]
    #[doc = "* It is not safe to read or write the `endpoint_type` member of the"]
    #[doc = "* given `topic_endpoint` while setting it."]
    #[doc = "* "]
    #[doc = "* \\param[inout] topic_endpoint_info Data structure to be populated."]
    #[doc = "* \\param[in] type Endpoint type to be set."]
    #[doc = "* \\returns `RMW_RET_OK` if successful, or"]
    #[doc = "* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or"]
    #[doc = "* \\returns `RMW_RET_ERROR` when an unspecified error occurs."]
    #[doc = "* \\remark This function sets the RMW error state on failure."]
    #[doc = "* /"]
    pub fn rmw_topic_endpoint_info_set_endpoint_type(
        topic_endpoint_info: *mut rmw_topic_endpoint_info_t,
        type_: rmw_endpoint_type_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Set the endpoint gid in the given topic endpoint info data structure."]
    #[doc = "* *"]
    #[doc = "* This functions copies the value of the `gid` argument to the data structure"]
    #[doc = "* `endpoint_gid` member."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Setting a member is a reentrant procedure, but access to the"]
    #[doc = "* topic endpoint info data structure is not synchronized."]
    #[doc = "* It is not safe to read or write the `gid` member of the"]
    #[doc = "* given `topic_endpoint` while setting it."]
    #[doc = "* "]
    #[doc = "* \\param[inout] topic_endpoint_info Data structure to be populated."]
    #[doc = "* \\param[in] gid Endpoint gid to be set."]
    #[doc = "* \\param[in] size Size of the given `gid`."]
    #[doc = "* \\returns `RMW_RET_OK` if successful, or"]
    #[doc = "* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or"]
    #[doc = "* \\returns `RMW_RET_INVALID_ARGUMENT` if `gid` is NULL, or"]
    #[doc = "* \\returns `RMW_RET_INVALID_ARGUMENT` if `size` is greater than RMW_GID_STORAGE_SIZE, or"]
    #[doc = "* \\returns `RMW_RET_ERROR` when an unspecified error occurs."]
    #[doc = "* \\remark This function sets the RMW error state on failure."]
    #[doc = "* /"]
    pub fn rmw_topic_endpoint_info_set_gid(
        topic_endpoint_info: *mut rmw_topic_endpoint_info_t,
        gid: *const u8,
        size: size_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Set the endpoint QoS profile in the given topic endpoint info data structure."]
    #[doc = "* *"]
    #[doc = "* This functions assigns the value of the `qos_profile` argument to the data structure"]
    #[doc = "* `qos_profile` member."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Setting a member is a reentrant procedure, but access to the"]
    #[doc = "* topic endpoint info data structure is not synchronized."]
    #[doc = "* It is not safe to read or write the `qos_profile` member of the"]
    #[doc = "* given `topic_endpoint` while setting it."]
    #[doc = "* "]
    #[doc = "* \\param[inout] topic_endpoint_info Data structure to be populated."]
    #[doc = "* \\param[in] qos_profile QoS profile to be set."]
    #[doc = "* \\returns `RMW_RET_OK` if successful, or"]
    #[doc = "* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or"]
    #[doc = "* \\returns `RMW_RET_INVALID_ARGUMENT` if `qos_profile` is NULL, or"]
    #[doc = "* \\returns `RMW_RET_ERROR` when an unspecified error occurs."]
    #[doc = "* \\remark This function sets the RMW error state on failure."]
    #[doc = "* /"]
    pub fn rmw_topic_endpoint_info_set_qos_profile(
        topic_endpoint_info: *mut rmw_topic_endpoint_info_t,
        qos_profile: *const rmw_qos_profile_t,
    ) -> rmw_ret_t;
}
#[doc = " Array of topic endpoint information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_topic_endpoint_info_array_t {
    #[doc = " Size of the array."]
    pub size: size_t,
    #[doc = " Contiguous storage for topic endpoint information elements."]
    pub info_array: *mut rmw_topic_endpoint_info_t,
}
#[test]
fn bindgen_test_layout_rmw_topic_endpoint_info_array_t() {
    assert_eq!(
        ::std::mem::size_of::<rmw_topic_endpoint_info_array_t>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_topic_endpoint_info_array_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_topic_endpoint_info_array_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_topic_endpoint_info_array_t))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_topic_endpoint_info_array_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_topic_endpoint_info_array_t),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_info_array() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rmw_topic_endpoint_info_array_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).info_array) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rmw_topic_endpoint_info_array_t),
                "::",
                stringify!(info_array)
            )
        );
    }
    test_field_info_array();
}
extern "C" {
    #[doc = " Return a zero initialized array of topic endpoint information."]
    pub fn rmw_get_zero_initialized_topic_endpoint_info_array() -> rmw_topic_endpoint_info_array_t;
}
extern "C" {
    #[doc = " Check that the given `topic_endpoint_info_array` is zero initialized."]
    #[doc = "* *"]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Access to the array of topic endpoint information is read-only, but it is not synchronized."]
    #[doc = "* Concurrent `topic_endpoint_info_array` reads are safe, but concurrent reads"]
    #[doc = "* and writes are not."]
    #[doc = "* "]
    #[doc = "* \\param[in] topic_endpoint_info_array Array to be checked."]
    #[doc = "* \\returns `RMW_RET_OK` if array is zero initialized, or"]
    #[doc = "* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info_array` is NULL, or"]
    #[doc = "* \\returns `RMW_RET_ERROR` if `topic_endpoint_info_array` is not zero initialized."]
    #[doc = "* \\remark This function sets the RMW error state on failure."]
    #[doc = "* /"]
    pub fn rmw_topic_endpoint_info_array_check_zero(
        topic_endpoint_info_array: *mut rmw_topic_endpoint_info_array_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Initialize an array of topic endpoint information."]
    #[doc = "* *"]
    #[doc = "* This function allocates space to hold `size` topic endpoint information elements."]
    #[doc = "* Both `info_array` and `size` members are updated accordingly."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Initialization is a reentrant procedure, but:"]
    #[doc = "* - Access to the array of topic endpoint information is not synchronized."]
    #[doc = "* It is not safe to read or write `topic_endpoint_info_array` during initialization."]
    #[doc = "* - The default allocators are thread-safe objects, but any custom `allocator` may not be."]
    #[doc = "* Check your allocator documentation for further reference."]
    #[doc = "* "]
    #[doc = "* \\param[inout] topic_endpoint_info_array Array to be initialized on success,"]
    #[doc = "* but left unchanged on failure."]
    #[doc = "* \\param[in] size Size of the array."]
    #[doc = "* \\param[in] allocator Allocator to be used to populate `names_and_types`."]
    #[doc = "* \\returns `RMW_RET_OK` if successful, or"]
    #[doc = "* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info_array` is NULL, or"]
    #[doc = "* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info_array` is not"]
    #[doc = "* a zero initialized array, or"]
    #[doc = "* \\returns `RMW_RET_INVALID_ARGUMENT` if `allocator` is invalid,"]
    #[doc = "* by rcutils_allocator_is_valid() definition, or"]
    #[doc = "* \\returns `RMW_BAD_ALLOC` if memory allocation fails, or"]
    #[doc = "* \\returns `RMW_RET_ERROR` when an unspecified error occurs."]
    #[doc = "* \\remark This function sets the RMW error state on failure."]
    #[doc = "* /"]
    pub fn rmw_topic_endpoint_info_array_init_with_size(
        topic_endpoint_info_array: *mut rmw_topic_endpoint_info_array_t,
        size: size_t,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Finalize an array of topic endpoint information."]
    #[doc = "* *"]
    #[doc = "* This function deallocates the given array storage, and then zero initializes it."]
    #[doc = "* If a logical error, such as `RMW_RET_INVALID_ARGUMENT`, ensues, this function will"]
    #[doc = "* return early, leaving the given array unchanged."]
    #[doc = "* Otherwise, it will proceed despite errors."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\par Thread-safety"]
    #[doc = "* Finalization is a reentrant procedure, but:"]
    #[doc = "* - Access to the array of topic endpoint information is not synchronized."]
    #[doc = "* It is not safe to read or write `topic_endpoint_info_array` during finalization."]
    #[doc = "* - The default allocators are thread-safe objects, but any custom `allocator` may not be."]
    #[doc = "* Check your allocator documentation for further reference."]
    #[doc = "* "]
    #[doc = "* \\pre Given `allocator` must be the same used to initialize the given `topic_endpoint_info_array`."]
    #[doc = "* "]
    #[doc = "* \\param[inout] topic_endpoint_info_array object to be finalized."]
    #[doc = "* \\param[in] allocator Allocator used to populate the given `topic_endpoint_info_array`."]
    #[doc = "* \\returns `RMW_RET_OK` if successful, or"]
    #[doc = "* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info_array` is NULL, or"]
    #[doc = "* \\returns `RMW_RET_INVALID_ARGUMENT` if `allocator` is invalid,"]
    #[doc = "* by rcutils_allocator_is_valid() definition, or"]
    #[doc = "* \\returns `RMW_RET_ERROR` when an unspecified error occurs."]
    #[doc = "* \\remark This function sets the RMW error state on failure."]
    #[doc = "* /"]
    pub fn rmw_topic_endpoint_info_array_fini(
        topic_endpoint_info_array: *mut rmw_topic_endpoint_info_array_t,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
#[doc = " Associative array of topic or service names and types."]
pub type rcl_names_and_types_t = rmw_names_and_types_t;
#[doc = " A data structure that encapsulates the node name, node namespace,"]
#[doc = " topic_type, gid, and qos_profile of publishers and subscriptions"]
#[doc = " for a topic."]
pub type rcl_topic_endpoint_info_t = rmw_topic_endpoint_info_t;
#[doc = " Array of topic endpoint information"]
pub type rcl_topic_endpoint_info_array_t = rmw_topic_endpoint_info_array_t;
extern "C" {
    #[doc = " Return a list of topic names and types for publishers associated with a node."]
    #[doc = "* *"]
    #[doc = "* The `node` parameter must point to a valid node."]
    #[doc = "* "]
    #[doc = "* The `topic_names_and_types` parameter must be allocated and zero initialized."]
    #[doc = "* This function allocates memory for the returned list of names and types and so it is the"]
    #[doc = "* callers responsibility to pass `topic_names_and_types` to rcl_names_and_types_fini()"]
    #[doc = "* when it is no longer needed."]
    #[doc = "* Failing to do so will result in leaked memory."]
    #[doc = "* "]
    #[doc = "* There may be some demangling that occurs when listing the names from the middleware"]
    #[doc = "* implementation."]
    #[doc = "* If the `no_demangle` argument is set to `true`, then this will be avoided and the names will be"]
    #[doc = "* returned as they appear to the middleware."]
    #[doc = "* "]
    #[doc = "* \\see rmw_get_topic_names_and_types for more details on no_demangle"]
    #[doc = "* "]
    #[doc = "* The returned names are not automatically remapped by this function."]
    #[doc = "* Attempting to create publishers or subscribers using names returned by this function may not"]
    #[doc = "* result in the desired topic name being used depending on the remap rules in use."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] implementation may need to protect the data structure with a lock</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node the handle to the node being used to query the ROS graph"]
    #[doc = "* \\param[in] allocator allocator to be used when allocating space for strings"]
    #[doc = "* \\param[in] no_demangle if true, list all topics without any demangling"]
    #[doc = "* \\param[in] node_name the node name of the topics to return"]
    #[doc = "* \\param[in] node_namespace the node namespace of the topics to return"]
    #[doc = "* \\param[out] topic_names_and_types list of topic names and their types"]
    #[doc = "* \\return #RCL_RET_OK if the query was successful, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID if the node is invalid, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID_NAME if the node name is invalid, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID_NAMESPACE if the node namespace is invalid, or"]
    #[doc = "* \\return #RCL_RET_NODE_NAME_NON_EXISTENT if the node name wasn't found, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_get_publisher_names_and_types_by_node(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        no_demangle: bool,
        node_name: *const ::std::os::raw::c_char,
        node_namespace: *const ::std::os::raw::c_char,
        topic_names_and_types: *mut rcl_names_and_types_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a list of topic names and types for subscriptions associated with a node."]
    #[doc = "* *"]
    #[doc = "* The `node` parameter must point to a valid node."]
    #[doc = "* "]
    #[doc = "* The `topic_names_and_types` parameter must be allocated and zero initialized."]
    #[doc = "* This function allocates memory for the returned list of names and types and so it is the"]
    #[doc = "* callers responsibility to pass `topic_names_and_types` to rcl_names_and_types_fini()"]
    #[doc = "* when it is no longer needed."]
    #[doc = "* Failing to do so will result in leaked memory."]
    #[doc = "* "]
    #[doc = "* \\see rcl_get_publisher_names_and_types_by_node for details on the `no_demangle` parameter."]
    #[doc = "* "]
    #[doc = "* The returned names are not automatically remapped by this function."]
    #[doc = "* Attempting to create publishers or subscribers using names returned by this function may not"]
    #[doc = "* result in the desired topic name being used depending on the remap rules in use."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] implementation may need to protect the data structure with a lock</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node the handle to the node being used to query the ROS graph"]
    #[doc = "* \\param[in] allocator allocator to be used when allocating space for strings"]
    #[doc = "* \\param[in] no_demangle if true, list all topics without any demangling"]
    #[doc = "* \\param[in] node_name the node name of the topics to return"]
    #[doc = "* \\param[in] node_namespace the node namespace of the topics to return"]
    #[doc = "* \\param[out] topic_names_and_types list of topic names and their types"]
    #[doc = "* \\return #RCL_RET_OK if the query was successful, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID if the node is invalid, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID_NAME if the node name is invalid, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID_NAMESPACE if the node namespace is invalid, or"]
    #[doc = "* \\return #RCL_RET_NODE_NAME_NON_EXISTENT if the node name wasn't found, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_get_subscriber_names_and_types_by_node(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        no_demangle: bool,
        node_name: *const ::std::os::raw::c_char,
        node_namespace: *const ::std::os::raw::c_char,
        topic_names_and_types: *mut rcl_names_and_types_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a list of service names and types associated with a node."]
    #[doc = "* *"]
    #[doc = "* The `node` parameter must point to a valid node."]
    #[doc = "* "]
    #[doc = "* The `service_names_and_types` parameter must be allocated and zero initialized."]
    #[doc = "* This function allocates memory for the returned list of names and types and so it is the"]
    #[doc = "* callers responsibility to pass `service_names_and_types` to rcl_names_and_types_fini()"]
    #[doc = "* when it is no longer needed."]
    #[doc = "* Failing to do so will result in leaked memory."]
    #[doc = "* "]
    #[doc = "* \\see rcl_get_publisher_names_and_types_by_node for details on the `no_demangle` parameter."]
    #[doc = "* "]
    #[doc = "* The returned names are not automatically remapped by this function."]
    #[doc = "* Attempting to create service clients using names returned by this function may not"]
    #[doc = "* result in the desired service name being used depending on the remap rules in use."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] implementation may need to protect the data structure with a lock</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node the handle to the node being used to query the ROS graph"]
    #[doc = "* \\param[in] allocator allocator to be used when allocating space for strings"]
    #[doc = "* \\param[in] node_name the node name of the services to return"]
    #[doc = "* \\param[in] node_namespace the node namespace of the services to return"]
    #[doc = "* \\param[out] service_names_and_types list of service names and their types"]
    #[doc = "* \\return #RCL_RET_OK if the query was successful, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID if the node is invalid, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID_NAME if the node name is invalid, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID_NAMESPACE if the node namespace is invalid, or"]
    #[doc = "* \\return #RCL_RET_NODE_NAME_NON_EXISTENT if the node name wasn't found, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_get_service_names_and_types_by_node(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        node_name: *const ::std::os::raw::c_char,
        node_namespace: *const ::std::os::raw::c_char,
        service_names_and_types: *mut rcl_names_and_types_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a list of service client names and types associated with a node."]
    #[doc = "* *"]
    #[doc = "* The `node` parameter must point to a valid node."]
    #[doc = "* "]
    #[doc = "* The `service_names_and_types` parameter must be allocated and zero initialized."]
    #[doc = "* This function allocates memory for the returned list of names and types and so it is the"]
    #[doc = "* callers responsibility to pass `service_names_and_types` to rcl_names_and_types_fini()"]
    #[doc = "* when it is no longer needed."]
    #[doc = "* Failing to do so will result in leaked memory."]
    #[doc = "* "]
    #[doc = "* \\see rcl_get_publisher_names_and_types_by_node for details on the `no_demangle` parameter."]
    #[doc = "* "]
    #[doc = "* The returned names are not automatically remapped by this function."]
    #[doc = "* Attempting to create service servers using names returned by this function may not"]
    #[doc = "* result in the desired service name being used depending on the remap rules in use."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] implementation may need to protect the data structure with a lock</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node the handle to the node being used to query the ROS graph"]
    #[doc = "* \\param[in] allocator allocator to be used when allocating space for strings"]
    #[doc = "* \\param[in] node_name the node name of the services to return"]
    #[doc = "* \\param[in] node_namespace the node namespace of the services to return"]
    #[doc = "* \\param[out] service_names_and_types list of service client names and their types"]
    #[doc = "* \\return #RCL_RET_OK if the query was successful, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID if the node is invalid, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID_NAME if the node name is invalid, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID_NAMESPACE if the node namespace is invalid, or"]
    #[doc = "* \\return #RCL_RET_NODE_NAME_NON_EXISTENT if the node name wasn't found, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_get_client_names_and_types_by_node(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        node_name: *const ::std::os::raw::c_char,
        node_namespace: *const ::std::os::raw::c_char,
        service_names_and_types: *mut rcl_names_and_types_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a list of topic names and their types."]
    #[doc = "* *"]
    #[doc = "* The `node` parameter must point to a valid node."]
    #[doc = "* "]
    #[doc = "* The `topic_names_and_types` parameter must be allocated and zero initialized."]
    #[doc = "* This function allocates memory for the returned list of names and types and so it is the"]
    #[doc = "* callers responsibility to pass `topic_names_and_types` to rcl_names_and_types_fini()"]
    #[doc = "* when it is no longer needed."]
    #[doc = "* Failing to do so will result in leaked memory."]
    #[doc = "* "]
    #[doc = "* \\see rcl_get_publisher_names_and_types_by_node for details on the `no_demangle` parameter."]
    #[doc = "* "]
    #[doc = "* The returned names are not automatically remapped by this function."]
    #[doc = "* Attempting to create publishers or subscribers using names returned by this function may not"]
    #[doc = "* result in the desired topic name being used depending on the remap rules in use."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] implementation may need to protect the data structure with a lock</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node the handle to the node being used to query the ROS graph"]
    #[doc = "* \\param[in] allocator allocator to be used when allocating space for strings"]
    #[doc = "* \\param[in] no_demangle if true, list all topics without any demangling"]
    #[doc = "* \\param[out] topic_names_and_types list of topic names and their types"]
    #[doc = "* \\return #RCL_RET_OK if the query was successful, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID if the node is invalid, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID_NAME if the node name is invalid, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID_NAMESPACE if the node namespace is invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_get_topic_names_and_types(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        no_demangle: bool,
        topic_names_and_types: *mut rcl_names_and_types_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a list of service names and their types."]
    #[doc = "* *"]
    #[doc = "* The `node` parameter must point to a valid node."]
    #[doc = "* "]
    #[doc = "* The `service_names_and_types` parameter must be allocated and zero initialized."]
    #[doc = "* This function allocates memory for the returned list of names and types and so it is the"]
    #[doc = "* callers responsibility to pass `service_names_and_types` to rcl_names_and_types_fini()"]
    #[doc = "* when it is no longer needed."]
    #[doc = "* Failing to do so will result in leaked memory."]
    #[doc = "* "]
    #[doc = "* The returned names are not automatically remapped by this function."]
    #[doc = "* Attempting to create clients or services using names returned by this function may not result in"]
    #[doc = "* the desired service name being used depending on the remap rules in use."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] implementation may need to protect the data structure with a lock</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node the handle to the node being used to query the ROS graph"]
    #[doc = "* \\param[in] allocator allocator to be used when allocating space for strings"]
    #[doc = "* \\param[out] service_names_and_types list of service names and their types"]
    #[doc = "* \\return #RCL_RET_OK if the query was successful, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID if the node is invalid, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_get_service_names_and_types(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        service_names_and_types: *mut rcl_names_and_types_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Initialize a rcl_names_and_types_t object."]
    #[doc = "* *"]
    #[doc = "* This function initializes the string array for the names and allocates space"]
    #[doc = "* for all the string arrays for the types according to the given size, but"]
    #[doc = "* it does not initialize the string array for each set of types."]
    #[doc = "* However, the string arrays for each set of types is zero initialized."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] names_and_types object to be initialized"]
    #[doc = "* \\param[in] size the number of names and sets of types to be stored"]
    #[doc = "* \\param[in] allocator to be used to allocate and deallocate memory"]
    #[doc = "* \\return #RCL_RET_OK on success, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if memory allocation fails, or"]
    #[doc = "* \\return #RCL_RET_ERROR when an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_names_and_types_init(
        names_and_types: *mut rcl_names_and_types_t,
        size: size_t,
        allocator: *mut rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a rcl_names_and_types_t object."]
    #[doc = "* *"]
    #[doc = "* The object is populated when given to one of the rcl_get_*_names_and_types()"]
    #[doc = "* functions."]
    #[doc = "* This function reclaims any resources allocated during population."]
    #[doc = "* "]
    #[doc = "* The `names_and_types` parameter must not be `NULL`, and must point to an"]
    #[doc = "* already allocated rcl_names_and_types_t struct that was previously"]
    #[doc = "* passed to a successful rcl_get_*_names_and_types() function call."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] names_and_types struct to be finalized"]
    #[doc = "* \\return #RCL_RET_OK if successful, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_names_and_types_fini(names_and_types: *mut rcl_names_and_types_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a list of available nodes in the ROS graph."]
    #[doc = "* *"]
    #[doc = "* The `node` parameter must point to a valid node."]
    #[doc = "* "]
    #[doc = "* The `node_names` parameter must be allocated and zero initialized."]
    #[doc = "* `node_names` is the output for this function, and contains allocated memory."]
    #[doc = "* Use rcutils_get_zero_initialized_string_array() for initializing an empty"]
    #[doc = "* rcutils_string_array_t struct."]
    #[doc = "* This `node_names` struct should therefore be passed to rcutils_string_array_fini()"]
    #[doc = "* when it is no longer needed."]
    #[doc = "* Failing to do so will result in leaked memory."]
    #[doc = "* "]
    #[doc = "* Example:"]
    #[doc = "* "]
    #[doc = "* ```c"]
    #[doc = "* rcutils_string_array_t node_names ="]
    #[doc = "* rcutils_get_zero_initialized_string_array();"]
    #[doc = "* rcl_ret_t ret = rcl_get_node_names(node, &node_names);"]
    #[doc = "* if (ret != RCL_RET_OK) {"]
    #[doc = "* // ... error handling"]
    #[doc = "* }"]
    #[doc = "* // ... use the node_names struct, and when done:"]
    #[doc = "* rcutils_ret_t rcutils_ret = rcutils_string_array_fini(&node_names);"]
    #[doc = "* if (rcutils_ret != RCUTILS_RET_OK) {"]
    #[doc = "* // ... error handling"]
    #[doc = "* }"]
    #[doc = "* ```"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] implementation may need to protect the data structure with a lock</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node the handle to the node being used to query the ROS graph"]
    #[doc = "* \\param[in] allocator used to control allocation and deallocation of names"]
    #[doc = "* \\param[out] node_names struct storing discovered node names"]
    #[doc = "* \\param[out] node_namespaces struct storing discovered node namespaces"]
    #[doc = "* \\return #RCL_RET_OK if the query was successful, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if an error occurred while allocating memory, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID_NAME if a node with an invalid name is detected, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID_NAMESPACE if a node with an invalid namespace is detected, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_get_node_names(
        node: *const rcl_node_t,
        allocator: rcl_allocator_t,
        node_names: *mut rcutils_string_array_t,
        node_namespaces: *mut rcutils_string_array_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a list of available nodes in the ROS graph, including their enclave names."]
    #[doc = "* *"]
    #[doc = "* An rcl_get_node_names() equivalent, but including in its output the enclave"]
    #[doc = "* name the node is using."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] RMW implementation in use may need to protect the data structure with a lock</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node the handle to the node being used to query the ROS graph"]
    #[doc = "* \\param[in] allocator used to control allocation and deallocation of names"]
    #[doc = "* \\param[out] node_names struct storing discovered node names"]
    #[doc = "* \\param[out] node_namespaces struct storing discovered node namespaces"]
    #[doc = "* \\param[out] enclaves struct storing discovered node enclaves"]
    #[doc = "* \\return #RCL_RET_OK if the query was successful, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if an error occurred while allocating memory, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_get_node_names_with_enclaves(
        node: *const rcl_node_t,
        allocator: rcl_allocator_t,
        node_names: *mut rcutils_string_array_t,
        node_namespaces: *mut rcutils_string_array_t,
        enclaves: *mut rcutils_string_array_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the number of publishers on a given topic."]
    #[doc = "* *"]
    #[doc = "* The `node` parameter must point to a valid node."]
    #[doc = "* "]
    #[doc = "* The `topic_name` parameter must not be `NULL`, and must not be an empty string."]
    #[doc = "* It should also follow the topic name rules."]
    #[doc = "* \\todo TODO(wjwwood): link to the topic name rules."]
    #[doc = "* "]
    #[doc = "* The `count` parameter must point to a valid bool."]
    #[doc = "* The `count` parameter is the output for this function and will be set."]
    #[doc = "* "]
    #[doc = "* In the event that error handling needs to allocate memory, this function"]
    #[doc = "* will try to use the node's allocator."]
    #[doc = "* "]
    #[doc = "* The topic name is not automatically remapped by this function."]
    #[doc = "* If there is a publisher created with topic name `foo` and remap rule `foo:=bar` then calling"]
    #[doc = "* this with `topic_name` set to `bar` will return a count of 1, and with `topic_name` set to `foo`"]
    #[doc = "* will return a count of 0."]
    #[doc = "* /sa rcl_remap_topic_name()"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] implementation may need to protect the data structure with a lock</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node the handle to the node being used to query the ROS graph"]
    #[doc = "* \\param[in] topic_name the name of the topic in question"]
    #[doc = "* \\param[out] count number of publishers on the given topic"]
    #[doc = "* \\return #RCL_RET_OK if the query was successful, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID if the node is invalid, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_count_publishers(
        node: *const rcl_node_t,
        topic_name: *const ::std::os::raw::c_char,
        count: *mut size_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the number of subscriptions on a given topic."]
    #[doc = "* *"]
    #[doc = "* The `node` parameter must point to a valid node."]
    #[doc = "* "]
    #[doc = "* The `topic_name` parameter must not be `NULL`, and must not be an empty string."]
    #[doc = "* It should also follow the topic name rules."]
    #[doc = "* \\todo TODO(wjwwood): link to the topic name rules."]
    #[doc = "* "]
    #[doc = "* The `count` parameter must point to a valid bool."]
    #[doc = "* The `count` parameter is the output for this function and will be set."]
    #[doc = "* "]
    #[doc = "* In the event that error handling needs to allocate memory, this function"]
    #[doc = "* will try to use the node's allocator."]
    #[doc = "* "]
    #[doc = "* The topic name is not automatically remapped by this function."]
    #[doc = "* If there is a subscriber created with topic name `foo` and remap rule `foo:=bar` then calling"]
    #[doc = "* this with `topic_name` set to `bar` will return a count of 1, and with `topic_name` set to `foo`"]
    #[doc = "* will return a count of 0."]
    #[doc = "* /sa rcl_remap_topic_name()"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] implementation may need to protect the data structure with a lock</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node the handle to the node being used to query the ROS graph"]
    #[doc = "* \\param[in] topic_name the name of the topic in question"]
    #[doc = "* \\param[out] count number of subscriptions on the given topic"]
    #[doc = "* \\return #RCL_RET_OK if the query was successful, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID if the node is invalid, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_count_subscribers(
        node: *const rcl_node_t,
        topic_name: *const ::std::os::raw::c_char,
        count: *mut size_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Wait for there to be a specified number of publishers on a given topic."]
    #[doc = "* *"]
    #[doc = "* The `node` parameter must point to a valid node."]
    #[doc = "* The nodes graph guard condition is used by this function, and therefore the caller should"]
    #[doc = "* take care not to use the guard condition concurrently in any other wait sets."]
    #[doc = "* "]
    #[doc = "* The `allocator` parameter must point to a valid allocator."]
    #[doc = "* "]
    #[doc = "* The `topic_name` parameter must not be `NULL`, and must not be an empty string."]
    #[doc = "* It should also follow the topic name rules."]
    #[doc = "* "]
    #[doc = "* This function blocks and will return when the number of publishers for `topic_name`"]
    #[doc = "* is greater than or equal to the `count` parameter, or the specified `timeout` is reached."]
    #[doc = "* "]
    #[doc = "* The `timeout` parameter is in nanoseconds."]
    #[doc = "* The timeout is based on system time elapsed."]
    #[doc = "* A negative value disables the timeout (i.e. this function blocks until the number of"]
    #[doc = "* publishers is greater than or equals to `count`)."]
    #[doc = "* "]
    #[doc = "* The `success` parameter must point to a valid bool."]
    #[doc = "* The `success` parameter is the output for this function and will be set."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] implementation may need to protect the data structure with a lock</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node the handle to the node being used to query the ROS graph"]
    #[doc = "* \\param[in] allocator to allocate space for the rcl_wait_set_t used to wait for graph events"]
    #[doc = "* \\param[in] topic_name the name of the topic in question"]
    #[doc = "* \\param[in] count number of publishers to wait for"]
    #[doc = "* \\param[in] timeout maximum duration to wait for publishers"]
    #[doc = "* \\param[out] success `true` if the number of publishers is equal to or greater than count, or"]
    #[doc = "* `false` if a timeout occurred waiting for publishers."]
    #[doc = "* \\return #RCL_RET_OK if there was no errors, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID if the node is invalid, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_TIMEOUT if a timeout occurs before the number of publishers is detected, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurred."]
    #[doc = "* /"]
    pub fn rcl_wait_for_publishers(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        topic_name: *const ::std::os::raw::c_char,
        count: size_t,
        timeout: rcutils_duration_value_t,
        success: *mut bool,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Wait for there to be a specified number of subscribers on a given topic."]
    #[doc = "* *"]
    #[doc = "* \\see rcl_wait_for_publishers"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] implementation may need to protect the data structure with a lock</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node the handle to the node being used to query the ROS graph"]
    #[doc = "* \\param[in] allocator to allocate space for the rcl_wait_set_t used to wait for graph events"]
    #[doc = "* \\param[in] topic_name the name of the topic in question"]
    #[doc = "* \\param[in] count number of subscribers to wait for"]
    #[doc = "* \\param[in] timeout maximum duration to wait for subscribers"]
    #[doc = "* \\param[out] success `true` if the number of subscribers is equal to or greater than count, or"]
    #[doc = "* `false` if a timeout occurred waiting for subscribers."]
    #[doc = "* \\return #RCL_RET_OK if there was no errors, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID if the node is invalid, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_TIMEOUT if a timeout occurs before the number of subscribers is detected, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurred."]
    #[doc = "* /"]
    pub fn rcl_wait_for_subscribers(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        topic_name: *const ::std::os::raw::c_char,
        count: size_t,
        timeout: rcutils_duration_value_t,
        success: *mut bool,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a list of all publishers to a topic."]
    #[doc = "* *"]
    #[doc = "* The `node` parameter must point to a valid node."]
    #[doc = "* "]
    #[doc = "* The `topic_name` parameter must not be `NULL`."]
    #[doc = "* "]
    #[doc = "* When the `no_mangle` parameter is `true`, the provided `topic_name` should be a valid topic name"]
    #[doc = "* for the middleware (useful when combining ROS with native middleware (e.g. DDS) apps)."]
    #[doc = "* When the `no_mangle` parameter is `false`, the provided `topic_name` should follow"]
    #[doc = "* ROS topic name conventions."]
    #[doc = "* In either case, the topic name should always be fully qualified."]
    #[doc = "* "]
    #[doc = "* Each element in the `publishers_info` array will contain the node name, node namespace,"]
    #[doc = "* topic type, gid and the qos profile of the publisher."]
    #[doc = "* It is the responsibility of the caller to ensure that `publishers_info` parameter points"]
    #[doc = "* to a valid struct of type rcl_topic_endpoint_info_array_t."]
    #[doc = "* The `count` field inside the struct must be set to 0 and the `info_array` field inside"]
    #[doc = "* the struct must be set to null."]
    #[doc = "* \\see rmw_get_zero_initialized_topic_endpoint_info_array"]
    #[doc = "* "]
    #[doc = "* The `allocator` will be used to allocate memory to the `info_array` member"]
    #[doc = "* inside of `publishers_info`."]
    #[doc = "* Moreover, every const char * member inside of"]
    #[doc = "* rmw_topic_endpoint_info_t will be assigned a copied value on allocated memory."]
    #[doc = "* \\see rmw_topic_endpoint_info_set_node_name and the likes."]
    #[doc = "* However, it is the responsibility of the caller to"]
    #[doc = "* reclaim any allocated resources to `publishers_info` to avoid leaking memory."]
    #[doc = "* \\see rmw_topic_endpoint_info_array_fini"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] implementation may need to protect the data structure with a lock</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node the handle to the node being used to query the ROS graph"]
    #[doc = "* \\param[in] allocator allocator to be used when allocating space for"]
    #[doc = "* the array inside publishers_info"]
    #[doc = "* \\param[in] topic_name the name of the topic in question"]
    #[doc = "* \\param[in] no_mangle if `true`, `topic_name` needs to be a valid middleware topic name,"]
    #[doc = "* otherwise it should be a valid ROS topic name"]
    #[doc = "* \\param[out] publishers_info a struct representing a list of publisher information"]
    #[doc = "* \\return #RCL_RET_OK if the query was successful, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID if the node is invalid, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if memory allocation fails, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_get_publishers_info_by_topic(
        node: *const rcl_node_t,
        allocator: *mut rcutils_allocator_t,
        topic_name: *const ::std::os::raw::c_char,
        no_mangle: bool,
        publishers_info: *mut rcl_topic_endpoint_info_array_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a list of all subscriptions to a topic."]
    #[doc = "* *"]
    #[doc = "* The `node` parameter must point to a valid node."]
    #[doc = "* "]
    #[doc = "* The `topic_name` parameter must not be `NULL`."]
    #[doc = "* "]
    #[doc = "* When the `no_mangle` parameter is `true`, the provided `topic_name` should be a valid topic name"]
    #[doc = "* for the middleware (useful when combining ROS with native middleware (e.g. DDS) apps)."]
    #[doc = "* When the `no_mangle` parameter is `false`, the provided `topic_name` should follow"]
    #[doc = "* ROS topic name conventions."]
    #[doc = "* In either case, the topic name should always be fully qualified."]
    #[doc = "* "]
    #[doc = "* Each element in the `subscriptions_info` array will contain the node name, node namespace,"]
    #[doc = "* topic type, gid and the qos profile of the subscription."]
    #[doc = "* It is the responsibility of the caller to ensure that `subscriptions_info` parameter points"]
    #[doc = "* to a valid struct of type rcl_topic_endpoint_info_array_t."]
    #[doc = "* The `count` field inside the struct must be set to 0 and the `info_array` field inside"]
    #[doc = "* the struct must be set to null."]
    #[doc = "* \\see rmw_get_zero_initialized_topic_endpoint_info_array"]
    #[doc = "* "]
    #[doc = "* The `allocator` will be used to allocate memory to the `info_array` member"]
    #[doc = "* inside of `subscriptions_info`."]
    #[doc = "* Moreover, every const char * member inside of"]
    #[doc = "* rmw_topic_endpoint_info_t will be assigned a copied value on allocated memory."]
    #[doc = "* \\see rmw_topic_endpoint_info_set_node_name and the likes."]
    #[doc = "* However, it is the responsibility of the caller to"]
    #[doc = "* reclaim any allocated resources to `subscriptions_info` to avoid leaking memory."]
    #[doc = "* \\see rmw_topic_endpoint_info_array_fini"]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] implementation may need to protect the data structure with a lock</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node the handle to the node being used to query the ROS graph"]
    #[doc = "* \\param[in] allocator allocator to be used when allocating space for"]
    #[doc = "* the array inside publishers_info"]
    #[doc = "* \\param[in] topic_name the name of the topic in question"]
    #[doc = "* \\param[in] no_mangle if `true`, `topic_name` needs to be a valid middleware topic name,"]
    #[doc = "* otherwise it should be a valid ROS topic name"]
    #[doc = "* \\param[out] subscriptions_info a struct representing a list of subscriptions information"]
    #[doc = "* \\return #RCL_RET_OK if the query was successful, or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID if the node is invalid, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_BAD_ALLOC if memory allocation fails, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_get_subscriptions_info_by_topic(
        node: *const rcl_node_t,
        allocator: *mut rcutils_allocator_t,
        topic_name: *const ::std::os::raw::c_char,
        no_mangle: bool,
        subscriptions_info: *mut rcl_topic_endpoint_info_array_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Check if a service server is available for the given service client."]
    #[doc = "* *"]
    #[doc = "* This function will return true for `is_available` if there is a service server"]
    #[doc = "* available for the given client."]
    #[doc = "* "]
    #[doc = "* The `node` parameter must point to a valid node."]
    #[doc = "* "]
    #[doc = "* The `client` parameter must point to a valid client."]
    #[doc = "* "]
    #[doc = "* The given client and node must match, i.e. the client must have been created"]
    #[doc = "* using the given node."]
    #[doc = "* "]
    #[doc = "* The `is_available` parameter must not be `NULL`, and must point a bool variable."]
    #[doc = "* The result of the check will be stored in the `is_available` parameter."]
    #[doc = "* "]
    #[doc = "* In the event that error handling needs to allocate memory, this function"]
    #[doc = "* will try to use the node's allocator."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] implementation may need to protect the data structure with a lock</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node the handle to the node being used to query the ROS graph"]
    #[doc = "* \\param[in] client the handle to the service client being queried"]
    #[doc = "* \\param[out] is_available set to true if there is a service server available, else false"]
    #[doc = "* \\return #RCL_RET_OK if the check was made successfully (regardless of the service readiness), or"]
    #[doc = "* \\return #RCL_RET_NODE_INVALID if the node is invalid, or"]
    #[doc = "* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or"]
    #[doc = "* \\return #RCL_RET_ERROR if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_service_server_is_available(
        node: *const rcl_node_t,
        client: *const rcl_client_t,
        is_available: *mut bool,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get a list of action names and types for action clients associated with a node."]
    #[doc = "* *"]
    #[doc = "* The `node` parameter must point to a valid node."]
    #[doc = "* "]
    #[doc = "* The `action_names_and_types` parameter must be allocated and zero initialized."]
    #[doc = "* This function allocates memory for the returned list of names and types and so it is the"]
    #[doc = "* callers responsibility to pass `action_names_and_types` to rcl_names_and_types_fini()"]
    #[doc = "* when it is no longer needed."]
    #[doc = "* Failing to do so will result in leaked memory."]
    #[doc = "* "]
    #[doc = "* The returned names are not automatically remapped by this function."]
    #[doc = "* Attempting to create action clients or action servers with names returned by this function may"]
    #[doc = "* not result in the desired action name depending on the remap rules in use."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] implementation may need to protect the data structure with a lock</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node the handle to the node being used to query the ROS graph"]
    #[doc = "* \\param[in] allocator allocator for allocating space for strings"]
    #[doc = "* \\param[in] node_name the node name of the actions to return"]
    #[doc = "* \\param[in] node_namespace the node namespace of the actions to return"]
    #[doc = "* \\param[out] action_names_and_types list of action names and their types"]
    #[doc = "* \\return `RCL_RET_OK` if the query was successful, or"]
    #[doc = "* \\return `RCL_RET_NODE_INVALID` if the node is invalid, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_get_client_names_and_types_by_node(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        node_name: *const ::std::os::raw::c_char,
        node_namespace: *const ::std::os::raw::c_char,
        action_names_and_types: *mut rcl_names_and_types_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get a list of action names and types for action servers associated with a node."]
    #[doc = "* *"]
    #[doc = "* This function returns a list of action names and types for action servers associated with"]
    #[doc = "* the provided node name."]
    #[doc = "* "]
    #[doc = "* The `node` parameter must point to a valid node."]
    #[doc = "* "]
    #[doc = "* The `action_names_and_types` parameter must be allocated and zero initialized."]
    #[doc = "* This function allocates memory for the returned list of names and types and so it is the"]
    #[doc = "* callers responsibility to pass `action_names_and_types` to rcl_names_and_types_fini()"]
    #[doc = "* when it is no longer needed."]
    #[doc = "* Failing to do so will result in leaked memory."]
    #[doc = "* "]
    #[doc = "* The returned names are not automatically remapped by this function."]
    #[doc = "* Attempting to create action clients or action servers with names returned by this function may"]
    #[doc = "* not result in the desired action name depending on the remap rules in use."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] implementation may need to protect the data structure with a lock</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node the handle to the node being used to query the ROS graph"]
    #[doc = "* \\param[in] allocator allocator for allocating space for strings"]
    #[doc = "* \\param[in] node_name the node name of the actions to return"]
    #[doc = "* \\param[in] node_namespace the node namespace of the actions to return"]
    #[doc = "* \\param[out] action_names_and_types list of action names and their types"]
    #[doc = "* \\return `RCL_RET_OK` if the query was successful, or"]
    #[doc = "* \\return `RCL_RET_NODE_INVALID` if the node is invalid, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_get_server_names_and_types_by_node(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        node_name: *const ::std::os::raw::c_char,
        node_namespace: *const ::std::os::raw::c_char,
        action_names_and_types: *mut rcl_names_and_types_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a list of action names and their types."]
    #[doc = "* *"]
    #[doc = "* This function returns a list of action names and types in the ROS graph."]
    #[doc = "* "]
    #[doc = "* The `node` parameter must point to a valid node."]
    #[doc = "* "]
    #[doc = "* The `action_names_and_types` parameter must be allocated and zero initialized."]
    #[doc = "* This function allocates memory for the returned list of names and types and so it is the"]
    #[doc = "* callers responsibility to pass `action_names_and_types` to rcl_names_and_types_fini()"]
    #[doc = "* when it is no longer needed."]
    #[doc = "* Failing to do so will result in leaked memory."]
    #[doc = "* "]
    #[doc = "* The returned names are not automatically remapped by this function."]
    #[doc = "* Attempting to create action clients or action servers with names returned by this function may"]
    #[doc = "* not result in the desired action name depending on the remap rules in use."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Maybe [1]"]
    #[doc = "* <i>[1] implementation may need to protect the data structure with a lock</i>"]
    #[doc = "* "]
    #[doc = "* \\param[in] node the handle to the node being used to query the ROS graph"]
    #[doc = "* \\param[in] allocator allocator for allocating space for strings"]
    #[doc = "* \\param[out] action_names_and_types list of action names and types"]
    #[doc = "* \\return `RCL_RET_OK` if the query was successful, or"]
    #[doc = "* \\return `RCL_RET_NODE_INVALID` if the node is invalid, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_get_names_and_types(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        action_names_and_types: *mut rcl_names_and_types_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Add a rcl_action_client_t to a wait set."]
    #[doc = "* *"]
    #[doc = "* This function will add the underlying service clients and subscribers to the wait set."]
    #[doc = "* "]
    #[doc = "* This function behaves similar to adding subscriptions to the wait set, but will add"]
    #[doc = "* five entities:"]
    #[doc = "* "]
    #[doc = "* - Three service clients"]
    #[doc = "* - Two subscriptions"]
    #[doc = "* "]
    #[doc = "* \\see rcl_wait_set_add_subscription"]
    #[doc = "* "]
    #[doc = "* If this function fails for any reason, `client_index` and `subscription_index` are not set."]
    #[doc = "* It is also possible the provided wait set is left in an inconsistent state (e.g. some"]
    #[doc = "* of the clients and subscriptions were added to the wait set, but not all)."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] wait_set struct where action client service client and subscription"]
    #[doc = "* are to be stored"]
    #[doc = "* \\param[in] action_client the action client to be added to the wait set"]
    #[doc = "* \\param[out] client_index the starting index in the wait set's client container where"]
    #[doc = "* the action clients underlying service clients were added. Optionally, set to `NULL`"]
    #[doc = "* if ignored."]
    #[doc = "* \\param[out] subscription_index the starting index in the wait set's subscription container"]
    #[doc = "* where the action clients underlying subscriptions were added. Optionally, set to `NULL`"]
    #[doc = "* if ignored."]
    #[doc = "* \\return `RCL_RET_OK` if added successfully, or"]
    #[doc = "* \\return `RCL_RET_WAIT_SET_INVALID` if the wait set is zero initialized, or"]
    #[doc = "* \\return `RCL_RET_WAIT_SET_FULL` if the subscription set is full, or"]
    #[doc = "* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action client is invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_wait_set_add_action_client(
        wait_set: *mut rcl_wait_set_t,
        action_client: *const rcl_action_client_t,
        client_index: *mut size_t,
        subscription_index: *mut size_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Add a rcl_action_server_t to a wait set."]
    #[doc = "* *"]
    #[doc = "* This function will add the underlying services to the wait set."]
    #[doc = "* "]
    #[doc = "* This function behaves similar to adding services to the wait set, but will add"]
    #[doc = "* three services."]
    #[doc = "* "]
    #[doc = "* \\see rcl_wait_set_add_service"]
    #[doc = "* "]
    #[doc = "* * If this function fails for any reason, `service_index` is not set."]
    #[doc = "* It is also possible the provided wait set is left in an inconsistent state (e.g. some"]
    #[doc = "* of the clients and subscribers were added to the wait set, but not all)."]
    #[doc = ""]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | Yes"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[inout] wait_set struct where action server services are to be stored"]
    #[doc = "* \\param[in] action_server the action server to be added to the wait set"]
    #[doc = "* \\param[out] service_index the starting index in the wait set's service container where"]
    #[doc = "* the action servers underlying services were added. Optionally, set to `NULL`"]
    #[doc = "* if ignored."]
    #[doc = "* \\return `RCL_RET_OK` if added successfully, or"]
    #[doc = "* \\return `RCL_RET_WAIT_SET_INVALID` if the wait set is zero initialized, or"]
    #[doc = "* \\return `RCL_RET_WAIT_SET_FULL` if the subscription set is full, or"]
    #[doc = "* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_wait_set_add_action_server(
        wait_set: *mut rcl_wait_set_t,
        action_server: *const rcl_action_server_t,
        service_index: *mut size_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the number of wait set entities associated with a rcl_action_client_t."]
    #[doc = "* *"]
    #[doc = "* Returns the number of entities that are added to the wait set if"]
    #[doc = "* rcl_action_wait_set_add_action_client() is called."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_client an action client to query"]
    #[doc = "* \\param[out] num_subscriptions the number of subscriptions added when the action client"]
    #[doc = "* is added to the wait set"]
    #[doc = "* \\param[out] num_guard_conditions the number of guard conditions added when the action client"]
    #[doc = "* is added to the wait set"]
    #[doc = "* \\param[out] num_timers the number of timers added when the action client"]
    #[doc = "* is added to the wait set"]
    #[doc = "* \\param[out] num_clients the number of clients added when the action client"]
    #[doc = "* is added to the wait set"]
    #[doc = "* \\param[out] num_services the number of services added when the action client"]
    #[doc = "* is added to the wait set"]
    #[doc = "* \\return `RCL_RET_OK` if call is successful, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action client is invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_client_wait_set_get_num_entities(
        action_client: *const rcl_action_client_t,
        num_subscriptions: *mut size_t,
        num_guard_conditions: *mut size_t,
        num_timers: *mut size_t,
        num_clients: *mut size_t,
        num_services: *mut size_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the number of wait set entities associated with a rcl_action_server_t."]
    #[doc = "* *"]
    #[doc = "* Returns the number of entities that are added to the wait set if"]
    #[doc = "* rcl_action_wait_set_add_action_server() is called."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | Yes"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] action_server an action server to query"]
    #[doc = "* \\param[out] num_subscriptions the number of subscriptions added when the action server"]
    #[doc = "* is added to the wait set"]
    #[doc = "* \\param[out] num_guard_conditions the number of guard conditions added when the action server"]
    #[doc = "* is added to the wait set"]
    #[doc = "* \\param[out] num_timers the number of timers added when the action server"]
    #[doc = "* is added to the wait set"]
    #[doc = "* \\param[out] num_clients the number of clients added when the action server"]
    #[doc = "* is added to the wait set"]
    #[doc = "* \\param[out] num_services the number of services added when the action server"]
    #[doc = "* is added to the wait set"]
    #[doc = "* \\return `RCL_RET_OK` if call is successful, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_server_wait_set_get_num_entities(
        action_server: *const rcl_action_server_t,
        num_subscriptions: *mut size_t,
        num_guard_conditions: *mut size_t,
        num_timers: *mut size_t,
        num_clients: *mut size_t,
        num_services: *mut size_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the wait set entities that are ready for a rcl_action_client_t."]
    #[doc = "* *"]
    #[doc = "* The caller can use this function to determine the relevant action client functions"]
    #[doc = "* to call: rcl_action_take_feedback(), rcl_action_take_status(),"]
    #[doc = "* rcl_action_take_goal_response(), rcl_action_take_cancel_response(), or"]
    #[doc = "* rcl_action_take_result_response()."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] wait_set struct where action server services are to be stored"]
    #[doc = "* \\param[in] action_client an action client to query"]
    #[doc = "* \\param[out] is_feedback_ready `true` if there is a feedback message ready to take,"]
    #[doc = "* `false` otherwise"]
    #[doc = "* \\param[out] is_status_ready `true` if there is a status message ready to take,"]
    #[doc = "* `false` otherwise"]
    #[doc = "* \\param[out] is_goal_response_ready `true` if there is a goal response message ready"]
    #[doc = "* to take, `false` otherwise"]
    #[doc = "* \\param[out] is_cancel_response_ready `true` if there is a cancel response message ready"]
    #[doc = "* to take, `false` otherwise"]
    #[doc = "* \\param[out] is_result_response_ready `true` if there is a result response message ready"]
    #[doc = "* to take, `false` otherwise"]
    #[doc = "* \\return `RCL_RET_OK` if call is successful, or"]
    #[doc = "* \\return `RCL_RET_WAIT_SET_INVALID` if the wait set is invalid, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action client is invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_client_wait_set_get_entities_ready(
        wait_set: *const rcl_wait_set_t,
        action_client: *const rcl_action_client_t,
        is_feedback_ready: *mut bool,
        is_status_ready: *mut bool,
        is_goal_response_ready: *mut bool,
        is_cancel_response_ready: *mut bool,
        is_result_response_ready: *mut bool,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the wait set entities that are ready for a rcl_action_server_t."]
    #[doc = "* *"]
    #[doc = "* The caller can use this function to determine the relevant action server functions"]
    #[doc = "* to call: rcl_action_take_goal_request(), rcl_action_take_cancel_request(), or"]
    #[doc = "* rcl_action_take_result_request()."]
    #[doc = "* "]
    #[doc = "* <hr>"]
    #[doc = "* Attribute          | Adherence"]
    #[doc = "* ------------------ | -------------"]
    #[doc = "* Allocates Memory   | No"]
    #[doc = "* Thread-Safe        | No"]
    #[doc = "* Uses Atomics       | No"]
    #[doc = "* Lock-Free          | Yes"]
    #[doc = "* "]
    #[doc = "* \\param[in] wait_set struct where action server services are to be stored"]
    #[doc = "* \\param[in] action_server an action server to query"]
    #[doc = "* \\param[out] is_goal_request_ready `true` if there is a goal request message ready"]
    #[doc = "* to take, `false` otherwise"]
    #[doc = "* \\param[out] is_cancel_request_ready `true` if there is a cancel request message ready"]
    #[doc = "* to take, `false` otherwise"]
    #[doc = "* \\param[out] is_result_request_ready `true` if there is a result request message ready"]
    #[doc = "* to take, `false` otherwise"]
    #[doc = "* \\param[out] is_goal_expired `true` if there is a goal that expired, `false` otherwise"]
    #[doc = "* \\return `RCL_RET_OK` if call is successful, or"]
    #[doc = "* \\return `RCL_RET_WAIT_SET_INVALID` if the wait set is invalid, or"]
    #[doc = "* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or"]
    #[doc = "* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action server is invalid, or"]
    #[doc = "* \\return `RCL_RET_ERROR` if an unspecified error occurs."]
    #[doc = "* /"]
    pub fn rcl_action_server_wait_set_get_entities_ready(
        wait_set: *const rcl_wait_set_t,
        action_server: *const rcl_action_server_t,
        is_goal_request_ready: *mut bool,
        is_cancel_request_ready: *mut bool,
        is_result_request_ready: *mut bool,
        is_goal_expired: *mut bool,
    ) -> rcl_ret_t;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    fn test_field_gp_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(gp_offset)
            )
        );
    }
    test_field_gp_offset();
    fn test_field_fp_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(fp_offset)
            )
        );
    }
    test_field_fp_offset();
    fn test_field_overflow_arg_area() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(overflow_arg_area)
            )
        );
    }
    test_field_overflow_arg_area();
    fn test_field_reg_save_area() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(reg_save_area)
            )
        );
    }
    test_field_reg_save_area();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
