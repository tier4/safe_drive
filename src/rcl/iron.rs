/* automatically generated by rust-bindgen 0.69.4 */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const RCUTILS_HAS_NONNULL: u32 = 1;
pub const RCUTILS_RET_OK: u32 = 0;
pub const RCUTILS_RET_WARN: u32 = 1;
pub const RCUTILS_RET_ERROR: u32 = 2;
pub const RCUTILS_RET_BAD_ALLOC: u32 = 10;
pub const RCUTILS_RET_INVALID_ARGUMENT: u32 = 11;
pub const RCUTILS_RET_NOT_ENOUGH_SPACE: u32 = 12;
pub const RCUTILS_RET_NOT_INITIALIZED: u32 = 13;
pub const RCUTILS_RET_NOT_FOUND: u32 = 14;
pub const RCUTILS_RET_STRING_MAP_ALREADY_INIT: u32 = 30;
pub const RCUTILS_RET_STRING_MAP_INVALID: u32 = 31;
pub const RCUTILS_RET_STRING_KEY_NOT_FOUND: u32 = 32;
pub const RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID: u32 = 40;
pub const RCUTILS_RET_LOGGING_SEVERITY_STRING_INVALID: u32 = 41;
pub const RCUTILS_RET_HASH_MAP_NO_MORE_ENTRIES: u32 = 50;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const RMW_RET_OK: u32 = 0;
pub const RMW_RET_ERROR: u32 = 1;
pub const RMW_RET_TIMEOUT: u32 = 2;
pub const RMW_RET_UNSUPPORTED: u32 = 3;
pub const RMW_RET_BAD_ALLOC: u32 = 10;
pub const RMW_RET_INVALID_ARGUMENT: u32 = 11;
pub const RMW_RET_INCORRECT_RMW_IMPLEMENTATION: u32 = 12;
pub const RMW_RET_NODE_NAME_NON_EXISTENT: u32 = 203;
pub const RMW_DISCOVERY_OPTIONS_STATIC_PEERS_MAX_LENGTH: u32 = 256;
pub const RMW_DEFAULT_DOMAIN_ID: i32 = -1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const _ASSERT_H: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const RCUTILS_FAULT_INJECTION_NEVER_FAIL: i32 = -1;
pub const RCUTILS_FAULT_INJECTION_FAIL_NOW: u32 = 0;
pub const RCUTILS_ERROR_STATE_LINE_NUMBER_STR_MAX_LENGTH: u32 = 20;
pub const RCUTILS_ERROR_FORMATTING_CHARACTERS: u32 = 6;
pub const RCUTILS_ERROR_MESSAGE_MAX_LENGTH: u32 = 1024;
pub const RCUTILS_ERROR_STATE_MESSAGE_MAX_LENGTH: u32 = 768;
pub const RCUTILS_ERROR_STATE_FILE_MAX_LENGTH: u32 = 229;
pub const RCUTILS_LOGGING_SEPARATOR_STRING: &[u8; 2] = b".\0";
pub const RMW_GID_STORAGE_SIZE: u32 = 16;
pub const RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE_DEPRECATED_MSG : & [u8 ; 145] = b"RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE is deprecated. Use RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC if manually asserted liveliness is needed.\0" ;
pub const RCL_RET_OK: u32 = 0;
pub const RCL_RET_ERROR: u32 = 1;
pub const RCL_RET_TIMEOUT: u32 = 2;
pub const RCL_RET_BAD_ALLOC: u32 = 10;
pub const RCL_RET_INVALID_ARGUMENT: u32 = 11;
pub const RCL_RET_UNSUPPORTED: u32 = 3;
pub const RCL_RET_ALREADY_INIT: u32 = 100;
pub const RCL_RET_NOT_INIT: u32 = 101;
pub const RCL_RET_MISMATCHED_RMW_ID: u32 = 102;
pub const RCL_RET_TOPIC_NAME_INVALID: u32 = 103;
pub const RCL_RET_SERVICE_NAME_INVALID: u32 = 104;
pub const RCL_RET_UNKNOWN_SUBSTITUTION: u32 = 105;
pub const RCL_RET_ALREADY_SHUTDOWN: u32 = 106;
pub const RCL_RET_NODE_INVALID: u32 = 200;
pub const RCL_RET_NODE_INVALID_NAME: u32 = 201;
pub const RCL_RET_NODE_INVALID_NAMESPACE: u32 = 202;
pub const RCL_RET_NODE_NAME_NON_EXISTENT: u32 = 203;
pub const RCL_RET_PUBLISHER_INVALID: u32 = 300;
pub const RCL_RET_SUBSCRIPTION_INVALID: u32 = 400;
pub const RCL_RET_SUBSCRIPTION_TAKE_FAILED: u32 = 401;
pub const RCL_RET_CLIENT_INVALID: u32 = 500;
pub const RCL_RET_CLIENT_TAKE_FAILED: u32 = 501;
pub const RCL_RET_SERVICE_INVALID: u32 = 600;
pub const RCL_RET_SERVICE_TAKE_FAILED: u32 = 601;
pub const RCL_RET_TIMER_INVALID: u32 = 800;
pub const RCL_RET_TIMER_CANCELED: u32 = 801;
pub const RCL_RET_WAIT_SET_INVALID: u32 = 900;
pub const RCL_RET_WAIT_SET_EMPTY: u32 = 901;
pub const RCL_RET_WAIT_SET_FULL: u32 = 902;
pub const RCL_RET_INVALID_REMAP_RULE: u32 = 1001;
pub const RCL_RET_WRONG_LEXEME: u32 = 1002;
pub const RCL_RET_INVALID_ROS_ARGS: u32 = 1003;
pub const RCL_RET_INVALID_PARAM_RULE: u32 = 1010;
pub const RCL_RET_INVALID_LOG_LEVEL_RULE: u32 = 1020;
pub const RCL_RET_EVENT_INVALID: u32 = 2000;
pub const RCL_RET_EVENT_TAKE_FAILED: u32 = 2001;
pub const RCL_RET_LIFECYCLE_STATE_REGISTERED: u32 = 3000;
pub const RCL_RET_LIFECYCLE_STATE_NOT_REGISTERED: u32 = 3001;
pub const RCL_ROS_ARGS_FLAG: &[u8; 11] = b"--ros-args\0";
pub const RCL_ROS_ARGS_EXPLICIT_END_TOKEN: &[u8; 3] = b"--\0";
pub const RCL_PARAM_FLAG: &[u8; 8] = b"--param\0";
pub const RCL_SHORT_PARAM_FLAG: &[u8; 3] = b"-p\0";
pub const RCL_PARAM_FILE_FLAG: &[u8; 14] = b"--params-file\0";
pub const RCL_REMAP_FLAG: &[u8; 8] = b"--remap\0";
pub const RCL_SHORT_REMAP_FLAG: &[u8; 3] = b"-r\0";
pub const RCL_ENCLAVE_FLAG: &[u8; 10] = b"--enclave\0";
pub const RCL_SHORT_ENCLAVE_FLAG: &[u8; 3] = b"-e\0";
pub const RCL_LOG_LEVEL_FLAG: &[u8; 12] = b"--log-level\0";
pub const RCL_EXTERNAL_LOG_CONFIG_FLAG: &[u8; 18] = b"--log-config-file\0";
pub const RCL_LOG_STDOUT_FLAG_SUFFIX: &[u8; 12] = b"stdout-logs\0";
pub const RCL_LOG_ROSOUT_FLAG_SUFFIX: &[u8; 12] = b"rosout-logs\0";
pub const RCL_LOG_EXT_LIB_FLAG_SUFFIX: &[u8; 18] = b"external-lib-logs\0";
pub const __alignas_is_defined: u32 = 1;
pub const __alignof_is_defined: u32 = 1;
pub const RCL_DEFAULT_DOMAIN_ID: i32 = -1;
pub const RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID: i32 = -1;
pub const RCUTILS_SHA256_BLOCK_SIZE: u32 = 32;
pub const ROSIDL_TYPE_HASH_VERSION_UNSET: u32 = 0;
pub const ROSIDL_TYPE_HASH_SIZE: u32 = 32;
pub const _UCHAR_H: u32 = 1;
pub const __mbstate_t_defined: u32 = 1;
pub const ROSIDL_DYNAMIC_TYPESUPPORT_SEQUENCE_TYPE_DELIMITER: u32 = 48;
pub const ROSIDL_DYNAMIC_TYPESUPPORT_ARRAY_OFFSET: u32 = 48;
pub const ROSIDL_DYNAMIC_TYPESUPPORT_UNBOUNDED_SEQUENCE_OFFSET: u32 = 96;
pub const ROSIDL_DYNAMIC_TYPESUPPORT_BOUNDED_SEQUENCE_OFFSET: u32 = 144;
pub const RCL_SERVICE_INTROSPECTION_TOPIC_POSTFIX: &[u8; 16] = b"/_service_event\0";
pub const RCL_RET_ACTION_NAME_INVALID: u32 = 2000;
pub const RCL_RET_ACTION_GOAL_ACCEPTED: u32 = 2100;
pub const RCL_RET_ACTION_GOAL_REJECTED: u32 = 2101;
pub const RCL_RET_ACTION_CLIENT_INVALID: u32 = 2102;
pub const RCL_RET_ACTION_CLIENT_TAKE_FAILED: u32 = 2103;
pub const RCL_RET_ACTION_SERVER_INVALID: u32 = 2200;
pub const RCL_RET_ACTION_SERVER_TAKE_FAILED: u32 = 2201;
pub const RCL_RET_ACTION_GOAL_HANDLE_INVALID: u32 = 2300;
pub const RCL_RET_ACTION_GOAL_EVENT_INVALID: u32 = 2301;
pub const UUID_SIZE: u32 = 16;
pub const GOAL_STATE_NUM_STATES: u32 = 7;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[doc = " The type that holds a return value for an rcutils operation."]
pub type rcutils_ret_t = ::std::os::raw::c_int;
#[doc = " Encapsulation of an allocator.\n**\n* The default allocator uses malloc(), free(), calloc(), and realloc().\n* It can be obtained using rcutils_get_default_allocator().\n*\n* The allocator should be trivially copyable.\n* Meaning that the struct should continue to work after being assignment\n* copied into a new struct.\n* Specifically the object pointed to by the state pointer should remain valid\n* until all uses of the allocator have been made.\n* Particular care should be taken when giving an allocator to functions like\n* rcutils_*_init() where it is stored within another object and used later.\n* Developers should note that, while the fields of a const-qualified allocator\n* struct cannot be modified, the state of the allocator can be modified.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_allocator_s {
    #[doc = " Allocate memory, given a size and the `state` pointer.\n** An error should be indicated by returning `NULL`. */"]
    pub allocate: ::std::option::Option<
        unsafe extern "C" fn(
            size: usize,
            state: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Deallocate previously allocated memory, mimicking free().\n** Also takes the `state` pointer. */"]
    pub deallocate: ::std::option::Option<
        unsafe extern "C" fn(
            pointer: *mut ::std::os::raw::c_void,
            state: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Reallocate if possible, otherwise it deallocates and allocates.\n**\n* Also takes the `state` pointer.\n*\n* If unsupported then do deallocate and then allocate.\n* This should behave as realloc() does, as opposed to posix's\n* [reallocf](https://linux.die.net/man/3/reallocf), i.e. the memory given\n* by pointer will not be free'd automatically if realloc() fails.\n* For reallocf-like behavior use rcutils_reallocf().\n* This function must be able to take an input pointer of `NULL` and succeed.\n*/"]
    pub reallocate: ::std::option::Option<
        unsafe extern "C" fn(
            pointer: *mut ::std::os::raw::c_void,
            size: usize,
            state: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Allocate memory with all elements set to zero, given a number of elements and their size.\n** An error should be indicated by returning `NULL`. */"]
    pub zero_allocate: ::std::option::Option<
        unsafe extern "C" fn(
            number_of_elements: usize,
            size_of_element: usize,
            state: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Implementation defined state storage.\n**\n* This is passed as the final parameter to other allocator functions.\n* Note that the contents of the state can be modified even in const-qualified\n* allocator objects.\n*/"]
    pub state: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rcutils_allocator_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcutils_allocator_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcutils_allocator_s>(),
        40usize,
        concat!("Size of: ", stringify!(rcutils_allocator_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcutils_allocator_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcutils_allocator_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_allocator_s),
            "::",
            stringify!(allocate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deallocate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_allocator_s),
            "::",
            stringify!(deallocate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reallocate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_allocator_s),
            "::",
            stringify!(reallocate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zero_allocate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_allocator_s),
            "::",
            stringify!(zero_allocate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_allocator_s),
            "::",
            stringify!(state)
        )
    );
}
#[doc = " Encapsulation of an allocator.\n**\n* The default allocator uses malloc(), free(), calloc(), and realloc().\n* It can be obtained using rcutils_get_default_allocator().\n*\n* The allocator should be trivially copyable.\n* Meaning that the struct should continue to work after being assignment\n* copied into a new struct.\n* Specifically the object pointed to by the state pointer should remain valid\n* until all uses of the allocator have been made.\n* Particular care should be taken when giving an allocator to functions like\n* rcutils_*_init() where it is stored within another object and used later.\n* Developers should note that, while the fields of a const-qualified allocator\n* struct cannot be modified, the state of the allocator can be modified.\n*/"]
pub type rcutils_allocator_t = rcutils_allocator_s;
extern "C" {
    #[doc = " Return a zero initialized allocator.\n**\n* Note that this is an invalid allocator and should only be used as a placeholder.\n*/"]
    pub fn rcutils_get_zero_initialized_allocator() -> rcutils_allocator_t;
}
extern "C" {
    #[doc = " Return a properly initialized rcutils_allocator_t with default values.\n**\n* This defaults to:\n*\n* - allocate = wraps malloc()\n* - deallocate = wraps free()\n* - reallocate = wraps realloc()\n* - zero_allocate = wraps calloc()\n* - state = `NULL`\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*/"]
    pub fn rcutils_get_default_allocator() -> rcutils_allocator_t;
}
extern "C" {
    #[doc = " Return true if the given allocator has non-null function pointers.\n**\n* \\param[in] allocator to be checked by the function\n* \\return `true` if the allocator is valid, `false` otherwise.\n*/"]
    pub fn rcutils_allocator_is_valid(allocator: *const rcutils_allocator_t) -> bool;
}
extern "C" {
    #[doc = " Emulate the behavior of [reallocf](https://linux.die.net/man/3/reallocf).\n**\n* This function will return `NULL` if the allocator is `NULL` or has `NULL` for\n* function pointer fields.\n* \\param[inout] pointer to the memory which will be reallocated\n* \\param[in] size in bytes\n* \\param[in] allocator to be used to allocate and deallocate memory\n*/"]
    pub fn rcutils_reallocf(
        pointer: *mut ::std::os::raw::c_void,
        size: usize,
        allocator: *mut rcutils_allocator_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " Encapsulation of an allocator.\n**\n* \\sa rcutils_allocator_t\n*/"]
pub type rcl_allocator_t = rcutils_allocator_t;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " Return code for rmw functions"]
pub type rmw_ret_t = i32;
#[doc = " The discovery range has not been set"]
pub const rmw_automatic_discovery_range_e_RMW_AUTOMATIC_DISCOVERY_RANGE_NOT_SET:
    rmw_automatic_discovery_range_e = 0;
#[doc = " Force discovery off"]
pub const rmw_automatic_discovery_range_e_RMW_AUTOMATIC_DISCOVERY_RANGE_OFF:
    rmw_automatic_discovery_range_e = 1;
#[doc = " Allows discovering nodes on the same host"]
pub const rmw_automatic_discovery_range_e_RMW_AUTOMATIC_DISCOVERY_RANGE_LOCALHOST:
    rmw_automatic_discovery_range_e = 2;
#[doc = " Allows discovering nodes on the same subnet"]
pub const rmw_automatic_discovery_range_e_RMW_AUTOMATIC_DISCOVERY_RANGE_SUBNET:
    rmw_automatic_discovery_range_e = 3;
#[doc = " Use discovery settings configured directly with the middleware"]
pub const rmw_automatic_discovery_range_e_RMW_AUTOMATIC_DISCOVERY_RANGE_SYSTEM_DEFAULT:
    rmw_automatic_discovery_range_e = 4;
#[doc = " Used to control the range that nodes will be discovered"]
pub type rmw_automatic_discovery_range_e = ::std::os::raw::c_uint;
#[doc = " Used to control the range that nodes will be discovered"]
pub use self::rmw_automatic_discovery_range_e as rmw_automatic_discovery_range_t;
#[doc = " Struct to typedef some of the peer addresses"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_peer_address_s {
    pub peer_address: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_rmw_peer_address_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_peer_address_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_peer_address_s>(),
        256usize,
        concat!("Size of: ", stringify!(rmw_peer_address_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_peer_address_s>(),
        1usize,
        concat!("Alignment of ", stringify!(rmw_peer_address_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).peer_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_peer_address_s),
            "::",
            stringify!(peer_address)
        )
    );
}
#[doc = " Struct to typedef some of the peer addresses"]
pub type rmw_peer_address_t = rmw_peer_address_s;
#[doc = " Used to specify the options that control how discovery is performed"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_discovery_options_s {
    #[doc = " How far to allow discovering nodes\n**\n* This needs to be set to something other than RMW_AUTOMATIC_DISCOVERY_RANGE_NOT_SET,\n* because that is just a sentinel value to see if this was set, but rmw\n* implementations should error if this is what is given during context init.\n*/"]
    pub automatic_discovery_range: rmw_automatic_discovery_range_t,
    #[doc = " The list of manually-specified peers to perform static discovery with\n**\n* Each peer is specified as a hostname or an IP address (IPv4 and IPv6 are both acceptable), or\n* a subnet, e.g. 192.168.0.0/24.\n*/"]
    pub static_peers: *mut rmw_peer_address_t,
    #[doc = " The number of manually-specified peers"]
    pub static_peers_count: usize,
    #[doc = " The allocator used to allocate static_peers"]
    pub allocator: rcutils_allocator_t,
}
#[test]
fn bindgen_test_layout_rmw_discovery_options_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_discovery_options_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_discovery_options_s>(),
        64usize,
        concat!("Size of: ", stringify!(rmw_discovery_options_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_discovery_options_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_discovery_options_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).automatic_discovery_range) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_discovery_options_s),
            "::",
            stringify!(automatic_discovery_range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).static_peers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_discovery_options_s),
            "::",
            stringify!(static_peers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).static_peers_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_discovery_options_s),
            "::",
            stringify!(static_peers_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_discovery_options_s),
            "::",
            stringify!(allocator)
        )
    );
}
#[doc = " Used to specify the options that control how discovery is performed"]
pub type rmw_discovery_options_t = rmw_discovery_options_s;
extern "C" {
    #[doc = " Return a zero-initialized discovery options structure."]
    pub fn rmw_get_zero_initialized_discovery_options() -> rmw_discovery_options_t;
}
extern "C" {
    #[doc = " Initialize a discovery options structure with a set number of static peers.\n**\n* This function initializes rmw_discovery_options_t with space for a set number of static peers.\n*\n* \\param[in] discovery_options Pointer to a zero initialized option structure to be initialized on\n* success, but left unchanged on failure.\n* \\param[in] size Number of static peers to allocate space for.\n* \\param[in] allocator Allocator to be used to allocate memory.\n* \\returns `RMW_RET_OK` if successful, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `discovery_options` is NULL, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `discovery_options` is not\n*   zero initialized, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `allocator` is invalid,\n*   by rcutils_allocator_is_valid() definition, or\n* \\returns `RMW_BAD_ALLOC` if memory allocation fails, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_discovery_options_init(
        discovery_options: *mut rmw_discovery_options_t,
        size: usize,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Compare two discovery parameter instances for equality.\n**\n* Equality means the automatic_discovery_range values are equal, they have the same\n* static_peers_count value, and each entry in static_peers is evaluated as\n* equal using strncmp.\n*\n* NOTE: If the two parameter structs list the static peers in different orders\n* then this will evaulate as NOT equal.\n*\n* \\param[in] left - The first set of options to compare\n* \\param[in] right - The second set of options to compare\n* \\param[out] result - The result of the calculation.\n*\n* \\return RMW_RET_OK when the input arguments are valid.\n* \\return RMW_RET_INVALID_ARGUMENT will be returned when any input is a nullptr,\n* or if something in either struct was malformed, such as static_peers being\n* a nullptr while static_peers_count is non-zero.\n*/"]
    pub fn rmw_discovery_options_equal(
        left: *const rmw_discovery_options_t,
        right: *const rmw_discovery_options_t,
        result: *mut bool,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Perform a deep copy of the discovery options from src into dst using the\n given allocator.\n**\n* The dst will be left with an owned copy of the static peers array whose\n* string values match the src.\n* If successful, src and dst will evaluate as equal using\n* rmw_discovery_options_equal.\n*\n* \\param[in] src discovery options to be copied.\n* \\param[in] allocator to use.\n* \\param[out] dst Destination options to use.\n* \\return RMW_RET_OK if success.\n* \\return RMW_RET_INVALID_ARGUMENT if either the src, allocator or dst is null, or\n* \\return RMW_RET_INVALID_ARUGMENT if src and dst are the same object.\n* \\return RMW_RET_BAD_ALLOC if allocation fails.\n*/"]
    pub fn rmw_discovery_options_copy(
        src: *const rmw_discovery_options_t,
        allocator: *mut rcutils_allocator_t,
        dst: *mut rmw_discovery_options_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Destructor for rmw_discovery_options_t\n**\n* \\param[in] discovery_options to destroy\n* \\param[in] allocator to be used for destruction.\n* \\return RMW_RET_OK if success.\n* \\return RMW_RET_INVALID_ARGUMENT if allocator is invalid\n* or discovery_options is null.\n*/"]
    pub fn rmw_discovery_options_fini(discovery_options: *mut rmw_discovery_options_t)
        -> rmw_ret_t;
}
#[doc = " Uses ROS_LOCALHOST_ONLY environment variable."]
pub const rmw_localhost_only_e_RMW_LOCALHOST_ONLY_DEFAULT: rmw_localhost_only_e = 0;
#[doc = " Forces using only localhost."]
pub const rmw_localhost_only_e_RMW_LOCALHOST_ONLY_ENABLED: rmw_localhost_only_e = 1;
#[doc = " Forces disabling localhost only."]
pub const rmw_localhost_only_e_RMW_LOCALHOST_ONLY_DISABLED: rmw_localhost_only_e = 2;
#[doc = " Used to specify if the context can only communicate through localhost."]
pub type rmw_localhost_only_e = ::std::os::raw::c_uint;
#[doc = " Used to specify if the context can only communicate through localhost."]
pub use self::rmw_localhost_only_e as rmw_localhost_only_t;
pub const rmw_security_enforcement_policy_e_RMW_SECURITY_ENFORCEMENT_PERMISSIVE:
    rmw_security_enforcement_policy_e = 0;
pub const rmw_security_enforcement_policy_e_RMW_SECURITY_ENFORCEMENT_ENFORCE:
    rmw_security_enforcement_policy_e = 1;
pub type rmw_security_enforcement_policy_e = ::std::os::raw::c_uint;
pub use self::rmw_security_enforcement_policy_e as rmw_security_enforcement_policy_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_security_options_s {
    pub enforce_security: rmw_security_enforcement_policy_t,
    pub security_root_path: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rmw_security_options_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_security_options_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_security_options_s>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_security_options_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_security_options_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_security_options_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enforce_security) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_security_options_s),
            "::",
            stringify!(enforce_security)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).security_root_path) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_security_options_s),
            "::",
            stringify!(security_root_path)
        )
    );
}
pub type rmw_security_options_t = rmw_security_options_s;
extern "C" {
    #[doc = " Get zero initialized security options."]
    pub fn rmw_get_zero_initialized_security_options() -> rmw_security_options_t;
}
extern "C" {
    #[doc = " Get default initialized security options."]
    pub fn rmw_get_default_security_options() -> rmw_security_options_t;
}
extern "C" {
    #[doc = " Copy the given security options.\n**\n* \\param[in] src security options to be copied.\n* \\param[in] allocator allocator used when copying data to the new security options.\n* \\param[out] dst security options to be set.\n* \\returns RMW_RET_BAD_ALLOC, or\n* \\returns RMW_RET_OK\n*/"]
    pub fn rmw_security_options_copy(
        src: *const rmw_security_options_t,
        allocator: *const rcutils_allocator_t,
        dst: *mut rmw_security_options_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Set the security root path for the given security options.\n**\n* The provided `security_root_path` will be copied into allocated memory.\n*\n* \\param[in] security_root_path path to be set.\n* \\param[in] allocator allocator used to allocate the new path.\n* \\param[inout] security_options security options to be set.\n* \\returns RMW_RET_BAD_ALLOC, or\n* \\returns RMW_RET_OK\n*/"]
    pub fn rmw_security_options_set_root_path(
        security_root_path: *const ::std::os::raw::c_char,
        allocator: *const rcutils_allocator_t,
        security_options: *mut rmw_security_options_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Finalize the given security_options.\n**\n* \\param[in] security_options security options to be finalized.\n* \\param[in] allocator allocator used to deallocate the root path.\n* \\returns RMW_RET_ERROR, or\n* \\returns RMW_RET_OK\n*/"]
    pub fn rmw_security_options_fini(
        security_options: *mut rmw_security_options_t,
        allocator: *const rcutils_allocator_t,
    ) -> rmw_ret_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_init_options_impl_s {
    _unused: [u8; 0],
}
#[doc = " Implementation defined options structure used during rmw_init().\n**\n* This should be defined by the rmw implementation.\n*/"]
pub type rmw_init_options_impl_t = rmw_init_options_impl_s;
#[doc = " Options structure used during rmw_init()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_init_options_s {
    #[doc = " Locally (process local) unique ID that represents this init/shutdown cycle.\n**\n* This should be set by the caller of `rmw_init()` to a number that is\n* unique within this process.\n* It is designed to be used with `rcl_init()` and `rcl_get_instance_id()`.\n*/"]
    pub instance_id: u64,
    #[doc = " Implementation identifier, used to ensure two different implementations are not being mixed."]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " ROS domain id"]
    pub domain_id: usize,
    #[doc = " Security options"]
    pub security_options: rmw_security_options_t,
    #[doc = " Enable localhost only"]
    pub localhost_only: rmw_localhost_only_t,
    #[doc = " Configure discovery"]
    pub discovery_options: rmw_discovery_options_t,
    #[doc = " Enclave, name used to find security artifacts in a sros2 keystore."]
    pub enclave: *mut ::std::os::raw::c_char,
    #[doc = " Allocator used during internal allocation of init options, if needed."]
    pub allocator: rcutils_allocator_t,
    #[doc = " Implementation defined init options.\n** May be NULL if there are no implementation defined options. */"]
    pub impl_: *mut rmw_init_options_impl_t,
}
#[test]
fn bindgen_test_layout_rmw_init_options_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_init_options_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_init_options_s>(),
        168usize,
        concat!("Size of: ", stringify!(rmw_init_options_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_init_options_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_init_options_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instance_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_init_options_s),
            "::",
            stringify!(instance_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_init_options_s),
            "::",
            stringify!(implementation_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).domain_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_init_options_s),
            "::",
            stringify!(domain_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).security_options) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_init_options_s),
            "::",
            stringify!(security_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).localhost_only) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_init_options_s),
            "::",
            stringify!(localhost_only)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).discovery_options) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_init_options_s),
            "::",
            stringify!(discovery_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enclave) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_init_options_s),
            "::",
            stringify!(enclave)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_init_options_s),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_init_options_s),
            "::",
            stringify!(impl_)
        )
    );
}
#[doc = " Options structure used during rmw_init()."]
pub type rmw_init_options_t = rmw_init_options_s;
extern "C" {
    #[doc = " Return a zero initialized init options structure."]
    pub fn rmw_get_zero_initialized_init_options() -> rmw_init_options_t;
}
extern "C" {
    #[doc = " Initialize given init options with the default values and implementation specific values.\n**\n* The given allocator is used, if required, during setup of the init options,\n* but is also used during initialization.\n*\n* In either case the given allocator is stored in the returned init options.\n*\n* The `impl` pointer should not be changed manually.\n*\n* \\pre The given init options must be zero initialized.\n*\n* \\post If initialization fails, init options will remain zero initialized.\n*\n* \\remark Giving an already initialized init options will result\n*   in a failure with return code `RMW_RET_INVALID_ARGUMENT`.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | Yes\n* Lock-Free          | Yes\n*\n* This should be defined by the rmw implementation.\n*\n* \\param[inout] init_options object to be setup\n* \\param[in] allocator to be used during setup and during initialization\n* \\return `RMW_RET_OK` if setup is successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RMW_RET_BAD_ALLOC` if allocating memory failed, or\n* \\return `RMW_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rmw_init_options_init(
        init_options: *mut rmw_init_options_t,
        allocator: rcutils_allocator_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Copy the given source init options to the destination init options.\n**\n* The allocator from the source is used for any allocations and stored in the\n* destination.\n*\n* \\pre The source init options must have been initialized\n*   i.e. had `rmw_init_options_init()` called on.\n* \\pre The destination init options must be zero initialized.\n*\n* \\post If copy fails, destination init options will remain zero initialized.\n*\n* \\remark Giving an zero initialized init options as a source will result\n*   in a failure with return code `RMW_RET_INVALID_ARGUMENT`.\n* \\remark Giving an already initialized init options for the destination will result\n*   in a failure with return code `RMW_RET_INVALID_ARGUMENT`.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | Yes\n* Lock-Free          | Yes\n*\n* This should be defined by the rmw implementation.\n*\n* \\param[in] src rcl_init_options_t object to be copied from\n* \\param[out] dst rcl_init_options_t object to be copied into\n* \\return `RMW_RET_OK` if the copy is successful, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation\n*   identifier for src does not match the implementation of this function, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RMW_RET_BAD_ALLOC` if allocating memory failed, or\n* \\return `RMW_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rmw_init_options_copy(
        src: *const rmw_init_options_t,
        dst: *mut rmw_init_options_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Finalize the given init options.\n**\n* This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`\n* or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given init options\n* unchanged.\n* Otherwise, it will proceed despite errors, freeing as much resources as it can and zero\n* initializing the given init options.\n*\n* \\pre The given init options must have been initialized\n*   i.e. had `rmw_init_options_init()` called on.\n*\n* \\remarks If init options are zero initialized,\n*   then `RMW_RET_INVALID_ARGUMENT` is returned.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | Yes\n* Lock-Free          | Yes\n*\n* This should be defined by the rmw implementation.\n*\n* \\param[inout] init_options object to finalized\n* \\return `RMW_RET_OK` if finalization is successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation\n*   identifier does not match the implementation of this function, or\n* \\return `RMW_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rmw_init_options_fini(init_options: *mut rmw_init_options_t) -> rmw_ret_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_context_impl_s {
    _unused: [u8; 0],
}
#[doc = " Implementation defined context structure returned by rmw_init().\n**\n* This should be defined by the rmw implementation.\n*/"]
pub type rmw_context_impl_t = rmw_context_impl_s;
#[doc = " Initialization context structure which is used to store init specific information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_context_s {
    #[doc = " Locally (process local) unique ID that represents this init/shutdown cycle."]
    pub instance_id: u64,
    #[doc = " Implementation identifier, used to ensure two different implementations are not being mixed."]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Options used to initialize the context."]
    pub options: rmw_init_options_t,
    #[doc = " Domain id that is being used."]
    pub actual_domain_id: usize,
    #[doc = " Implementation defined context information.\n** May be NULL if there is no implementation defined context information. */"]
    pub impl_: *mut rmw_context_impl_t,
}
#[test]
fn bindgen_test_layout_rmw_context_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_context_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_context_s>(),
        200usize,
        concat!("Size of: ", stringify!(rmw_context_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_context_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_context_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instance_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_context_s),
            "::",
            stringify!(instance_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_context_s),
            "::",
            stringify!(implementation_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_context_s),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).actual_domain_id) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_context_s),
            "::",
            stringify!(actual_domain_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_context_s),
            "::",
            stringify!(impl_)
        )
    );
}
#[doc = " Initialization context structure which is used to store init specific information."]
pub type rmw_context_t = rmw_context_s;
extern "C" {
    #[doc = " Return a zero initialized context structure."]
    pub fn rmw_get_zero_initialized_context() -> rmw_context_t;
}
extern "C" {
    #[doc = " Initialize the middleware with the given options, and yielding an context.\n**\n* Context is filled with middleware specific data upon success of this function.\n* The context is used when initializing some entities like nodes and\n* guard conditions, and is also required to properly call `rmw_shutdown()`.\n*\n* \\pre The given options must have been initialized\n*   i.e. `rmw_init_options_init()` called on it and\n*   an enclave set.\n* \\pre The given context must be zero initialized.\n*\n* \\post If initialization fails, context will remain zero initialized.\n* \\post `context->actual_domain_id` will be set with the domain id the rmw implementation is using.\n*  This matches `options->domain_id` if it is not RMW_DEFAULT_DOMAIN_ID.\n*  In other case, the value is rmw implementation dependent.\n*\n* \\remarks If options are zero-initialized, then `RMW_RET_INVALID_ARGUMENT` is returned.\n*   If options are initialized but no enclave is provided, then `RMW_RET_INVALID_ARGUMENT`\n*   is returned.\n*   If context has been already initialized (`rmw_init()` was called on it), then\n*   `RMW_RET_INVALID_ARGUMENT` is returned.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* This should be defined by the rmw implementation.\n*\n* \\param[in] options initialization options to be used during initialization\n* \\param[out] context resulting context struct\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation\n*   identifier does not match, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_init(options: *const rmw_init_options_t, context: *mut rmw_context_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Shutdown the middleware for a given context.\n**\n* \\pre The given context must be a valid context which has been initialized with `rmw_init()`.\n*\n* \\remarks If context is zero initialized, then `RMW_RET_INVALID_ARGUMENT` is returned.\n*   If context has been already invalidated (`rmw_shutdown()` was called on it), then\n*   this function is a no-op and `RMW_RET_OK` is returned.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* This should be defined by the rmw implementation.\n*\n* \\param[in] context resulting context struct\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if any argument are invalid, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation\n*   identifier does not match, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_shutdown(context: *mut rmw_context_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Finalize a context.\n**\n* This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`\n* or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given context unchanged.\n* Otherwise, it will proceed despite errors, freeing as much resources as it can and zero\n* initializing the given context.\n*\n* \\pre The context to be finalized must have been previously initialized with\n*   `rmw_init()`, and then later invalidated with `rmw_shutdown()`.\n*\n* \\remarks If context is zero initialized, then `RMW_RET_INVALID_ARGUMENT` is returned.\n*   If context is initialized and valid (`rmw_shutdown()` was not called on it), then\n*   `RMW_RET_INVALID_ARGUMENT` is returned.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | Yes\n* Lock-Free          | Yes [1]\n* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>\n*\n* This should be defined by the rmw implementation.\n*\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation\n*   identifier does not match, or\n* \\return `RMW_RET_ERROR` if an unspecified error occur.\n*/"]
    pub fn rmw_context_fini(context: *mut rmw_context_t) -> rmw_ret_t;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    ) -> !;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Format a string.\n**\n* This function just wraps snprintf() as defined in C11 in a portable way.\n*\n* On Windows this defaults to the _TRUNCATE behavior of _snprintf_s(), but\n* only returns -1 if errno is not 0.\n* Unlike _snprintf_s() which returns -1 when truncation occurs, this function\n* behaves like snprintf() (http://en.cppreference.com/w/cpp/io/c/fprintf):\n*\n* > Number of characters written if successful or negative value if an error\n* > occurred.\n* > If the resulting string gets truncated due to buf_size limit, function\n* > returns the total number of characters (not including the terminating\n* > null-byte) which would have been written, if the limit was not imposed.\n*\n* If `NULL` and `0` are given for buffer and buffer_size respectively, the\n* size of the string that would be generated is returned.\n* Either snprintf() or _vscprintf() is used to calculate this value.\n*\n* \\see snprintf()\n* \\see _snprintf_s()\n* \\return the number of bytes that would have been written given enough space, or\n* \\return a negative number if there is an error, but unlike _snprintf_s(),\n*   -1 is not returned if there is truncation.\n*/"]
    pub fn rcutils_snprintf(
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: usize,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Format a string with va_list for arguments, see rcutils_snprintf()."]
    pub fn rcutils_vsnprintf(
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: usize,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcutils_fault_injection_is_test_complete() -> bool;
}
extern "C" {
    #[doc = " \\brief Atomically set the fault injection counter.\n\n This is typically not the preferred method of interacting directly with the fault injection\n logic, instead use `RCUTILS_FAULT_INJECTION_TEST` instead.\n\n This function may also be used for pausing code inside of a `RCUTILS_FAULT_INJECTION_TEST` with\n something like the following:\n\n RCUTILS_FAULT_INJECTION_TEST({\n     ...  // code to run with fault injection\n     int64_t count = rcutils_fault_injection_get_count();\n     rcutils_fault_injection_set_count(RCUTILS_FAULT_INJECTION_NEVER_FAIL);\n     ...  // code to run without fault injection\n     rcutils_fault_injection_set_count(count);\n     ...  // code to run with fault injection\n });\n\n \\param count The count to set the fault injection counter to. If count is negative, then fault\n injection errors will be disabled. The counter is globally initialized to\n RCUTILS_FAULT_INJECTION_NEVER_FAIL."]
    pub fn rcutils_fault_injection_set_count(count: int_least64_t);
}
extern "C" {
    #[doc = " \\brief Atomically get the fault injection counter value\n\n This function is typically not used directly but instead indirectly inside an\n `RCUTILS_FAULT_INJECTION_TEST`"]
    pub fn rcutils_fault_injection_get_count() -> int_least64_t;
}
extern "C" {
    #[doc = " \\brief Implementation of fault injection decrementer\n\n This is included inside of macros, so it needs to be exported as a public function, but it\n should not be used directly."]
    pub fn _rcutils_fault_injection_maybe_fail() -> int_least64_t;
}
#[doc = " Struct wrapping a fixed-size c string used for returning the formatted error string."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_error_string_s {
    #[doc = " The fixed-size C string used for returning the formatted error string."]
    pub str_: [::std::os::raw::c_char; 1024usize],
}
#[test]
fn bindgen_test_layout_rcutils_error_string_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcutils_error_string_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcutils_error_string_s>(),
        1024usize,
        concat!("Size of: ", stringify!(rcutils_error_string_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcutils_error_string_s>(),
        1usize,
        concat!("Alignment of ", stringify!(rcutils_error_string_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_error_string_s),
            "::",
            stringify!(str_)
        )
    );
}
#[doc = " Struct wrapping a fixed-size c string used for returning the formatted error string."]
pub type rcutils_error_string_t = rcutils_error_string_s;
#[doc = " Struct which encapsulates the error state set by RCUTILS_SET_ERROR_MSG()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_error_state_s {
    #[doc = " User message storage, limited to RCUTILS_ERROR_STATE_MESSAGE_MAX_LENGTH characters."]
    pub message: [::std::os::raw::c_char; 768usize],
    #[doc = " File name, limited to what's left from RCUTILS_ERROR_STATE_MAX_SIZE characters\n after subtracting storage for others."]
    pub file: [::std::os::raw::c_char; 229usize],
    #[doc = " Line number of error."]
    pub line_number: u64,
}
#[test]
fn bindgen_test_layout_rcutils_error_state_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcutils_error_state_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcutils_error_state_s>(),
        1008usize,
        concat!("Size of: ", stringify!(rcutils_error_state_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcutils_error_state_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcutils_error_state_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_error_state_s),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_error_state_s),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_number) as usize - ptr as usize },
        1000usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_error_state_s),
            "::",
            stringify!(line_number)
        )
    );
}
#[doc = " Struct which encapsulates the error state set by RCUTILS_SET_ERROR_MSG()."]
pub type rcutils_error_state_t = rcutils_error_state_s;
extern "C" {
    #[doc = " Forces initialization of thread-local storage if called in a newly created thread.\n**\n* If this function is not called beforehand, then the first time the error\n* state is set or the first time the error message is retrieved, the default\n* allocator will be used to allocate thread-local storage.\n*\n* This function may or may not allocate memory.\n* The system's thread-local storage implementation may need to allocate\n* memory, since it usually has no way of knowing how much storage is needed\n* without knowing how many threads will be created.\n* Most implementations (e.g. C11, C++11, and pthread) do not have ways to\n* specify how this memory is allocated, but if the implementation allows, the\n* given allocator to this function will be used, but is otherwise unused.\n* This only occurs when creating and destroying threads, which can be avoided\n* in the \"steady\" state by reusing pools of threads.\n*\n* It is worth considering that repeated thread creation and destruction will\n* result in repeated memory allocations and could result in memory\n* fragmentation.\n* This is typically avoided anyways by using pools of threads.\n*\n* In case an error is indicated by the return code, no error message will have\n* been set.\n*\n* If called more than once in a thread, or after implicitly initialized by\n* setting the error state, it will still return `RCUTILS_RET_OK`, even\n* if the given allocator is invalid.\n* Essentially this function does nothing if thread-local storage has already\n* been called.\n* If already initialized, the given allocator is ignored, even if it does not\n* match the allocator used originally to initialize the thread-local storage.\n*\n* \\param[in] allocator to be used to allocate and deallocate memory\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if the allocator is invalid, or\n* \\return #RCUTILS_RET_BAD_ALLOC if allocating memory fails, or\n* \\return #RCUTILS_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcutils_initialize_error_handling_thread_local_storage(
        allocator: rcutils_allocator_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Set the error message, as well as the file and line on which it occurred.\n**\n* This is not meant to be used directly, but instead via the\n* RCUTILS_SET_ERROR_MSG(msg) macro.\n*\n* The error_msg parameter is copied into the internal error storage and must\n* be null terminated.\n* The file parameter is copied into the internal error storage and must\n* be null terminated.\n*\n* \\param[in] error_string The error message to set.\n* \\param[in] file The path to the file in which the error occurred.\n* \\param[in] line_number The line number on which the error occurred.\n*/"]
    pub fn rcutils_set_error_state(
        error_string: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line_number: usize,
    );
}
extern "C" {
    #[doc = " Return `true` if the error is set, otherwise `false`."]
    pub fn rcutils_error_is_set() -> bool;
}
extern "C" {
    #[doc = " Return an rcutils_error_state_t which was set with rcutils_set_error_state().\n**\n* The returned pointer will be NULL if no error has been set in this thread.\n*\n* The returned pointer is valid until RCUTILS_SET_ERROR_MSG, rcutils_set_error_state,\n* or rcutils_reset_error are called in the same thread.\n*\n* \\return A pointer to the current error state struct.\n*/"]
    pub fn rcutils_get_error_state() -> *const rcutils_error_state_t;
}
extern "C" {
    #[doc = " Return the error message followed by `, at <file>:<line>` if set, else \"error not set\".\n**\n* This function is \"safe\" because it returns a copy of the current error\n* string or one containing the string \"error not set\" if no error was set.\n* This ensures that the copy is owned by the calling thread and is therefore\n* never invalidated by other error handling calls, and that the C string\n* inside is always valid and null terminated.\n*\n* \\return The current error string, with file and line number, or \"error not set\" if not set.\n*/"]
    pub fn rcutils_get_error_string() -> rcutils_error_string_t;
}
extern "C" {
    #[doc = " Reset the error state by clearing any previously set error state."]
    pub fn rcutils_reset_error();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_array_list_impl_s {
    _unused: [u8; 0],
}
#[doc = " The structure holding the metadata for an array list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_array_list_s {
    #[doc = " A pointer to the PIMPL implementation type."]
    pub impl_: *mut rcutils_array_list_impl_s,
}
#[test]
fn bindgen_test_layout_rcutils_array_list_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcutils_array_list_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcutils_array_list_s>(),
        8usize,
        concat!("Size of: ", stringify!(rcutils_array_list_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcutils_array_list_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcutils_array_list_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_array_list_s),
            "::",
            stringify!(impl_)
        )
    );
}
#[doc = " The structure holding the metadata for an array list."]
pub type rcutils_array_list_t = rcutils_array_list_s;
extern "C" {
    #[doc = " Return an empty array_list struct.\n**\n* This function returns an empty and zero initialized array_list struct.\n* Calling rcutils_array_list_fini() on any non-initialized instance leads\n* to undefined behavior.\n* Every instance of array_list_t has to either be zero_initialized with this\n* function or manually allocated.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* Example:\n*\n* ```c\n* rcutils_array_list_t foo;\n* rcutils_array_list_fini(&foo); // undefined behavior!\n*\n* rcutils_array_list_t bar = rcutils_get_zero_initialized_array_list();\n* rcutils_array_list_fini(&bar); // ok\n* ```\n*/"]
    pub fn rcutils_get_zero_initialized_array_list() -> rcutils_array_list_t;
}
extern "C" {
    #[doc = " Initialize an array list with a given initial capacity.\n**\n* This function will initialize a given, zero initialized, array_list to\n* a given size.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* Example:\n*\n* ```c\n* rcutils_allocator_t allocator = rcutils_get_default_allocator();\n* rcutils_array_list_t array_list = rcutils_get_zero_initialized_array_list();\n* rcutils_ret_t ret = rcutils_array_list_init(&array_list, 2, sizeof(int), &allocator);\n* if (ret != RCUTILS_RET_OK) {\n*   // ... error handling\n* }\n* int data = 42;\n* int out_data = 0;\n* ret = rcutils_array_list_add(&array_list, &data);\n* data++;\n* ret = rcutils_array_list_get(&array_list, 0, &out_data);\n* assert(42 == out_data);\n* ret = rcutils_array_list_fini(&array_list);\n* ```\n*\n* \\param[inout] array_list object to be initialized\n* \\param[in] initial_capacity the initial capacity to allocate in the list\n* \\param[in] data_size the size (in bytes) of the data object being stored in the list\n* \\param[in] allocator to be used to allocate and deallocate memory\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_array_list_init(
        array_list: *mut rcutils_array_list_t,
        initial_capacity: usize,
        data_size: usize,
        allocator: *const rcutils_allocator_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Finalize an array list, reclaiming all resources.\n**\n* This function reclaims any memory owned by the array list.\n*\n* The allocator used to initialize the array list is used to deallocate each\n* entry in the list and the list itself.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] array_list object to be finalized\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_array_list_fini(array_list: *mut rcutils_array_list_t) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Adds an entry to the list\n**\n* This function adds the provided data to the end of the list. A shallow copy of\n* the provided data is made to store in the list instead of just storing\n* the pointer to the provided data.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] array_list to add the data to\n* \\param[in] data a pointer to the data to add to the list\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_array_list_add(
        array_list: *mut rcutils_array_list_t,
        data: *const ::std::os::raw::c_void,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Sets an entry in the list to the provided data\n**\n* This function sets the provided data at the specified index in the list.\n* A shallow copy of the provided data is made to store in the list instead\n* of just storing the pointer to the provided data.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] array_list to add the data to\n* \\param[in] index the position in the list to set the data\n* \\param[in] data a pointer to the data that will be set in the list\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if index out of bounds, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_array_list_set(
        array_list: *mut rcutils_array_list_t,
        index: usize,
        data: *const ::std::os::raw::c_void,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Removes an entry in the list at the provided index\n**\n* This function removes data from the list at the specified index. The capacity\n* of the list will never decrease when entries are removed.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] array_list to add the data to\n* \\param[in] index the index of the item to remove from the list\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if index out of bounds, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_array_list_remove(
        array_list: *mut rcutils_array_list_t,
        index: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Retrieves an entry in the list at the provided index\n**\n* This function retrieves a copy of the data stored in the list at the provided index.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n*\n* \\param[in] array_list to add the data to\n* \\param[in] index the index at which to get the data\n* \\param[out] data a copy of the data stored in the list\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_array_list_get(
        array_list: *const rcutils_array_list_t,
        index: usize,
        data: *mut ::std::os::raw::c_void,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Retrieves the size of the provided array_list\n**\n* This function retrieves the number of items in the provided array list\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n*\n* \\param[in] array_list list to get the size of\n* \\param[out] size The number of items currently stored in the list\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_array_list_get_size(
        array_list: *const rcutils_array_list_t,
        size: *mut usize,
    ) -> rcutils_ret_t;
}
#[doc = " The structure holding the metadata for a char array."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_char_array_s {
    #[doc = " A pointer to the allocated memory for this char array."]
    pub buffer: *mut ::std::os::raw::c_char,
    #[doc = " if this is true, we may safely free/realloc the buffer as needed;\n otherwise we will leave the buffer alone and alloc new memory if\n more space is needed"]
    pub owns_buffer: bool,
    #[doc = " The length of the data stored in the buffer pointer."]
    pub buffer_length: usize,
    #[doc = " The maximum capacity of the buffer pointer."]
    pub buffer_capacity: usize,
    #[doc = " The allocator used to allocate and free the data in the pointer."]
    pub allocator: rcutils_allocator_t,
}
#[test]
fn bindgen_test_layout_rcutils_char_array_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcutils_char_array_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcutils_char_array_s>(),
        72usize,
        concat!("Size of: ", stringify!(rcutils_char_array_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcutils_char_array_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcutils_char_array_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_char_array_s),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owns_buffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_char_array_s),
            "::",
            stringify!(owns_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_char_array_s),
            "::",
            stringify!(buffer_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_capacity) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_char_array_s),
            "::",
            stringify!(buffer_capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_char_array_s),
            "::",
            stringify!(allocator)
        )
    );
}
#[doc = " The structure holding the metadata for a char array."]
pub type rcutils_char_array_t = rcutils_char_array_s;
extern "C" {
    #[doc = " Return a zero initialized char array struct.\n**\n* \\return rcutils_char_array_t a zero initialized char array struct\n*/"]
    pub fn rcutils_get_zero_initialized_char_array() -> rcutils_char_array_t;
}
extern "C" {
    #[doc = " Initialize a zero initialized char array struct.\n**\n* This function may leak if the char array struct is already\n* pre-initialized.\n* If the capacity is set to 0, no memory is allocated and the internal buffer\n* is still NULL.\n*\n* \\param[in] char_array a pointer to the to be initialized char array struct\n* \\param[in] buffer_capacity the size of the memory to allocate for the byte stream\n* \\param[in] allocator the allocator to use for the memory allocation\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCUTILS_RET_BAD_ALLOC if no memory could be allocated correctly\n* \\return #RCUTILS_RET_ERROR if an unexpected error occurs.\n*/"]
    pub fn rcutils_char_array_init(
        char_array: *mut rcutils_char_array_t,
        buffer_capacity: usize,
        allocator: *const rcutils_allocator_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Finalize a char array struct.\n**\n* Cleans up and deallocates any resources owned by rcutils_char_array_t.\n* The array passed to this function needs to have been initialized by\n* rcutils_char_array_init().\n* If .owns_buffer is false, this function has no effect because that\n* implies that the char_array does not own the internal buffer.\n* Passing an uninitialized instance to this function leads to undefined\n* behavior.\n*\n* \\param[in] char_array pointer to the rcutils_char_array_t to be cleaned up\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if the char_array argument is invalid\n* \\return #RCUTILS_RET_ERROR if an unexpected error occurs.\n*/"]
    pub fn rcutils_char_array_fini(char_array: *mut rcutils_char_array_t) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Resize the internal buffer of the char array.\n**\n* The internal buffer of the char array can be resized dynamically if needed.\n* If the new size is smaller than the current capacity, then the memory is\n* truncated.\n* Be aware, that this will deallocate the memory and therefore invalidates any\n* pointers to this storage.\n* If the new size is larger, new memory is getting allocated and the existing\n* content is copied over.\n* Note that if the array doesn't own the current buffer the function just\n* allocates a new block of memory and copies the contents of the old buffer\n* instead of resizing the existing buffer.\n*\n* \\param[in] char_array pointer to the instance of rcutils_char_array_t which is being resized\n* \\param[in] new_size the new size of the internal buffer\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if new_size is set to zero\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or\n* \\return #RCUTILS_RET_ERROR if an unexpected error occurs.\n*/"]
    pub fn rcutils_char_array_resize(
        char_array: *mut rcutils_char_array_t,
        new_size: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Expand the internal buffer of the char array.\n**\n* This function is equivalent to `rcutils_char_array_resize` except that it resizes\n* the internal buffer only when it is not big enough.\n* If the buffer is already big enough for `new_size`, it returns `RCUTILS_RET_OK` without\n* doing anything.\n*\n* \\param[inout] char_array pointer to the instance of rcutils_char_array_t which is being resized\n* \\param[in] new_size the new size of the internal buffer\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or\n* \\return #RCUTILS_RET_ERROR if an unexpected error occurs.\n*/"]
    pub fn rcutils_char_array_expand_as_needed(
        char_array: *mut rcutils_char_array_t,
        new_size: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Produce output according to format and args.\n**\n* This function is equivalent to `vsprintf(char_array->buffer, format, args)`\n* except that the buffer grows as needed so a user doesn't have to deal with\n* memory management.\n* The `va_list args` will be cloned before being used, so a user can safely\n* use it again after calling this function.\n*\n* \\param[inout] char_array pointer to the instance of rcutils_char_array_t which is being\n* written to\n* \\param[in] format the format string used by the underlying `vsnprintf`\n* \\param[in] args the `va_list` used by the underlying `vsnprintf`\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or\n* \\return #RCUTILS_RET_ERROR if an unexpected error occurs.\n*/"]
    pub fn rcutils_char_array_vsprintf(
        char_array: *mut rcutils_char_array_t,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Append a string (or part of it) to the string in buffer.\n**\n* This function treats the internal buffer as a string and appends the src string to it.\n* If src is longer than n, n bytes will be used and an extra null byte will be appended.\n* It is virtually equivalent to `strncat(char_array->buffer, src, n)` except that the buffer\n* grows as needed so a user doesn't have to deal with memory management.\n*\n* \\param[inout] char_array pointer to the instance of rcutils_char_array_t which is being appended to\n* \\param[in] src the string to be appended to the end of the string in buffer\n* \\param[in] n it uses at most n bytes from the src string\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or\n* \\return #RCUTILS_RET_ERROR if an unexpected error occurs.\n*/"]
    pub fn rcutils_char_array_strncat(
        char_array: *mut rcutils_char_array_t,
        src: *const ::std::os::raw::c_char,
        n: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Append a string to the string in buffer.\n**\n* This function treats the internal buffer as a string and appends the src string to it.\n* It is virtually equivalent to `strcat(char_array->buffer, src)` except that the buffer\n* grows as needed. That is to say, a user can safely use it without doing calculation or\n* checks on the sizes of the src and buffer.\n*\n* \\param[inout] char_array pointer to the instance of rcutils_char_array_t which is being\n* appended to\n* \\param[in] src the string to be appended to the end of the string in buffer\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or\n* \\return #RCUTILS_RET_ERROR if an unexpected error occurs.\n*/"]
    pub fn rcutils_char_array_strcat(
        char_array: *mut rcutils_char_array_t,
        src: *const ::std::os::raw::c_char,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Copy memory to buffer.\n**\n* This function is equivalent to `memcpy(char_array->buffer, src, n)` except that the buffer\n* grows as needed so a user doesn't have to worry about overflow.\n*\n* \\param[inout] char_array pointer to the instance of rcutils_char_array_t which is being resized\n* \\param[in] src the memory to be copied from\n* \\param[in] n a total of n bytes will be copied\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or\n* \\return #RCUTILS_RET_ERROR if an unexpected error occurs.\n*/"]
    pub fn rcutils_char_array_memcpy(
        char_array: *mut rcutils_char_array_t,
        src: *const ::std::os::raw::c_char,
        n: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Copy a string to buffer.\n**\n* This function is equivalent to `strcpy(char_array->buffer, src)` except that the buffer\n* grows as needed so that `src` will fit without overflow.\n*\n* \\param[inout] char_array pointer to the instance of rcutils_char_array_t which is being\n* copied to\n* \\param[in] src the string to be copied from\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or\n* \\return #RCUTILS_RET_ERROR if an unexpected error occurs.\n*/"]
    pub fn rcutils_char_array_strcpy(
        char_array: *mut rcutils_char_array_t,
        src: *const ::std::os::raw::c_char,
    ) -> rcutils_ret_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_hash_map_impl_s {
    _unused: [u8; 0],
}
#[doc = " The structure holding the metadata for a hash map."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_hash_map_s {
    #[doc = " A pointer to the PIMPL implementation type."]
    pub impl_: *mut rcutils_hash_map_impl_s,
}
#[test]
fn bindgen_test_layout_rcutils_hash_map_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcutils_hash_map_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcutils_hash_map_s>(),
        8usize,
        concat!("Size of: ", stringify!(rcutils_hash_map_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcutils_hash_map_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcutils_hash_map_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_hash_map_s),
            "::",
            stringify!(impl_)
        )
    );
}
#[doc = " The structure holding the metadata for a hash map."]
pub type rcutils_hash_map_t = rcutils_hash_map_s;
#[doc = " The function signature for a key hashing function.\n**\n* \\param[in] key The key that needs to be hashed\n* \\return A hash value for the provided string\n*/"]
pub type rcutils_hash_map_key_hasher_t =
    ::std::option::Option<unsafe extern "C" fn(key: *const ::std::os::raw::c_void) -> usize>;
#[doc = " The function signature for a key comparison function.\n**\n* \\param[in] val1 The first value to compare\n* \\param[in] val2 The second value to compare\n* \\return A negative number if val1 < val2, or\n* \\return A positve number if val1 > val2, or\n* \\return Zero if val1 == val2.\n*/"]
pub type rcutils_hash_map_key_cmp_t = ::std::option::Option<
    unsafe extern "C" fn(
        val1: *const ::std::os::raw::c_void,
        val2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " A hashing function for a null terminated c string.\n**\n* A hashing function for a null terminated c string.\n* Should be used when your key is just a pointer to a c-string\n*/"]
    pub fn rcutils_hash_map_string_hash_func(key_str: *const ::std::os::raw::c_void) -> usize;
}
extern "C" {
    #[doc = " A comparison function for a null terminated c string.\n**\n* A comparison function for a null terminated c string.\n* Should be used when your key is just a pointer to a c-string\n*/"]
    pub fn rcutils_hash_map_string_cmp_func(
        val1: *const ::std::os::raw::c_void,
        val2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return an empty hash_map struct.\n**\n* This function returns an empty and zero initialized hash_map struct.\n* All hash maps should be initialized with this or manually initialized\n* before being used.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* Example:\n* ```c\n* // Do not do this:\n* // rcutils_hash_map_t foo;\n* // rcutils_hash_map_fini(&foo); // undefined behavior!\n*\n* // Do this instead:\n* rcutils_hash_map_t bar = rcutils_get_zero_initialized_hash_map();\n* rcutils_hash_map_fini(&bar); // ok\n* ```\n* */"]
    pub fn rcutils_get_zero_initialized_hash_map() -> rcutils_hash_map_t;
}
extern "C" {
    #[doc = " Initialize a rcutils_hash_map_t, allocating space for given capacity.\n**\n* This function initializes the rcutils_hash_map_t with a given initial\n* capacity for entries.\n* Note this does not allocate space for keys or values in the hash_map, just the\n* arrays of pointers to the keys and values.\n* rcutils_hash_map_set() should still be used when assigning values.\n*\n* The hash_map argument should point to allocated memory and should have\n* been zero initialized with rcutils_get_zero_initialized_hash_map().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* Example:\n* ```c\n* rcutils_hash_map_t hash_map = rcutils_get_zero_initialized_hash_map();\n* rcutils_ret_t ret =\n*   rcutils_hash_map_init(&hash_map, 2, rcutils_get_default_allocator());\n* if (ret != RCUTILS_RET_OK) {\n*   // ... do error handling\n* }\n* // ... use the hash_map and when done:\n* ret = rcutils_hash_map_fini(&hash_map);\n* if (ret != RCUTILS_RET_OK) {\n*   // ... do error handling\n* }\n* ```\n*\n* \\param[inout] hash_map rcutils_hash_map_t to be initialized\n* \\param[in] initial_capacity the amount of initial capacity for the hash_map - this must be\n*                             greater than zero and will be automatically rounded up to the next power of 2\n* \\param[in] key_size the size (in bytes) of the key used to index the data\n* \\param[in] data_size the size (in bytes) of the data being stored\n* \\param[in] key_hashing_func a function that returns a hashed value for a key\n* \\param[in] key_cmp_func a function used to compare keys\n* \\param[in] allocator the allocator to use through out the lifetime of the hash_map\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCUTILS_RET_STRING_MAP_ALREADY_INIT if alread initialized, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_hash_map_init(
        hash_map: *mut rcutils_hash_map_t,
        initial_capacity: usize,
        key_size: usize,
        data_size: usize,
        key_hashing_func: rcutils_hash_map_key_hasher_t,
        key_cmp_func: rcutils_hash_map_key_cmp_t,
        allocator: *const rcutils_allocator_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Finalize the previously initialized hash_map struct.\n**\n* This function will free any resources which were created when initializing\n* or when calling rcutils_hash_map_set().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] hash_map rcutils_hash_map_t to be finalized\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_hash_map_fini(hash_map: *mut rcutils_hash_map_t) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Get the current capacity of the hash_map.\n**\n* This function will return the internal capacity of the hash_map, which is the\n* number of buckets the hash_map uses to sort the keys.\n* The capacity does not indicate how many key value pairs are stored in the\n* hash_map, the rcutils_hash_map_get_size() function can provide that, nor the\n* maximum number that can be stored without increasing the capacity.\n* The capacity can be set initially with rcutils_hash_map_init().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] hash_map rcutils_hash_map_t to be queried\n* \\param[out] capacity capacity of the hash_map\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_NOT_INITIALIZED if the hash_map is invalid, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_hash_map_get_capacity(
        hash_map: *const rcutils_hash_map_t,
        capacity: *mut usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Get the current size of the hash_map.\n**\n* This function will return the internal size of the hash_map, which is the\n* current number of key value pairs in the hash_map.\n* The size is changed when calling rcutils_hash_map_set() or rcutils_hash_map_unset().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] hash_map rcutils_hash_map_t to be queried\n* \\param[out] size size of the hash_map\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_NOT_INITIALIZED if the hash_map is invalid, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_hash_map_get_size(
        hash_map: *const rcutils_hash_map_t,
        size: *mut usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Set a key value pair in the hash_map, increasing capacity if necessary.\n**\n* If the key already exists in the map then the value is updated to the new value\n* provided. If it does not already exist then a new entry is added for the new key\n* and value. The capacity will be increased if needed.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] hash_map rcutils_hash_map_t to be updated\n* \\param[in] key hash_map key\n* \\param[in] value value for given hash_map key\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCUTILS_RET_NOT_INITIALIZED if the hash_map is invalid, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_hash_map_set(
        hash_map: *mut rcutils_hash_map_t,
        key: *const ::std::os::raw::c_void,
        value: *const ::std::os::raw::c_void,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Unset a key value pair in the hash_map.\n**\n* Unsets the key value pair in the hash_map and frees any internal resources allocated\n* for the entry. This function will never decrease the capacity when removing keys.\n* If the given key is not found, RCUTILS_RET_STRING_KEY_NOT_FOUND is returned.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] hash_map rcutils_hash_map_t to be updated\n* \\param[in] key hash_map key, must be null terminated c string\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_NOT_INITIALIZED if the hash_map is invalid, or\n* \\return #RCUTILS_RET_STRING_KEY_NOT_FOUND if the key is not found in the map, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_hash_map_unset(
        hash_map: *mut rcutils_hash_map_t,
        key: *const ::std::os::raw::c_void,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Get whether or not a key exists.\n**\n* Returns true if the provided key exists in the hash_map or false if it does not or\n* if the hash_map or key are invalid.\n* In all cases no error message is set.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] hash_map rcutils_hash_map_t to be searched\n* \\param[in] key hash_map key, must be null terminated c string\n* \\return `true` if key is in the hash_map, or\n* \\return `false` if key is not in the hash_map, or\n* \\return `false` for invalid arguments, or\n* \\return `false` if the hash_map is invalid.\n*/"]
    pub fn rcutils_hash_map_key_exists(
        hash_map: *const rcutils_hash_map_t,
        key: *const ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Get value given a key.\n**\n* This function can be used to retrieve a shallow copy of the stored data. The data\n* pointer must point to a section of memory large enough to copy the full size of\n* the data being stored, which is specified when the hash_map in initialized.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] hash_map rcutils_hash_map_t to be searched\n* \\param[in] key hash_map key to look up the data for\n* \\param[out] data A copy of the data stored in the map\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_NOT_INITIALIZED if the hash_map is invalid, or\n* \\return #RCUTILS_RET_NOT_FOUND if the key doesn't exist in the map, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_hash_map_get(
        hash_map: *const rcutils_hash_map_t,
        key: *const ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Get the next key in the hash_map, unless NULL is given, then get the first key.\n**\n* This function allows you to iteratively get each key/value pair in the hash_map.\n*\n* If NULL is given for the previous_key, then the first key in the hash_map is returned.\n* If that returned key is given as the previous_key for the next call to this function,\n* then the next key in the hash_map is returned.\n* If there are no more keys in the hash_map or if the given key is not in the hash_map,\n* an error will be returned.\n*\n* The order of the keys in the hash_map is arbitrary and if the hash_map is modified\n* between calls to this function the behavior is undefined.\n* If the hash_map is modified then iteration should begin again by passing NULL to\n* get the first key again.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* Example:\n* ```c\n* printf(\"entries in the hash_map:\\n\");\n* int key = 0, data = 0;\n* rcutils_ret_t status = rcutils_hash_map_get_next_key(&hash_map, NULL, &key, &data);\n* while (RCUTILS_RET_OK == status) {\n*   printf(\"%i: %i\\n\", key, data);\n*   status = rcutils_hash_map_get_next_key(&hash_map, &key, &key, &data);\n* }\n* ```\n*\n* \\param[in] hash_map rcutils_hash_map_t to be queried\n* \\param[in] previous_key NULL to get the first key or the previous key to get the next for\n* \\param[out] key A copy of the next key in the sequence\n* \\param[out] data A copy of the next data in the sequence\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_NOT_INITIALIZED if the hash_map is invalid, or\n* \\return #RCUTILS_RET_NOT_FOUND if the previous_key doesn't exist in the map, or\n* \\return #RCUTILS_RET_HASH_MAP_NO_MORE_ENTRIES if there is no more data beyound the previous_key, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_hash_map_get_next_key_and_data(
        hash_map: *const rcutils_hash_map_t,
        previous_key: *const ::std::os::raw::c_void,
        key: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Interface to qsort with rcutils-style argument validation.\n**\n* This function changes the order of the elements in the array so that they\n* are in ascending order according to the given comparison function.\n*\n* This function is thread-safe.\n*\n* \\param[inout] ptr object whose elements should be sorted.\n* \\param[in] count number of elements present in the object.\n* \\param[in] size size of each element, in bytes.\n* \\param[in] comp function used to compare two elements.\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_qsort(
        ptr: *mut ::std::os::raw::c_void,
        count: usize,
        size: usize,
        comp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> rcutils_ret_t;
}
#[doc = " The structure holding the metadata for a string array."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_string_array_s {
    #[doc = " The number of strings that can be stored in the string array."]
    pub size: usize,
    #[doc = " The allocated memory for the string array."]
    pub data: *mut *mut ::std::os::raw::c_char,
    #[doc = " The allocator used to allocate and free memory for the string array."]
    pub allocator: rcutils_allocator_t,
}
#[test]
fn bindgen_test_layout_rcutils_string_array_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcutils_string_array_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcutils_string_array_s>(),
        56usize,
        concat!("Size of: ", stringify!(rcutils_string_array_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcutils_string_array_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcutils_string_array_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_string_array_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_string_array_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_string_array_s),
            "::",
            stringify!(allocator)
        )
    );
}
#[doc = " The structure holding the metadata for a string array."]
pub type rcutils_string_array_t = rcutils_string_array_s;
extern "C" {
    #[doc = " Return an empty string array struct.\n**\n* This function returns an empty and zero initialized string array struct.\n* Calling rcutils_string_array_fini() on any non-initialized instance leads\n* to undefined behavior.\n* Every instance of string_array_t has to either be zero_initialized with this\n* function or manually allocated.\n*\n* Example:\n*\n* ```c\n* rcutils_string_array_t foo;\n* rcutils_string_array_fini(&foo); // undefined behavior!\n*\n* rcutils_string_array_t bar = rcutils_get_zero_initialized_string_array();\n* rcutils_string_array_fini(&bar); // ok\n* ```\n*/"]
    pub fn rcutils_get_zero_initialized_string_array() -> rcutils_string_array_t;
}
extern "C" {
    #[doc = " Initialize a string array with a given size.\n**\n* This function will initialize a given, zero initialized, string array to\n* a given size.\n*\n* Note that putting a string into the array gives owenship to the array.\n*\n* Example:\n*\n* ```c\n* rcutils_allocator_t allocator = rcutils_get_default_allocator();\n* rcutils_string_array_t string_array = rcutils_get_zero_initialized_string_array();\n* rcutils_ret_t ret = rcutils_string_array_init(&string_array, 2, &allocator);\n* if (ret != RCUTILS_RET_OK) {\n*   // ... error handling\n* }\n* string_array.data[0] = rcutils_strdup(\"Hello\", &allocator);\n* string_array.data[1] = rcutils_strdup(\"World\", &allocator);\n* ret = rcutils_string_array_fini(&string_array);\n* ```\n*\n* \\param[inout] string_array object to be initialized\n* \\param[in] size the size the array should be\n* \\param[in] allocator to be used to allocate and deallocate memory\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_array_init(
        string_array: *mut rcutils_string_array_t,
        size: usize,
        allocator: *const rcutils_allocator_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Finalize a string array, reclaiming all resources.\n**\n* This function reclaims any memory owned by the string array, including the\n* strings it references.\n*\n* The allocator used to initialize the string array is used to deallocate each\n* string in the array and the array of strings itself.\n*\n* \\param[inout] string_array object to be finalized\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_array_fini(string_array: *mut rcutils_string_array_t) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Compare two string arrays.\n**\n* The two string arrays are compared according to lexicographical order.\n*\n* \\param[in] lhs The first string array.\n* \\param[in] rhs The second string array.\n* \\param[out] res Negative value if `lhs` appears before `rhs` in lexicographical order.\n*   Zero if `lhs` and `rhs` are equal.\n*   Positive value if `lhs` appears after `rhs` in lexographical order.\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if any argument is `NULL, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if `lhs->data` or `rhs->data` is `NULL, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_array_cmp(
        lhs: *const rcutils_string_array_t,
        rhs: *const rcutils_string_array_t,
        res: *mut ::std::os::raw::c_int,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Resize a string array, reclaiming removed resources.\n**\n* This function changes the size of an existing string array.\n* If the new size is larger, new entries are added to the end of the array and\n* are zero- initialized.\n* If the new size is smaller, entries are removed from the end of the array\n* and their resources reclaimed.\n*\n* \\par Note:\n* Resizing to 0 is not a substitute for calling ::rcutils_string_array_fini.\n*\n* \\par Note:\n* If this function fails, \\p string_array remains unchanged and should still\n* be reclaimed with ::rcutils_string_array_fini.\n*\n* \\param[inout] string_array object to be resized.\n* \\param[in] new_size the size the array should be changed to.\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_array_resize(
        string_array: *mut rcutils_string_array_t,
        new_size: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Lexicographic comparer for pointers to string pointers.\n**\n* This functions compares pointers to string pointers lexicographically\n* ascending.\n*\n* \\param[in] lhs pointer to the first string pointer.\n* \\param[in] rhs pointer to the second string pointer.\n* \\return <0 if lhs is lexicographically lower, or\n* \\return 0 if the strings are the same, or\n* \\return >0 if lhs is lexicographically higher.\n*/"]
    pub fn rcutils_string_array_sort_compare(
        lhs: *const ::std::os::raw::c_void,
        rhs: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_string_map_impl_s {
    _unused: [u8; 0],
}
#[doc = " The structure holding the metadata for a string map."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_string_map_s {
    #[doc = " A pointer to the PIMPL implementation type."]
    pub impl_: *mut rcutils_string_map_impl_s,
}
#[test]
fn bindgen_test_layout_rcutils_string_map_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcutils_string_map_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcutils_string_map_s>(),
        8usize,
        concat!("Size of: ", stringify!(rcutils_string_map_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcutils_string_map_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcutils_string_map_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_string_map_s),
            "::",
            stringify!(impl_)
        )
    );
}
#[doc = " The structure holding the metadata for a string map."]
pub type rcutils_string_map_t = rcutils_string_map_s;
extern "C" {
    #[doc = " Return an empty string map struct.\n**\n* This function returns an empty and zero initialized string map struct.\n*\n* Example:\n*\n* ```c\n* // Do not do this:\n* // rcutils_string_map_t foo;\n* // rcutils_string_map_fini(&foo); // undefined behavior!\n*\n* // Do this instead:\n* rcutils_string_map_t bar = rcutils_get_zero_initialized_string_map();\n* rcutils_string_map_fini(&bar); // ok\n* ```\n* */"]
    pub fn rcutils_get_zero_initialized_string_map() -> rcutils_string_map_t;
}
extern "C" {
    #[doc = " Initialize a rcutils_string_map_t, allocating space for given capacity.\n**\n* This function initializes the rcutils_string_map_t with a given initial\n* capacity for entries.\n* Note this does not allocate space for keys or values in the map, just the\n* arrays of pointers to the keys and values.\n* rcutils_string_map_set() should still be used when assigning values.\n*\n* The string_map argument should point to allocated memory and should have\n* been zero initialized with rcutils_get_zero_initialized_string_map().\n* For example:\n*\n* ```c\n* rcutils_string_map_t string_map = rcutils_get_zero_initialized_string_map();\n* rcutils_ret_t ret =\n*   rcutils_string_map_init(&string_map, 10, rcutils_get_default_allocator());\n* if (ret != RCUTILS_RET_OK) {\n*   // ... do error handling\n* }\n* // ... use the string map and when done:\n* ret = rcutils_string_map_fini(&string_map);\n* if (ret != RCUTILS_RET_OK) {\n*   // ... do error handling\n* }\n* ```\n*\n* \\param[inout] string_map rcutils_string_map_t to be initialized\n* \\param[in] initial_capacity the amount of initial capacity for the string map\n* \\param[in] allocator the allocator to use through out the lifetime of the map\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCUTILS_RET_STRING_MAP_ALREADY_INIT if already initialized, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_init(
        string_map: *mut rcutils_string_map_t,
        initial_capacity: usize,
        allocator: rcutils_allocator_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Finalize the previously initialized string map struct.\n**\n* This function will free any resources which were created when initializing\n* or when calling rcutils_string_map_set().\n*\n* \\param[inout] string_map rcutils_string_map_t to be finalized\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_fini(string_map: *mut rcutils_string_map_t) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Get the current capacity of the string map.\n**\n* This function will return the internal capacity of the map, which is the\n* maximum number of key value pairs the map could hold.\n* The capacity can be set initially with rcutils_string_map_init() or\n* with rcutils_string_map_reserve().\n* The capacity does not indicate how many key value paris are stored in the\n* map, the rcutils_string_map_get_size() function can provide that.\n*\n* \\param[in] string_map rcutils_string_map_t to be queried\n* \\param[out] capacity capacity of the string map\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_get_capacity(
        string_map: *const rcutils_string_map_t,
        capacity: *mut usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Get the current size of the string map.\n**\n* This function will return the internal size of the map, which is the\n* current number of key value pairs in the map.\n* The size is changed when calling rcutils_string_map_set_no_resize(),\n* rcutils_string_map_set(), or rcutils_string_map_unset().\n*\n* \\param[in] string_map rcutils_string_map_t to be queried\n* \\param[out] size size of the string map\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_get_size(
        string_map: *const rcutils_string_map_t,
        size: *mut usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Reserve a given amount of capacity in the map.\n**\n* Increases the capacity of the map to at least the given size.\n*\n* If the current capacity is less than requested capacity then the capacity\n* is increased using the allocator given during initialization of the map in\n* rcutils_string_map_init().\n* If the requested capacity is less than the current capacity, the capacity\n* may be reduced, but no existing key value pairs will be truncated to do so.\n* In effect, the capacity will be shrunk to fit the number of items in map or\n* the requested capacity, which ever is larger.\n*\n* If recovering all resources is desired first call rcutils_string_map_clear()\n* and then this function with a capacity of 0.\n*\n* \\param[inout] string_map rcutils_string_map_t to have space reserved in\n* \\param[in] capacity requested size to reserve in the map\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_reserve(
        string_map: *mut rcutils_string_map_t,
        capacity: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Remove all key value pairs from the map.\n**\n* This function will remove all key value pairs from the map, and it will\n* reclaim all resources allocated as a result of setting key value pairs.\n* rcutils_string_map_fini() should still be called after this.\n*\n* \\param[inout] string_map rcutils_string_map_t to be cleared\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_clear(string_map: *mut rcutils_string_map_t) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Set a key value pair in the map, increasing capacity if necessary.\n**\n* The capacity will be increased if needed using rcutils_string_map_reserve().\n* Otherwise it is the same as rcutils_string_map_set_no_resize().\n*\n* \\see rcutils_string_map_set_no_resize()\n*\n* \\param[inout] string_map rcutils_string_map_t to be updated\n* \\param[in] key map key, must be null terminated c string\n* \\param[in] value value for given map key, must be null terminated c string\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_set(
        string_map: *mut rcutils_string_map_t,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Set a key value pair in the map but only if the map has enough capacity.\n**\n* If the map already contains the given key, the existing value will be\n* replaced with the given value.\n* If the map does not contain the given key, and the map has additional\n* unused capacity, then it will store the given key and value in the map.\n* If there is no unused capacity in the map, then RCUTILS_RET_NOT_ENOUGH_SPACE\n* is returned.\n*\n* The given key and value c strings are copied into the map, and so storage is\n* allocated for them in the map when this function is called if necessary.\n* The storage allocated for this purpose is reclaimed either when\n* rcutils_string_map_fini() is called on this map or when using this function\n* or rcutils_string_map_unset().\n*\n* Any allocation that occurs in this functions uses the allocator of the map,\n* which is given when the map is initialized in rcutils_string_map_init().\n*\n* \\param[inout] string_map rcutils_string_map_t to be updated\n* \\param[in] key map key, must be null terminated c string\n* \\param[in] value value for given map key, must be null terminated c string\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or\n* \\return #RCUTILS_RET_NOT_ENOUGH_SPACE if map is full, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_set_no_resize(
        string_map: *mut rcutils_string_map_t,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Unset a key value pair in the map.\n**\n* The key needs to be a null terminated c string.\n* If the given key is not found, RCUTILS_RET_STRING_KEY_NOT_FOUND is returned.\n*\n* \\param[inout] string_map rcutils_string_map_t to be updated\n* \\param[in] key map key, must be null terminated c string\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or\n* \\return #RCUTILS_RET_STRING_KEY_NOT_FOUND if key not found, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_unset(
        string_map: *mut rcutils_string_map_t,
        key: *const ::std::os::raw::c_char,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Get whether or not a key exists.\n**\n* The key needs to be a null terminated c string.\n*\n* This function can fail and return false if the key is not found,\n* or the string_map is NULL or invalid, or if the key is NULL.\n* In all cases no error message is set.\n*\n* \\param[in] string_map rcutils_string_map_t to be searched\n* \\param[in] key map key, must be null terminated c string\n* \\return `true` if key is in the map, or\n* \\return `false` if key is not in the map, or\n* \\return `false` for invalid arguments, or\n* \\return `false` if the string map is invalid.\n*/"]
    pub fn rcutils_string_map_key_exists(
        string_map: *const rcutils_string_map_t,
        key: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Get whether or not a key of known length exists.\n**\n* Identical to rcutils_string_map_key_exists() but without relying on key to be\n* a null terminated c string.\n*\n* \\param[in] string_map rcutils_string_map_t to be searched\n* \\param[in] key map key\n* \\param[in] key_length map key length\n* \\return `true` if key is in the map, or\n* \\return `false` if key is not in the map, or\n* \\return `false` for invalid arguments, or\n* \\return `false` if the string map is invalid.\n*/"]
    pub fn rcutils_string_map_key_existsn(
        string_map: *const rcutils_string_map_t,
        key: *const ::std::os::raw::c_char,
        key_length: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Get value given a key.\n**\n* The key needs to be a null terminated c string.\n*\n* This function can fail, and therefore return NULL, if the key is not found,\n* or the string_map is NULL or invalid, or if the key is NULL.\n* In all cases no error message is set.\n*\n* The returned value string is still owned by the map, and it should not be\n* modified or free'd.\n* This also means that the value pointer becomes invalid if either\n* rcutils_string_map_clear() or rcutils_string_map_fini() are called or if\n* the key value pair is updated or removed with one of rcutils_string_map_set()\n* or rcutils_string_map_set_no_resize() or rcutils_string_map_unset().\n*\n* \\param[in] string_map rcutils_string_map_t to be searched\n* \\param[in] key map key, must be null terminated c string\n* \\return value for the given key if successful, or\n* \\return `NULL` for invalid arguments, or\n* \\return `NULL` if the string map is invalid, or\n* \\return `NULL` if key not found, or\n* \\return `NULL` if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_get(
        string_map: *const rcutils_string_map_t,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get value given a key and key length.\n**\n* Identical to rcutils_string_map_get() but without relying on key to be a\n* null terminated c string.\n*\n* \\param[in] string_map rcutils_string_map_t to be searched\n* \\param[in] key map key\n* \\param[in] key_length map key length\n* \\return value for the given key if successful, or\n* \\return `NULL` for invalid arguments, or\n* \\return `NULL` if the string map is invalid, or\n* \\return `NULL` if key not found, or\n* \\return `NULL` if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_getn(
        string_map: *const rcutils_string_map_t,
        key: *const ::std::os::raw::c_char,
        key_length: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the next key in the map, unless NULL is given, then get the first key.\n**\n* This function allows you iteratively get each key in the map.\n*\n* If NULL is given for the key, then the first key in the map is returned.\n* If that returned key if given to the this function, then the next key in the\n* map is returned.\n* If there are no more keys in the map or if the given key is not in the map,\n* NULL is returned.\n*\n* The order of the keys in the map is arbitrary and if the map is modified\n* between calls to this function the behavior is undefined.\n* If the map is modifeid then iteration should begin again by passing NULL to\n* get the first key again.\n*\n* This function operates based on the address of the pointer, you cannot pass\n* a copy of a key to get the next key.\n*\n* Example:\n*\n* ```c\n* printf(\"keys in the map:\\n\");\n* const char * current_key = rcutils_string_map_get_next_key(&map, NULL);\n* while (current_key) {\n*   printf(\"  - %s\\n\", current_key);\n*   current_key = rcutils_string_map_get_next_key(&map, current_key);\n* }\n* ```\n*\n* NULL can also be returned if NULL is given for the string_map or if the\n* string_map is invalid.\n*\n* \\param[in] string_map rcutils_string_map_t to be queried\n* \\param[in] key NULL to get the first key or the previous key to get the next\n* \\return value for the given key if successful, or\n* \\return `NULL` for invalid arguments, or\n* \\return `NULL` if the string map is invalid, or\n* \\return `NULL` if key not found, or\n* \\return `NULL` if there are no more keys in the map, or\n* \\return `NULL` if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_get_next_key(
        string_map: *const rcutils_string_map_t,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Copy all the key value pairs from one map into another, overwritting and resizing if needed.\n**\n* If the destination string map does not have enough storage, then it is will\n* be resized.\n* If a key value pair exists in the destination map, its value will be\n* replaced with the source map's value.\n*\n* It is possible for only some of the values to be copied if an error happens\n* during the copying process, e.g. if memory allocation fails.\n*\n* \\param[in] src_string_map rcutils_string_map_t to be copied from\n* \\param[inout] dst_string_map rcutils_string_map_t to be copied to\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or\n* \\return #RCUTILS_RET_ERROR if an unknown error occurs.\n*/"]
    pub fn rcutils_string_map_copy(
        src_string_map: *const rcutils_string_map_t,
        dst_string_map: *mut rcutils_string_map_t,
    ) -> rcutils_ret_t;
}
#[doc = " The structure holding the metadata for a uint8 array."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_uint8_array_s {
    #[doc = " The allocated memory for the uint8 array."]
    pub buffer: *mut u8,
    #[doc = " The number of valid elements in the uint8 array."]
    pub buffer_length: usize,
    #[doc = " The maximum capacity of the uint8 array."]
    pub buffer_capacity: usize,
    #[doc = " The allocator used to allocate and free memory for the uint8 array."]
    pub allocator: rcutils_allocator_t,
}
#[test]
fn bindgen_test_layout_rcutils_uint8_array_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcutils_uint8_array_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcutils_uint8_array_s>(),
        64usize,
        concat!("Size of: ", stringify!(rcutils_uint8_array_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcutils_uint8_array_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcutils_uint8_array_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_uint8_array_s),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_uint8_array_s),
            "::",
            stringify!(buffer_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_uint8_array_s),
            "::",
            stringify!(buffer_capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_uint8_array_s),
            "::",
            stringify!(allocator)
        )
    );
}
#[doc = " The structure holding the metadata for a uint8 array."]
pub type rcutils_uint8_array_t = rcutils_uint8_array_s;
extern "C" {
    #[doc = " Return a zero initialized uint8 array struct.\n**\n* \\return rcutils_uint8_array_t a zero initialized uint8 array struct\n*/"]
    pub fn rcutils_get_zero_initialized_uint8_array() -> rcutils_uint8_array_t;
}
extern "C" {
    #[doc = " Initialize a zero initialized uint8 array struct.\n**\n* This function may leak if the uint8 array struct is already initialized.\n* If the capacity is set to 0, no memory is allocated and the internal buffer\n* is still NULL.\n*\n* \\param[inout] uint8_array a pointer to the to be initialized uint8 array struct\n* \\param[in] buffer_capacity the size of the memory to allocate for the byte stream\n* \\param[in] allocator the allocator to use for the memory allocation\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return 'RCUTILS_RET_BAD_ALLOC` if no memory could be allocated correctly\n* \\return #RCUTILS_RET_ERROR if an unexpected error occurs.\n*/"]
    pub fn rcutils_uint8_array_init(
        uint8_array: *mut rcutils_uint8_array_t,
        buffer_capacity: usize,
        allocator: *const rcutils_allocator_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Finalize a uint8 array struct.\n**\n* Cleans up and deallocates any resources used in a rcutils_uint8_array_t.\n* The array passed to this function needs to have been initialized by\n* rcutils_uint8_array_init().\n* Passing an uninitialized instance to this function leads to undefined\n* behavior.\n*\n* \\param[in] uint8_array pointer to the rcutils_uint8_array_t to be cleaned up\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if the uint8_array argument is invalid\n* \\return #RCUTILS_RET_ERROR if an unexpected error occurs.\n*/"]
    pub fn rcutils_uint8_array_fini(uint8_array: *mut rcutils_uint8_array_t) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Resize the internal buffer of the uint8 array.\n**\n* The internal buffer of the uint8 array can be resized dynamically if needed.\n* If the new size is smaller than the current capacity, then the memory is\n* truncated.\n* Be aware, that this might deallocate the memory and therefore invalidates any\n* pointers to this storage.\n*\n* \\param[inout] uint8_array pointer to the instance of rcutils_uint8_array_t which is\n* being resized\n* \\param[in] new_size the new size of the internal buffer\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if new_size is set to zero\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or\n* \\return #RCUTILS_RET_ERROR if an unexpected error occurs.\n*/"]
    pub fn rcutils_uint8_array_resize(
        uint8_array: *mut rcutils_uint8_array_t,
        new_size: usize,
    ) -> rcutils_ret_t;
}
#[doc = " A single point in time, measured in nanoseconds since the Unix epoch."]
pub type rcutils_time_point_value_t = i64;
#[doc = " A duration of time, measured in nanoseconds."]
pub type rcutils_duration_value_t = i64;
extern "C" {
    #[doc = " This function returns the time from a system clock.\n The closest equivalent would be to std::chrono::system_clock::now();\n\n The resolution (e.g. nanoseconds vs microseconds) is not guaranteed.\n\n The now argument must point to an allocated rcutils_time_point_value_t object,\n as the result is copied into this variable.\n\n <hr>\n Attribute          | Adherence\n ------------------ | -------------\n Allocates Memory   | No\n Thread-Safe        | Yes\n Uses Atomics       | No\n Lock-Free          | Yes\n\n \\param[out] now a datafield in which the current time is stored\n \\return #RCUTILS_RET_OK if the current time was successfully obtained, or\n \\return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or\n \\return #RCUTILS_RET_ERROR if an unspecified error occur."]
    pub fn rcutils_system_time_now(now: *mut rcutils_time_point_value_t) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Retrieve the current time as a rcutils_time_point_value_t object.\n**\n* This function returns the time from a monotonically increasing clock.\n* The closest equivalent would be to std::chrono::steady_clock::now();\n*\n* The resolution (e.g. nanoseconds vs microseconds) is not guaranteed.\n*\n* The now argument must point to an allocated rcutils_time_point_value_t object,\n* as the result is copied into this variable.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[out] now a struct in which the current time is stored\n* \\return #RCUTILS_RET_OK if the current time was successfully obtained, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCUTILS_RET_ERROR if an unspecified error occur.\n*/"]
    pub fn rcutils_steady_time_now(now: *mut rcutils_time_point_value_t) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Return a time point as nanoseconds in a string.\n**\n* The number is always fixed width, with left padding zeros up to the maximum\n* number of digits the time point can represent.\n* Right now that is 19 digits (so 19 characters) for a signed 64-bit integer.\n* Negative values will have a leading `-`, so they will be one character\n* longer than the positive values.\n*\n* The recommended minimum size of the input string is 32 characters, but\n* 21 (` ` or `-` for sign, 19 digits, null terminator) should be sufficiently\n* large for both positive and negative values.\n* If the given string is not large enough, the result will be truncated.\n* If you need a string with variable width, using `snprintf()` directly is\n* recommended.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No [1]\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] if `snprintf()` does not allocate additional memory internally</i>\n*\n* \\param[in] time_point the time to be made into a string\n* \\param[out] str the output string in which it is stored\n* \\param[in] str_size the size of the output string\n* \\return #RCUTILS_RET_OK if successful (even if truncated), or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCUTILS_RET_ERROR if an unspecified error occur.\n*/"]
    pub fn rcutils_time_point_value_as_nanoseconds_string(
        time_point: *const rcutils_time_point_value_t,
        str_: *mut ::std::os::raw::c_char,
        str_size: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Return a time point as floating point seconds in a string.\n**\n* The number is always fixed width, with left padding zeros up to the maximum\n* number of digits for the mantissa that the time point can represent and a\n* characteristic (fractional-part) with a fixed width of 9 digits.\n* Right now that means the mantissa is always 10 digits to add up to 19 total\n* for the signed 64-bit time point type.\n* Negative values will have a leading `-`, so they will be one character\n* longer then positive values.\n*\n* The recommended minimum size of the input string is 32 characters, but\n* 22 (` ` or `-` for sign, 19 digits, decimal point, null terminator) should\n* be sufficient for now.\n* If the given string is not large enough, the result will be truncated.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No [1]\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] if `snprintf()` does not allocate additional memory internally</i>\n*\n* \\param[in] time_point the time to be made into a string\n* \\param[out] str the output string in which it is stored\n* \\param[in] str_size the size of the output string\n* \\return #RCUTILS_RET_OK if successful (even if truncated), or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCUTILS_RET_ERROR if an unspecified error occur.\n*/"]
    pub fn rcutils_time_point_value_as_seconds_string(
        time_point: *const rcutils_time_point_value_t,
        str_: *mut ::std::os::raw::c_char,
        str_size: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " The flag if the logging system has been initialized."]
    pub static mut g_rcutils_logging_initialized: bool;
}
extern "C" {
    #[doc = " Initialize the logging system using the specified allocator.\n**\n* Initialize the logging system only if it was not in an initialized state.\n*\n* If an invalid allocator is passed, the initialization will fail.\n* Otherwise, this function will still set the internal state to initialized\n* even if an error occurs, to avoid repeated failing initialization attempts\n* since this function is called automatically from logging macros.\n* To re-attempt initialization, call rcutils_logging_shutdown() before\n* re-calling this function.\n*\n* If multiple errors occur, the error code of the last error will be returned.\n*\n* The `RCUTILS_CONSOLE_OUTPUT_FORMAT` environment variable can be used to set\n* the output format of messages logged to the console.\n* Available tokens are:\n*   - `file_name`, the full file name of the caller including the path\n*   - `function_name`, the function name of the caller\n*   - `line_number`, the line number of the caller\n*   - `message`, the message string after it has been formatted\n*   - `name`, the full logger name\n*   - `severity`, the name of the severity level, e.g. `INFO`\n*   - `time`, the timestamp of log message in floating point seconds\n*   - `time_as_nanoseconds`, the timestamp of log message in integer nanoseconds\n*\n* The `RCUTILS_COLORIZED_OUTPUT` environment variable allows configuring if colours\n* are used or not. Available values are:\n*  - `1`: Force using colours.\n*  - `0`: Don't use colours.\n* If it is unset, colours are used depending if the target stream is a terminal or not.\n* See `isatty` documentation.\n*\n* The format string can use these tokens by referencing them in curly brackets,\n* e.g. `\"[{severity}] [{name}]: {message} ({function_name}() at {file_name}:{line_number})\"`.\n* Any number of tokens can be used.\n* The limit of the format string is 2048 characters.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] allocator rcutils_allocator_t to be used.\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if the allocator is invalid, in which\n*   case initialization will fail, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if an error occurs reading the output\n*   format from the `RCUTILS_CONSOLE_OUTPUT_FORMAT` environment variable, in\n*   which case the default format will be used, or\n* \\return #RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID if the internal logger\n*   severity level map cannot be initialized, in which case logger severity\n*   levels will not be configurable.\n*/"]
    pub fn rcutils_logging_initialize_with_allocator(
        allocator: rcutils_allocator_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Initialize the logging system.\n**\n* Call rcutils_logging_initialize_with_allocator() using the default allocator.\n* This function is called automatically when using the logging macros.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT if an error occurs reading the output\n*   format from the `RCUTILS_CONSOLE_OUTPUT_FORMAT` environment variable, in\n*   which case the default format will be used, or\n* \\return #RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID if the internal logger\n*   severity level map cannot be initialized, in which case logger levels\n*   will not be configurable.\n*/"]
    pub fn rcutils_logging_initialize() -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Shutdown the logging system.\n**\n* Free the resources allocated for the logging system.\n* This puts the system into a state equivalent to being uninitialized.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID if the internal logger\n*   severity level map cannot be finalized.\n*/"]
    pub fn rcutils_logging_shutdown() -> rcutils_ret_t;
}
#[doc = " The structure identifying the caller location in the source code."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_log_location_s {
    #[doc = " The name of the function containing the log call."]
    pub function_name: *const ::std::os::raw::c_char,
    #[doc = " The name of the source file containing the log call."]
    pub file_name: *const ::std::os::raw::c_char,
    #[doc = " The line number containing the log call."]
    pub line_number: usize,
}
#[test]
fn bindgen_test_layout_rcutils_log_location_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcutils_log_location_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcutils_log_location_s>(),
        24usize,
        concat!("Size of: ", stringify!(rcutils_log_location_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcutils_log_location_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcutils_log_location_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).function_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_log_location_s),
            "::",
            stringify!(function_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_log_location_s),
            "::",
            stringify!(file_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_number) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_log_location_s),
            "::",
            stringify!(line_number)
        )
    );
}
#[doc = " The structure identifying the caller location in the source code."]
pub type rcutils_log_location_t = rcutils_log_location_s;
#[doc = "< The unset log level"]
pub const RCUTILS_LOG_SEVERITY_RCUTILS_LOG_SEVERITY_UNSET: RCUTILS_LOG_SEVERITY = 0;
#[doc = "< The debug log level"]
pub const RCUTILS_LOG_SEVERITY_RCUTILS_LOG_SEVERITY_DEBUG: RCUTILS_LOG_SEVERITY = 10;
#[doc = "< The info log level"]
pub const RCUTILS_LOG_SEVERITY_RCUTILS_LOG_SEVERITY_INFO: RCUTILS_LOG_SEVERITY = 20;
#[doc = "< The warn log level"]
pub const RCUTILS_LOG_SEVERITY_RCUTILS_LOG_SEVERITY_WARN: RCUTILS_LOG_SEVERITY = 30;
#[doc = "< The error log level"]
pub const RCUTILS_LOG_SEVERITY_RCUTILS_LOG_SEVERITY_ERROR: RCUTILS_LOG_SEVERITY = 40;
#[doc = "< The fatal log level"]
pub const RCUTILS_LOG_SEVERITY_RCUTILS_LOG_SEVERITY_FATAL: RCUTILS_LOG_SEVERITY = 50;
#[doc = " The severity levels of log messages / loggers.\n**\n* Note: all logging levels have their Least Significant Bit as 0, which is used as an\n* optimization.  If adding new logging levels, ensure that the new levels keep this property.\n*/"]
pub type RCUTILS_LOG_SEVERITY = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " The names of severity levels."]
    pub static g_rcutils_log_severity_names: [*const ::std::os::raw::c_char; 51usize];
}
extern "C" {
    #[doc = " Get a severity value from its string representation (e.g. DEBUG).\n**\n* String representation must match one of the values in\n* `g_rcutils_log_severity_names`, but is not case-sensitive.\n* Examples: UNSET, DEBUG, INFO, WARN, Error, fatal.\n*\n* \\param[in] severity_string String representation of the severity, must be a\n*   null terminated c string\n* \\param[in] allocator rcutils_allocator_t to be used\n* \\param[in,out] severity The severity level as a represented by the\n*   `RCUTILS_LOG_SEVERITY` enum\n* \\return #RCUTILS_RET_OK if successful, or\n* \\return #RCUTILS_RET_INVALID_ARGUMENT on invalid arguments, or\n* \\return #RCUTILS_RET_LOGGING_SEVERITY_STRING_INVALID if unable to match\n*   string, or\n* \\return #RCUTILS_RET_ERROR if an unspecified error occured.\n*/"]
    pub fn rcutils_logging_severity_level_from_string(
        severity_string: *const ::std::os::raw::c_char,
        allocator: rcutils_allocator_t,
        severity: *mut ::std::os::raw::c_int,
    ) -> rcutils_ret_t;
}
#[doc = " The function signature to log messages.\n**\n* \\param[in] location The location information about where the log came from\n* \\param[in] severity The severity of the log message expressed as an integer\n* \\param[in] name The name of the logger that this message came from\n* \\param[in] timestamp The time at which the log message was generated\n* \\param[in] format The list of arguments to insert into the formatted log message\n* \\param[in] args The variable argument list\n*/"]
pub type rcutils_logging_output_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        location: *const rcutils_log_location_t,
        severity: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        timestamp: rcutils_time_point_value_t,
        format: *const ::std::os::raw::c_char,
        args: *mut va_list,
    ),
>;
extern "C" {
    #[doc = " Get the current output handler.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No, provided logging system is already initialized\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\return The function pointer of the current output handler.\n*/"]
    pub fn rcutils_logging_get_output_handler() -> rcutils_logging_output_handler_t;
}
extern "C" {
    #[doc = " Set the current output handler.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No, provided logging system is already initialized\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] function The function pointer of the output handler to be used.\n*/"]
    pub fn rcutils_logging_set_output_handler(function: rcutils_logging_output_handler_t);
}
extern "C" {
    #[doc = " Formats a log message according to RCUTILS_CONSOLE_OUTPUT_FORMAT\n**\n* A formatter that is meant to be used by an output handler to format a log message to the match\n* the format specified in RCUTILS_CONSOLE_OUTPUT_FORMAT by performing token replacement.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] location The location information about where the log came from\n* \\param[in] severity The severity of the log message expressed as an integer\n* \\param[in] name The name of the logger that this message came from\n* \\param[in] timestamp The time at which the log message was generated\n* \\param[in] msg The message being logged\n* \\param[out] logging_output An output buffer for the formatted message\n* \\return #RCUTILS_RET_OK if successful.\n* \\return #RCUTILS_RET_BAD_ALLOC if memory allocation error occured\n*/"]
    pub fn rcutils_logging_format_message(
        location: *const rcutils_log_location_t,
        severity: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        timestamp: rcutils_time_point_value_t,
        msg: *const ::std::os::raw::c_char,
        logging_output: *mut rcutils_char_array_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Get the default level for loggers.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No, provided logging system is already initialized\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\return The level.\n*/"]
    pub fn rcutils_logging_get_default_logger_level() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the default severity level for loggers.\n**\n* If the severity level requested is `RCUTILS_LOG_SEVERITY_UNSET`, the default\n* value for the default logger (`RCUTILS_DEFAULT_LOGGER_DEFAULT_LEVEL`)\n* will be restored instead.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No, provided logging system is already initialized\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] level The level to be used.\n*/"]
    pub fn rcutils_logging_set_default_logger_level(level: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Get the severity level for a logger.\n**\n* This considers the severity level of the specifed logger only.\n* To get the effective level of a logger given the severity level of its\n* ancestors, see rcutils_logging_get_logger_effective_level().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No, provided logging system is already initialized\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] name The name of the logger, must be null terminated c string\n* \\return The level of the logger if it has been set, or\n* \\return `RCUTILS_LOG_SEVERITY_UNSET` if unset, or\n* \\return the default logger level for an empty name, or\n* \\return -1 on invalid arguments, or\n* \\return -1 if an error occurred\n*/"]
    pub fn rcutils_logging_get_logger_level(
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the level for a logger and its name length.\n**\n* Identical to rcutils_logging_get_logger_level() but without\n* relying on the logger name to be a null terminated c string.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No, provided logging system is already initialized\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] name The name of the logger\n* \\param[in] name_length Logger name length\n* \\return The level of the logger if it has been set, or\n* \\return `RCUTILS_LOG_SEVERITY_UNSET` if unset, or\n* \\return the default logger level for an empty name, or\n* \\return -1 on invalid arguments, or\n* \\return -1 if an error occurred\n*/"]
    pub fn rcutils_logging_get_logger_leveln(
        name: *const ::std::os::raw::c_char,
        name_length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the severity level for a logger.\n**\n* If an empty string is specified as the name, the default logger level will be set.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] name The name of the logger, must be null terminated c string.\n* \\param[in] level The level to be used.\n* \\return `RCUTILS_RET_OK` if successful, or\n* \\return `RCUTILS_RET_INVALID_ARGUMENT` on invalid arguments, or\n* \\return `RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID` if severity map invalid, or\n* \\return `RCUTILS_RET_ERROR` if an unspecified error occured\n*/"]
    pub fn rcutils_logging_set_logger_level(
        name: *const ::std::os::raw::c_char,
        level: ::std::os::raw::c_int,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Determine if a logger is enabled for a severity level.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No, provided logging system is already initialized\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] name The name of the logger, must be null terminated c string or NULL.\n* \\param[in] severity The severity level.\n*\n* \\return `true` if the logger is enabled for the level, or\n* \\return `false` otherwise.\n*/"]
    pub fn rcutils_logging_logger_is_enabled_for(
        name: *const ::std::os::raw::c_char,
        severity: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " Determine the effective level for a logger.\n**\n* The effective level is determined as the severity level of\n* the logger if it is set, otherwise it is the first specified severity\n* level of the logger's ancestors, starting with its closest ancestor.\n* The ancestor hierarchy is signified by logger names being separated by dots:\n* a logger named `x` is an ancestor of `x.y`, and both `x` and `x.y` are\n* ancestors of `x.y.z`, etc.\n* If the level has not been set for the logger nor any of its\n* ancestors, the default level is used.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No, provided logging system is already initialized\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] name The name of the logger, must be null terminated c string.\n*\n* \\return The level, or\n* \\return -1 on invalid arguments, or\n* \\return -1 if an error occurred.\n*/"]
    pub fn rcutils_logging_get_logger_effective_level(
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Internal call to log a message.\n**\n* Unconditionally log a message.\n* This is an internal function, and assumes that the caller has already called\n* rcutils_logging_logger_is_enabled_for().\n* End-user software should never call this, and instead should call rcutils_log()\n* or one of the RCUTILS_LOG_ macros.\n*\n* The attributes of this function are influenced by the currently set output handler.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No, for formatted outputs <= 1023 characters\n*                    | Yes, for formatted outputs >= 1024 characters\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] location The pointer to the location struct or NULL\n* \\param[in] severity The severity level\n* \\param[in] name The name of the logger, must be null terminated c string or NULL\n* \\param[in] format The format string\n* \\param[in] ... The variable arguments\n*/"]
    pub fn rcutils_log_internal(
        location: *const rcutils_log_location_t,
        severity: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Log a message.\n**\n* The attributes of this function are influenced by the currently set output handler.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No, for formatted outputs <= 1023 characters\n*                    | Yes, for formatted outputs >= 1024 characters\n* Thread-Safe        | Yes, with itself [1]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] should be thread-safe with itself but not with other logging functions</i>\n*\n* This should be thread-safe with itself, but is not thread-safe with other\n* logging functions that do things like set logger levels.\n*\n* \\todo There are no thread-safety gurantees between this function and other\n*   logging functions in rcutils, even though it is likely users are calling\n*   them concurrently today.\n*   We need to revisit these functions with respect to this issue and make\n*   guarantees where we can, and change functions higher in the stack to\n*   provide the thread-safety where we cannot.\n*\n* \\param[in] location The pointer to the location struct or NULL\n* \\param[in] severity The severity level\n* \\param[in] name The name of the logger, must be null terminated c string or NULL\n* \\param[in] format The format string\n* \\param[in] ... The variable arguments\n*/"]
    pub fn rcutils_log(
        location: *const rcutils_log_location_t,
        severity: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " The default output handler outputs log messages to the standard streams.\n**\n* The messages with a severity level `DEBUG` and `INFO` are written to `stdout`.\n* The messages with a severity level `WARN`, `ERROR`, and `FATAL` are written\n* to `stderr`.\n* The console output format of the logged message can be configured through\n* the `RCUTILS_CONSOLE_OUTPUT_FORMAT` environment variable: see\n* rcutils_logging_initialize_with_allocator() for details.\n* For configuring if using colours or not, `RCUTILS_COLORIZED_OUTPUT` can be used:\n* see rcutils_logging_initialize_with_allocator() for details.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes, if the underlying *printf functions are\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] location The pointer to the location struct or NULL\n* \\param[in] severity The severity level\n* \\param[in] name The name of the logger, must be null terminated c string\n* \\param[in] timestamp The timestamp for when the log message was made\n* \\param[in] format The format string\n* \\param[in] args The `va_list` used by the logger\n*/"]
    pub fn rcutils_logging_console_output_handler(
        location: *const rcutils_log_location_t,
        severity: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        timestamp: rcutils_time_point_value_t,
        format: *const ::std::os::raw::c_char,
        args: *mut va_list,
    );
}
pub const rmw_qos_policy_kind_e_RMW_QOS_POLICY_INVALID: rmw_qos_policy_kind_e = 1;
pub const rmw_qos_policy_kind_e_RMW_QOS_POLICY_DURABILITY: rmw_qos_policy_kind_e = 2;
pub const rmw_qos_policy_kind_e_RMW_QOS_POLICY_DEADLINE: rmw_qos_policy_kind_e = 4;
pub const rmw_qos_policy_kind_e_RMW_QOS_POLICY_LIVELINESS: rmw_qos_policy_kind_e = 8;
pub const rmw_qos_policy_kind_e_RMW_QOS_POLICY_RELIABILITY: rmw_qos_policy_kind_e = 16;
pub const rmw_qos_policy_kind_e_RMW_QOS_POLICY_HISTORY: rmw_qos_policy_kind_e = 32;
pub const rmw_qos_policy_kind_e_RMW_QOS_POLICY_LIFESPAN: rmw_qos_policy_kind_e = 64;
pub const rmw_qos_policy_kind_e_RMW_QOS_POLICY_DEPTH: rmw_qos_policy_kind_e = 128;
pub const rmw_qos_policy_kind_e_RMW_QOS_POLICY_LIVELINESS_LEASE_DURATION: rmw_qos_policy_kind_e =
    256;
pub const rmw_qos_policy_kind_e_RMW_QOS_POLICY_AVOID_ROS_NAMESPACE_CONVENTIONS:
    rmw_qos_policy_kind_e = 512;
#[doc = " QoS Policy Kinds"]
pub type rmw_qos_policy_kind_e = ::std::os::raw::c_uint;
#[doc = " QoS Policy Kinds"]
pub use self::rmw_qos_policy_kind_e as rmw_qos_policy_kind_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_qos_incompatible_event_status_s {
    #[doc = " Total cumulative number of times the concerned subscription discovered a\n publisher for the same topic with an offered QoS that was incompatible\n with that requested by the subscription."]
    pub total_count: i32,
    #[doc = " The change in total_count since the last time the status was read."]
    pub total_count_change: i32,
    #[doc = " The Qos Policy Kind of one of the policies that was found to be\n incompatible the last time an incompatibility was detected."]
    pub last_policy_kind: rmw_qos_policy_kind_t,
}
#[test]
fn bindgen_test_layout_rmw_qos_incompatible_event_status_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_qos_incompatible_event_status_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_qos_incompatible_event_status_s>(),
        12usize,
        concat!("Size of: ", stringify!(rmw_qos_incompatible_event_status_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_qos_incompatible_event_status_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rmw_qos_incompatible_event_status_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_qos_incompatible_event_status_s),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_count_change) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_qos_incompatible_event_status_s),
            "::",
            stringify!(total_count_change)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_policy_kind) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_qos_incompatible_event_status_s),
            "::",
            stringify!(last_policy_kind)
        )
    );
}
pub type rmw_qos_incompatible_event_status_t = rmw_qos_incompatible_event_status_s;
#[doc = " Event state for a subscription's 'RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE' events."]
pub type rmw_requested_qos_incompatible_event_status_t = rmw_qos_incompatible_event_status_t;
#[doc = " Event state for a publisher's 'RMW_EVENT_OFFERED_QOS_INCOMPATIBLE' events."]
pub type rmw_offered_qos_incompatible_event_status_t = rmw_qos_incompatible_event_status_t;
#[doc = " Incompatible type information provided by a topic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_incompatible_type_status_s {
    #[doc = " Lifetime cumulative number of incompatible types detected."]
    pub total_count: i32,
    #[doc = " The incremental number of incompatible types detected since the status was read."]
    pub total_count_change: i32,
}
#[test]
fn bindgen_test_layout_rmw_incompatible_type_status_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_incompatible_type_status_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_incompatible_type_status_s>(),
        8usize,
        concat!("Size of: ", stringify!(rmw_incompatible_type_status_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_incompatible_type_status_s>(),
        4usize,
        concat!("Alignment of ", stringify!(rmw_incompatible_type_status_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_incompatible_type_status_s),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_count_change) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_incompatible_type_status_s),
            "::",
            stringify!(total_count_change)
        )
    );
}
#[doc = " Incompatible type information provided by a topic."]
pub type rmw_incompatible_type_status_t = rmw_incompatible_type_status_s;
#[doc = " QoS Liveliness Changed information provided by a subscription."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_liveliness_changed_status_s {
    #[doc = " The total number of currently active Publishers which publish to the topic associated with\n the Subscription.\n This count increases when a newly matched Publisher asserts its liveliness for the first time\n or when a Publisher previously considered to be not alive reasserts its liveliness.\n The count decreases when a Publisher considered alive fails to assert its liveliness and\n becomes not alive, whether because it was deleted normally or for some other reason."]
    pub alive_count: i32,
    #[doc = " The total count of current Publishers which publish to the topic associated with the\n Subscription that are no longer asserting their liveliness.\n This count increases when a Publisher considered alive fails to assert its liveliness and\n becomes not alive for some reason other than the normal deletion of that Publisher.\n It decreases when a previously not alive Publisher either reasserts its liveliness or is\n deleted normally."]
    pub not_alive_count: i32,
    #[doc = " The change in the alive_count since the status was last read."]
    pub alive_count_change: i32,
    #[doc = " The change in the not_alive_count since the status was last read."]
    pub not_alive_count_change: i32,
}
#[test]
fn bindgen_test_layout_rmw_liveliness_changed_status_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_liveliness_changed_status_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_liveliness_changed_status_s>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_liveliness_changed_status_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_liveliness_changed_status_s>(),
        4usize,
        concat!("Alignment of ", stringify!(rmw_liveliness_changed_status_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alive_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_liveliness_changed_status_s),
            "::",
            stringify!(alive_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).not_alive_count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_liveliness_changed_status_s),
            "::",
            stringify!(not_alive_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alive_count_change) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_liveliness_changed_status_s),
            "::",
            stringify!(alive_count_change)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).not_alive_count_change) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_liveliness_changed_status_s),
            "::",
            stringify!(not_alive_count_change)
        )
    );
}
#[doc = " QoS Liveliness Changed information provided by a subscription."]
pub type rmw_liveliness_changed_status_t = rmw_liveliness_changed_status_s;
#[doc = " QoS Liveliness Lost information provided by a publisher."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_liveliness_lost_status_s {
    #[doc = " Lifetime cumulative number of times that a previously-alive Publisher became not alive due to\n a failure to actively signal its liveliness within its offered liveliness period.\n This count does not change when an already not alive Publisher simply remains not alive for\n another liveliness period."]
    pub total_count: i32,
    #[doc = " The change in total_count since the last time the status was last read."]
    pub total_count_change: i32,
}
#[test]
fn bindgen_test_layout_rmw_liveliness_lost_status_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_liveliness_lost_status_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_liveliness_lost_status_s>(),
        8usize,
        concat!("Size of: ", stringify!(rmw_liveliness_lost_status_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_liveliness_lost_status_s>(),
        4usize,
        concat!("Alignment of ", stringify!(rmw_liveliness_lost_status_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_liveliness_lost_status_s),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_count_change) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_liveliness_lost_status_s),
            "::",
            stringify!(total_count_change)
        )
    );
}
#[doc = " QoS Liveliness Lost information provided by a publisher."]
pub type rmw_liveliness_lost_status_t = rmw_liveliness_lost_status_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_matched_status_s {
    #[doc = " For publisher, the total cumulative count of subscribers matched to the concerned publisher.\n\n For subscriber, the total cumulative count of publishers matched to the concerned subscriber."]
    pub total_count: usize,
    #[doc = " total_count change since last time the status was read."]
    pub total_count_change: usize,
    #[doc = " For publisher, the number of subscribers currently matched to the concerned publisher.\n\n For subscriber, the number of publishers currently matched to the concerned subscriber."]
    pub current_count: usize,
    #[doc = " The current_count change since last time the status was read."]
    pub current_count_change: i32,
}
#[test]
fn bindgen_test_layout_rmw_matched_status_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_matched_status_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_matched_status_s>(),
        32usize,
        concat!("Size of: ", stringify!(rmw_matched_status_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_matched_status_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_matched_status_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_matched_status_s),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_count_change) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_matched_status_s),
            "::",
            stringify!(total_count_change)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_matched_status_s),
            "::",
            stringify!(current_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_count_change) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_matched_status_s),
            "::",
            stringify!(current_count_change)
        )
    );
}
pub type rmw_matched_status_t = rmw_matched_status_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_message_lost_status_s {
    #[doc = " Total number of messages lost."]
    pub total_count: usize,
    #[doc = " Number of messages lost since last callback."]
    pub total_count_change: usize,
}
#[test]
fn bindgen_test_layout_rmw_message_lost_status_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_message_lost_status_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_message_lost_status_s>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_message_lost_status_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_message_lost_status_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_message_lost_status_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_message_lost_status_s),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_count_change) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_message_lost_status_s),
            "::",
            stringify!(total_count_change)
        )
    );
}
pub type rmw_message_lost_status_t = rmw_message_lost_status_s;
#[doc = " QoS Deadline Missed information provided by a publisher."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_offered_deadline_missed_status_s {
    #[doc = " Lifetime cumulative number of offered deadline periods elapsed during which a Publisher failed\n to provide data.\n Missed deadlines accumulate; that is, each deadline period the total_count will be incremented\n by one."]
    pub total_count: i32,
    #[doc = " The change in total_count since the last time the status was last read."]
    pub total_count_change: i32,
}
#[test]
fn bindgen_test_layout_rmw_offered_deadline_missed_status_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_offered_deadline_missed_status_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_offered_deadline_missed_status_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rmw_offered_deadline_missed_status_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_offered_deadline_missed_status_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rmw_offered_deadline_missed_status_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_offered_deadline_missed_status_s),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_count_change) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_offered_deadline_missed_status_s),
            "::",
            stringify!(total_count_change)
        )
    );
}
#[doc = " QoS Deadline Missed information provided by a publisher."]
pub type rmw_offered_deadline_missed_status_t = rmw_offered_deadline_missed_status_s;
#[doc = " QoS Requested Deadline Missed information provided by a subscription."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_requested_deadline_missed_status_s {
    #[doc = " Lifetime cumulative number of missed deadlines detected for any instance read by the\n subscription.\n Missed deadlines accumulate; that is, each deadline period the total_count will be incremented\n by one for each instance for which data was not received."]
    pub total_count: i32,
    #[doc = " The incremental number of deadlines detected since the status was read."]
    pub total_count_change: i32,
}
#[test]
fn bindgen_test_layout_rmw_requested_deadline_missed_status_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_requested_deadline_missed_status_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_requested_deadline_missed_status_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rmw_requested_deadline_missed_status_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_requested_deadline_missed_status_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rmw_requested_deadline_missed_status_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_requested_deadline_missed_status_s),
            "::",
            stringify!(total_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_count_change) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_requested_deadline_missed_status_s),
            "::",
            stringify!(total_count_change)
        )
    );
}
#[doc = " QoS Requested Deadline Missed information provided by a subscription."]
pub type rmw_requested_deadline_missed_status_t = rmw_requested_deadline_missed_status_s;
#[doc = " \\brief Serialized message as a string of bytes.\n\n It includes (but it is not limited to) the following members:\n   \\e \\c buffer the reference to internal storage, as a pointer\n   \\e \\c buffer_length the size of stored contents, as an unsigned integer\n   \\e \\c buffer_capacity the capacity of internal storage, as an unsigned integer"]
pub type rmw_serialized_message_t = rcutils_uint8_array_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_subscription_content_filter_options_s {
    #[doc = " Specify the criteria to select the data samples of interest.\n\n It is similar to the WHERE part of an SQL clause."]
    pub filter_expression: *mut ::std::os::raw::c_char,
    #[doc = " Give values to the tokens placeholder parameters (i.e., \"%n\" tokens begin from 0) in the\n filter_expression. The number of supplied parameters must fit with the requested values.\n\n It can be NULL if there is no \"%n\" tokens placeholder in filter_expression.\n The maximum index number must be smaller than 100."]
    pub expression_parameters: rcutils_string_array_t,
}
#[test]
fn bindgen_test_layout_rmw_subscription_content_filter_options_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_subscription_content_filter_options_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_subscription_content_filter_options_s>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(rmw_subscription_content_filter_options_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_subscription_content_filter_options_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rmw_subscription_content_filter_options_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter_expression) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_subscription_content_filter_options_s),
            "::",
            stringify!(filter_expression)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expression_parameters) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_subscription_content_filter_options_s),
            "::",
            stringify!(expression_parameters)
        )
    );
}
pub type rmw_subscription_content_filter_options_t = rmw_subscription_content_filter_options_s;
extern "C" {
    #[doc = " Get zero initialized content filter options."]
    pub fn rmw_get_zero_initialized_content_filter_options(
    ) -> rmw_subscription_content_filter_options_t;
}
extern "C" {
    #[doc = " Initialize the given content filter options.\n**\n* \\param[in] filter_expression The filter expression.\n* \\param[in] expression_parameters_argc The expression parameters argc.\n* \\param[in] expression_parameter_argv The expression parameters argv.\n* \\param[in] allocator The allocator used when copying data to the content filter options.\n* \\param[out] options The content filter options to be set.\n* \\returns RMW_RET_INVALID_ARGUMENT, or\n* \\returns RMW_RET_BAD_ALLOC, or\n* \\returns RMW_RET_OK\n*/"]
    pub fn rmw_subscription_content_filter_options_init(
        filter_expression: *const ::std::os::raw::c_char,
        expression_parameters_argc: usize,
        expression_parameter_argv: *mut *const ::std::os::raw::c_char,
        allocator: *const rcutils_allocator_t,
        options: *mut rmw_subscription_content_filter_options_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Set the given content filter options.\n**\n* \\param[in] filter_expression The filter expression.\n* \\param[in] expression_parameters_argc The expression parameters argc.\n* \\param[in] expression_parameter_argv The expression parameters argv.\n* \\param[in] allocator The allocator used when copying data to the content filter options.\n* \\param[out] options The content filter options to be set.\n* \\returns RMW_RET_INVALID_ARGUMENT, or\n* \\returns RMW_RET_BAD_ALLOC, or\n* \\returns RMW_RET_OK\n*/"]
    pub fn rmw_subscription_content_filter_options_set(
        filter_expression: *const ::std::os::raw::c_char,
        expression_parameters_argc: usize,
        expression_parameter_argv: *mut *const ::std::os::raw::c_char,
        allocator: *const rcutils_allocator_t,
        options: *mut rmw_subscription_content_filter_options_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Copy the given content filter options.\n**\n* \\param[in] src content filter options to be copied.\n* \\param[in] allocator allocator used when copying data to the new content filter options.\n* \\param[out] dst content filter options to be set.\n* \\returns RMW_RET_INVALID_ARGUMENT, or\n* \\returns RMW_RET_BAD_ALLOC, or\n* \\returns RMW_RET_OK\n*/"]
    pub fn rmw_subscription_content_filter_options_copy(
        src: *const rmw_subscription_content_filter_options_t,
        allocator: *const rcutils_allocator_t,
        dst: *mut rmw_subscription_content_filter_options_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Finalize the content filter options.\n**\n* \\param[in] options content filter options to be finalized.\n* \\param[in] allocator allocator used to deallocate the content filter options.\n* \\returns RMW_RET_INVALID_ARGUMENT, or\n* \\returns RMW_RET_ERROR, or\n* \\returns RMW_RET_OK\n*/"]
    pub fn rmw_subscription_content_filter_options_fini(
        options: *mut rmw_subscription_content_filter_options_t,
        allocator: *const rcutils_allocator_t,
    ) -> rmw_ret_t;
}
#[doc = " A struct representing a duration or relative time in RMW - does not encode an origin."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_time_s {
    #[doc = " Seconds component"]
    pub sec: u64,
    #[doc = " Nanoseconds component"]
    pub nsec: u64,
}
#[test]
fn bindgen_test_layout_rmw_time_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_time_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_time_s>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_time_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_time_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_time_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_time_s),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_time_s),
            "::",
            stringify!(nsec)
        )
    );
}
#[doc = " A struct representing a duration or relative time in RMW - does not encode an origin."]
pub type rmw_time_t = rmw_time_s;
pub type rmw_time_point_value_t = rcutils_time_point_value_t;
pub type rmw_duration_t = rcutils_duration_value_t;
extern "C" {
    #[doc = " Check whether two rmw_time_t represent the same time."]
    pub fn rmw_time_equal(left: rmw_time_t, right: rmw_time_t) -> bool;
}
extern "C" {
    #[doc = " Return the total nanosecond representation of a time.\n**\n* \\return INT64_MAX if input is too large to store in 64 bits\n*/"]
    pub fn rmw_time_total_nsec(time: rmw_time_t) -> rmw_duration_t;
}
extern "C" {
    #[doc = " Construct rmw_time_t from a total nanoseconds representation.\n**\n* rmw_time_t only specifies relative time, so the origin is not relevant for this calculation.\n* \\return RMW_DURATION_INFINITE if input is negative, which is not representable in rmw_time_t\n*/"]
    pub fn rmw_time_from_nsec(nanoseconds: rmw_duration_t) -> rmw_time_t;
}
extern "C" {
    #[doc = " Ensure that an rmw_time_t does not have nanoseconds > 1 second."]
    pub fn rmw_time_normalize(time: rmw_time_t) -> rmw_time_t;
}
#[doc = " Structure which encapsulates an rmw node"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_node_s {
    #[doc = " Name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Type erased pointer to this node's data"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " A concise name of this rmw node for identification"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " The namespace of this rmw node"]
    pub namespace_: *const ::std::os::raw::c_char,
    #[doc = " Context information about node's init specific information"]
    pub context: *mut rmw_context_t,
}
#[test]
fn bindgen_test_layout_rmw_node_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_node_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_node_s>(),
        40usize,
        concat!("Size of: ", stringify!(rmw_node_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_node_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_node_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_node_s),
            "::",
            stringify!(implementation_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_node_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_node_s),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).namespace_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_node_s),
            "::",
            stringify!(namespace_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_node_s),
            "::",
            stringify!(context)
        )
    );
}
#[doc = " Structure which encapsulates an rmw node"]
pub type rmw_node_t = rmw_node_s;
#[doc = " Endpoint type has not yet been set"]
pub const rmw_endpoint_type_e_RMW_ENDPOINT_INVALID: rmw_endpoint_type_e = 0;
#[doc = " Creates and publishes messages to the ROS topic"]
pub const rmw_endpoint_type_e_RMW_ENDPOINT_PUBLISHER: rmw_endpoint_type_e = 1;
#[doc = " Listens for and receives messages from a topic"]
pub const rmw_endpoint_type_e_RMW_ENDPOINT_SUBSCRIPTION: rmw_endpoint_type_e = 2;
#[doc = " Endpoint enumeration type"]
pub type rmw_endpoint_type_e = ::std::os::raw::c_uint;
#[doc = " Endpoint enumeration type"]
pub use self::rmw_endpoint_type_e as rmw_endpoint_type_t;
#[doc = " Unique network flow endpoints not required"]
pub const rmw_unique_network_flow_endpoints_requirement_e_RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_NOT_REQUIRED : rmw_unique_network_flow_endpoints_requirement_e = 0 ;
#[doc = " Unique network flow endpoins strictly required.\n Error if not provided by RMW implementation."]
pub const rmw_unique_network_flow_endpoints_requirement_e_RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_STRICTLY_REQUIRED : rmw_unique_network_flow_endpoints_requirement_e = 1 ;
#[doc = " Unique network flow endpoints optionally required.\n No error if not provided RMW implementation."]
pub const rmw_unique_network_flow_endpoints_requirement_e_RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_OPTIONALLY_REQUIRED : rmw_unique_network_flow_endpoints_requirement_e = 2 ;
#[doc = " Unique network flow endpoints requirement decided by system."]
pub const rmw_unique_network_flow_endpoints_requirement_e_RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_SYSTEM_DEFAULT : rmw_unique_network_flow_endpoints_requirement_e = 3 ;
#[doc = " Unique network flow endpoints requirement enumeration"]
pub type rmw_unique_network_flow_endpoints_requirement_e = ::std::os::raw::c_uint;
#[doc = " Unique network flow endpoints requirement enumeration"]
pub use self::rmw_unique_network_flow_endpoints_requirement_e as rmw_unique_network_flow_endpoints_requirement_t;
#[doc = " Options that can be used to configure the creation of a publisher in rmw."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_publisher_options_s {
    #[doc = " Used to pass rmw implementation specific resources during publisher creation.\n**\n* This field is type erased (rather than forward declared) because it will\n* usually be a non-owned reference to an language specific object, e.g.\n* C++ it may be a polymorphic class that only the rmw implementation can use.\n*\n* The resource pointed to here needs to outlive this options structure, and\n* any rmw_publisher objects that are created using it, as they copy this\n* structure and may use this payload throughout their lifetime.\n*/"]
    pub rmw_specific_publisher_payload: *mut ::std::os::raw::c_void,
    #[doc = " Require middleware to generate unique network flow endpoints.\n**\n* Unique network flow endpoints are required to differentiate the QoS provided by\n* networks for flows between publishers and subscribers in communicating\n* nodes.\n* Default value is RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_NOT_REQUIRED.\n*/"]
    pub require_unique_network_flow_endpoints: rmw_unique_network_flow_endpoints_requirement_t,
}
#[test]
fn bindgen_test_layout_rmw_publisher_options_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_publisher_options_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_publisher_options_s>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_publisher_options_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_publisher_options_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_publisher_options_s))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).rmw_specific_publisher_payload) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_publisher_options_s),
            "::",
            stringify!(rmw_specific_publisher_payload)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).require_unique_network_flow_endpoints) as usize
                - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_publisher_options_s),
            "::",
            stringify!(require_unique_network_flow_endpoints)
        )
    );
}
#[doc = " Options that can be used to configure the creation of a publisher in rmw."]
pub type rmw_publisher_options_t = rmw_publisher_options_s;
#[doc = " Structure which encapsulates an rmw publisher"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_publisher_s {
    #[doc = " Name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Type erased pointer to this publisher's data"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " The name of the ROS topic this publisher publishes to"]
    pub topic_name: *const ::std::os::raw::c_char,
    #[doc = " Publisher options.\n**\n* The options structure passed to rmw_create_publisher() should be\n* assigned to this field by the rmw implementation.\n* The fields should not be modified after creation, but\n* the contents of the options structure may or may not be const, i.e.\n* shallow const-ness.\n* This field is not marked const to avoid any const casting during setup.\n*/"]
    pub options: rmw_publisher_options_t,
    #[doc = " Indicate whether this publisher supports loaning messages"]
    pub can_loan_messages: bool,
}
#[test]
fn bindgen_test_layout_rmw_publisher_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_publisher_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_publisher_s>(),
        48usize,
        concat!("Size of: ", stringify!(rmw_publisher_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_publisher_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_publisher_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_publisher_s),
            "::",
            stringify!(implementation_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_publisher_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topic_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_publisher_s),
            "::",
            stringify!(topic_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_publisher_s),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_loan_messages) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_publisher_s),
            "::",
            stringify!(can_loan_messages)
        )
    );
}
#[doc = " Structure which encapsulates an rmw publisher"]
pub type rmw_publisher_t = rmw_publisher_s;
#[doc = " Options that can be used to configure the creation of a subscription in rmw."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_subscription_options_s {
    #[doc = " Used to pass rmw implementation specific resources during subscription creation.\n**\n* All the same details and restrictions of this field in\n* rmw_publisher_options_t apply to this struct as well.\n*\n* \\sa rmw_publisher_options_t.rmw_specific_publisher_payload\n*/"]
    pub rmw_specific_subscription_payload: *mut ::std::os::raw::c_void,
    #[doc = " If true then the middleware should not deliver data from local publishers.\n**\n* This setting is most often used when data should only be received from\n* remote nodes, especially to avoid \"double delivery\" when both intra- and\n* inter- process communication is taking place.\n*\n* \\todo(wjwwood): nail this down when participant mapping is sorted out.\n*   See: https://github.com/ros2/design/pull/250\n*\n* The definition of local is somewhat vague at the moment.\n* Right now it means local to the node, and that definition works best, but\n* may become more complicated when/if participants map to a context instead.\n*/"]
    pub ignore_local_publications: bool,
    #[doc = " Require middleware to generate unique network flow endpoints.\n**\n* Unique network flow endpoints are required to differentiate the QoS provided by\n* networks for flows between publishers and subscribers in communicating\n* nodes.\n* Default value is RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_NOT_REQUIRED.\n*/"]
    pub require_unique_network_flow_endpoints: rmw_unique_network_flow_endpoints_requirement_t,
    #[doc = " Used to create a content filter options during subscription creation."]
    pub content_filter_options: *mut rmw_subscription_content_filter_options_t,
}
#[test]
fn bindgen_test_layout_rmw_subscription_options_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_subscription_options_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_subscription_options_s>(),
        24usize,
        concat!("Size of: ", stringify!(rmw_subscription_options_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_subscription_options_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_subscription_options_s))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).rmw_specific_subscription_payload) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_subscription_options_s),
            "::",
            stringify!(rmw_specific_subscription_payload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ignore_local_publications) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_subscription_options_s),
            "::",
            stringify!(ignore_local_publications)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).require_unique_network_flow_endpoints) as usize
                - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_subscription_options_s),
            "::",
            stringify!(require_unique_network_flow_endpoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_filter_options) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_subscription_options_s),
            "::",
            stringify!(content_filter_options)
        )
    );
}
#[doc = " Options that can be used to configure the creation of a subscription in rmw."]
pub type rmw_subscription_options_t = rmw_subscription_options_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_subscription_s {
    #[doc = " Name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Type erased pointer to this subscription"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " Name of the ros topic this subscription listens to"]
    pub topic_name: *const ::std::os::raw::c_char,
    #[doc = " Subscription options.\n**\n* The options structure passed to rmw_create_subscription() should be\n* assigned to this field by the rmw implementation.\n* The fields should not be modified after creation, but\n* the contents of the options structure may or may not be const, i.e.\n* shallow const-ness.\n* This field is not marked const to avoid any const casting during setup.\n*/"]
    pub options: rmw_subscription_options_t,
    #[doc = " Indicates whether this subscription can loan messages"]
    pub can_loan_messages: bool,
    #[doc = " Indicates whether content filtered topic of this subscription is enabled"]
    pub is_cft_enabled: bool,
}
#[test]
fn bindgen_test_layout_rmw_subscription_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_subscription_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_subscription_s>(),
        56usize,
        concat!("Size of: ", stringify!(rmw_subscription_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_subscription_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_subscription_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_subscription_s),
            "::",
            stringify!(implementation_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_subscription_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topic_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_subscription_s),
            "::",
            stringify!(topic_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_subscription_s),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_loan_messages) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_subscription_s),
            "::",
            stringify!(can_loan_messages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_cft_enabled) as usize - ptr as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_subscription_s),
            "::",
            stringify!(is_cft_enabled)
        )
    );
}
pub type rmw_subscription_t = rmw_subscription_s;
#[doc = " A handle to an rmw service"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_service_s {
    #[doc = " The name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Type erased pointer to this service"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " The name of this service as exposed to the ros graph"]
    pub service_name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rmw_service_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_service_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_service_s>(),
        24usize,
        concat!("Size of: ", stringify!(rmw_service_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_service_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_service_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_service_s),
            "::",
            stringify!(implementation_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_service_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_service_s),
            "::",
            stringify!(service_name)
        )
    );
}
#[doc = " A handle to an rmw service"]
pub type rmw_service_t = rmw_service_s;
#[doc = " A handle to an rmw service client"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_client_s {
    #[doc = " The name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Type erased pointer to this service client"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " The name of this service as exposed to the ros graph"]
    pub service_name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rmw_client_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_client_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_client_s>(),
        24usize,
        concat!("Size of: ", stringify!(rmw_client_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_client_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_client_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_client_s),
            "::",
            stringify!(implementation_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_client_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_client_s),
            "::",
            stringify!(service_name)
        )
    );
}
#[doc = " A handle to an rmw service client"]
pub type rmw_client_t = rmw_client_s;
#[doc = " Handle for an rmw guard condition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_guard_condition_s {
    #[doc = " The name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Type erased pointer to this guard condition"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " rmw context associated with this guard condition"]
    pub context: *mut rmw_context_t,
}
#[test]
fn bindgen_test_layout_rmw_guard_condition_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_guard_condition_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_guard_condition_s>(),
        24usize,
        concat!("Size of: ", stringify!(rmw_guard_condition_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_guard_condition_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_guard_condition_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_guard_condition_s),
            "::",
            stringify!(implementation_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_guard_condition_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_guard_condition_s),
            "::",
            stringify!(context)
        )
    );
}
#[doc = " Handle for an rmw guard condition"]
pub type rmw_guard_condition_t = rmw_guard_condition_s;
#[doc = " Allocation of memory for an rmw publisher"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_publisher_allocation_s {
    #[doc = " The name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Type erased pointer to this allocation"]
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rmw_publisher_allocation_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_publisher_allocation_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_publisher_allocation_s>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_publisher_allocation_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_publisher_allocation_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_publisher_allocation_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_publisher_allocation_s),
            "::",
            stringify!(implementation_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_publisher_allocation_s),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Allocation of memory for an rmw publisher"]
pub type rmw_publisher_allocation_t = rmw_publisher_allocation_s;
#[doc = " Allocation of memory for an rmw subscription"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_subscription_allocation_s {
    #[doc = " The name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Type erased pointer to this allocation"]
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rmw_subscription_allocation_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_subscription_allocation_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_subscription_allocation_s>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_subscription_allocation_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_subscription_allocation_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_subscription_allocation_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_subscription_allocation_s),
            "::",
            stringify!(implementation_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_subscription_allocation_s),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Allocation of memory for an rmw subscription"]
pub type rmw_subscription_allocation_t = rmw_subscription_allocation_s;
#[doc = " Array of subscriber handles.\n**\n* An array of void * pointers representing type-erased middleware-specific subscriptions.\n* The number of non-null entries may be smaller than the allocated size of the array.\n* The number of subscriptions represented may be smaller than the allocated size of the array.\n* The creator of this struct is responsible for allocating and deallocating the array.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_subscriptions_s {
    #[doc = " The number of subscribers represented by the array."]
    pub subscriber_count: usize,
    #[doc = " Pointer to an array of void * pointers of subscriptions."]
    pub subscribers: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rmw_subscriptions_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_subscriptions_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_subscriptions_s>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_subscriptions_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_subscriptions_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_subscriptions_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subscriber_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_subscriptions_s),
            "::",
            stringify!(subscriber_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subscribers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_subscriptions_s),
            "::",
            stringify!(subscribers)
        )
    );
}
#[doc = " Array of subscriber handles.\n**\n* An array of void * pointers representing type-erased middleware-specific subscriptions.\n* The number of non-null entries may be smaller than the allocated size of the array.\n* The number of subscriptions represented may be smaller than the allocated size of the array.\n* The creator of this struct is responsible for allocating and deallocating the array.\n*/"]
pub type rmw_subscriptions_t = rmw_subscriptions_s;
#[doc = " Array of service handles.\n**\n* An array of void * pointers representing type-erased middleware-specific services.\n* The number of non-null entries may be smaller than the allocated size of the array.\n* The number of services represented may be smaller than the allocated size of the array.\n* The creator of this struct is responsible for allocating and deallocating the array.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_services_s {
    #[doc = " The number of services represented by the array."]
    pub service_count: usize,
    #[doc = " Pointer to an array of void * pointers of services."]
    pub services: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rmw_services_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_services_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_services_s>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_services_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_services_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_services_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_services_s),
            "::",
            stringify!(service_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).services) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_services_s),
            "::",
            stringify!(services)
        )
    );
}
#[doc = " Array of service handles.\n**\n* An array of void * pointers representing type-erased middleware-specific services.\n* The number of non-null entries may be smaller than the allocated size of the array.\n* The number of services represented may be smaller than the allocated size of the array.\n* The creator of this struct is responsible for allocating and deallocating the array.\n*/"]
pub type rmw_services_t = rmw_services_s;
#[doc = " Array of client handles.\n**\n* An array of void * pointers representing type-erased middleware-specific clients.\n* The number of non-null entries may be smaller than the allocated size of the array.\n* The number of clients represented may be smaller than the allocated size of the array.\n* The creator of this struct is responsible for allocating and deallocating the array.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_clients_s {
    #[doc = " The number of clients represented by the array."]
    pub client_count: usize,
    #[doc = " Pointer to an array of void * pointers of clients."]
    pub clients: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rmw_clients_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_clients_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_clients_s>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_clients_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_clients_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_clients_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_clients_s),
            "::",
            stringify!(client_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clients) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_clients_s),
            "::",
            stringify!(clients)
        )
    );
}
#[doc = " Array of client handles.\n**\n* An array of void * pointers representing type-erased middleware-specific clients.\n* The number of non-null entries may be smaller than the allocated size of the array.\n* The number of clients represented may be smaller than the allocated size of the array.\n* The creator of this struct is responsible for allocating and deallocating the array.\n*/"]
pub type rmw_clients_t = rmw_clients_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_events_s {
    #[doc = " The number of events represented by the array."]
    pub event_count: usize,
    #[doc = " Pointer to an array of void * pointers of events."]
    pub events: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rmw_events_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_events_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_events_s>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_events_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_events_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_events_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_events_s),
            "::",
            stringify!(event_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_events_s),
            "::",
            stringify!(events)
        )
    );
}
pub type rmw_events_t = rmw_events_s;
#[doc = " Array of guard condition handles.\n**\n* An array of void * pointers representing type-erased middleware-specific guard conditions.\n* The number of non-null entries may be smaller than the allocated size of the array.\n* The number of guard conditions represented may be smaller than the allocated size of the array.\n* The creator of this struct is responsible for allocating and deallocating the array.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_guard_conditions_s {
    #[doc = " The number of guard conditions represented by the array."]
    pub guard_condition_count: usize,
    #[doc = " Pointer to an array of void * pointers of guard conditions."]
    pub guard_conditions: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rmw_guard_conditions_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_guard_conditions_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_guard_conditions_s>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_guard_conditions_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_guard_conditions_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_guard_conditions_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guard_condition_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_guard_conditions_s),
            "::",
            stringify!(guard_condition_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guard_conditions) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_guard_conditions_s),
            "::",
            stringify!(guard_conditions)
        )
    );
}
#[doc = " Array of guard condition handles.\n**\n* An array of void * pointers representing type-erased middleware-specific guard conditions.\n* The number of non-null entries may be smaller than the allocated size of the array.\n* The number of guard conditions represented may be smaller than the allocated size of the array.\n* The creator of this struct is responsible for allocating and deallocating the array.\n*/"]
pub type rmw_guard_conditions_t = rmw_guard_conditions_s;
#[doc = " Container for guard conditions to be waited on"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_wait_set_s {
    #[doc = " The name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " The guard condition to be waited on"]
    pub guard_conditions: *mut rmw_guard_conditions_t,
    #[doc = " Type erased pointer to this wait set's data"]
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rmw_wait_set_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_wait_set_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_wait_set_s>(),
        24usize,
        concat!("Size of: ", stringify!(rmw_wait_set_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_wait_set_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_wait_set_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_wait_set_s),
            "::",
            stringify!(implementation_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guard_conditions) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_wait_set_s),
            "::",
            stringify!(guard_conditions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_wait_set_s),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Container for guard conditions to be waited on"]
pub type rmw_wait_set_t = rmw_wait_set_s;
#[doc = " An rmw service request identifier"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_request_id_s {
    #[doc = " The guid of the writer associated with this request"]
    pub writer_guid: [u8; 16usize],
    #[doc = " Sequence number of this service"]
    pub sequence_number: i64,
}
#[test]
fn bindgen_test_layout_rmw_request_id_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_request_id_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_request_id_s>(),
        24usize,
        concat!("Size of: ", stringify!(rmw_request_id_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_request_id_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_request_id_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writer_guid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_request_id_s),
            "::",
            stringify!(writer_guid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence_number) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_request_id_s),
            "::",
            stringify!(sequence_number)
        )
    );
}
#[doc = " An rmw service request identifier"]
pub type rmw_request_id_t = rmw_request_id_s;
#[doc = " Meta-data for a service-related take."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_service_info_s {
    pub source_timestamp: rmw_time_point_value_t,
    pub received_timestamp: rmw_time_point_value_t,
    pub request_id: rmw_request_id_t,
}
#[test]
fn bindgen_test_layout_rmw_service_info_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_service_info_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_service_info_s>(),
        40usize,
        concat!("Size of: ", stringify!(rmw_service_info_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_service_info_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_service_info_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_timestamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_service_info_s),
            "::",
            stringify!(source_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).received_timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_service_info_s),
            "::",
            stringify!(received_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_service_info_s),
            "::",
            stringify!(request_id)
        )
    );
}
#[doc = " Meta-data for a service-related take."]
pub type rmw_service_info_t = rmw_service_info_s;
#[doc = " Implementation specific default"]
pub const rmw_qos_reliability_policy_e_RMW_QOS_POLICY_RELIABILITY_SYSTEM_DEFAULT:
    rmw_qos_reliability_policy_e = 0;
#[doc = " Guarantee that samples are delivered, may retry multiple times."]
pub const rmw_qos_reliability_policy_e_RMW_QOS_POLICY_RELIABILITY_RELIABLE:
    rmw_qos_reliability_policy_e = 1;
#[doc = " Attempt to deliver samples, but some may be lost if the network is not robust"]
pub const rmw_qos_reliability_policy_e_RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT:
    rmw_qos_reliability_policy_e = 2;
#[doc = " Reliability policy has not yet been set"]
pub const rmw_qos_reliability_policy_e_RMW_QOS_POLICY_RELIABILITY_UNKNOWN:
    rmw_qos_reliability_policy_e = 3;
#[doc = " Will match the majority of endpoints and use a reliable policy if possible\n**\n* A policy will be chosen at the time of creating a subscription or publisher.\n* A reliable policy will by chosen if it matches with all discovered endpoints,\n* otherwise a best effort policy will be chosen.\n*\n* The QoS policy reported by functions like `rmw_subscription_get_actual_qos` or\n* `rmw_publisher_get_actual_qos` may be best available, reliable, or best effort.\n*\n* Services and clients are not supported and default to the reliability value in\n* `rmw_qos_profile_services_default`.\n*\n* The middleware is not expected to update the policy after creating a subscription or\n* publisher, even if the chosen policy is incompatible with newly discovered endpoints.\n* Therefore, this policy should be used with care since non-deterministic behavior\n* can occur due to races with discovery.\n*/"]
pub const rmw_qos_reliability_policy_e_RMW_QOS_POLICY_RELIABILITY_BEST_AVAILABLE:
    rmw_qos_reliability_policy_e = 4;
pub type rmw_qos_reliability_policy_e = ::std::os::raw::c_uint;
pub use self::rmw_qos_reliability_policy_e as rmw_qos_reliability_policy_t;
#[doc = " Implementation default for history policy"]
pub const rmw_qos_history_policy_e_RMW_QOS_POLICY_HISTORY_SYSTEM_DEFAULT: rmw_qos_history_policy_e =
    0;
#[doc = " Only store up to a maximum number of samples, dropping oldest once max is exceeded"]
pub const rmw_qos_history_policy_e_RMW_QOS_POLICY_HISTORY_KEEP_LAST: rmw_qos_history_policy_e = 1;
#[doc = " Store all samples, subject to resource limits"]
pub const rmw_qos_history_policy_e_RMW_QOS_POLICY_HISTORY_KEEP_ALL: rmw_qos_history_policy_e = 2;
#[doc = " History policy has not yet been set"]
pub const rmw_qos_history_policy_e_RMW_QOS_POLICY_HISTORY_UNKNOWN: rmw_qos_history_policy_e = 3;
#[doc = " QoS history enumerations describing how samples endure"]
pub type rmw_qos_history_policy_e = ::std::os::raw::c_uint;
#[doc = " QoS history enumerations describing how samples endure"]
pub use self::rmw_qos_history_policy_e as rmw_qos_history_policy_t;
#[doc = " Impplementation specific default"]
pub const rmw_qos_durability_policy_e_RMW_QOS_POLICY_DURABILITY_SYSTEM_DEFAULT:
    rmw_qos_durability_policy_e = 0;
#[doc = " The rmw publisher is responsible for persisting samples for late-joining subscribers"]
pub const rmw_qos_durability_policy_e_RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL:
    rmw_qos_durability_policy_e = 1;
#[doc = " Samples are not persistent"]
pub const rmw_qos_durability_policy_e_RMW_QOS_POLICY_DURABILITY_VOLATILE:
    rmw_qos_durability_policy_e = 2;
#[doc = " Durability policy has not yet been set"]
pub const rmw_qos_durability_policy_e_RMW_QOS_POLICY_DURABILITY_UNKNOWN:
    rmw_qos_durability_policy_e = 3;
#[doc = " Will match the majority of endpoints and use a transient local policy if possible\n**\n* A policy will be chosen at the time of creating a subscription or publisher.\n* A transient local policy will by chosen if it matches with all discovered endpoints,\n* otherwise a volatile policy will be chosen.\n*\n* In the case that a volatile policy is chosen for a subscription, any messages sent before\n* the subscription was created by transient local publishers will not be received.\n*\n* The QoS policy reported by functions like `rmw_subscription_get_actual_qos` or\n* `rmw_publisher_get_actual_qos` may be best available, transient local, or volatile.\n*\n* Services and clients are not supported and default to the durability value in\n* `rmw_qos_profile_services_default`.\n*\n* The middleware is not expected to update the policy after creating a subscription or\n* publisher, even if the chosen policy is incompatible with newly discovered endpoints.\n* Therefore, this policy should be used with care since non-deterministic behavior\n* can occur due to races with discovery.\n*/"]
pub const rmw_qos_durability_policy_e_RMW_QOS_POLICY_DURABILITY_BEST_AVAILABLE:
    rmw_qos_durability_policy_e = 4;
#[doc = " QoS durability enumerations describing how samples persist"]
pub type rmw_qos_durability_policy_e = ::std::os::raw::c_uint;
#[doc = " QoS durability enumerations describing how samples persist"]
pub use self::rmw_qos_durability_policy_e as rmw_qos_durability_policy_t;
#[doc = " Implementation specific default"]
pub const rmw_qos_liveliness_policy_e_RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT:
    rmw_qos_liveliness_policy_e = 0;
#[doc = " The signal that establishes a Topic is alive comes from the ROS rmw layer."]
pub const rmw_qos_liveliness_policy_e_RMW_QOS_POLICY_LIVELINESS_AUTOMATIC:
    rmw_qos_liveliness_policy_e = 1;
pub const rmw_qos_liveliness_policy_e_RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE:
    rmw_qos_liveliness_policy_e = 2;
#[doc = " The signal that establishes a Topic is alive is at the Topic level. Only publishing a message\n on the Topic or an explicit signal from the application to assert liveliness on the Topic\n will mark the Topic as being alive."]
pub const rmw_qos_liveliness_policy_e_RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC:
    rmw_qos_liveliness_policy_e = 3;
#[doc = " Liveliness policy has not yet been set"]
pub const rmw_qos_liveliness_policy_e_RMW_QOS_POLICY_LIVELINESS_UNKNOWN:
    rmw_qos_liveliness_policy_e = 4;
#[doc = " Will match the majority of endpoints and use a manual by topic policy if possible\n**\n* A policy will be chosen at the time of creating a subscription or publisher.\n* A manual by topic policy will by chosen if it matches with all discovered endpoints,\n* otherwise an automatic policy will be chosen.\n*\n* The QoS policy reported by functions like `rmw_subscription_get_actual_qos` or\n* `rmw_publisher_get_actual_qos` may be best available, automatic, or manual by topic.\n*\n* Services and clients are not supported and default to the liveliness value in\n* `rmw_qos_profile_services_default`.\n*\n* The middleware is not expected to update the policy after creating a subscription or\n* publisher, even if the chosen policy is incompatible with newly discovered endpoints.\n* Therefore, this policy should be used with care since non-deterministic behavior\n* can occur due to races with discovery.\n*/"]
pub const rmw_qos_liveliness_policy_e_RMW_QOS_POLICY_LIVELINESS_BEST_AVAILABLE:
    rmw_qos_liveliness_policy_e = 5;
#[doc = " QoS liveliness enumerations that describe a publisher's reporting policy for its alive status.\n For a subscriber, these are its requirements for its topic's publishers."]
pub type rmw_qos_liveliness_policy_e = ::std::os::raw::c_uint;
#[doc = " QoS liveliness enumerations that describe a publisher's reporting policy for its alive status.\n For a subscriber, these are its requirements for its topic's publishers."]
pub use self::rmw_qos_liveliness_policy_e as rmw_qos_liveliness_policy_t;
#[doc = " ROS MiddleWare quality of service profile."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_qos_profile_s {
    pub history: rmw_qos_history_policy_e,
    #[doc = " Size of the message queue."]
    pub depth: usize,
    #[doc = " Reliabiilty QoS policy setting"]
    pub reliability: rmw_qos_reliability_policy_e,
    #[doc = " Durability QoS policy setting"]
    pub durability: rmw_qos_durability_policy_e,
    #[doc = " The period at which messages are expected to be sent/received\n**\n* RMW_DURATION_UNSPEFICIED will use the RMW implementation's default value,\n*   which may or may not be infinite.\n* RMW_DURATION_INFINITE explicitly states that messages never miss a deadline expectation.\n*/"]
    pub deadline: rmw_time_s,
    #[doc = " The age at which messages are considered expired and no longer valid\n**\n* RMW_DURATION_UNSPEFICIED will use the RMW implementation's default value,\n*   which may or may not be infinite.\n* RMW_DURATION_INFINITE explicitly states that messages do not expire.\n*/"]
    pub lifespan: rmw_time_s,
    #[doc = " Liveliness QoS policy setting"]
    pub liveliness: rmw_qos_liveliness_policy_e,
    #[doc = " The time within which the RMW node or publisher must show that it is alive\n**\n* RMW_DURATION_UNSPEFICIED will use the RMW implementation's default value,\n*   which may or may not be infinite.\n* RMW_DURATION_INFINITE explicitly states that liveliness is not enforced.\n*/"]
    pub liveliness_lease_duration: rmw_time_s,
    #[doc = " If true, any ROS specific namespacing conventions will be circumvented.\n**\n* In the case of DDS and topics, for example, this means the typical\n* ROS specific prefix of `rt` would not be applied as described here:\n*\n*   http://design.ros2.org/articles/topic_and_service_names.html#ros-specific-namespace-prefix\n*\n* This might be useful when trying to directly connect a native DDS topic\n* with a ROS 2 topic.\n*/"]
    pub avoid_ros_namespace_conventions: bool,
}
#[test]
fn bindgen_test_layout_rmw_qos_profile_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_qos_profile_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_qos_profile_s>(),
        88usize,
        concat!("Size of: ", stringify!(rmw_qos_profile_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_qos_profile_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_qos_profile_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).history) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_qos_profile_s),
            "::",
            stringify!(history)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_qos_profile_s),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reliability) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_qos_profile_s),
            "::",
            stringify!(reliability)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).durability) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_qos_profile_s),
            "::",
            stringify!(durability)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deadline) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_qos_profile_s),
            "::",
            stringify!(deadline)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lifespan) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_qos_profile_s),
            "::",
            stringify!(lifespan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).liveliness) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_qos_profile_s),
            "::",
            stringify!(liveliness)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).liveliness_lease_duration) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_qos_profile_s),
            "::",
            stringify!(liveliness_lease_duration)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).avoid_ros_namespace_conventions) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_qos_profile_s),
            "::",
            stringify!(avoid_ros_namespace_conventions)
        )
    );
}
#[doc = " ROS MiddleWare quality of service profile."]
pub type rmw_qos_profile_t = rmw_qos_profile_s;
#[doc = " Globally unique identifier for a ROS graph entity\n**\n* This is expected to be globally unique within a ROS domain.\n* The identifier should be the same when reported both locally (where the entity was created)\n* and on remote hosts or processes.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_gid_s {
    #[doc = " Name of the rmw implementation"]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Byte data GID value"]
    pub data: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_rmw_gid_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_gid_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_gid_s>(),
        24usize,
        concat!("Size of: ", stringify!(rmw_gid_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_gid_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_gid_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_gid_s),
            "::",
            stringify!(implementation_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_gid_s),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Globally unique identifier for a ROS graph entity\n**\n* This is expected to be globally unique within a ROS domain.\n* The identifier should be the same when reported both locally (where the entity was created)\n* and on remote hosts or processes.\n*/"]
pub type rmw_gid_t = rmw_gid_s;
#[doc = " Information describing an rmw message"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_message_info_s {
    #[doc = " Time when the message was published by the publisher.\n**\n* The exact point at which the timestamp is taken is not specified, but\n* it should be taken consistently at the same point in the\n* publishing process each time.\n*/"]
    pub source_timestamp: rmw_time_point_value_t,
    #[doc = " Time when the message was received by the subscription.\n**\n* The exact point at which the timestamp is taken is not specified, but\n* it should be taken consistently at the same point in the\n* process of receiving a message each time.\n*/"]
    pub received_timestamp: rmw_time_point_value_t,
    #[doc = " Sequence number of the received message set by the publisher.\n**\n* This sequence number is set by the publisher and therefore uniquely identifies\n* a message when combined with the publisher GID.\n* For long running applications, the sequence number might wrap around at some point.\n*\n* If the rmw implementation doesn't support sequence numbers, its value will be\n* RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED.\n*\n* Requirements:\n*\n* If `psn1` and `psn2` are the publication sequence numbers obtained by\n* calls to `rmw_take*()`, where `psn1` was obtained in a call that happened before `psn2` and both\n* sequence numbers are from the same publisher (i.e. also same publisher gid), then:\n*\n* - psn2 > psn1 (except in the case of a wrap around)\n* - `psn2 - psn1 - 1` is the number of messages the publisher sent in the middle of both\n*   received messages.\n*   Those might have already been taken by other `rmw_take*()` calls that happened in between or lost.\n*   `psn2 - psn1 - 1 = 0` if and only if the messages were sent by the publisher consecutively.\n*/"]
    pub publication_sequence_number: u64,
    #[doc = " Sequence number of the received message set by the subscription.\n**\n* This sequence number is set by the subscription regardless of which\n* publisher sent the message.\n* For long running applications, the sequence number might wrap around at some point.\n*\n* If the rmw implementation doesn't support sequence numbers, its value will be\n* RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED.\n*\n* Requirements:\n*\n* If `rsn1` and `rsn2` are the reception sequence numbers obtained by\n* calls to `rmw_take*()`, where `rsn1` was obtained in a call that happened before `rsn2`, then:\n*\n* - rsn2 > rsn1 (except in the case of a wrap around)\n* - `rsn2 = rsn1 + 1` if and only if both `rmw_take*()` calls happened consecutively.\n*/"]
    pub reception_sequence_number: u64,
    #[doc = " Global unique identifier of the publisher that sent the message.\n**\n* The identifier uniquely identifies the publisher for the local context, but\n* it will not necessarily be the same identifier given in other contexts or processes\n* for the same publisher.\n* Therefore the identifier will uniquely identify the publisher within your application\n* but may disagree about the identifier for that publisher when compared to another\n* application.\n* Even with this limitation, when combined with the publisher sequence number it can\n* uniquely identify a message within your local context.\n* Publisher GIDs generated by the rmw implementation could collide at some point, in which\n* case it is not possible to distinguish which publisher sent the message.\n* The details of how GIDs are generated are rmw implementation dependent.\n*\n* It is possible the the rmw implementation needs to reuse a publisher GID,\n* due to running out of unique identifiers or some other constraint, in which case\n* the rmw implementation may document what happens in that case, but that\n* behavior is not defined here.\n* However, this should be avoided, if at all possible, by the rmw implementation,\n* and should be unlikely to happen in practice.\n*\n* \\todo In the future we want this to uniquely identify the publisher globally across\n*   contexts, processes, and machines.\n*/"]
    pub publisher_gid: rmw_gid_t,
    #[doc = " Whether this message is from intra_process communication or not"]
    pub from_intra_process: bool,
}
#[test]
fn bindgen_test_layout_rmw_message_info_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_message_info_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_message_info_s>(),
        64usize,
        concat!("Size of: ", stringify!(rmw_message_info_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_message_info_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_message_info_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_timestamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_message_info_s),
            "::",
            stringify!(source_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).received_timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_message_info_s),
            "::",
            stringify!(received_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).publication_sequence_number) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_message_info_s),
            "::",
            stringify!(publication_sequence_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reception_sequence_number) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_message_info_s),
            "::",
            stringify!(reception_sequence_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).publisher_gid) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_message_info_s),
            "::",
            stringify!(publisher_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).from_intra_process) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_message_info_s),
            "::",
            stringify!(from_intra_process)
        )
    );
}
#[doc = " Information describing an rmw message"]
pub type rmw_message_info_t = rmw_message_info_s;
extern "C" {
    #[doc = " Get zero initialized mesage info."]
    pub fn rmw_get_zero_initialized_message_info() -> rmw_message_info_t;
}
pub const RMW_QOS_POLICY_DEPTH_SYSTEM_DEFAULT: _bindgen_ty_1 = 0;
#[doc = " Default size of the rmw queue when history is set to RMW_QOS_POLICY_HISTORY_KEEP_LAST,\n 0 indicates it is currently not set"]
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[doc = " Debug log severity, for pedantic messaging"]
pub const rmw_log_severity_t_RMW_LOG_SEVERITY_DEBUG: rmw_log_severity_t = 10;
#[doc = " Informational log severity, for reporting expected but not overwhelming information"]
pub const rmw_log_severity_t_RMW_LOG_SEVERITY_INFO: rmw_log_severity_t = 20;
#[doc = " Warning log severity, for reporting recoverable issues"]
pub const rmw_log_severity_t_RMW_LOG_SEVERITY_WARN: rmw_log_severity_t = 30;
#[doc = " Error log severity, for reporting uncoverable issues"]
pub const rmw_log_severity_t_RMW_LOG_SEVERITY_ERROR: rmw_log_severity_t = 40;
#[doc = " Fatal log severity, for reporting issue causing imminent shutdown"]
pub const rmw_log_severity_t_RMW_LOG_SEVERITY_FATAL: rmw_log_severity_t = 50;
#[doc = " Type mapping of rcutils log severity types to rmw specific types."]
pub type rmw_log_severity_t = ::std::os::raw::c_uint;
#[doc = " The type that holds an rcl return code."]
pub type rcl_ret_t = rmw_ret_t;
#[doc = " typedef for rmw_serialized_message_t;"]
pub type rcl_serialized_message_t = rmw_serialized_message_t;
#[doc = " typedef for RCUTILS_LOG_SEVERITY;"]
pub use self::RCUTILS_LOG_SEVERITY as rcl_log_severity_t;
#[doc = " A logger item to specify a name and a log level."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_logger_setting_s {
    #[doc = " Name for the logger."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Minimum log level severity of the logger."]
    pub level: rcl_log_severity_t,
}
#[test]
fn bindgen_test_layout_rcl_logger_setting_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_logger_setting_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_logger_setting_s>(),
        16usize,
        concat!("Size of: ", stringify!(rcl_logger_setting_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_logger_setting_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_logger_setting_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_logger_setting_s),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_logger_setting_s),
            "::",
            stringify!(level)
        )
    );
}
#[doc = " A logger item to specify a name and a log level."]
pub type rcl_logger_setting_t = rcl_logger_setting_s;
#[doc = " Hold default logger level and other logger setting."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_log_levels_s {
    #[doc = " Minimum default logger level severity."]
    pub default_logger_level: rcl_log_severity_t,
    #[doc = " Array of logger setting."]
    pub logger_settings: *mut rcl_logger_setting_t,
    #[doc = " Number of logger settings."]
    pub num_logger_settings: usize,
    #[doc = " Capacity of logger settings."]
    pub capacity_logger_settings: usize,
    #[doc = " Allocator used to allocate objects in this struct."]
    pub allocator: rcl_allocator_t,
}
#[test]
fn bindgen_test_layout_rcl_log_levels_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_log_levels_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_log_levels_s>(),
        72usize,
        concat!("Size of: ", stringify!(rcl_log_levels_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_log_levels_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_log_levels_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_logger_level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_log_levels_s),
            "::",
            stringify!(default_logger_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logger_settings) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_log_levels_s),
            "::",
            stringify!(logger_settings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_logger_settings) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_log_levels_s),
            "::",
            stringify!(num_logger_settings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity_logger_settings) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_log_levels_s),
            "::",
            stringify!(capacity_logger_settings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_log_levels_s),
            "::",
            stringify!(allocator)
        )
    );
}
#[doc = " Hold default logger level and other logger setting."]
pub type rcl_log_levels_t = rcl_log_levels_s;
extern "C" {
    #[doc = " Return a rcl_log_levels_t struct with members initialized to zero value.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\return a rcl_log_levels_t struct with members initialized to zero value.\n*/"]
    pub fn rcl_get_zero_initialized_log_levels() -> rcl_log_levels_t;
}
extern "C" {
    #[doc = " Initialize a log levels structure.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] log_levels The structure to be initialized.\n* \\param[in] allocator Memory allocator to be used and assigned into log_levels.\n* \\param[in] logger_count Number of logger settings to be allocated.\n*  This reserves memory for logger_settings, but doesn't initialize it.\n* \\return #RCL_RET_OK if the structure was initialized successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if log_levels is NULL, or\n* \\return #RCL_RET_INVALID_ARGUMENT if log_levels contains initialized memory, or\n* \\return #RCL_RET_INVALID_ARGUMENT if allocator is invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed.\n*/"]
    pub fn rcl_log_levels_init(
        log_levels: *mut rcl_log_levels_t,
        allocator: *const rcl_allocator_t,
        logger_count: usize,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Copy one log levels structure into another.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] src The structure to be copied.\n*  Its allocator is used to copy memory into the new structure.\n* \\param[out] dst A log levels structure to be copied into.\n* \\return #RCL_RET_OK if the structure was copied successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if src is NULL, or\n* \\return #RCL_RET_INVALID_ARGUMENT if src allocator is invalid, or\n* \\return #RCL_RET_INVALID_ARGUMENT if dst is NULL, or\n* \\return #RCL_RET_INVALID_ARGUMENT if dst contains already allocated memory, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed.\n*/"]
    pub fn rcl_log_levels_copy(
        src: *const rcl_log_levels_t,
        dst: *mut rcl_log_levels_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Reclaim resources held inside rcl_log_levels_t structure.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] log_levels The structure which its resources have to be deallocated.\n* \\return #RCL_RET_OK if the memory was successfully freed, or\n* \\return #RCL_RET_INVALID_ARGUMENT if log_levels is NULL, or\n* \\return #RCL_RET_INVALID_ARGUMENT if the log_levels allocator is invalid and the structure contains initialized memory.\n*/"]
    pub fn rcl_log_levels_fini(log_levels: *mut rcl_log_levels_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Shrink log levels structure.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] log_levels The structure to be shrunk.\n* \\return #RCL_RET_OK if the memory was successfully shrunk, or\n* \\return #RCL_RET_INVALID_ARGUMENT if log_levels is NULL or if its allocator is invalid, or\n* \\return #RCL_RET_BAD_ALLOC if reallocating memory failed.\n*/"]
    pub fn rcl_log_levels_shrink_to_size(log_levels: *mut rcl_log_levels_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Add logger setting with a name and a level.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] log_levels The structure where to set the logger log level.\n* \\param[in] logger_name Name for the logger, a copy of it will be stored in the structure.\n* \\param[in] log_level Minimum log level severity to be set for logger_name.\n* \\return #RCL_RET_OK if add logger setting successfully, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_INVALID_ARGUMENT if log_levels is NULL, or\n* \\return #RCL_RET_INVALID_ARGUMENT if log_levels was not initialized, or\n* \\return #RCL_RET_INVALID_ARGUMENT if log_levels allocator is invalid, or\n* \\return #RCL_RET_INVALID_ARGUMENT if logger_name is NULL, or\n* \\return #RCL_RET_ERROR if the log_levels structure is already full.\n*/"]
    pub fn rcl_log_levels_add_logger_setting(
        log_levels: *mut rcl_log_levels_t,
        logger_name: *const ::std::os::raw::c_char,
        log_level: rcl_log_severity_t,
    ) -> rcl_ret_t;
}
#[doc = " Array of bool values"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_bool_array_s {
    #[doc = " Array with bool values"]
    pub values: *mut bool,
    #[doc = " Number of values in the array"]
    pub size: usize,
}
#[test]
fn bindgen_test_layout_rcl_bool_array_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_bool_array_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_bool_array_s>(),
        16usize,
        concat!("Size of: ", stringify!(rcl_bool_array_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_bool_array_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_bool_array_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_bool_array_s),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_bool_array_s),
            "::",
            stringify!(size)
        )
    );
}
#[doc = " Array of bool values"]
pub type rcl_bool_array_t = rcl_bool_array_s;
#[doc = " Array of int64_t values"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_int64_array_s {
    #[doc = " Array with int64 values"]
    pub values: *mut i64,
    #[doc = " Number of values in the array"]
    pub size: usize,
}
#[test]
fn bindgen_test_layout_rcl_int64_array_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_int64_array_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_int64_array_s>(),
        16usize,
        concat!("Size of: ", stringify!(rcl_int64_array_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_int64_array_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_int64_array_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_int64_array_s),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_int64_array_s),
            "::",
            stringify!(size)
        )
    );
}
#[doc = " Array of int64_t values"]
pub type rcl_int64_array_t = rcl_int64_array_s;
#[doc = " Array of double values"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_double_array_s {
    #[doc = " Array with double values"]
    pub values: *mut f64,
    #[doc = " Number of values in the array"]
    pub size: usize,
}
#[test]
fn bindgen_test_layout_rcl_double_array_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_double_array_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_double_array_s>(),
        16usize,
        concat!("Size of: ", stringify!(rcl_double_array_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_double_array_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_double_array_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_double_array_s),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_double_array_s),
            "::",
            stringify!(size)
        )
    );
}
#[doc = " Array of double values"]
pub type rcl_double_array_t = rcl_double_array_s;
#[doc = " Array of byte values"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_byte_array_s {
    #[doc = " Array with uint8_t values"]
    pub values: *mut u8,
    #[doc = " Number of values in the array"]
    pub size: usize,
}
#[test]
fn bindgen_test_layout_rcl_byte_array_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_byte_array_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_byte_array_s>(),
        16usize,
        concat!("Size of: ", stringify!(rcl_byte_array_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_byte_array_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_byte_array_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_byte_array_s),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_byte_array_s),
            "::",
            stringify!(size)
        )
    );
}
#[doc = " Array of byte values"]
pub type rcl_byte_array_t = rcl_byte_array_s;
#[doc = " variant_t stores the value of a parameter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_variant_s {
    #[doc = "< If bool, gets stored here"]
    pub bool_value: *mut bool,
    #[doc = "< If integer, gets stored here"]
    pub integer_value: *mut i64,
    #[doc = "< If double, gets stored here"]
    pub double_value: *mut f64,
    #[doc = "< If string, gets stored here"]
    pub string_value: *mut ::std::os::raw::c_char,
    #[doc = "< If array of bytes"]
    pub byte_array_value: *mut rcl_byte_array_t,
    #[doc = "< If array of bool's"]
    pub bool_array_value: *mut rcl_bool_array_t,
    #[doc = "< If array of integers"]
    pub integer_array_value: *mut rcl_int64_array_t,
    #[doc = "< If array of doubles"]
    pub double_array_value: *mut rcl_double_array_t,
    #[doc = "< If array of strings"]
    pub string_array_value: *mut rcutils_string_array_t,
}
#[test]
fn bindgen_test_layout_rcl_variant_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_variant_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_variant_s>(),
        72usize,
        concat!("Size of: ", stringify!(rcl_variant_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_variant_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_variant_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bool_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_variant_s),
            "::",
            stringify!(bool_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).integer_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_variant_s),
            "::",
            stringify!(integer_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).double_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_variant_s),
            "::",
            stringify!(double_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string_value) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_variant_s),
            "::",
            stringify!(string_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte_array_value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_variant_s),
            "::",
            stringify!(byte_array_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bool_array_value) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_variant_s),
            "::",
            stringify!(bool_array_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).integer_array_value) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_variant_s),
            "::",
            stringify!(integer_array_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).double_array_value) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_variant_s),
            "::",
            stringify!(double_array_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string_array_value) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_variant_s),
            "::",
            stringify!(string_array_value)
        )
    );
}
#[doc = " variant_t stores the value of a parameter"]
pub type rcl_variant_t = rcl_variant_s;
#[doc = " node_params_t stores all the parameters(key:value) of a single node"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_node_params_s {
    #[doc = "< Array of parameter names (keys)"]
    pub parameter_names: *mut *mut ::std::os::raw::c_char,
    #[doc = "< Array of coressponding parameter values"]
    pub parameter_values: *mut rcl_variant_t,
    #[doc = "< Number of parameters in the node"]
    pub num_params: usize,
    #[doc = "< Capacity of parameters in the node"]
    pub capacity_params: usize,
}
#[test]
fn bindgen_test_layout_rcl_node_params_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_node_params_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_node_params_s>(),
        32usize,
        concat!("Size of: ", stringify!(rcl_node_params_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_node_params_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_node_params_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parameter_names) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_node_params_s),
            "::",
            stringify!(parameter_names)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parameter_values) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_node_params_s),
            "::",
            stringify!(parameter_values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_params) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_node_params_s),
            "::",
            stringify!(num_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity_params) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_node_params_s),
            "::",
            stringify!(capacity_params)
        )
    );
}
#[doc = " node_params_t stores all the parameters(key:value) of a single node"]
pub type rcl_node_params_t = rcl_node_params_s;
#[doc = " stores all the parameters of all nodes of a process"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_params_s {
    #[doc = "< List of names of the node"]
    pub node_names: *mut *mut ::std::os::raw::c_char,
    #[doc = "<  Array of parameters"]
    pub params: *mut rcl_node_params_t,
    #[doc = "< Number of nodes"]
    pub num_nodes: usize,
    #[doc = "< Capacity of nodes"]
    pub capacity_nodes: usize,
    #[doc = "< Allocator used"]
    pub allocator: rcutils_allocator_t,
}
#[test]
fn bindgen_test_layout_rcl_params_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_params_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_params_s>(),
        72usize,
        concat!("Size of: ", stringify!(rcl_params_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_params_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_params_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_names) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_params_s),
            "::",
            stringify!(node_names)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_params_s),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_nodes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_params_s),
            "::",
            stringify!(num_nodes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity_nodes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_params_s),
            "::",
            stringify!(capacity_nodes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_params_s),
            "::",
            stringify!(allocator)
        )
    );
}
#[doc = " stores all the parameters of all nodes of a process"]
pub type rcl_params_t = rcl_params_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_arguments_impl_s {
    _unused: [u8; 0],
}
pub type rcl_arguments_impl_t = rcl_arguments_impl_s;
#[doc = " Hold output of parsing command line arguments."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_arguments_s {
    #[doc = " Private implementation pointer."]
    pub impl_: *mut rcl_arguments_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_arguments_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_arguments_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_arguments_s>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_arguments_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_arguments_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_arguments_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_arguments_s),
            "::",
            stringify!(impl_)
        )
    );
}
#[doc = " Hold output of parsing command line arguments."]
pub type rcl_arguments_t = rcl_arguments_s;
extern "C" {
    #[doc = " Return a rcl_arguments_t struct with members initialized to `NULL`."]
    pub fn rcl_get_zero_initialized_arguments() -> rcl_arguments_t;
}
extern "C" {
    #[doc = " Parse command line arguments into a structure usable by code.\n**\n* \\sa rcl_get_zero_initialized_arguments()\n*\n* ROS arguments are expected to be scoped by a leading `--ros-args` flag and a trailing double\n* dash token `--` which may be elided if no non-ROS arguments follow after the last `--ros-args`.\n*\n* Remap rule parsing is supported via `-r/--remap` flags e.g. `--remap from:=to` or `-r from:=to`.\n* Successfully parsed remap rules are stored in the order they were given in `argv`.\n* If given arguments `{\"__ns:=/foo\", \"__ns:=/bar\"}` then the namespace used by nodes in this\n* process will be `/foo` and not `/bar`.\n*\n* \\sa rcl_remap_topic_name()\n* \\sa rcl_remap_service_name()\n* \\sa rcl_remap_node_name()\n* \\sa rcl_remap_node_namespace()\n*\n* Parameter override rule parsing is supported via `-p/--param` flags e.g. `--param name:=value`\n* or `-p name:=value`.\n*\n* The default log level will be parsed as `--log-level level` and logger levels will be parsed as\n* multiple `--log-level name:=level`, where `level` is a name representing one of the log levels\n* in the `RCUTILS_LOG_SEVERITY` enum, e.g. `info`, `debug`, `warn`, not case sensitive.\n* If multiple of these rules are found, the last one parsed will be used.\n*\n* If an argument does not appear to be a valid ROS argument e.g. a `-r/--remap` flag followed by\n* anything but a valid remap rule, parsing will fail immediately.\n*\n* If an argument does not appear to be a known ROS argument, then it is skipped and left unparsed.\n*\n* \\sa rcl_arguments_get_count_unparsed_ros()\n* \\sa rcl_arguments_get_unparsed_ros()\n*\n* All arguments found outside a `--ros-args ... --` scope are skipped and left unparsed.\n*\n* \\sa rcl_arguments_get_count_unparsed()\n* \\sa rcl_arguments_get_unparsed()\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] argc The number of arguments in argv.\n* \\param[in] argv The values of the arguments.\n* \\param[in] allocator A valid allocator.\n* \\param[out] args_output A structure that will contain the result of parsing.\n*   Must be zero initialized before use.\n* \\return #RCL_RET_OK if the arguments were parsed successfully, or\n* \\return #RCL_RET_INVALID_ROS_ARGS if an invalid ROS argument is found, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_parse_arguments(
        argc: ::std::os::raw::c_int,
        argv: *const *const ::std::os::raw::c_char,
        allocator: rcl_allocator_t,
        args_output: *mut rcl_arguments_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the number of arguments that were not ROS specific arguments.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] args An arguments structure that has been parsed.\n* \\return number of unparsed arguments, or\n* \\return -1 if args is `NULL` or zero initialized.\n*/"]
    pub fn rcl_arguments_get_count_unparsed(args: *const rcl_arguments_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a list of indices to non ROS specific arguments.\n**\n* Non ROS specific arguments may have been provided i.e. arguments outside a '--ros-args' scope.\n* This function populates an array of indices to these arguments in the original argv array.\n* Since the first argument is always assumed to be a process name, the list will always contain\n* the index 0.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] args An arguments structure that has been parsed.\n* \\param[in] allocator A valid allocator.\n* \\param[out] output_unparsed_indices An allocated array of indices into the original argv array.\n*   This array must be deallocated by the caller using the given allocator.\n*   If there are no unparsed args then the output will be set to NULL.\n* \\return #RCL_RET_OK if everything goes correctly, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_arguments_get_unparsed(
        args: *const rcl_arguments_t,
        allocator: rcl_allocator_t,
        output_unparsed_indices: *mut *mut ::std::os::raw::c_int,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the number of ROS specific arguments that were not successfully parsed.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] args An arguments structure that has been parsed.\n* \\return number of unparsed ROS specific arguments, or\n* \\return -1 if args is `NULL` or zero initialized.\n*/"]
    pub fn rcl_arguments_get_count_unparsed_ros(
        args: *const rcl_arguments_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a list of indices to unknown ROS specific arguments that were left unparsed.\n**\n* Some ROS specific arguments may not have been recognized, or were not intended to be\n* parsed by rcl.\n* This function populates an array of indices to these arguments in the original argv array.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] args An arguments structure that has been parsed.\n* \\param[in] allocator A valid allocator.\n* \\param[out] output_unparsed_ros_indices An allocated array of indices into the original argv array.\n*   This array must be deallocated by the caller using the given allocator.\n*   If there are no unparsed ROS specific arguments then the output will be set to NULL.\n* \\return #RCL_RET_OK if everything goes correctly, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_arguments_get_unparsed_ros(
        args: *const rcl_arguments_t,
        allocator: rcl_allocator_t,
        output_unparsed_ros_indices: *mut *mut ::std::os::raw::c_int,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the number of parameter yaml files given in the arguments.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] args An arguments structure that has been parsed.\n* \\return number of yaml files, or\n* \\return -1 if args is `NULL` or zero initialized.\n*/"]
    pub fn rcl_arguments_get_param_files_count(
        args: *const rcl_arguments_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a list of yaml parameter file paths specified on the command line.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] arguments An arguments structure that has been parsed.\n* \\param[in] allocator A valid allocator.\n* \\param[out] parameter_files An allocated array of paramter file names.\n*   This array must be deallocated by the caller using the given allocator.\n*   The output is NULL if there were no paramter files.\n* \\return #RCL_RET_OK if everything goes correctly, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_arguments_get_param_files(
        arguments: *const rcl_arguments_t,
        allocator: rcl_allocator_t,
        parameter_files: *mut *mut *mut ::std::os::raw::c_char,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return all parameter overrides parsed from the command line.\n**\n* Parameter overrides are parsed directly from command line arguments and\n* parameter files provided in the command line.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] arguments An arguments structure that has been parsed.\n* \\param[out] parameter_overrides Parameter overrides as parsed from command line arguments.\n*   This structure must be finalized by the caller.\n*   The output is NULL if no parameter overrides were parsed.\n* \\return #RCL_RET_OK if everything goes correctly, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_arguments_get_param_overrides(
        arguments: *const rcl_arguments_t,
        parameter_overrides: *mut *mut rcl_params_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a list of arguments with ROS-specific arguments removed.\n**\n* Some arguments may not have been intended as ROS arguments.\n* This function populates an array of the aruments in a new argv array.\n* Since the first argument is always assumed to be a process name, the list\n* will always contain the first value from the argument vector.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] argv The argument vector\n* \\param[in] args An arguments structure that has been parsed.\n* \\param[in] allocator A valid allocator.\n* \\param[out] nonros_argc The count of arguments that aren't ROS-specific\n* \\param[out] nonros_argv An allocated array of arguments that aren't ROS-specific\n*   This array must be deallocated by the caller using the given allocator.\n*   If there are no non-ROS args, then the output will be set to NULL.\n* \\return #RCL_RET_OK if everything goes correctly, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_remove_ros_arguments(
        argv: *const *const ::std::os::raw::c_char,
        args: *const rcl_arguments_t,
        allocator: rcl_allocator_t,
        nonros_argc: *mut ::std::os::raw::c_int,
        nonros_argv: *mut *mut *const ::std::os::raw::c_char,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return log levels parsed from the command line.\n**\n* Log levels are parsed directly from command line arguments.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] arguments An arguments structure that has been parsed.\n* \\param[out] log_levels Log levels as parsed from command line arguments.\n*   The output must be finished by the caller if the function successes.\n* \\return #RCL_RET_OK if everything goes correctly, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed.\n*/"]
    pub fn rcl_arguments_get_log_levels(
        arguments: *const rcl_arguments_t,
        log_levels: *mut rcl_log_levels_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Copy one arguments structure into another.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] args The structure to be copied.\n*  Its allocator is used to copy memory into the new structure.\n* \\param[out] args_out A zero-initialized arguments structure to be copied into.\n* \\return #RCL_RET_OK if the structure was copied successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_arguments_copy(
        args: *const rcl_arguments_t,
        args_out: *mut rcl_arguments_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Reclaim resources held inside rcl_arguments_t structure.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] args The structure to be deallocated.\n* \\return #RCL_RET_OK if the memory was successfully freed, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_arguments_fini(args: *mut rcl_arguments_t) -> rcl_ret_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_init_options_impl_s {
    _unused: [u8; 0],
}
pub type rcl_init_options_impl_t = rcl_init_options_impl_s;
#[doc = " Encapsulation of init options and implementation defined init options."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_init_options_s {
    #[doc = " Implementation specific pointer."]
    pub impl_: *mut rcl_init_options_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_init_options_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_init_options_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_init_options_s>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_init_options_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_init_options_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_init_options_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_init_options_s),
            "::",
            stringify!(impl_)
        )
    );
}
#[doc = " Encapsulation of init options and implementation defined init options."]
pub type rcl_init_options_t = rcl_init_options_s;
extern "C" {
    #[doc = " Return a zero initialized rcl_init_options_t struct."]
    pub fn rcl_get_zero_initialized_init_options() -> rcl_init_options_t;
}
extern "C" {
    #[doc = " Initialize given init_options with the default values and implementation specific values.\n**\n* The given allocator is used, if required, during setup of the init options,\n* but is also used during initialization.\n*\n* In either case the given allocator is stored in the returned init options.\n*\n* The `impl` pointer should not be changed manually.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | Yes\n* Lock-Free          | Yes\n*\n* \\param[inout] init_options object to be setup\n* \\param[in] allocator to be used during setup and during initialization\n* \\return #RCL_RET_OK if setup is successful, or\n* \\return #RCL_RET_ALREADY_INIT if init_options has already be initialized, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_init_options_init(
        init_options: *mut rcl_init_options_t,
        allocator: rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Copy the given source init_options to the destination init_options.\n**\n* The allocator from the source is used for any allocations and stored in the\n* destination.\n*\n* The destination should either be zero initialized with\n* rcl_get_zero_initialized_init_options() or should have had\n* rcl_init_options_fini() called on it.\n* Giving an already initialized init options for the destination will result\n* in a failure with return code #RCL_RET_ALREADY_INIT.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | Yes\n* Lock-Free          | Yes\n*\n* \\param[in] src rcl_init_options_t object to be copied from\n* \\param[out] dst rcl_init_options_t object to be copied into\n* \\return #RCL_RET_OK if the copy is successful, or\n* \\return #RCL_RET_ALREADY_INIT if the dst has already be initialized, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_init_options_copy(
        src: *const rcl_init_options_t,
        dst: *mut rcl_init_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize the given init_options.\n**\n* The given init_options must be non-`NULL` and valid, i.e. had\n* rcl_init_options_init() called on it but not this function yet.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | Yes\n* Lock-Free          | Yes\n*\n* \\param[inout] init_options object to be setup\n* \\return #RCL_RET_OK if setup is successful, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_init_options_fini(init_options: *mut rcl_init_options_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the domain_id stored in the init options.\n**\n* Get the domain id from the specified rcl_init_options_t object.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] init_options object from which the domain id should be retrieved.\n* \\param[out] domain_id domain id to be set in init_options object.\n* \\return #RCL_RET_OK if successful, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid.\n*/"]
    pub fn rcl_init_options_get_domain_id(
        init_options: *const rcl_init_options_t,
        domain_id: *mut usize,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Set a domain id in the init options provided.\n**\n* Store the domain id in the specified init_options object.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] init_options objects in which to set the specified domain id.\n* \\param[in] domain_id domain id to be set in init_options object.\n* \\return #RCL_RET_OK if successful, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid.\n*/"]
    pub fn rcl_init_options_set_domain_id(
        init_options: *mut rcl_init_options_t,
        domain_id: usize,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the rmw init options which are stored internally.\n**\n* This function can fail and return `NULL` if:\n*   - init_options is NULL\n*   - init_options is invalid, e.g. init_options->impl is NULL\n*\n* If NULL is returned an error message will have been set.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | Yes\n* Lock-Free          | Yes\n*\n* \\param[in] init_options object from which the rmw init options should be retrieved\n* \\return pointer to the the rcl init options, or\n* \\return `NULL` if there was an error\n*/"]
    pub fn rcl_init_options_get_rmw_init_options(
        init_options: *mut rcl_init_options_t,
    ) -> *mut rmw_init_options_t;
}
extern "C" {
    #[doc = " Return the allocator stored in the init_options.\n**\n* This function can fail and return `NULL` if:\n*   - init_options is NULL\n*   - init_options is invalid, e.g. init_options->impl is NULL\n*\n* If NULL is returned an error message will have been set.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] init_options object from which the allocator should be retrieved\n* \\return pointer to the rcl allocator, or\n* \\return `NULL` if there was an error\n*/"]
    pub fn rcl_init_options_get_allocator(
        init_options: *const rcl_init_options_t,
    ) -> *const rcl_allocator_t;
}
#[doc = " A unique ID per context instance."]
pub type rcl_context_instance_id_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_context_impl_s {
    _unused: [u8; 0],
}
pub type rcl_context_impl_t = rcl_context_impl_s;
#[doc = " Encapsulates the non-global state of an init/shutdown cycle.\n**\n* The context is used in the creation of top level entities like nodes and\n* guard conditions, as well as to shutdown a specific instance of init.\n*\n* Here is a diagram of a typical context's lifecycle:\n*\n* ```\n*    +---------------+\n*    |               |\n* +--> uninitialized +---> rcl_get_zero_initialized_context() +\n* |  |               |                                        |\n* |  +---------------+                                        |\n* |                                                           |\n* |           +-----------------------------------------------+\n* |           |\n* |  +--------v---------+                +-----------------------+\n* |  |                  |                |                       |\n* |  | zero-initialized +-> rcl_init() +-> initialized and valid +-> rcl_shutdown() +\n* |  |                  |                |                       |                  |\n* |  +------------------+                +-----------------------+                  |\n* |                                                                                 |\n* |               +-----------------------------------------------------------------+\n* |               |\n* |  +------------v------------+\n* |  |                         |\n* |  | initialized but invalid +---> finalize all entities, then rcl_context_fini() +\n* |  |                         |                                                    |\n* |  +-------------------------+                                                    |\n* |                                                                                 |\n* +---------------------------------------------------------------------------------+\n* ```\n*\n* A declared but not defined rcl_context_t instance is considered to be\n* \"uninitialized\", and passing an uninitialized context to any functions will\n* result in undefined behavior.\n* Some functions, like rcl_init() require the context instance to be\n* zero initialized (all members set to \"zero\" state) before use.\n*\n* Zero initialization of an rcl_context_t should be done with\n* rcl_get_zero_initialized_context(), which ensures the context is in a safe\n* state for initialization with rcl_init().\n*\n* Initialization of an rcl_context_t should be done with rcl_init(), after\n* which the context is considered both initialized and valid.\n* After initialization it can be used in the creation of other entities like\n* nodes and guard conditions.\n*\n* At any time the context can be invalidated by calling rcl_shutdown() on\n* the rcl_context_t, after which the context is still initialized but now\n* invalid.\n*\n* Invalidation indicates to other entities that the context was shutdown, but\n* is still accessible for use during cleanup of themselves.\n*\n* After being invalidated, and after all of the entities which used it have\n* been finalized, the context should be finalized with rcl_context_fini().\n*\n* Finalizing the context while entities which have copies of it have not yet\n* been finalized is undefined behavior.\n* Therefore, the context's lifetime (between calls to rcl_init() and\n* rcl_context_fini()) should exceed the lifetime of all entities which use\n* it directly (e.g. nodes and guard conditions) or indirectly (e.g.\n* subscriptions and topics).\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_context_s {
    #[doc = " Global arguments for all nodes which share this context.\n** Typically generated by the parsing of argc/argv in rcl_init(). */"]
    pub global_arguments: rcl_arguments_t,
    #[doc = " Implementation specific pointer."]
    pub impl_: *mut rcl_context_impl_t,
    #[doc = " @endcond\n Private storage for instance ID atomic.\n**\n* Accessing the instance id should be done using the function\n* rcl_context_get_instance_id() because the instance id's type is an\n* atomic and needs to be accessed properly to ensure safety.\n*\n* The instance id should not be changed manually - doing so is undefined\n* behavior.\n*\n* The instance id cannot be protected within the `impl` pointer's type\n* because it needs to be accessible even when the context is zero\n* initialized and therefore `impl` is `NULL`.\n* Specifically, storing the instance id in the `impl` would introduce a\n* race condition between accessing it and finalizing the context.\n* Additionally, C11 atomics (i.e. \"stdatomic.h\") cannot be used directly\n* here in the case that this header is included into a C++ program.\n* See this paper for an effort to make this possible in the future:\n*   http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0943r1.html\n*/"]
    pub instance_id_storage: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rcl_context_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_context_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_context_s>(),
        24usize,
        concat!("Size of: ", stringify!(rcl_context_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_context_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_context_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).global_arguments) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_context_s),
            "::",
            stringify!(global_arguments)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_context_s),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instance_id_storage) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_context_s),
            "::",
            stringify!(instance_id_storage)
        )
    );
}
#[doc = " Encapsulates the non-global state of an init/shutdown cycle.\n**\n* The context is used in the creation of top level entities like nodes and\n* guard conditions, as well as to shutdown a specific instance of init.\n*\n* Here is a diagram of a typical context's lifecycle:\n*\n* ```\n*    +---------------+\n*    |               |\n* +--> uninitialized +---> rcl_get_zero_initialized_context() +\n* |  |               |                                        |\n* |  +---------------+                                        |\n* |                                                           |\n* |           +-----------------------------------------------+\n* |           |\n* |  +--------v---------+                +-----------------------+\n* |  |                  |                |                       |\n* |  | zero-initialized +-> rcl_init() +-> initialized and valid +-> rcl_shutdown() +\n* |  |                  |                |                       |                  |\n* |  +------------------+                +-----------------------+                  |\n* |                                                                                 |\n* |               +-----------------------------------------------------------------+\n* |               |\n* |  +------------v------------+\n* |  |                         |\n* |  | initialized but invalid +---> finalize all entities, then rcl_context_fini() +\n* |  |                         |                                                    |\n* |  +-------------------------+                                                    |\n* |                                                                                 |\n* +---------------------------------------------------------------------------------+\n* ```\n*\n* A declared but not defined rcl_context_t instance is considered to be\n* \"uninitialized\", and passing an uninitialized context to any functions will\n* result in undefined behavior.\n* Some functions, like rcl_init() require the context instance to be\n* zero initialized (all members set to \"zero\" state) before use.\n*\n* Zero initialization of an rcl_context_t should be done with\n* rcl_get_zero_initialized_context(), which ensures the context is in a safe\n* state for initialization with rcl_init().\n*\n* Initialization of an rcl_context_t should be done with rcl_init(), after\n* which the context is considered both initialized and valid.\n* After initialization it can be used in the creation of other entities like\n* nodes and guard conditions.\n*\n* At any time the context can be invalidated by calling rcl_shutdown() on\n* the rcl_context_t, after which the context is still initialized but now\n* invalid.\n*\n* Invalidation indicates to other entities that the context was shutdown, but\n* is still accessible for use during cleanup of themselves.\n*\n* After being invalidated, and after all of the entities which used it have\n* been finalized, the context should be finalized with rcl_context_fini().\n*\n* Finalizing the context while entities which have copies of it have not yet\n* been finalized is undefined behavior.\n* Therefore, the context's lifetime (between calls to rcl_init() and\n* rcl_context_fini()) should exceed the lifetime of all entities which use\n* it directly (e.g. nodes and guard conditions) or indirectly (e.g.\n* subscriptions and topics).\n*/"]
pub type rcl_context_t = rcl_context_s;
extern "C" {
    #[doc = " Return a zero initialization context object."]
    pub fn rcl_get_zero_initialized_context() -> rcl_context_t;
}
extern "C" {
    #[doc = " Finalize a context.\n**\n* The context to be finalized must have been previously initialized with\n* rcl_init(), and then later invalidated with rcl_shutdown().\n* A zero-initialized context that has not been initialized can be finalized.\n* If context is `NULL`, then #RCL_RET_INVALID_ARGUMENT is returned.\n* If context is zero-initialized, then #RCL_RET_OK is returned.\n* If context is initialized and valid (rcl_shutdown() was not called on it),\n* then #RCL_RET_INVALID_ARGUMENT is returned.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | Yes\n* Lock-Free          | Yes [1]\n* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>\n*\n* \\param[inout] context object to be finalized.\n* \\return #RCL_RET_OK if the shutdown was completed successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occur.\n*/"]
    pub fn rcl_context_fini(context: *mut rcl_context_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the init options used during initialization for this context.\n**\n* This function can fail and return `NULL` if:\n*   - context is NULL\n*   - context is zero-initialized, e.g. context->impl is `NULL`\n*\n* If context is uninitialized then that is undefined behavior.\n*\n* If `NULL` is returned an error message will have been set.\n*\n* The options are for reference only, and therefore the returned pointer is\n* const.\n* Changing the values in the options is undefined behavior but will likely\n* have no effect.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Yes\n* Lock-Free          | Yes\n*\n* \\param[in] context object from which the init options should be retrieved\n* \\return pointer to the the init options, or\n* \\return `NULL` if there was an error\n*/"]
    pub fn rcl_context_get_init_options(context: *const rcl_context_t)
        -> *const rcl_init_options_t;
}
extern "C" {
    #[doc = " Returns an unsigned integer that is unique to the given context, or `0` if invalid.\n**\n* The given context must be non-`NULL`, but does not need to be initialized or valid.\n* If context is `NULL`, then `0` will be returned.\n* If context is uninitialized, then it is undefined behavior.\n*\n* The instance ID may be `0` if the context is zero-initialized or if the\n* context has been invalidated by rcl_shutdown().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Yes\n* Lock-Free          | Yes [1]\n* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>\n*\n* \\param[in] context object from which the instance id should be retrieved\n* \\return a unique id specific to this context instance, or\n* \\return `0` if invalid, or\n* \\return `0` if context is `NULL`\n*/"]
    pub fn rcl_context_get_instance_id(context: *const rcl_context_t) -> rcl_context_instance_id_t;
}
extern "C" {
    #[doc = " Returns the context domain id.\n**\n* \\pre If context is uninitialized, then it is undefined behavior.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes [1]\n* Uses Atomics       | No\n* Lock-Free          | No\n*\n* <i>[1] Calling the function asynchronously with rcl_init() or rcl_shutdown() can result\n*  in the function sometimes succeeding and sometimes returning #RCL_RET_INVALID_ARGUMENT.</i>\n*\n* \\param[in] context from which the domain id should be retrieved.\n* \\param[out] domain_id output variable where the domain id will be returned.\n* \\return #RCL_RET_INVALID_ARGUMENT if `context` is invalid (see rcl_context_is_valid()), or\n* \\return #RCL_RET_INVALID_ARGUMENT if `domain_id` is `NULL`, or\n* \\return #RCL_RET_OK if the domain id was correctly retrieved.\n*/"]
    pub fn rcl_context_get_domain_id(
        context: *mut rcl_context_t,
        domain_id: *mut usize,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return `true` if the given context is currently valid, otherwise `false`.\n**\n* If context is `NULL`, then `false` is returned.\n* If context is zero-initialized, then `false` is returned.\n* If context is uninitialized, then it is undefined behavior.\n*\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Yes\n* Lock-Free          | Yes [1]\n* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>\n*\n* \\param[in] context object which should be checked for validity\n* \\return `true` if valid, otherwise `false`\n*/"]
    pub fn rcl_context_is_valid(context: *const rcl_context_t) -> bool;
}
extern "C" {
    #[doc = " Return pointer to the rmw context if the given context is currently valid, otherwise `NULL`.\n**\n* If context is `NULL`, then `NULL` is returned.\n* If context is zero-initialized, then `NULL` is returned.\n* If context is uninitialized, then it is undefined behavior.\n*\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Yes\n* Lock-Free          | Yes [1]\n* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>\n*\n* \\param[in] context object from which the rmw context should be retrieved.\n* \\return pointer to rmw context if valid, otherwise `NULL`\n*/"]
    pub fn rcl_context_get_rmw_context(context: *mut rcl_context_t) -> *mut rmw_context_t;
}
extern "C" {
    #[doc = " Initialization of rcl.\n**\n* This function can be run any number of times, so long as the given context\n* has been properly prepared.\n*\n* The given rcl_context_t must be zero initialized with the function\n* rcl_get_zero_initialized_context() and must not be already initialized\n* by this function.\n* If the context is already initialized this function will fail and return the\n* #RCL_RET_ALREADY_INIT error code.\n* A context may be initialized again after it has been finalized with the\n* rcl_shutdown() function and zero initialized again with\n* rcl_get_zero_initialized_context().\n*\n* The `argc` and `argv` parameters may contain command line arguments for the\n* program.\n* rcl specific arguments will be parsed, but not removed.\n* If `argc` is `0` and `argv` is `NULL` no parameters will be parsed.\n*\n* The `options` argument must be non-`NULL` and must have been initialized\n* with rcl_init_options_init().\n* It is unmodified by this function, and the ownership is not transfered to\n* the context, but instead a copy is made into the context for later reference.\n* Therefore, the given options need to be cleaned up with\n* rcl_init_options_fini() after this function returns.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | Yes\n* Lock-Free          | Yes [1]\n* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>\n*\n* \\param[in] argc number of strings in argv\n* \\param[in] argv command line arguments; rcl specific arguments are removed\n* \\param[in] options options used during initialization\n* \\param[out] context resulting context object that represents this init\n* \\return #RCL_RET_OK if initialization is successful, or\n* \\return #RCL_RET_ALREADY_INIT if rcl_init has already been called, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_INVALID_ROS_ARGS if an invalid ROS argument is found, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_init(
        argc: ::std::os::raw::c_int,
        argv: *const *const ::std::os::raw::c_char,
        options: *const rcl_init_options_t,
        context: *mut rcl_context_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Shutdown a given rcl context.\n**\n* The given context must have been initialized with rcl_init().\n* If not, this function will fail with #RCL_RET_ALREADY_SHUTDOWN.\n*\n* When this function is called:\n*  - Any rcl objects created using this context are invalidated.\n*  - Functions called on invalid objects may or may not fail.\n*  - Calls to rcl_context_is_initialized() will return `false`.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | Yes\n* Uses Atomics       | Yes\n* Lock-Free          | Yes [1]\n* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>\n*\n* \\param[inout] context object to shutdown\n* \\return #RCL_RET_OK if the shutdown was completed successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ALREADY_SHUTDOWN if the context is not currently valid, or\n* \\return #RCL_RET_ERROR if an unspecified error occur.\n*/"]
    pub fn rcl_shutdown(context: *mut rcl_context_t) -> rcl_ret_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_guard_condition_impl_s {
    _unused: [u8; 0],
}
#[doc = " Internal rcl guard condition implementation struct."]
pub type rcl_guard_condition_impl_t = rcl_guard_condition_impl_s;
#[doc = " Handle for a rcl guard condition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_guard_condition_s {
    #[doc = " Context associated with this guard condition."]
    pub context: *mut rcl_context_t,
    #[doc = " Pointer to the guard condition implementation"]
    pub impl_: *mut rcl_guard_condition_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_guard_condition_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_guard_condition_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_guard_condition_s>(),
        16usize,
        concat!("Size of: ", stringify!(rcl_guard_condition_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_guard_condition_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_guard_condition_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_guard_condition_s),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_guard_condition_s),
            "::",
            stringify!(impl_)
        )
    );
}
#[doc = " Handle for a rcl guard condition."]
pub type rcl_guard_condition_t = rcl_guard_condition_s;
#[doc = " Options available for a rcl guard condition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_guard_condition_options_s {
    #[doc = " Custom allocator for the guard condition, used for internal allocations."]
    pub allocator: rcl_allocator_t,
}
#[test]
fn bindgen_test_layout_rcl_guard_condition_options_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_guard_condition_options_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_guard_condition_options_s>(),
        40usize,
        concat!("Size of: ", stringify!(rcl_guard_condition_options_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_guard_condition_options_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_guard_condition_options_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_guard_condition_options_s),
            "::",
            stringify!(allocator)
        )
    );
}
#[doc = " Options available for a rcl guard condition."]
pub type rcl_guard_condition_options_t = rcl_guard_condition_options_s;
extern "C" {
    #[doc = " Return a rcl_guard_condition_t struct with members set to `NULL`."]
    pub fn rcl_get_zero_initialized_guard_condition() -> rcl_guard_condition_t;
}
extern "C" {
    #[doc = " Initialize a rcl guard_condition.\n**\n* After calling this function on a rcl_guard_condition_t, it can be passed to\n* rcl_wait() and then concurrently it can be triggered to wake-up rcl_wait().\n*\n* Expected usage:\n*\n* ```c\n* #include <rcl/rcl.h>\n*\n* // ... error handling\n* rcl_guard_condition_t guard_condition = rcl_get_zero_initialized_guard_condition();\n* // ... customize guard condition options\n* rcl_ret_t ret = rcl_guard_condition_init(\n*   &guard_condition, context, rcl_guard_condition_get_default_options());\n* // ... error handling, and on shutdown do deinitialization:\n* ret = rcl_guard_condition_fini(&guard_condition);\n* // ... error handling for rcl_guard_condition_fini()\n* ```\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] guard_condition preallocated guard_condition structure\n* \\param[in] context the context instance with which the guard condition\n*   should be associated\n* \\param[in] options the guard_condition's options\n* \\return #RCL_RET_OK if guard_condition was initialized successfully, or\n* \\return #RCL_RET_ALREADY_INIT if the guard condition is already initialized, or\n* \\return #RCL_RET_NOT_INIT if the given context is invalid, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_guard_condition_init(
        guard_condition: *mut rcl_guard_condition_t,
        context: *mut rcl_context_t,
        options: rcl_guard_condition_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Same as rcl_guard_condition_init(), but reusing an existing rmw handle.\n**\n* In addition to the documentation for rcl_guard_condition_init(), the\n* `rmw_guard_condition` parameter must not be `NULL` and must point to a valid\n* rmw guard condition.\n*\n* Also the life time of the rcl guard condition is tied to the life time of\n* the rmw guard condition.\n* So if the rmw guard condition is destroyed before the rcl guard condition,\n* the rcl guard condition becomes invalid.\n*\n* Similarly if the resulting rcl guard condition is fini'ed before the rmw\n* guard condition, then the rmw guard condition is no longer valid.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] guard_condition preallocated guard_condition structure\n* \\param[in] rmw_guard_condition existing rmw guard condition to reuse\n* \\param[in] context the context instance with which the rmw guard condition\n*   was initialized with, i.e. the rmw context inside rcl context needs to\n*   match rmw context in rmw guard condition\n* \\param[in] options the guard_condition's options\n* \\return #RCL_RET_OK if guard_condition was initialized successfully, or\n* \\return #RCL_RET_ALREADY_INIT if the guard condition is already initialized, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_guard_condition_init_from_rmw(
        guard_condition: *mut rcl_guard_condition_t,
        rmw_guard_condition: *const rmw_guard_condition_t,
        context: *mut rcl_context_t,
        options: rcl_guard_condition_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a rcl_guard_condition_t.\n**\n* After calling, calls to rcl_trigger_guard_condition() will fail when using\n* this guard condition.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No [1]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] specifically not thread-safe with rcl_trigger_guard_condition()</i>\n*\n* \\param[inout] guard_condition handle to the guard_condition to be finalized\n* \\return #RCL_RET_OK if guard_condition was finalized successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_guard_condition_fini(guard_condition: *mut rcl_guard_condition_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the default options in a rcl_guard_condition_options_t struct.\n**\n* The defaults are:\n*\n* - allocator = rcl_get_default_allocator()\n*\n* \\return the default options in an rcl_guard_condition_options_t struct.\n*/"]
    pub fn rcl_guard_condition_get_default_options() -> rcl_guard_condition_options_t;
}
extern "C" {
    #[doc = " Trigger a rcl guard condition.\n**\n* This function can fail, and return RCL_RET_INVALID_ARGUMENT, if the:\n*   - guard condition is `NULL`\n*   - guard condition is invalid (never called init or called fini)\n*\n* A guard condition can be triggered from any thread.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No [1]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] it can be called concurrently with itself, even on the same guard condition</i>\n*\n* \\param[in] guard_condition handle to the guard_condition to be triggered\n* \\return #RCL_RET_OK if the guard condition was triggered, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_trigger_guard_condition(guard_condition: *mut rcl_guard_condition_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the guard condition options.\n**\n* Returned is a pointer to the internally held rcl_guard_condition_options_t.\n* This function can fail, and therefore return `NULL`, if the:\n*   - guard_condition is `NULL`\n*   - guard_condition is invalid (never called init, called fini, or invalid node)\n*\n* The returned pointer is made invalid if the guard condition is finalized.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] guard_condition pointer to the rcl guard_condition\n* \\return rcl guard condition options if successful, otherwise `NULL`\n*/"]
    pub fn rcl_guard_condition_get_options(
        guard_condition: *const rcl_guard_condition_t,
    ) -> *const rcl_guard_condition_options_t;
}
extern "C" {
    #[doc = " Return the rmw guard condition handle.\n**\n* The handle returned is a pointer to the internally held rmw handle.\n* This function can fail, and therefore return `NULL`, if the:\n*   - guard_condition is `NULL`\n*   - guard_condition is invalid (never called init, called fini, or invalid node)\n*\n* The returned handle is made invalid if the guard condition is finalized or\n* if rcl_shutdown() is called.\n* The returned handle is not guaranteed to be valid for the life time of the\n* guard condition as it may be finalized and recreated itself.\n* Therefore it is recommended to get the handle from the guard condition using\n* this function each time it is needed and avoid use of the handle\n* concurrently with functions that might change it.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] guard_condition pointer to the rcl guard_condition\n* \\return rmw guard condition handle if successful, otherwise `NULL`\n*/"]
    pub fn rcl_guard_condition_get_rmw_handle(
        guard_condition: *const rcl_guard_condition_t,
    ) -> *mut rmw_guard_condition_t;
}
extern "C" {
    pub static RCL_DOMAIN_ID_ENV_VAR: *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Determine the default domain ID, based on the environment.\n**\n* \\param[out] domain_id Must not be NULL.\n* \\returns #RCL_RET_INVALID_ARGUMENT if an argument is invalid, or,\n* \\returns #RCL_RET_ERROR in case of an unexpected error, or,\n* \\returns #RCL_RET_OK.\n*/"]
    pub fn rcl_get_default_domain_id(domain_id: *mut usize) -> rcl_ret_t;
}
#[doc = " Structure which encapsulates the options for creating a rcl_node_t."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_node_options_s {
    #[doc = " Custom allocator used for internal allocations."]
    pub allocator: rcl_allocator_t,
    #[doc = " If false then only use arguments in this struct, otherwise use global arguments also."]
    pub use_global_arguments: bool,
    #[doc = " Command line arguments that apply only to this node."]
    pub arguments: rcl_arguments_t,
    #[doc = " Flag to enable rosout for this node"]
    pub enable_rosout: bool,
    #[doc = " Middleware quality of service settings for /rosout."]
    pub rosout_qos: rmw_qos_profile_t,
    #[doc = " Deprecated: this feature is to be enabled via parameters in rclcpp and rclpy."]
    pub enable_type_description_service: bool,
}
#[test]
fn bindgen_test_layout_rcl_node_options_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_node_options_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_node_options_s>(),
        160usize,
        concat!("Size of: ", stringify!(rcl_node_options_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_node_options_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_node_options_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_node_options_s),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_global_arguments) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_node_options_s),
            "::",
            stringify!(use_global_arguments)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arguments) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_node_options_s),
            "::",
            stringify!(arguments)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_rosout) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_node_options_s),
            "::",
            stringify!(enable_rosout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rosout_qos) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_node_options_s),
            "::",
            stringify!(rosout_qos)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).enable_type_description_service) as usize - ptr as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_node_options_s),
            "::",
            stringify!(enable_type_description_service)
        )
    );
}
#[doc = " Structure which encapsulates the options for creating a rcl_node_t."]
pub type rcl_node_options_t = rcl_node_options_s;
extern "C" {
    #[doc = " Return the default node options in a rcl_node_options_t.\n**\n* The default values are:\n*\n* - allocator = rcl_get_default_allocator()\n* - use_global_arguments = true\n* - enable_rosout = true\n* - arguments = rcl_get_zero_initialized_arguments()\n* - rosout_qos = rcl_qos_profile_rosout_default\n*\n* \\return A structure with the default node options.\n*/"]
    pub fn rcl_node_get_default_options() -> rcl_node_options_t;
}
extern "C" {
    #[doc = " Copy one options structure into another.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] options The structure to be copied.\n*   Its allocator is used to copy memory into the new structure.\n* \\param[out] options_out An options structure containing default values.\n* \\return #RCL_RET_OK if the structure was copied successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_node_options_copy(
        options: *const rcl_node_options_t,
        options_out: *mut rcl_node_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize the given node_options.\n**\n* The given node_options must be non-`NULL` and valid, i.e. had\n* rcl_node_get_default_options() called on it but not this function yet.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | Yes\n* Lock-Free          | Yes\n*\n* \\param[inout] options object to be finalized\n* \\return #RCL_RET_OK if setup is successful, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_node_options_fini(options: *mut rcl_node_options_t) -> rcl_ret_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__float__Sequence {
    pub data: *mut f32,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__float__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__float__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__float__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__float__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__float__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__float__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__float__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__float__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__float__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__double__Sequence {
    pub data: *mut f64,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__double__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__double__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__double__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__double__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__double__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__double__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__double__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__double__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__double__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__long_double__Sequence {
    pub data: *mut u128,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__long_double__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__long_double__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__long_double__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_runtime_c__long_double__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__long_double__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__long_double__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__long_double__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__long_double__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__long_double__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__char__Sequence {
    pub data: *mut ::std::os::raw::c_schar,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__char__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__char__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__char__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__char__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__char__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__char__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__char__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__char__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__char__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__wchar__Sequence {
    pub data: *mut u16,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__wchar__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__wchar__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__wchar__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__wchar__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__wchar__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__wchar__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__wchar__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__wchar__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__wchar__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__boolean__Sequence {
    pub data: *mut bool,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__boolean__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__boolean__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__boolean__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__boolean__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__boolean__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__boolean__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__boolean__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__boolean__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__boolean__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__octet__Sequence {
    pub data: *mut u8,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__octet__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__octet__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__octet__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__octet__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__octet__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__octet__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__octet__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__octet__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__octet__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__uint8__Sequence {
    pub data: *mut u8,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__uint8__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__uint8__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__uint8__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__uint8__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__uint8__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__uint8__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint8__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint8__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint8__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__int8__Sequence {
    pub data: *mut i8,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__int8__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__int8__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__int8__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__int8__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__int8__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__int8__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int8__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int8__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int8__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__uint16__Sequence {
    pub data: *mut u16,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__uint16__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__uint16__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__uint16__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__uint16__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__uint16__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__uint16__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint16__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint16__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint16__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__int16__Sequence {
    pub data: *mut i16,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__int16__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__int16__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__int16__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__int16__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__int16__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__int16__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int16__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int16__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int16__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__uint32__Sequence {
    pub data: *mut u32,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__uint32__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__uint32__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__uint32__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__uint32__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__uint32__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__uint32__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint32__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint32__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint32__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__int32__Sequence {
    pub data: *mut i32,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__int32__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__int32__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__int32__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__int32__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__int32__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__int32__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int32__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int32__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int32__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__uint64__Sequence {
    pub data: *mut u64,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__uint64__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__uint64__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__uint64__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__uint64__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__uint64__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__uint64__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint64__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint64__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint64__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__int64__Sequence {
    pub data: *mut i64,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__int64__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__int64__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__int64__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__int64__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__int64__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__int64__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int64__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int64__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int64__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
pub type rosidl_runtime_c__bool__Sequence = rosidl_runtime_c__boolean__Sequence;
pub type rosidl_runtime_c__byte__Sequence = rosidl_runtime_c__octet__Sequence;
pub type rosidl_runtime_c__float32__Sequence = rosidl_runtime_c__float__Sequence;
pub type rosidl_runtime_c__float64__Sequence = rosidl_runtime_c__double__Sequence;
#[doc = " An array of 8-bit characters terminated by a null byte."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__String {
    #[doc = " The pointer to the first character, the sequence ends with a null byte."]
    pub data: *mut ::std::os::raw::c_char,
    #[doc = " The length of the string (excluding the null byte)."]
    pub size: usize,
    #[doc = " The capacity represents the number of allocated bytes (including the null byte)."]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__String() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__String> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__String>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__String))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__String>(),
        8usize,
        concat!("Alignment of ", stringify!(rosidl_runtime_c__String))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__String),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__String),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__String),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__String__Sequence {
    pub data: *mut rosidl_runtime_c__String,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__String__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__String__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__String__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__String__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__String__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__String__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__String__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__String__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__String__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[doc = " Struct defined in srv/GetTypeDescription in the package type_description_interfaces."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct type_description_interfaces__srv__GetTypeDescription_Request {
    pub type_name: rosidl_runtime_c__String,
    #[doc = " REP-2011 RIHS hash string."]
    pub type_hash: rosidl_runtime_c__String,
    #[doc = " Whether to return the original idl/msg/etc. source file(s) in the response."]
    pub include_type_sources: bool,
}
#[test]
fn bindgen_test_layout_type_description_interfaces__srv__GetTypeDescription_Request() {
    const UNINIT: ::std::mem::MaybeUninit<
        type_description_interfaces__srv__GetTypeDescription_Request,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<type_description_interfaces__srv__GetTypeDescription_Request>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Request)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<type_description_interfaces__srv__GetTypeDescription_Request>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Request),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_hash) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Request),
            "::",
            stringify!(type_hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).include_type_sources) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Request),
            "::",
            stringify!(include_type_sources)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct type_description_interfaces__srv__GetTypeDescription_Request__Sequence {
    pub data: *mut type_description_interfaces__srv__GetTypeDescription_Request,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_type_description_interfaces__srv__GetTypeDescription_Request__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<
        type_description_interfaces__srv__GetTypeDescription_Request__Sequence,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<type_description_interfaces__srv__GetTypeDescription_Request__Sequence>(
        ),
        24usize,
        concat!(
            "Size of: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Request__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            type_description_interfaces__srv__GetTypeDescription_Request__Sequence,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Request__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Request__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Request__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Request__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_NOT_SET: _bindgen_ty_2 = 0;
#[doc = " Constant 'FIELD_TYPE_NOT_SET'.\n**\n* A constant for each type supported according to:\n*   http://design.ros2.org/articles/legacy_interface_definition.html\n* and:\n*   http://design.ros2.org/articles/idl_interface_definition.html\n* Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n*  https://www.omg.org/spec/IDL/4.2\n* Layout of constants across the 0-255 decimal values in the uint8:\n*\n* - 000    : Reserved for \"not set\"\n* - 001-048: Primitive types, strings, and reserved space for future primitive types\n* - 049-096: Fixed sized array of primitive and string types\n* - 097-144: Bounded Sequences of primitive and string types\n* - 145-192: Unbounded Sequences of primitive and string types\n* - 193-255: Reserved space for future array/sequence-like types\n*/"]
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_NESTED_TYPE: _bindgen_ty_3 = 1;
#[doc = " Constant 'FIELD_TYPE_NESTED_TYPE'.\n**\n* Nested type defined in other .msg/.idl files.\n*/"]
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_INT8: _bindgen_ty_4 = 2;
#[doc = " Constant 'FIELD_TYPE_INT8'.\n**\n* Integer Types\n*/"]
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_UINT8: _bindgen_ty_5 = 3;
#[doc = " Constant 'FIELD_TYPE_UINT8'."]
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_INT16: _bindgen_ty_6 = 4;
#[doc = " Constant 'FIELD_TYPE_INT16'."]
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_UINT16: _bindgen_ty_7 = 5;
#[doc = " Constant 'FIELD_TYPE_UINT16'."]
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_INT32: _bindgen_ty_8 = 6;
#[doc = " Constant 'FIELD_TYPE_INT32'."]
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_UINT32: _bindgen_ty_9 = 7;
#[doc = " Constant 'FIELD_TYPE_UINT32'."]
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_INT64: _bindgen_ty_10 = 8;
#[doc = " Constant 'FIELD_TYPE_INT64'."]
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_UINT64: _bindgen_ty_11 = 9;
#[doc = " Constant 'FIELD_TYPE_UINT64'."]
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_FLOAT: _bindgen_ty_12 = 10;
#[doc = " Constant 'FIELD_TYPE_FLOAT'.\n**\n* Floating-Point Types\n*/"]
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_DOUBLE: _bindgen_ty_13 = 11;
#[doc = " Constant 'FIELD_TYPE_DOUBLE'."]
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_LONG_DOUBLE: _bindgen_ty_14 = 12;
#[doc = " Constant 'FIELD_TYPE_LONG_DOUBLE'."]
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_CHAR: _bindgen_ty_15 = 13;
#[doc = " Constant 'FIELD_TYPE_CHAR'.\n**\n* Char and WChar Types\n*/"]
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_WCHAR: _bindgen_ty_16 = 14;
#[doc = " Constant 'FIELD_TYPE_WCHAR'."]
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_BOOLEAN: _bindgen_ty_17 = 15;
#[doc = " Constant 'FIELD_TYPE_BOOLEAN'.\n**\n* Boolean Type\n*/"]
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_BYTE: _bindgen_ty_18 = 16;
#[doc = " Constant 'FIELD_TYPE_BYTE'.\n**\n* Byte/Octet Type\n*/"]
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_STRING: _bindgen_ty_19 = 17;
#[doc = " Constant 'FIELD_TYPE_STRING'.\n**\n* String Types\n*/"]
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_WSTRING: _bindgen_ty_20 = 18;
#[doc = " Constant 'FIELD_TYPE_WSTRING'."]
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_FIXED_STRING: _bindgen_ty_21 = 19;
#[doc = " Constant 'FIELD_TYPE_FIXED_STRING'.\n**\n* Fixed String Types\n*/"]
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_FIXED_WSTRING: _bindgen_ty_22 =
    20;
#[doc = " Constant 'FIELD_TYPE_FIXED_WSTRING'."]
pub type _bindgen_ty_22 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_BOUNDED_STRING: _bindgen_ty_23 =
    21;
#[doc = " Constant 'FIELD_TYPE_BOUNDED_STRING'.\n**\n* Bounded String Types\n*/"]
pub type _bindgen_ty_23 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_BOUNDED_WSTRING: _bindgen_ty_24 =
    22;
#[doc = " Constant 'FIELD_TYPE_BOUNDED_WSTRING'."]
pub type _bindgen_ty_24 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_NESTED_TYPE_ARRAY:
    _bindgen_ty_25 = 49;
#[doc = " Constant 'FIELD_TYPE_NESTED_TYPE_ARRAY'.\n**\n* Fixed Sized Array Types\n*/"]
pub type _bindgen_ty_25 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_INT8_ARRAY: _bindgen_ty_26 = 50;
#[doc = " Constant 'FIELD_TYPE_INT8_ARRAY'."]
pub type _bindgen_ty_26 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_UINT8_ARRAY: _bindgen_ty_27 = 51;
#[doc = " Constant 'FIELD_TYPE_UINT8_ARRAY'."]
pub type _bindgen_ty_27 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_INT16_ARRAY: _bindgen_ty_28 = 52;
#[doc = " Constant 'FIELD_TYPE_INT16_ARRAY'."]
pub type _bindgen_ty_28 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_UINT16_ARRAY: _bindgen_ty_29 = 53;
#[doc = " Constant 'FIELD_TYPE_UINT16_ARRAY'."]
pub type _bindgen_ty_29 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_INT32_ARRAY: _bindgen_ty_30 = 54;
#[doc = " Constant 'FIELD_TYPE_INT32_ARRAY'."]
pub type _bindgen_ty_30 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_UINT32_ARRAY: _bindgen_ty_31 = 55;
#[doc = " Constant 'FIELD_TYPE_UINT32_ARRAY'."]
pub type _bindgen_ty_31 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_INT64_ARRAY: _bindgen_ty_32 = 56;
#[doc = " Constant 'FIELD_TYPE_INT64_ARRAY'."]
pub type _bindgen_ty_32 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_UINT64_ARRAY: _bindgen_ty_33 = 57;
#[doc = " Constant 'FIELD_TYPE_UINT64_ARRAY'."]
pub type _bindgen_ty_33 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_FLOAT_ARRAY: _bindgen_ty_34 = 58;
#[doc = " Constant 'FIELD_TYPE_FLOAT_ARRAY'."]
pub type _bindgen_ty_34 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_DOUBLE_ARRAY: _bindgen_ty_35 = 59;
#[doc = " Constant 'FIELD_TYPE_DOUBLE_ARRAY'."]
pub type _bindgen_ty_35 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_LONG_DOUBLE_ARRAY:
    _bindgen_ty_36 = 60;
#[doc = " Constant 'FIELD_TYPE_LONG_DOUBLE_ARRAY'."]
pub type _bindgen_ty_36 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_CHAR_ARRAY: _bindgen_ty_37 = 61;
#[doc = " Constant 'FIELD_TYPE_CHAR_ARRAY'."]
pub type _bindgen_ty_37 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_WCHAR_ARRAY: _bindgen_ty_38 = 62;
#[doc = " Constant 'FIELD_TYPE_WCHAR_ARRAY'."]
pub type _bindgen_ty_38 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_BOOLEAN_ARRAY: _bindgen_ty_39 =
    63;
#[doc = " Constant 'FIELD_TYPE_BOOLEAN_ARRAY'."]
pub type _bindgen_ty_39 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_BYTE_ARRAY: _bindgen_ty_40 = 64;
#[doc = " Constant 'FIELD_TYPE_BYTE_ARRAY'."]
pub type _bindgen_ty_40 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_STRING_ARRAY: _bindgen_ty_41 = 65;
#[doc = " Constant 'FIELD_TYPE_STRING_ARRAY'."]
pub type _bindgen_ty_41 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_WSTRING_ARRAY: _bindgen_ty_42 =
    66;
#[doc = " Constant 'FIELD_TYPE_WSTRING_ARRAY'."]
pub type _bindgen_ty_42 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_FIXED_STRING_ARRAY:
    _bindgen_ty_43 = 67;
#[doc = " Constant 'FIELD_TYPE_FIXED_STRING_ARRAY'."]
pub type _bindgen_ty_43 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_FIXED_WSTRING_ARRAY:
    _bindgen_ty_44 = 68;
#[doc = " Constant 'FIELD_TYPE_FIXED_WSTRING_ARRAY'."]
pub type _bindgen_ty_44 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_BOUNDED_STRING_ARRAY:
    _bindgen_ty_45 = 69;
#[doc = " Constant 'FIELD_TYPE_BOUNDED_STRING_ARRAY'."]
pub type _bindgen_ty_45 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_BOUNDED_WSTRING_ARRAY:
    _bindgen_ty_46 = 70;
#[doc = " Constant 'FIELD_TYPE_BOUNDED_WSTRING_ARRAY'."]
pub type _bindgen_ty_46 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE:
    _bindgen_ty_47 = 97;
#[doc = " Constant 'FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE'.\n**\n* Bounded Sequence Types\n*/"]
pub type _bindgen_ty_47 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_INT8_BOUNDED_SEQUENCE:
    _bindgen_ty_48 = 98;
#[doc = " Constant 'FIELD_TYPE_INT8_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_48 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_UINT8_BOUNDED_SEQUENCE:
    _bindgen_ty_49 = 99;
#[doc = " Constant 'FIELD_TYPE_UINT8_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_49 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_INT16_BOUNDED_SEQUENCE:
    _bindgen_ty_50 = 100;
#[doc = " Constant 'FIELD_TYPE_INT16_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_50 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_UINT16_BOUNDED_SEQUENCE:
    _bindgen_ty_51 = 101;
#[doc = " Constant 'FIELD_TYPE_UINT16_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_51 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_INT32_BOUNDED_SEQUENCE:
    _bindgen_ty_52 = 102;
#[doc = " Constant 'FIELD_TYPE_INT32_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_52 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_UINT32_BOUNDED_SEQUENCE:
    _bindgen_ty_53 = 103;
#[doc = " Constant 'FIELD_TYPE_UINT32_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_53 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_INT64_BOUNDED_SEQUENCE:
    _bindgen_ty_54 = 104;
#[doc = " Constant 'FIELD_TYPE_INT64_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_54 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_UINT64_BOUNDED_SEQUENCE:
    _bindgen_ty_55 = 105;
#[doc = " Constant 'FIELD_TYPE_UINT64_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_55 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE:
    _bindgen_ty_56 = 106;
#[doc = " Constant 'FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_56 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE:
    _bindgen_ty_57 = 107;
#[doc = " Constant 'FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_57 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE:
    _bindgen_ty_58 = 108;
#[doc = " Constant 'FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_58 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_CHAR_BOUNDED_SEQUENCE:
    _bindgen_ty_59 = 109;
#[doc = " Constant 'FIELD_TYPE_CHAR_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_59 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE:
    _bindgen_ty_60 = 110;
#[doc = " Constant 'FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_60 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE:
    _bindgen_ty_61 = 111;
#[doc = " Constant 'FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_61 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_BYTE_BOUNDED_SEQUENCE:
    _bindgen_ty_62 = 112;
#[doc = " Constant 'FIELD_TYPE_BYTE_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_62 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_STRING_BOUNDED_SEQUENCE:
    _bindgen_ty_63 = 113;
#[doc = " Constant 'FIELD_TYPE_STRING_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_63 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE:
    _bindgen_ty_64 = 114;
#[doc = " Constant 'FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_64 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE:
    _bindgen_ty_65 = 115;
#[doc = " Constant 'FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_65 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE:
    _bindgen_ty_66 = 116;
#[doc = " Constant 'FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_66 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE : _bindgen_ty_67 = 117 ;
#[doc = " Constant 'FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_67 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE : _bindgen_ty_68 = 118 ;
#[doc = " Constant 'FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_68 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE:
    _bindgen_ty_69 = 145;
#[doc = " Constant 'FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE'.\n**\n* Unbounded Sequence Types\n*/"]
pub type _bindgen_ty_69 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE:
    _bindgen_ty_70 = 146;
#[doc = " Constant 'FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_70 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE:
    _bindgen_ty_71 = 147;
#[doc = " Constant 'FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_71 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE:
    _bindgen_ty_72 = 148;
#[doc = " Constant 'FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_72 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE:
    _bindgen_ty_73 = 149;
#[doc = " Constant 'FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_73 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE:
    _bindgen_ty_74 = 150;
#[doc = " Constant 'FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_74 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE:
    _bindgen_ty_75 = 151;
#[doc = " Constant 'FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_75 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE:
    _bindgen_ty_76 = 152;
#[doc = " Constant 'FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_76 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE:
    _bindgen_ty_77 = 153;
#[doc = " Constant 'FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_77 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE:
    _bindgen_ty_78 = 154;
#[doc = " Constant 'FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_78 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE:
    _bindgen_ty_79 = 155;
#[doc = " Constant 'FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_79 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE:
    _bindgen_ty_80 = 156;
#[doc = " Constant 'FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_80 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE:
    _bindgen_ty_81 = 157;
#[doc = " Constant 'FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_81 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE:
    _bindgen_ty_82 = 158;
#[doc = " Constant 'FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_82 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE:
    _bindgen_ty_83 = 159;
#[doc = " Constant 'FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_83 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE:
    _bindgen_ty_84 = 160;
#[doc = " Constant 'FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_84 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE:
    _bindgen_ty_85 = 161;
#[doc = " Constant 'FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_85 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE:
    _bindgen_ty_86 = 162;
#[doc = " Constant 'FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_86 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE : _bindgen_ty_87 = 163 ;
#[doc = " Constant 'FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_87 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE : _bindgen_ty_88 = 164 ;
#[doc = " Constant 'FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_88 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE : _bindgen_ty_89 = 165 ;
#[doc = " Constant 'FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_89 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE : _bindgen_ty_90 = 166 ;
#[doc = " Constant 'FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_90 = ::std::os::raw::c_uint;
pub const type_description_interfaces__msg__FieldType__nested_type_name__MAX_STRING_SIZE:
    _bindgen_ty_91 = 255;
pub type _bindgen_ty_91 = ::std::os::raw::c_uint;
#[doc = " Struct defined in msg/FieldType in the package type_description_interfaces.\n**\n* Represents the type of a field and related meta-data.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct type_description_interfaces__msg__FieldType {
    #[doc = " Identifying number for the type of the field, using one of the above constants."]
    pub type_id: u8,
    #[doc = " Only used when the type is an array or a bounded sequence.\n In the case of an array, this is the fixed capacity of the array.\n In the case of a bounded sequence, this is the maximum capacity of the sequence.\n In all other cases this field is unused."]
    pub capacity: u64,
    #[doc = " Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n In the case of a fixed string/wstring, it is the fixed length of the string.\n In the case of a bounded string/wstring, it is the maximum capacity of the string.\n In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n It is not currently possible to have different string capacities per element in the array/sequence."]
    pub string_capacity: u64,
    #[doc = " Only used when the type is a nested type or array/sequence of nested types.\n This is limited to 255 characters.\n TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n   We lack a ROS 2 specific limit in our design documents, but we should update\n   this and/or link to the design doc when that is available."]
    pub nested_type_name: rosidl_runtime_c__String,
}
#[test]
fn bindgen_test_layout_type_description_interfaces__msg__FieldType() {
    const UNINIT: ::std::mem::MaybeUninit<type_description_interfaces__msg__FieldType> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<type_description_interfaces__msg__FieldType>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(type_description_interfaces__msg__FieldType)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<type_description_interfaces__msg__FieldType>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(type_description_interfaces__msg__FieldType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__FieldType),
            "::",
            stringify!(type_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__FieldType),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string_capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__FieldType),
            "::",
            stringify!(string_capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nested_type_name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__FieldType),
            "::",
            stringify!(nested_type_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct type_description_interfaces__msg__FieldType__Sequence {
    pub data: *mut type_description_interfaces__msg__FieldType,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_type_description_interfaces__msg__FieldType__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<type_description_interfaces__msg__FieldType__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<type_description_interfaces__msg__FieldType__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(type_description_interfaces__msg__FieldType__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<type_description_interfaces__msg__FieldType__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(type_description_interfaces__msg__FieldType__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__FieldType__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__FieldType__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__FieldType__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[doc = " Struct defined in msg/Field in the package type_description_interfaces.\n**\n* Represents a single field in a type.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct type_description_interfaces__msg__Field {
    #[doc = " Name of the field."]
    pub name: rosidl_runtime_c__String,
    #[doc = " Type of the field, including details about the type like length, nested name, etc."]
    pub type_: type_description_interfaces__msg__FieldType,
    #[doc = " Literal default value of the field as a string, as it appeared in the original\n message description file, whether that be .msg/.srv/.action or .idl."]
    pub default_value: rosidl_runtime_c__String,
}
#[test]
fn bindgen_test_layout_type_description_interfaces__msg__Field() {
    const UNINIT: ::std::mem::MaybeUninit<type_description_interfaces__msg__Field> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<type_description_interfaces__msg__Field>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(type_description_interfaces__msg__Field)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<type_description_interfaces__msg__Field>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(type_description_interfaces__msg__Field)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__Field),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__Field),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__Field),
            "::",
            stringify!(default_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct type_description_interfaces__msg__Field__Sequence {
    pub data: *mut type_description_interfaces__msg__Field,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_type_description_interfaces__msg__Field__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<type_description_interfaces__msg__Field__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<type_description_interfaces__msg__Field__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(type_description_interfaces__msg__Field__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<type_description_interfaces__msg__Field__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(type_description_interfaces__msg__Field__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__Field__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__Field__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__Field__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
pub const type_description_interfaces__msg__IndividualTypeDescription__type_name__MAX_STRING_SIZE : _bindgen_ty_92 = 255 ;
pub type _bindgen_ty_92 = ::std::os::raw::c_uint;
#[doc = " Struct defined in msg/IndividualTypeDescription in the package type_description_interfaces.\n**\n* Represents a single type, without the types it references, if any.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct type_description_interfaces__msg__IndividualTypeDescription {
    #[doc = " Name of the type.\n This is limited to 255 characters.\n TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n   We lack a ROS 2 specific limit in our design documents, but we should update\n   this and/or link to the design doc when that is available."]
    pub type_name: rosidl_runtime_c__String,
    #[doc = " Fields of the type."]
    pub fields: type_description_interfaces__msg__Field__Sequence,
}
#[test]
fn bindgen_test_layout_type_description_interfaces__msg__IndividualTypeDescription() {
    const UNINIT: ::std::mem::MaybeUninit<
        type_description_interfaces__msg__IndividualTypeDescription,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<type_description_interfaces__msg__IndividualTypeDescription>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(type_description_interfaces__msg__IndividualTypeDescription)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<type_description_interfaces__msg__IndividualTypeDescription>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(type_description_interfaces__msg__IndividualTypeDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__IndividualTypeDescription),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fields) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__IndividualTypeDescription),
            "::",
            stringify!(fields)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct type_description_interfaces__msg__IndividualTypeDescription__Sequence {
    pub data: *mut type_description_interfaces__msg__IndividualTypeDescription,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_type_description_interfaces__msg__IndividualTypeDescription__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<
        type_description_interfaces__msg__IndividualTypeDescription__Sequence,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<type_description_interfaces__msg__IndividualTypeDescription__Sequence>(
        ),
        24usize,
        concat!(
            "Size of: ",
            stringify!(type_description_interfaces__msg__IndividualTypeDescription__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<type_description_interfaces__msg__IndividualTypeDescription__Sequence>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(type_description_interfaces__msg__IndividualTypeDescription__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__IndividualTypeDescription__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__IndividualTypeDescription__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__IndividualTypeDescription__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[doc = " Struct defined in msg/TypeDescription in the package type_description_interfaces.\n**\n* Represents a complete type description, including the type itself as well as the types it references.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct type_description_interfaces__msg__TypeDescription {
    #[doc = " Description of the type."]
    pub type_description: type_description_interfaces__msg__IndividualTypeDescription,
    #[doc = " Descriptions of all referenced types, recursively."]
    pub referenced_type_descriptions:
        type_description_interfaces__msg__IndividualTypeDescription__Sequence,
}
#[test]
fn bindgen_test_layout_type_description_interfaces__msg__TypeDescription() {
    const UNINIT: ::std::mem::MaybeUninit<type_description_interfaces__msg__TypeDescription> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<type_description_interfaces__msg__TypeDescription>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(type_description_interfaces__msg__TypeDescription)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<type_description_interfaces__msg__TypeDescription>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(type_description_interfaces__msg__TypeDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_description) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__TypeDescription),
            "::",
            stringify!(type_description)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).referenced_type_descriptions) as usize - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__TypeDescription),
            "::",
            stringify!(referenced_type_descriptions)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct type_description_interfaces__msg__TypeDescription__Sequence {
    pub data: *mut type_description_interfaces__msg__TypeDescription,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_type_description_interfaces__msg__TypeDescription__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<
        type_description_interfaces__msg__TypeDescription__Sequence,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<type_description_interfaces__msg__TypeDescription__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(type_description_interfaces__msg__TypeDescription__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<type_description_interfaces__msg__TypeDescription__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(type_description_interfaces__msg__TypeDescription__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__TypeDescription__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__TypeDescription__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__TypeDescription__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[doc = " Struct defined in msg/TypeSource in the package type_description_interfaces.\n**\n* Represents the original source of a ROS 2 interface definition.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct type_description_interfaces__msg__TypeSource {
    #[doc = " ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format."]
    pub type_name: rosidl_runtime_c__String,
    #[doc = " The type of the original source file, typically matching the file extension.\n Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n \"implicit\" specifies a type created automatically as a subtype of a\n complex type (service or action) - such as the request message for a service.\n Implicit types will have no contents, the full source will be available on the parent srv/action."]
    pub encoding: rosidl_runtime_c__String,
    #[doc = " Dumped contents of the interface definition source file.\n If `encoding` is \"dynamic\" or \"implicit\", this field will be empty."]
    pub raw_file_contents: rosidl_runtime_c__String,
}
#[test]
fn bindgen_test_layout_type_description_interfaces__msg__TypeSource() {
    const UNINIT: ::std::mem::MaybeUninit<type_description_interfaces__msg__TypeSource> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<type_description_interfaces__msg__TypeSource>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(type_description_interfaces__msg__TypeSource)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<type_description_interfaces__msg__TypeSource>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(type_description_interfaces__msg__TypeSource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__TypeSource),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoding) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__TypeSource),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_file_contents) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__TypeSource),
            "::",
            stringify!(raw_file_contents)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct type_description_interfaces__msg__TypeSource__Sequence {
    pub data: *mut type_description_interfaces__msg__TypeSource,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_type_description_interfaces__msg__TypeSource__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<type_description_interfaces__msg__TypeSource__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<type_description_interfaces__msg__TypeSource__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(type_description_interfaces__msg__TypeSource__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<type_description_interfaces__msg__TypeSource__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(type_description_interfaces__msg__TypeSource__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__TypeSource__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__TypeSource__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__TypeSource__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[doc = " Struct defined in msg/KeyValue in the package type_description_interfaces.\n**\n* Represents an arbitrary key-value pair for application-specific information.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct type_description_interfaces__msg__KeyValue {
    pub key: rosidl_runtime_c__String,
    pub value: rosidl_runtime_c__String,
}
#[test]
fn bindgen_test_layout_type_description_interfaces__msg__KeyValue() {
    const UNINIT: ::std::mem::MaybeUninit<type_description_interfaces__msg__KeyValue> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<type_description_interfaces__msg__KeyValue>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(type_description_interfaces__msg__KeyValue)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<type_description_interfaces__msg__KeyValue>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(type_description_interfaces__msg__KeyValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__KeyValue),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__KeyValue),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct type_description_interfaces__msg__KeyValue__Sequence {
    pub data: *mut type_description_interfaces__msg__KeyValue,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_type_description_interfaces__msg__KeyValue__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<type_description_interfaces__msg__KeyValue__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<type_description_interfaces__msg__KeyValue__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(type_description_interfaces__msg__KeyValue__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<type_description_interfaces__msg__KeyValue__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(type_description_interfaces__msg__KeyValue__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__KeyValue__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__KeyValue__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__msg__KeyValue__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[doc = " Struct defined in srv/GetTypeDescription in the package type_description_interfaces."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct type_description_interfaces__srv__GetTypeDescription_Response {
    pub successful: bool,
    #[doc = " If `successful` is false, contains a reason for failure.\n If `successful` is true, this is left empty."]
    pub failure_reason: rosidl_runtime_c__String,
    #[doc = " The parsed type description which can be used programmatically."]
    pub type_description: type_description_interfaces__msg__TypeDescription,
    #[doc = " A list containing the interface definition source text of the requested type,\n plus all types it recursively depends on.\n Each source text is a copy of the original contents of the\n .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n The `encoding` field of each entry informs how to interpret its contents."]
    pub type_sources: type_description_interfaces__msg__TypeSource__Sequence,
    #[doc = " Key-value pairs of extra information."]
    pub extra_information: type_description_interfaces__msg__KeyValue__Sequence,
}
#[test]
fn bindgen_test_layout_type_description_interfaces__srv__GetTypeDescription_Response() {
    const UNINIT: ::std::mem::MaybeUninit<
        type_description_interfaces__srv__GetTypeDescription_Response,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<type_description_interfaces__srv__GetTypeDescription_Response>(),
        152usize,
        concat!(
            "Size of: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Response)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<type_description_interfaces__srv__GetTypeDescription_Response>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Response)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).successful) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Response),
            "::",
            stringify!(successful)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).failure_reason) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Response),
            "::",
            stringify!(failure_reason)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_description) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Response),
            "::",
            stringify!(type_description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_sources) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Response),
            "::",
            stringify!(type_sources)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extra_information) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Response),
            "::",
            stringify!(extra_information)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct type_description_interfaces__srv__GetTypeDescription_Response__Sequence {
    pub data: *mut type_description_interfaces__srv__GetTypeDescription_Response,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_type_description_interfaces__srv__GetTypeDescription_Response__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<
        type_description_interfaces__srv__GetTypeDescription_Response__Sequence,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            type_description_interfaces__srv__GetTypeDescription_Response__Sequence,
        >(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Response__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            type_description_interfaces__srv__GetTypeDescription_Response__Sequence,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Response__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Response__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Response__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Response__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
pub const service_msgs__msg__ServiceEventInfo__REQUEST_SENT: _bindgen_ty_93 = 0;
#[doc = " Constant 'REQUEST_SENT'."]
pub type _bindgen_ty_93 = ::std::os::raw::c_uint;
pub const service_msgs__msg__ServiceEventInfo__REQUEST_RECEIVED: _bindgen_ty_94 = 1;
#[doc = " Constant 'REQUEST_RECEIVED'."]
pub type _bindgen_ty_94 = ::std::os::raw::c_uint;
pub const service_msgs__msg__ServiceEventInfo__RESPONSE_SENT: _bindgen_ty_95 = 2;
#[doc = " Constant 'RESPONSE_SENT'."]
pub type _bindgen_ty_95 = ::std::os::raw::c_uint;
pub const service_msgs__msg__ServiceEventInfo__RESPONSE_RECEIVED: _bindgen_ty_96 = 3;
#[doc = " Constant 'RESPONSE_RECEIVED'."]
pub type _bindgen_ty_96 = ::std::os::raw::c_uint;
#[doc = " Struct defined in msg/Time in the package builtin_interfaces.\n**\n* This message communicates ROS Time defined here:\n* https://design.ros2.org/articles/clock_and_time.html\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct builtin_interfaces__msg__Time {
    #[doc = " The seconds component, valid over all int32 values."]
    pub sec: i32,
    #[doc = " The nanoseconds component, valid in the range [0, 1e9)."]
    pub nanosec: u32,
}
#[test]
fn bindgen_test_layout_builtin_interfaces__msg__Time() {
    const UNINIT: ::std::mem::MaybeUninit<builtin_interfaces__msg__Time> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<builtin_interfaces__msg__Time>(),
        8usize,
        concat!("Size of: ", stringify!(builtin_interfaces__msg__Time))
    );
    assert_eq!(
        ::std::mem::align_of::<builtin_interfaces__msg__Time>(),
        4usize,
        concat!("Alignment of ", stringify!(builtin_interfaces__msg__Time))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Time),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nanosec) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Time),
            "::",
            stringify!(nanosec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct builtin_interfaces__msg__Time__Sequence {
    pub data: *mut builtin_interfaces__msg__Time,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_builtin_interfaces__msg__Time__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<builtin_interfaces__msg__Time__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<builtin_interfaces__msg__Time__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(builtin_interfaces__msg__Time__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<builtin_interfaces__msg__Time__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(builtin_interfaces__msg__Time__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Time__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Time__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Time__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[doc = " Struct defined in msg/ServiceEventInfo in the package service_msgs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct service_msgs__msg__ServiceEventInfo {
    #[doc = " The type of event this message represents"]
    pub event_type: u8,
    #[doc = " Timestamp for when the event occurred (sent or received time)"]
    pub stamp: builtin_interfaces__msg__Time,
    #[doc = " Unique identifier for the client that sent the service request\n Note, this is only unique for the current session.\n The size here has to match the size of rmw_dds_common/msg/Gid,\n but unfortunately we cannot use that message directly due to a\n circular dependency."]
    pub client_gid: [u8; 16usize],
    #[doc = " Sequence number for the request\n Combined with the client ID, this creates a unique ID for the service transaction"]
    pub sequence_number: i64,
}
#[test]
fn bindgen_test_layout_service_msgs__msg__ServiceEventInfo() {
    const UNINIT: ::std::mem::MaybeUninit<service_msgs__msg__ServiceEventInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<service_msgs__msg__ServiceEventInfo>(),
        40usize,
        concat!("Size of: ", stringify!(service_msgs__msg__ServiceEventInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<service_msgs__msg__ServiceEventInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(service_msgs__msg__ServiceEventInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(service_msgs__msg__ServiceEventInfo),
            "::",
            stringify!(event_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(service_msgs__msg__ServiceEventInfo),
            "::",
            stringify!(stamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_gid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(service_msgs__msg__ServiceEventInfo),
            "::",
            stringify!(client_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence_number) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(service_msgs__msg__ServiceEventInfo),
            "::",
            stringify!(sequence_number)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct service_msgs__msg__ServiceEventInfo__Sequence {
    pub data: *mut service_msgs__msg__ServiceEventInfo,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_service_msgs__msg__ServiceEventInfo__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<service_msgs__msg__ServiceEventInfo__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<service_msgs__msg__ServiceEventInfo__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(service_msgs__msg__ServiceEventInfo__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<service_msgs__msg__ServiceEventInfo__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(service_msgs__msg__ServiceEventInfo__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(service_msgs__msg__ServiceEventInfo__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(service_msgs__msg__ServiceEventInfo__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(service_msgs__msg__ServiceEventInfo__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
pub const type_description_interfaces__srv__GetTypeDescription_Event__request__MAX_SIZE:
    _bindgen_ty_97 = 1;
pub type _bindgen_ty_97 = ::std::os::raw::c_uint;
pub const type_description_interfaces__srv__GetTypeDescription_Event__response__MAX_SIZE:
    _bindgen_ty_98 = 1;
pub type _bindgen_ty_98 = ::std::os::raw::c_uint;
#[doc = " Struct defined in srv/GetTypeDescription in the package type_description_interfaces."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct type_description_interfaces__srv__GetTypeDescription_Event {
    pub info: service_msgs__msg__ServiceEventInfo,
    pub request: type_description_interfaces__srv__GetTypeDescription_Request__Sequence,
    pub response: type_description_interfaces__srv__GetTypeDescription_Response__Sequence,
}
#[test]
fn bindgen_test_layout_type_description_interfaces__srv__GetTypeDescription_Event() {
    const UNINIT: ::std::mem::MaybeUninit<
        type_description_interfaces__srv__GetTypeDescription_Event,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<type_description_interfaces__srv__GetTypeDescription_Event>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Event)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<type_description_interfaces__srv__GetTypeDescription_Event>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Event),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Event),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Event),
            "::",
            stringify!(response)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct type_description_interfaces__srv__GetTypeDescription_Event__Sequence {
    pub data: *mut type_description_interfaces__srv__GetTypeDescription_Event,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_type_description_interfaces__srv__GetTypeDescription_Event__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<
        type_description_interfaces__srv__GetTypeDescription_Event__Sequence,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<type_description_interfaces__srv__GetTypeDescription_Event__Sequence>(
        ),
        24usize,
        concat!(
            "Size of: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Event__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<type_description_interfaces__srv__GetTypeDescription_Event__Sequence>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Event__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Event__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Event__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(type_description_interfaces__srv__GetTypeDescription_Event__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_NOT_SET: _bindgen_ty_99 = 0;
#[doc = " Constant 'FIELD_TYPE_NOT_SET'.\n**\n* A constant for each type supported according to:\n*   http://design.ros2.org/articles/legacy_interface_definition.html\n* and:\n*   http://design.ros2.org/articles/idl_interface_definition.html\n* Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n*  https://www.omg.org/spec/IDL/4.2\n* Layout of constants across the 0-255 decimal values in the uint8:\n*\n* - 000    : Reserved for \"not set\"\n* - 001-048: Primitive types, strings, and reserved space for future primitive types\n* - 049-096: Fixed sized array of primitive and string types\n* - 097-144: Bounded Sequences of primitive and string types\n* - 145-192: Unbounded Sequences of primitive and string types\n* - 193-255: Reserved space for future array/sequence-like types\n*/"]
pub type _bindgen_ty_99 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_NESTED_TYPE: _bindgen_ty_100 =
    1;
#[doc = " Constant 'FIELD_TYPE_NESTED_TYPE'.\n**\n* Nested type defined in other .msg/.idl files.\n*/"]
pub type _bindgen_ty_100 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT8: _bindgen_ty_101 = 2;
#[doc = " Constant 'FIELD_TYPE_INT8'.\n**\n* Integer Types\n*/"]
pub type _bindgen_ty_101 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT8: _bindgen_ty_102 = 3;
#[doc = " Constant 'FIELD_TYPE_UINT8'."]
pub type _bindgen_ty_102 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT16: _bindgen_ty_103 = 4;
#[doc = " Constant 'FIELD_TYPE_INT16'."]
pub type _bindgen_ty_103 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT16: _bindgen_ty_104 = 5;
#[doc = " Constant 'FIELD_TYPE_UINT16'."]
pub type _bindgen_ty_104 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT32: _bindgen_ty_105 = 6;
#[doc = " Constant 'FIELD_TYPE_INT32'."]
pub type _bindgen_ty_105 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT32: _bindgen_ty_106 = 7;
#[doc = " Constant 'FIELD_TYPE_UINT32'."]
pub type _bindgen_ty_106 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT64: _bindgen_ty_107 = 8;
#[doc = " Constant 'FIELD_TYPE_INT64'."]
pub type _bindgen_ty_107 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT64: _bindgen_ty_108 = 9;
#[doc = " Constant 'FIELD_TYPE_UINT64'."]
pub type _bindgen_ty_108 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_FLOAT: _bindgen_ty_109 = 10;
#[doc = " Constant 'FIELD_TYPE_FLOAT'.\n**\n* Floating-Point Types\n*/"]
pub type _bindgen_ty_109 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_DOUBLE: _bindgen_ty_110 = 11;
#[doc = " Constant 'FIELD_TYPE_DOUBLE'."]
pub type _bindgen_ty_110 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_LONG_DOUBLE: _bindgen_ty_111 =
    12;
#[doc = " Constant 'FIELD_TYPE_LONG_DOUBLE'."]
pub type _bindgen_ty_111 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_CHAR: _bindgen_ty_112 = 13;
#[doc = " Constant 'FIELD_TYPE_CHAR'.\n**\n* Char and WChar Types\n*/"]
pub type _bindgen_ty_112 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_WCHAR: _bindgen_ty_113 = 14;
#[doc = " Constant 'FIELD_TYPE_WCHAR'."]
pub type _bindgen_ty_113 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BOOLEAN: _bindgen_ty_114 = 15;
#[doc = " Constant 'FIELD_TYPE_BOOLEAN'.\n**\n* Boolean Type\n*/"]
pub type _bindgen_ty_114 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BYTE: _bindgen_ty_115 = 16;
#[doc = " Constant 'FIELD_TYPE_BYTE'.\n**\n* Byte/Octet Type\n*/"]
pub type _bindgen_ty_115 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_STRING: _bindgen_ty_116 = 17;
#[doc = " Constant 'FIELD_TYPE_STRING'.\n**\n* String Types\n*/"]
pub type _bindgen_ty_116 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_WSTRING: _bindgen_ty_117 = 18;
#[doc = " Constant 'FIELD_TYPE_WSTRING'."]
pub type _bindgen_ty_117 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_FIXED_STRING: _bindgen_ty_118 =
    19;
#[doc = " Constant 'FIELD_TYPE_FIXED_STRING'.\n**\n* Fixed String Types\n*/"]
pub type _bindgen_ty_118 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_FIXED_WSTRING: _bindgen_ty_119 =
    20;
#[doc = " Constant 'FIELD_TYPE_FIXED_WSTRING'."]
pub type _bindgen_ty_119 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BOUNDED_STRING:
    _bindgen_ty_120 = 21;
#[doc = " Constant 'FIELD_TYPE_BOUNDED_STRING'.\n**\n* Bounded String Types\n*/"]
pub type _bindgen_ty_120 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BOUNDED_WSTRING:
    _bindgen_ty_121 = 22;
#[doc = " Constant 'FIELD_TYPE_BOUNDED_WSTRING'."]
pub type _bindgen_ty_121 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_NESTED_TYPE_ARRAY:
    _bindgen_ty_122 = 49;
#[doc = " Constant 'FIELD_TYPE_NESTED_TYPE_ARRAY'.\n**\n* Fixed Sized Array Types\n*/"]
pub type _bindgen_ty_122 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT8_ARRAY: _bindgen_ty_123 =
    50;
#[doc = " Constant 'FIELD_TYPE_INT8_ARRAY'."]
pub type _bindgen_ty_123 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT8_ARRAY: _bindgen_ty_124 =
    51;
#[doc = " Constant 'FIELD_TYPE_UINT8_ARRAY'."]
pub type _bindgen_ty_124 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT16_ARRAY: _bindgen_ty_125 =
    52;
#[doc = " Constant 'FIELD_TYPE_INT16_ARRAY'."]
pub type _bindgen_ty_125 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT16_ARRAY: _bindgen_ty_126 =
    53;
#[doc = " Constant 'FIELD_TYPE_UINT16_ARRAY'."]
pub type _bindgen_ty_126 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT32_ARRAY: _bindgen_ty_127 =
    54;
#[doc = " Constant 'FIELD_TYPE_INT32_ARRAY'."]
pub type _bindgen_ty_127 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT32_ARRAY: _bindgen_ty_128 =
    55;
#[doc = " Constant 'FIELD_TYPE_UINT32_ARRAY'."]
pub type _bindgen_ty_128 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT64_ARRAY: _bindgen_ty_129 =
    56;
#[doc = " Constant 'FIELD_TYPE_INT64_ARRAY'."]
pub type _bindgen_ty_129 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT64_ARRAY: _bindgen_ty_130 =
    57;
#[doc = " Constant 'FIELD_TYPE_UINT64_ARRAY'."]
pub type _bindgen_ty_130 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_FLOAT_ARRAY: _bindgen_ty_131 =
    58;
#[doc = " Constant 'FIELD_TYPE_FLOAT_ARRAY'."]
pub type _bindgen_ty_131 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_DOUBLE_ARRAY: _bindgen_ty_132 =
    59;
#[doc = " Constant 'FIELD_TYPE_DOUBLE_ARRAY'."]
pub type _bindgen_ty_132 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_LONG_DOUBLE_ARRAY:
    _bindgen_ty_133 = 60;
#[doc = " Constant 'FIELD_TYPE_LONG_DOUBLE_ARRAY'."]
pub type _bindgen_ty_133 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_CHAR_ARRAY: _bindgen_ty_134 =
    61;
#[doc = " Constant 'FIELD_TYPE_CHAR_ARRAY'."]
pub type _bindgen_ty_134 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_WCHAR_ARRAY: _bindgen_ty_135 =
    62;
#[doc = " Constant 'FIELD_TYPE_WCHAR_ARRAY'."]
pub type _bindgen_ty_135 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BOOLEAN_ARRAY: _bindgen_ty_136 =
    63;
#[doc = " Constant 'FIELD_TYPE_BOOLEAN_ARRAY'."]
pub type _bindgen_ty_136 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BYTE_ARRAY: _bindgen_ty_137 =
    64;
#[doc = " Constant 'FIELD_TYPE_BYTE_ARRAY'."]
pub type _bindgen_ty_137 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_STRING_ARRAY: _bindgen_ty_138 =
    65;
#[doc = " Constant 'FIELD_TYPE_STRING_ARRAY'."]
pub type _bindgen_ty_138 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_WSTRING_ARRAY: _bindgen_ty_139 =
    66;
#[doc = " Constant 'FIELD_TYPE_WSTRING_ARRAY'."]
pub type _bindgen_ty_139 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_FIXED_STRING_ARRAY:
    _bindgen_ty_140 = 67;
#[doc = " Constant 'FIELD_TYPE_FIXED_STRING_ARRAY'."]
pub type _bindgen_ty_140 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_FIXED_WSTRING_ARRAY:
    _bindgen_ty_141 = 68;
#[doc = " Constant 'FIELD_TYPE_FIXED_WSTRING_ARRAY'."]
pub type _bindgen_ty_141 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BOUNDED_STRING_ARRAY:
    _bindgen_ty_142 = 69;
#[doc = " Constant 'FIELD_TYPE_BOUNDED_STRING_ARRAY'."]
pub type _bindgen_ty_142 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BOUNDED_WSTRING_ARRAY:
    _bindgen_ty_143 = 70;
#[doc = " Constant 'FIELD_TYPE_BOUNDED_WSTRING_ARRAY'."]
pub type _bindgen_ty_143 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE:
    _bindgen_ty_144 = 97;
#[doc = " Constant 'FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE'.\n**\n* Bounded Sequence Types\n*/"]
pub type _bindgen_ty_144 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT8_BOUNDED_SEQUENCE:
    _bindgen_ty_145 = 98;
#[doc = " Constant 'FIELD_TYPE_INT8_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_145 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT8_BOUNDED_SEQUENCE:
    _bindgen_ty_146 = 99;
#[doc = " Constant 'FIELD_TYPE_UINT8_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_146 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT16_BOUNDED_SEQUENCE:
    _bindgen_ty_147 = 100;
#[doc = " Constant 'FIELD_TYPE_INT16_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_147 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT16_BOUNDED_SEQUENCE:
    _bindgen_ty_148 = 101;
#[doc = " Constant 'FIELD_TYPE_UINT16_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_148 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT32_BOUNDED_SEQUENCE:
    _bindgen_ty_149 = 102;
#[doc = " Constant 'FIELD_TYPE_INT32_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_149 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT32_BOUNDED_SEQUENCE:
    _bindgen_ty_150 = 103;
#[doc = " Constant 'FIELD_TYPE_UINT32_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_150 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT64_BOUNDED_SEQUENCE:
    _bindgen_ty_151 = 104;
#[doc = " Constant 'FIELD_TYPE_INT64_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_151 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT64_BOUNDED_SEQUENCE:
    _bindgen_ty_152 = 105;
#[doc = " Constant 'FIELD_TYPE_UINT64_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_152 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE:
    _bindgen_ty_153 = 106;
#[doc = " Constant 'FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_153 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE:
    _bindgen_ty_154 = 107;
#[doc = " Constant 'FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_154 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE:
    _bindgen_ty_155 = 108;
#[doc = " Constant 'FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_155 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_CHAR_BOUNDED_SEQUENCE:
    _bindgen_ty_156 = 109;
#[doc = " Constant 'FIELD_TYPE_CHAR_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_156 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE:
    _bindgen_ty_157 = 110;
#[doc = " Constant 'FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_157 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE:
    _bindgen_ty_158 = 111;
#[doc = " Constant 'FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_158 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BYTE_BOUNDED_SEQUENCE:
    _bindgen_ty_159 = 112;
#[doc = " Constant 'FIELD_TYPE_BYTE_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_159 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_STRING_BOUNDED_SEQUENCE:
    _bindgen_ty_160 = 113;
#[doc = " Constant 'FIELD_TYPE_STRING_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_160 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE:
    _bindgen_ty_161 = 114;
#[doc = " Constant 'FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_161 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE : _bindgen_ty_162 = 115 ;
#[doc = " Constant 'FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_162 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE : _bindgen_ty_163 = 116 ;
#[doc = " Constant 'FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_163 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE : _bindgen_ty_164 = 117 ;
#[doc = " Constant 'FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_164 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE : _bindgen_ty_165 = 118 ;
#[doc = " Constant 'FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_165 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE : _bindgen_ty_166 = 145 ;
#[doc = " Constant 'FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE'.\n**\n* Unbounded Sequence Types\n*/"]
pub type _bindgen_ty_166 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE:
    _bindgen_ty_167 = 146;
#[doc = " Constant 'FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_167 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE:
    _bindgen_ty_168 = 147;
#[doc = " Constant 'FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_168 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE:
    _bindgen_ty_169 = 148;
#[doc = " Constant 'FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_169 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE:
    _bindgen_ty_170 = 149;
#[doc = " Constant 'FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_170 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE:
    _bindgen_ty_171 = 150;
#[doc = " Constant 'FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_171 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE:
    _bindgen_ty_172 = 151;
#[doc = " Constant 'FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_172 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE:
    _bindgen_ty_173 = 152;
#[doc = " Constant 'FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_173 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE:
    _bindgen_ty_174 = 153;
#[doc = " Constant 'FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_174 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE:
    _bindgen_ty_175 = 154;
#[doc = " Constant 'FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_175 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE:
    _bindgen_ty_176 = 155;
#[doc = " Constant 'FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_176 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE : _bindgen_ty_177 = 156 ;
#[doc = " Constant 'FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_177 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE:
    _bindgen_ty_178 = 157;
#[doc = " Constant 'FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_178 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE:
    _bindgen_ty_179 = 158;
#[doc = " Constant 'FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_179 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE:
    _bindgen_ty_180 = 159;
#[doc = " Constant 'FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_180 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE:
    _bindgen_ty_181 = 160;
#[doc = " Constant 'FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_181 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE:
    _bindgen_ty_182 = 161;
#[doc = " Constant 'FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_182 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE:
    _bindgen_ty_183 = 162;
#[doc = " Constant 'FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_183 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE : _bindgen_ty_184 = 163 ;
#[doc = " Constant 'FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_184 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE : _bindgen_ty_185 = 164 ;
#[doc = " Constant 'FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_185 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE : _bindgen_ty_186 = 165 ;
#[doc = " Constant 'FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_186 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE : _bindgen_ty_187 = 166 ;
#[doc = " Constant 'FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_187 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__nested_type_name__MAX_STRING_SIZE:
    _bindgen_ty_188 = 255;
pub type _bindgen_ty_188 = ::std::os::raw::c_uint;
#[doc = " Struct defined in msg/FieldType in the package type_description_interfaces.\n**\n* Represents the type of a field and related meta-data.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__type_description__FieldType {
    #[doc = " Identifying number for the type of the field, using one of the above constants."]
    pub type_id: u8,
    #[doc = " Only used when the type is an array or a bounded sequence.\n In the case of an array, this is the fixed capacity of the array.\n In the case of a bounded sequence, this is the maximum capacity of the sequence.\n In all other cases this field is unused."]
    pub capacity: u64,
    #[doc = " Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n In the case of a fixed string/wstring, it is the fixed length of the string.\n In the case of a bounded string/wstring, it is the maximum capacity of the string.\n In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n It is not currently possible to have different string capacities per element in the array/sequence."]
    pub string_capacity: u64,
    #[doc = " Only used when the type is a nested type or array/sequence of nested types.\n This is limited to 255 characters.\n TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n   We lack a ROS 2 specific limit in our design documents, but we should update\n   this and/or link to the design doc when that is available."]
    pub nested_type_name: rosidl_runtime_c__String,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__type_description__FieldType() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__type_description__FieldType> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__type_description__FieldType>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_runtime_c__type_description__FieldType)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__type_description__FieldType>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__type_description__FieldType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__FieldType),
            "::",
            stringify!(type_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__FieldType),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string_capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__FieldType),
            "::",
            stringify!(string_capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nested_type_name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__FieldType),
            "::",
            stringify!(nested_type_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__type_description__FieldType__Sequence {
    pub data: *mut rosidl_runtime_c__type_description__FieldType,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__type_description__FieldType__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__type_description__FieldType__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__type_description__FieldType__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_runtime_c__type_description__FieldType__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__type_description__FieldType__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__type_description__FieldType__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__FieldType__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__FieldType__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__FieldType__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[doc = " Struct defined in msg/Field in the package type_description_interfaces.\n**\n* Represents a single field in a type.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__type_description__Field {
    #[doc = " Name of the field."]
    pub name: rosidl_runtime_c__String,
    #[doc = " Type of the field, including details about the type like length, nested name, etc."]
    pub type_: rosidl_runtime_c__type_description__FieldType,
    #[doc = " Literal default value of the field as a string, as it appeared in the original\n message description file, whether that be .msg/.srv/.action or .idl."]
    pub default_value: rosidl_runtime_c__String,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__type_description__Field() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__type_description__Field> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__type_description__Field>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_runtime_c__type_description__Field)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__type_description__Field>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__type_description__Field)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__Field),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__Field),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__Field),
            "::",
            stringify!(default_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__type_description__Field__Sequence {
    pub data: *mut rosidl_runtime_c__type_description__Field,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__type_description__Field__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__type_description__Field__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__type_description__Field__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_runtime_c__type_description__Field__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__type_description__Field__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__type_description__Field__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__Field__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__Field__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__Field__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
pub const rosidl_runtime_c__type_description__IndividualTypeDescription__type_name__MAX_STRING_SIZE : _bindgen_ty_189 = 255 ;
pub type _bindgen_ty_189 = ::std::os::raw::c_uint;
#[doc = " Struct defined in msg/IndividualTypeDescription in the package type_description_interfaces.\n**\n* Represents a single type, without the types it references, if any.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__type_description__IndividualTypeDescription {
    #[doc = " Name of the type.\n This is limited to 255 characters.\n TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n   We lack a ROS 2 specific limit in our design documents, but we should update\n   this and/or link to the design doc when that is available."]
    pub type_name: rosidl_runtime_c__String,
    #[doc = " Fields of the type."]
    pub fields: rosidl_runtime_c__type_description__Field__Sequence,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__type_description__IndividualTypeDescription() {
    const UNINIT: ::std::mem::MaybeUninit<
        rosidl_runtime_c__type_description__IndividualTypeDescription,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__type_description__IndividualTypeDescription>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_runtime_c__type_description__IndividualTypeDescription)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__type_description__IndividualTypeDescription>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__type_description__IndividualTypeDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__IndividualTypeDescription),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fields) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__IndividualTypeDescription),
            "::",
            stringify!(fields)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__type_description__IndividualTypeDescription__Sequence {
    pub data: *mut rosidl_runtime_c__type_description__IndividualTypeDescription,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__type_description__IndividualTypeDescription__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<
        rosidl_runtime_c__type_description__IndividualTypeDescription__Sequence,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            rosidl_runtime_c__type_description__IndividualTypeDescription__Sequence,
        >(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_runtime_c__type_description__IndividualTypeDescription__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            rosidl_runtime_c__type_description__IndividualTypeDescription__Sequence,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__type_description__IndividualTypeDescription__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__IndividualTypeDescription__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__IndividualTypeDescription__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__IndividualTypeDescription__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[doc = " Struct defined in msg/TypeDescription in the package type_description_interfaces.\n**\n* Represents a complete type description, including the type itself as well as the types it references.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__type_description__TypeDescription {
    #[doc = " Description of the type."]
    pub type_description: rosidl_runtime_c__type_description__IndividualTypeDescription,
    #[doc = " Descriptions of all referenced types, recursively."]
    pub referenced_type_descriptions:
        rosidl_runtime_c__type_description__IndividualTypeDescription__Sequence,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__type_description__TypeDescription() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__type_description__TypeDescription> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__type_description__TypeDescription>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_runtime_c__type_description__TypeDescription)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__type_description__TypeDescription>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__type_description__TypeDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_description) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__TypeDescription),
            "::",
            stringify!(type_description)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).referenced_type_descriptions) as usize - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__TypeDescription),
            "::",
            stringify!(referenced_type_descriptions)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__type_description__TypeDescription__Sequence {
    pub data: *mut rosidl_runtime_c__type_description__TypeDescription,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__type_description__TypeDescription__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<
        rosidl_runtime_c__type_description__TypeDescription__Sequence,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__type_description__TypeDescription__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_runtime_c__type_description__TypeDescription__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__type_description__TypeDescription__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__type_description__TypeDescription__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__TypeDescription__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__TypeDescription__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__TypeDescription__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[doc = " Struct defined in msg/TypeSource in the package type_description_interfaces.\n**\n* Represents the original source of a ROS 2 interface definition.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__type_description__TypeSource {
    #[doc = " ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format."]
    pub type_name: rosidl_runtime_c__String,
    #[doc = " The type of the original source file, typically matching the file extension.\n Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n \"implicit\" specifies a type created automatically as a subtype of a\n complex type (service or action) - such as the request message for a service.\n Implicit types will have no contents, the full source will be available on the parent srv/action."]
    pub encoding: rosidl_runtime_c__String,
    #[doc = " Dumped contents of the interface definition source file.\n If `encoding` is \"dynamic\" or \"implicit\", this field will be empty."]
    pub raw_file_contents: rosidl_runtime_c__String,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__type_description__TypeSource() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__type_description__TypeSource> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__type_description__TypeSource>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_runtime_c__type_description__TypeSource)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__type_description__TypeSource>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__type_description__TypeSource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__TypeSource),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoding) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__TypeSource),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_file_contents) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__TypeSource),
            "::",
            stringify!(raw_file_contents)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__type_description__TypeSource__Sequence {
    pub data: *mut rosidl_runtime_c__type_description__TypeSource,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__type_description__TypeSource__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<
        rosidl_runtime_c__type_description__TypeSource__Sequence,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__type_description__TypeSource__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_runtime_c__type_description__TypeSource__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__type_description__TypeSource__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__type_description__TypeSource__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__TypeSource__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__TypeSource__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__TypeSource__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_sha256_ctx_s {
    pub data: [u8; 64usize],
    pub datalen: usize,
    pub bitlen: u64,
    pub state: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_rcutils_sha256_ctx_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcutils_sha256_ctx_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcutils_sha256_ctx_s>(),
        112usize,
        concat!("Size of: ", stringify!(rcutils_sha256_ctx_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcutils_sha256_ctx_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcutils_sha256_ctx_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_sha256_ctx_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).datalen) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_sha256_ctx_s),
            "::",
            stringify!(datalen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitlen) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_sha256_ctx_s),
            "::",
            stringify!(bitlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_sha256_ctx_s),
            "::",
            stringify!(state)
        )
    );
}
pub type rcutils_sha256_ctx_t = rcutils_sha256_ctx_s;
extern "C" {
    #[doc = " Initialize the sha256 algorithm context with starting state.\n**\n* Call this on any new context before starting to input data.\n*\n* \\param[inout] ctx\n* \\return void\n*/"]
    pub fn rcutils_sha256_init(ctx: *mut rcutils_sha256_ctx_t);
}
extern "C" {
    #[doc = " Add data to the sha256 algorithm\n**\n* This may be called repeatedly on an initialized context.\n*\n* \\param[inout] ctx Initialized sha256 context struct\n* \\param[in] data Data to add to the total message being hashed\n* \\param[in] data_len Size of the input data.\n* \\return void\n*/"]
    pub fn rcutils_sha256_update(ctx: *mut rcutils_sha256_ctx_t, data: *const u8, data_len: usize);
}
extern "C" {
    pub fn rcutils_sha256_final(ctx: *mut rcutils_sha256_ctx_t, output_hash: *mut u8);
}
#[doc = " A ROS 2 interface type hash per REP-2011 RIHS standard."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_type_hash_s {
    pub version: u8,
    pub value: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_rosidl_type_hash_s() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_type_hash_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_type_hash_s>(),
        33usize,
        concat!("Size of: ", stringify!(rosidl_type_hash_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_type_hash_s>(),
        1usize,
        concat!("Alignment of ", stringify!(rosidl_type_hash_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_type_hash_s),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_type_hash_s),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " A ROS 2 interface type hash per REP-2011 RIHS standard."]
pub type rosidl_type_hash_t = rosidl_type_hash_s;
extern "C" {
    #[doc = " Get a new zero-initialized type hash structure.\n**\n* Note that the version equals ROSIDL_TYPE_HASH_VERSION_UNSET.\n*/"]
    pub fn rosidl_get_zero_initialized_type_hash() -> rosidl_type_hash_t;
}
extern "C" {
    #[doc = " Convert type hash to a standardized string representation.\n**\n* Follows format RIHS{version}_{value}.\n*\n* \\param[in] type_hash Type hash to convert to string\n* \\param[in] allocator Allocator to use for allocating string space\n* \\param[out] output_string Handle to a pointer that will be set\n*   to the newly allocated null-terminated string representation.\n* \\return RCUTILS_RET_INVALID_ARGUMENT if any pointer arguments are null or allocator invalid\n* \\return RCUTILS_RET_BAD_ALLOC if space could not be allocated for resulting string\n* \\return RCUTILS_RET_OK otherwise\n*/"]
    pub fn rosidl_stringify_type_hash(
        type_hash: *const rosidl_type_hash_t,
        allocator: rcutils_allocator_t,
        output_string: *mut *mut ::std::os::raw::c_char,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Parse a stringified type hash to a struct.\n**\n* \\param[in] type_hash_string Null-terminated string with the hash representation\n* \\param[out] hash_out Preallocated structure to be filled with parsed hash information.\n*   hash_out->version will be 0 if no version could be parsed,\n*   but if a version could be determined this field will be set even if an error is returned\n* \\return RCTUILS_RET_INVALID_ARGUMENT on any null pointer argumunts, or malformed hash string.\n* \\return RCUTILS_RET_OK otherwise\n*/"]
    pub fn rosidl_parse_type_hash_string(
        type_hash_string: *const ::std::os::raw::c_char,
        hash_out: *mut rosidl_type_hash_t,
    ) -> rcutils_ret_t;
}
pub type rosidl_message_typesupport_handle_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_message_type_support_t,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const rosidl_message_type_support_t,
>;
pub type rosidl_message_get_type_hash_function = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const rosidl_message_type_support_t) -> *const rosidl_type_hash_t,
>;
pub type rosidl_message_get_type_description_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeDescription,
>;
pub type rosidl_message_get_type_description_sources_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource__Sequence,
>;
#[doc = " Contains rosidl message type support data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_message_type_support_t {
    #[doc = " String identifier for the type_support."]
    pub typesupport_identifier: *const ::std::os::raw::c_char,
    #[doc = " Pointer to the message type support library"]
    pub data: *const ::std::os::raw::c_void,
    #[doc = " Pointer to the message type support handler function"]
    pub func: rosidl_message_typesupport_handle_function,
    #[doc = " Pointer to function to get the hash of the message's description"]
    pub get_type_hash_func: rosidl_message_get_type_hash_function,
    #[doc = " Pointer to function to get the description of the type"]
    pub get_type_description_func: rosidl_message_get_type_description_function,
    #[doc = " Pointer to function to get the text of the sources that defined the description of the type"]
    pub get_type_description_sources_func: rosidl_message_get_type_description_sources_function,
}
#[test]
fn bindgen_test_layout_rosidl_message_type_support_t() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_message_type_support_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_message_type_support_t>(),
        48usize,
        concat!("Size of: ", stringify!(rosidl_message_type_support_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_message_type_support_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rosidl_message_type_support_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).typesupport_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_message_type_support_t),
            "::",
            stringify!(typesupport_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_message_type_support_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_message_type_support_t),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_type_hash_func) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_message_type_support_t),
            "::",
            stringify!(get_type_hash_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_type_description_func) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_message_type_support_t),
            "::",
            stringify!(get_type_description_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).get_type_description_sources_func) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_message_type_support_t),
            "::",
            stringify!(get_type_description_sources_func)
        )
    );
}
extern "C" {
    #[doc = " Return a rosidl_message_type_support_t struct with members set to `NULL`."]
    pub fn rosidl_get_zero_initialized_message_type_support_handle() -> rosidl_message_type_support_t;
}
extern "C" {
    #[doc = " Get the message type support handle specific to this identifier.\n**\n* The handle's message typesupport identifier function is returned or if the parameters are NULL\n* then an assert will happen.\n*\n* \\param handle Handle to message type support\n* \\param identifier The typesupport identifier to get the handle function for\n* \\return The associated message typesupport handle function.\n*/"]
    pub fn get_message_typesupport_handle(
        handle: *const rosidl_message_type_support_t,
        identifier: *const ::std::os::raw::c_char,
    ) -> *const rosidl_message_type_support_t;
}
extern "C" {
    #[doc = " If the identifier is the same as this handle's typesupport_identifier the handle is simply\n returned or if the parameters are NULL then an assert will happen.\n\n \\param handle Handle to message type support\n \\param identifier The typesupport identifier to get the handle function for\n \\return if the identifier match's the handle's identifier then the handle's function\n   is returned."]
    pub fn get_message_typesupport_handle_function(
        handle: *const rosidl_message_type_support_t,
        identifier: *const ::std::os::raw::c_char,
    ) -> *const rosidl_message_type_support_t;
}
pub type rosidl_service_typesupport_handle_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_service_type_support_t,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const rosidl_service_type_support_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_service_introspection_info_s {
    pub event_type: u8,
    pub stamp_sec: i32,
    pub stamp_nanosec: u32,
    pub client_gid: [u8; 16usize],
    pub sequence_number: i64,
}
#[test]
fn bindgen_test_layout_rosidl_service_introspection_info_s() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_service_introspection_info_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_service_introspection_info_s>(),
        40usize,
        concat!("Size of: ", stringify!(rosidl_service_introspection_info_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_service_introspection_info_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_service_introspection_info_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_introspection_info_s),
            "::",
            stringify!(event_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stamp_sec) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_introspection_info_s),
            "::",
            stringify!(stamp_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stamp_nanosec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_introspection_info_s),
            "::",
            stringify!(stamp_nanosec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_gid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_introspection_info_s),
            "::",
            stringify!(client_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence_number) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_introspection_info_s),
            "::",
            stringify!(sequence_number)
        )
    );
}
pub type rosidl_service_introspection_info_t = rosidl_service_introspection_info_s;
#[doc = " Creates a ServiceEvent message for the service.\n**\n* Instantiates a ServiceEvent message with the given info and request/response message.\n* The message is allocated using the given allocator and must be deallocated using\n* the rosidl_service_introspection_destroy_handle\n*\n* \\param[in] info POD fields of service_msgs/msg/ServiceEventInfo to be passed from rcl\n* \\param[in] allocator The allocator to use for allocating the ServiceEvent message\n* \\param[in] request_message type-erased handle to request message from rcl. Can be NULL.\n* \\param[in] response_message type-erased handle to request message from rcl. Can be NULL.\n* \\return The built ServiceEvent message. Will return NULL if the message could not be built.\n**/"]
pub type rosidl_event_message_create_handle_function_function = ::std::option::Option<
    unsafe extern "C" fn(
        info: *const rosidl_service_introspection_info_t,
        allocator: *mut rcutils_allocator_t,
        request_message: *const ::std::os::raw::c_void,
        response_message: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Destroys a ServiceEvent message\n**\n* Destroys a ServiceEvent message returned by a rosidl_service_introspection_message_create_handle\n* by calling the corresponding __fini function then deallocating\n*\n* \\param[in] event_message The message to destroy.\n* \\param[in] allocator The allocator to use for deallocating the message.\n*/"]
pub type rosidl_event_message_destroy_handle_function_function = ::std::option::Option<
    unsafe extern "C" fn(
        event_message: *mut ::std::os::raw::c_void,
        allocator: *mut rcutils_allocator_t,
    ) -> bool,
>;
pub type rosidl_service_get_type_hash_function = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const rosidl_service_type_support_t) -> *const rosidl_type_hash_t,
>;
pub type rosidl_service_get_type_description_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_service_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeDescription,
>;
pub type rosidl_service_get_type_description_sources_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_service_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource__Sequence,
>;
#[doc = " Contains rosidl service type support data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_service_type_support_t {
    #[doc = " String identifier for the type_support."]
    pub typesupport_identifier: *const ::std::os::raw::c_char,
    #[doc = " Pointer to the service type support library"]
    pub data: *const ::std::os::raw::c_void,
    #[doc = " Pointer to the service type support handler function"]
    pub func: rosidl_service_typesupport_handle_function,
    #[doc = " Service request message typesupport"]
    pub request_typesupport: *const rosidl_message_type_support_t,
    #[doc = " Service response message typesupport"]
    pub response_typesupport: *const rosidl_message_type_support_t,
    #[doc = " Service event message typesupport"]
    pub event_typesupport: *const rosidl_message_type_support_t,
    #[doc = " Pointer to function to create the introspection message"]
    pub event_message_create_handle_function: rosidl_event_message_create_handle_function_function,
    #[doc = " Pointer to function to finalize the introspection message"]
    pub event_message_destroy_handle_function:
        rosidl_event_message_destroy_handle_function_function,
    #[doc = " Pointer to function to get the hash of the message's description"]
    pub get_type_hash_func: rosidl_service_get_type_hash_function,
    #[doc = " Pointer to function to get the description of the type"]
    pub get_type_description_func: rosidl_service_get_type_description_function,
    #[doc = " Pointer to function to get the text of the sources that defined the description of the type"]
    pub get_type_description_sources_func: rosidl_service_get_type_description_sources_function,
}
#[test]
fn bindgen_test_layout_rosidl_service_type_support_t() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_service_type_support_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_service_type_support_t>(),
        88usize,
        concat!("Size of: ", stringify!(rosidl_service_type_support_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_service_type_support_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rosidl_service_type_support_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).typesupport_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_type_support_t),
            "::",
            stringify!(typesupport_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_type_support_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_type_support_t),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_typesupport) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_type_support_t),
            "::",
            stringify!(request_typesupport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_typesupport) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_type_support_t),
            "::",
            stringify!(response_typesupport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_typesupport) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_type_support_t),
            "::",
            stringify!(event_typesupport)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).event_message_create_handle_function) as usize
                - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_type_support_t),
            "::",
            stringify!(event_message_create_handle_function)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).event_message_destroy_handle_function) as usize
                - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_type_support_t),
            "::",
            stringify!(event_message_destroy_handle_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_type_hash_func) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_type_support_t),
            "::",
            stringify!(get_type_hash_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_type_description_func) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_type_support_t),
            "::",
            stringify!(get_type_description_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).get_type_description_sources_func) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_type_support_t),
            "::",
            stringify!(get_type_description_sources_func)
        )
    );
}
extern "C" {
    #[doc = " Get the service type support handle specific to this identifier.\n**\n* The handle's message typesupport identifier function is returned or if the parameters are NULL\n* then an assert will happen.\n*\n* \\param handle Handle to service type support\n* \\param identifier The typesupport identifier to get the handle function for\n* \\return The associated service typesupport handle function.\n*/"]
    pub fn get_service_typesupport_handle(
        handle: *const rosidl_service_type_support_t,
        identifier: *const ::std::os::raw::c_char,
    ) -> *const rosidl_service_type_support_t;
}
extern "C" {
    #[doc = " Get the service type support handle function specific to this identifier.\n**\n* If the identifier is the same as this handle's typesupport_identifier the handle is simply\n* returned or if the parameters are NULL then an assert will happen.\n*\n* \\param handle Handle to service type support\n* \\param identifier The typesupport identifier to get the handle function for\n* \\return if the identifier match's the handle's identifier then the handle's function\n*   is returned.\n*/"]
    pub fn get_service_typesupport_handle_function(
        handle: *const rosidl_service_type_support_t,
        identifier: *const ::std::os::raw::c_char,
    ) -> *const rosidl_service_type_support_t;
}
pub type rosidl_action_get_type_hash_function = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const rosidl_action_type_support_t) -> *const rosidl_type_hash_t,
>;
pub type rosidl_action_get_type_description_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_action_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeDescription,
>;
pub type rosidl_action_get_type_description_sources_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_action_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource__Sequence,
>;
#[doc = " Contains rosidl action type support data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_action_type_support_t {
    pub goal_service_type_support: *const rosidl_service_type_support_t,
    pub result_service_type_support: *const rosidl_service_type_support_t,
    pub cancel_service_type_support: *const rosidl_service_type_support_t,
    pub feedback_message_type_support: *const rosidl_message_type_support_t,
    pub status_message_type_support: *const rosidl_message_type_support_t,
    #[doc = " Pointer to function to get the hash of the action's description"]
    pub get_type_hash_func: rosidl_action_get_type_hash_function,
    #[doc = " Pointer to function to get the description of the type"]
    pub get_type_description_func: rosidl_action_get_type_description_function,
    #[doc = " Pointer to function to get the text of the sources that defined the description of the type"]
    pub get_type_description_sources_func: rosidl_action_get_type_description_sources_function,
}
#[test]
fn bindgen_test_layout_rosidl_action_type_support_t() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_action_type_support_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_action_type_support_t>(),
        64usize,
        concat!("Size of: ", stringify!(rosidl_action_type_support_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_action_type_support_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rosidl_action_type_support_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).goal_service_type_support) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_action_type_support_t),
            "::",
            stringify!(goal_service_type_support)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result_service_type_support) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_action_type_support_t),
            "::",
            stringify!(result_service_type_support)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cancel_service_type_support) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_action_type_support_t),
            "::",
            stringify!(cancel_service_type_support)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).feedback_message_type_support) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_action_type_support_t),
            "::",
            stringify!(feedback_message_type_support)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status_message_type_support) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_action_type_support_t),
            "::",
            stringify!(status_message_type_support)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_type_hash_func) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_action_type_support_t),
            "::",
            stringify!(get_type_hash_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_type_description_func) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_action_type_support_t),
            "::",
            stringify!(get_type_description_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).get_type_description_sources_func) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_action_type_support_t),
            "::",
            stringify!(get_type_description_sources_func)
        )
    );
}
extern "C" {
    #[doc = " Retrieve pointer to the hash of the description of this type."]
    pub fn type_description_interfaces__srv__GetTypeDescription__get_type_hash(
        type_support: *const rosidl_service_type_support_t,
    ) -> *const rosidl_type_hash_t;
}
extern "C" {
    #[doc = " Retrieve pointer to the description of this type."]
    pub fn type_description_interfaces__srv__GetTypeDescription__get_type_description(
        type_support: *const rosidl_service_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeDescription;
}
extern "C" {
    #[doc = " Retrieve pointer to the single raw source text that defined this type."]
    pub fn type_description_interfaces__srv__GetTypeDescription__get_individual_type_description_source(
        type_support: *const rosidl_service_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource;
}
extern "C" {
    #[doc = " Retrieve pointer to the recursive raw sources that defined the description of this type."]
    pub fn type_description_interfaces__srv__GetTypeDescription__get_type_description_sources(
        type_support: *const rosidl_service_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource__Sequence;
}
extern "C" {
    #[doc = " Initialize srv/GetTypeDescription message.\n**\n* If the init function is called twice for the same message without\n* calling fini inbetween previously allocated memory will be leaked.\n* \\param[in,out] msg The previously allocated message pointer.\n* Fields without a default value will not be initialized by this function.\n* You might want to call memset(msg, 0, sizeof(\n* type_description_interfaces__srv__GetTypeDescription_Request\n* )) before or use\n* type_description_interfaces__srv__GetTypeDescription_Request__create()\n* to allocate and initialize the message.\n* \\return true if initialization was successful, otherwise false\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Request__init(
        msg: *mut type_description_interfaces__srv__GetTypeDescription_Request,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize srv/GetTypeDescription message.\n**\n* \\param[in,out] msg The allocated message pointer.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Request__fini(
        msg: *mut type_description_interfaces__srv__GetTypeDescription_Request,
    );
}
extern "C" {
    #[doc = " Create srv/GetTypeDescription message.\n**\n* It allocates the memory for the message, sets the memory to zero, and\n* calls\n* type_description_interfaces__srv__GetTypeDescription_Request__init().\n* \\return The pointer to the initialized message if successful,\n* otherwise NULL\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Request__create(
    ) -> *mut type_description_interfaces__srv__GetTypeDescription_Request;
}
extern "C" {
    #[doc = " Destroy srv/GetTypeDescription message.\n**\n* It calls\n* type_description_interfaces__srv__GetTypeDescription_Request__fini()\n* and frees the memory of the message.\n* \\param[in,out] msg The allocated message pointer.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Request__destroy(
        msg: *mut type_description_interfaces__srv__GetTypeDescription_Request,
    );
}
extern "C" {
    #[doc = " Check for srv/GetTypeDescription message equality.\n**\n* \\param[in] lhs The message on the left hand size of the equality operator.\n* \\param[in] rhs The message on the right hand size of the equality operator.\n* \\return true if messages are equal, otherwise false.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Request__are_equal(
        lhs: *const type_description_interfaces__srv__GetTypeDescription_Request,
        rhs: *const type_description_interfaces__srv__GetTypeDescription_Request,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a srv/GetTypeDescription message.\n**\n* This functions performs a deep copy, as opposed to the shallow copy that\n* plain assignment yields.\n*\n* \\param[in] input The source message pointer.\n* \\param[out] output The target message pointer, which must\n*   have been initialized before calling this function.\n* \\return true if successful, or false if either pointer is null\n*   or memory allocation fails.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Request__copy(
        input: *const type_description_interfaces__srv__GetTypeDescription_Request,
        output: *mut type_description_interfaces__srv__GetTypeDescription_Request,
    ) -> bool;
}
extern "C" {
    #[doc = " Retrieve pointer to the hash of the description of this type."]
    pub fn type_description_interfaces__srv__GetTypeDescription_Request__get_type_hash(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_type_hash_t;
}
extern "C" {
    #[doc = " Retrieve pointer to the description of this type."]
    pub fn type_description_interfaces__srv__GetTypeDescription_Request__get_type_description(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeDescription;
}
extern "C" {
    #[doc = " Retrieve pointer to the single raw source text that defined this type."]
    pub fn type_description_interfaces__srv__GetTypeDescription_Request__get_individual_type_description_source(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource;
}
extern "C" {
    #[doc = " Retrieve pointer to the recursive raw sources that defined the description of this type."]
    pub fn type_description_interfaces__srv__GetTypeDescription_Request__get_type_description_sources(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource__Sequence;
}
extern "C" {
    #[doc = " Initialize array of srv/GetTypeDescription messages.\n**\n* It allocates the memory for the number of elements and calls\n* type_description_interfaces__srv__GetTypeDescription_Request__init()\n* for each element of the array.\n* \\param[in,out] array The allocated array pointer.\n* \\param[in] size The size / capacity of the array.\n* \\return true if initialization was successful, otherwise false\n* If the array pointer is valid and the size is zero it is guaranteed\n# to return true.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Request__Sequence__init(
        array: *mut type_description_interfaces__srv__GetTypeDescription_Request__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of srv/GetTypeDescription messages.\n**\n* It calls\n* type_description_interfaces__srv__GetTypeDescription_Request__fini()\n* for each element of the array and frees the memory for the number of\n* elements.\n* \\param[in,out] array The initialized array pointer.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Request__Sequence__fini(
        array: *mut type_description_interfaces__srv__GetTypeDescription_Request__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of srv/GetTypeDescription messages.\n**\n* It allocates the memory for the array and calls\n* type_description_interfaces__srv__GetTypeDescription_Request__Sequence__init().\n* \\param[in] size The size / capacity of the array.\n* \\return The pointer to the initialized array if successful, otherwise NULL\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Request__Sequence__create(
        size: usize,
    ) -> *mut type_description_interfaces__srv__GetTypeDescription_Request__Sequence;
}
extern "C" {
    #[doc = " Destroy array of srv/GetTypeDescription messages.\n**\n* It calls\n* type_description_interfaces__srv__GetTypeDescription_Request__Sequence__fini()\n* on the array,\n* and frees the memory of the array.\n* \\param[in,out] array The initialized array pointer.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Request__Sequence__destroy(
        array: *mut type_description_interfaces__srv__GetTypeDescription_Request__Sequence,
    );
}
extern "C" {
    #[doc = " Check for srv/GetTypeDescription message array equality.\n**\n* \\param[in] lhs The message array on the left hand size of the equality operator.\n* \\param[in] rhs The message array on the right hand size of the equality operator.\n* \\return true if message arrays are equal in size and content, otherwise false.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Request__Sequence__are_equal(
        lhs: *const type_description_interfaces__srv__GetTypeDescription_Request__Sequence,
        rhs: *const type_description_interfaces__srv__GetTypeDescription_Request__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of srv/GetTypeDescription messages.\n**\n* This functions performs a deep copy, as opposed to the shallow copy that\n* plain assignment yields.\n*\n* \\param[in] input The source array pointer.\n* \\param[out] output The target array pointer, which must\n*   have been initialized before calling this function.\n* \\return true if successful, or false if either pointer\n*   is null or memory allocation fails.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Request__Sequence__copy(
        input: *const type_description_interfaces__srv__GetTypeDescription_Request__Sequence,
        output: *mut type_description_interfaces__srv__GetTypeDescription_Request__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize srv/GetTypeDescription message.\n**\n* If the init function is called twice for the same message without\n* calling fini inbetween previously allocated memory will be leaked.\n* \\param[in,out] msg The previously allocated message pointer.\n* Fields without a default value will not be initialized by this function.\n* You might want to call memset(msg, 0, sizeof(\n* type_description_interfaces__srv__GetTypeDescription_Response\n* )) before or use\n* type_description_interfaces__srv__GetTypeDescription_Response__create()\n* to allocate and initialize the message.\n* \\return true if initialization was successful, otherwise false\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Response__init(
        msg: *mut type_description_interfaces__srv__GetTypeDescription_Response,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize srv/GetTypeDescription message.\n**\n* \\param[in,out] msg The allocated message pointer.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Response__fini(
        msg: *mut type_description_interfaces__srv__GetTypeDescription_Response,
    );
}
extern "C" {
    #[doc = " Create srv/GetTypeDescription message.\n**\n* It allocates the memory for the message, sets the memory to zero, and\n* calls\n* type_description_interfaces__srv__GetTypeDescription_Response__init().\n* \\return The pointer to the initialized message if successful,\n* otherwise NULL\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Response__create(
    ) -> *mut type_description_interfaces__srv__GetTypeDescription_Response;
}
extern "C" {
    #[doc = " Destroy srv/GetTypeDescription message.\n**\n* It calls\n* type_description_interfaces__srv__GetTypeDescription_Response__fini()\n* and frees the memory of the message.\n* \\param[in,out] msg The allocated message pointer.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Response__destroy(
        msg: *mut type_description_interfaces__srv__GetTypeDescription_Response,
    );
}
extern "C" {
    #[doc = " Check for srv/GetTypeDescription message equality.\n**\n* \\param[in] lhs The message on the left hand size of the equality operator.\n* \\param[in] rhs The message on the right hand size of the equality operator.\n* \\return true if messages are equal, otherwise false.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Response__are_equal(
        lhs: *const type_description_interfaces__srv__GetTypeDescription_Response,
        rhs: *const type_description_interfaces__srv__GetTypeDescription_Response,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a srv/GetTypeDescription message.\n**\n* This functions performs a deep copy, as opposed to the shallow copy that\n* plain assignment yields.\n*\n* \\param[in] input The source message pointer.\n* \\param[out] output The target message pointer, which must\n*   have been initialized before calling this function.\n* \\return true if successful, or false if either pointer is null\n*   or memory allocation fails.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Response__copy(
        input: *const type_description_interfaces__srv__GetTypeDescription_Response,
        output: *mut type_description_interfaces__srv__GetTypeDescription_Response,
    ) -> bool;
}
extern "C" {
    #[doc = " Retrieve pointer to the hash of the description of this type."]
    pub fn type_description_interfaces__srv__GetTypeDescription_Response__get_type_hash(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_type_hash_t;
}
extern "C" {
    #[doc = " Retrieve pointer to the description of this type."]
    pub fn type_description_interfaces__srv__GetTypeDescription_Response__get_type_description(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeDescription;
}
extern "C" {
    #[doc = " Retrieve pointer to the single raw source text that defined this type."]
    pub fn type_description_interfaces__srv__GetTypeDescription_Response__get_individual_type_description_source(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource;
}
extern "C" {
    #[doc = " Retrieve pointer to the recursive raw sources that defined the description of this type."]
    pub fn type_description_interfaces__srv__GetTypeDescription_Response__get_type_description_sources(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource__Sequence;
}
extern "C" {
    #[doc = " Initialize array of srv/GetTypeDescription messages.\n**\n* It allocates the memory for the number of elements and calls\n* type_description_interfaces__srv__GetTypeDescription_Response__init()\n* for each element of the array.\n* \\param[in,out] array The allocated array pointer.\n* \\param[in] size The size / capacity of the array.\n* \\return true if initialization was successful, otherwise false\n* If the array pointer is valid and the size is zero it is guaranteed\n# to return true.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Response__Sequence__init(
        array: *mut type_description_interfaces__srv__GetTypeDescription_Response__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of srv/GetTypeDescription messages.\n**\n* It calls\n* type_description_interfaces__srv__GetTypeDescription_Response__fini()\n* for each element of the array and frees the memory for the number of\n* elements.\n* \\param[in,out] array The initialized array pointer.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Response__Sequence__fini(
        array: *mut type_description_interfaces__srv__GetTypeDescription_Response__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of srv/GetTypeDescription messages.\n**\n* It allocates the memory for the array and calls\n* type_description_interfaces__srv__GetTypeDescription_Response__Sequence__init().\n* \\param[in] size The size / capacity of the array.\n* \\return The pointer to the initialized array if successful, otherwise NULL\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Response__Sequence__create(
        size: usize,
    ) -> *mut type_description_interfaces__srv__GetTypeDescription_Response__Sequence;
}
extern "C" {
    #[doc = " Destroy array of srv/GetTypeDescription messages.\n**\n* It calls\n* type_description_interfaces__srv__GetTypeDescription_Response__Sequence__fini()\n* on the array,\n* and frees the memory of the array.\n* \\param[in,out] array The initialized array pointer.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Response__Sequence__destroy(
        array: *mut type_description_interfaces__srv__GetTypeDescription_Response__Sequence,
    );
}
extern "C" {
    #[doc = " Check for srv/GetTypeDescription message array equality.\n**\n* \\param[in] lhs The message array on the left hand size of the equality operator.\n* \\param[in] rhs The message array on the right hand size of the equality operator.\n* \\return true if message arrays are equal in size and content, otherwise false.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Response__Sequence__are_equal(
        lhs: *const type_description_interfaces__srv__GetTypeDescription_Response__Sequence,
        rhs: *const type_description_interfaces__srv__GetTypeDescription_Response__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of srv/GetTypeDescription messages.\n**\n* This functions performs a deep copy, as opposed to the shallow copy that\n* plain assignment yields.\n*\n* \\param[in] input The source array pointer.\n* \\param[out] output The target array pointer, which must\n*   have been initialized before calling this function.\n* \\return true if successful, or false if either pointer\n*   is null or memory allocation fails.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Response__Sequence__copy(
        input: *const type_description_interfaces__srv__GetTypeDescription_Response__Sequence,
        output: *mut type_description_interfaces__srv__GetTypeDescription_Response__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize srv/GetTypeDescription message.\n**\n* If the init function is called twice for the same message without\n* calling fini inbetween previously allocated memory will be leaked.\n* \\param[in,out] msg The previously allocated message pointer.\n* Fields without a default value will not be initialized by this function.\n* You might want to call memset(msg, 0, sizeof(\n* type_description_interfaces__srv__GetTypeDescription_Event\n* )) before or use\n* type_description_interfaces__srv__GetTypeDescription_Event__create()\n* to allocate and initialize the message.\n* \\return true if initialization was successful, otherwise false\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Event__init(
        msg: *mut type_description_interfaces__srv__GetTypeDescription_Event,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize srv/GetTypeDescription message.\n**\n* \\param[in,out] msg The allocated message pointer.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Event__fini(
        msg: *mut type_description_interfaces__srv__GetTypeDescription_Event,
    );
}
extern "C" {
    #[doc = " Create srv/GetTypeDescription message.\n**\n* It allocates the memory for the message, sets the memory to zero, and\n* calls\n* type_description_interfaces__srv__GetTypeDescription_Event__init().\n* \\return The pointer to the initialized message if successful,\n* otherwise NULL\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Event__create(
    ) -> *mut type_description_interfaces__srv__GetTypeDescription_Event;
}
extern "C" {
    #[doc = " Destroy srv/GetTypeDescription message.\n**\n* It calls\n* type_description_interfaces__srv__GetTypeDescription_Event__fini()\n* and frees the memory of the message.\n* \\param[in,out] msg The allocated message pointer.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Event__destroy(
        msg: *mut type_description_interfaces__srv__GetTypeDescription_Event,
    );
}
extern "C" {
    #[doc = " Check for srv/GetTypeDescription message equality.\n**\n* \\param[in] lhs The message on the left hand size of the equality operator.\n* \\param[in] rhs The message on the right hand size of the equality operator.\n* \\return true if messages are equal, otherwise false.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Event__are_equal(
        lhs: *const type_description_interfaces__srv__GetTypeDescription_Event,
        rhs: *const type_description_interfaces__srv__GetTypeDescription_Event,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a srv/GetTypeDescription message.\n**\n* This functions performs a deep copy, as opposed to the shallow copy that\n* plain assignment yields.\n*\n* \\param[in] input The source message pointer.\n* \\param[out] output The target message pointer, which must\n*   have been initialized before calling this function.\n* \\return true if successful, or false if either pointer is null\n*   or memory allocation fails.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Event__copy(
        input: *const type_description_interfaces__srv__GetTypeDescription_Event,
        output: *mut type_description_interfaces__srv__GetTypeDescription_Event,
    ) -> bool;
}
extern "C" {
    #[doc = " Retrieve pointer to the hash of the description of this type."]
    pub fn type_description_interfaces__srv__GetTypeDescription_Event__get_type_hash(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_type_hash_t;
}
extern "C" {
    #[doc = " Retrieve pointer to the description of this type."]
    pub fn type_description_interfaces__srv__GetTypeDescription_Event__get_type_description(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeDescription;
}
extern "C" {
    #[doc = " Retrieve pointer to the single raw source text that defined this type."]
    pub fn type_description_interfaces__srv__GetTypeDescription_Event__get_individual_type_description_source(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource;
}
extern "C" {
    #[doc = " Retrieve pointer to the recursive raw sources that defined the description of this type."]
    pub fn type_description_interfaces__srv__GetTypeDescription_Event__get_type_description_sources(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource__Sequence;
}
extern "C" {
    #[doc = " Initialize array of srv/GetTypeDescription messages.\n**\n* It allocates the memory for the number of elements and calls\n* type_description_interfaces__srv__GetTypeDescription_Event__init()\n* for each element of the array.\n* \\param[in,out] array The allocated array pointer.\n* \\param[in] size The size / capacity of the array.\n* \\return true if initialization was successful, otherwise false\n* If the array pointer is valid and the size is zero it is guaranteed\n# to return true.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Event__Sequence__init(
        array: *mut type_description_interfaces__srv__GetTypeDescription_Event__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of srv/GetTypeDescription messages.\n**\n* It calls\n* type_description_interfaces__srv__GetTypeDescription_Event__fini()\n* for each element of the array and frees the memory for the number of\n* elements.\n* \\param[in,out] array The initialized array pointer.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Event__Sequence__fini(
        array: *mut type_description_interfaces__srv__GetTypeDescription_Event__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of srv/GetTypeDescription messages.\n**\n* It allocates the memory for the array and calls\n* type_description_interfaces__srv__GetTypeDescription_Event__Sequence__init().\n* \\param[in] size The size / capacity of the array.\n* \\return The pointer to the initialized array if successful, otherwise NULL\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Event__Sequence__create(
        size: usize,
    ) -> *mut type_description_interfaces__srv__GetTypeDescription_Event__Sequence;
}
extern "C" {
    #[doc = " Destroy array of srv/GetTypeDescription messages.\n**\n* It calls\n* type_description_interfaces__srv__GetTypeDescription_Event__Sequence__fini()\n* on the array,\n* and frees the memory of the array.\n* \\param[in,out] array The initialized array pointer.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Event__Sequence__destroy(
        array: *mut type_description_interfaces__srv__GetTypeDescription_Event__Sequence,
    );
}
extern "C" {
    #[doc = " Check for srv/GetTypeDescription message array equality.\n**\n* \\param[in] lhs The message array on the left hand size of the equality operator.\n* \\param[in] rhs The message array on the right hand size of the equality operator.\n* \\return true if message arrays are equal in size and content, otherwise false.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Event__Sequence__are_equal(
        lhs: *const type_description_interfaces__srv__GetTypeDescription_Event__Sequence,
        rhs: *const type_description_interfaces__srv__GetTypeDescription_Event__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of srv/GetTypeDescription messages.\n**\n* This functions performs a deep copy, as opposed to the shallow copy that\n* plain assignment yields.\n*\n* \\param[in] input The source array pointer.\n* \\param[out] output The target array pointer, which must\n*   have been initialized before calling this function.\n* \\return true if successful, or false if either pointer\n*   is null or memory allocation fails.\n*/"]
    pub fn type_description_interfaces__srv__GetTypeDescription_Event__Sequence__copy(
        input: *const type_description_interfaces__srv__GetTypeDescription_Event__Sequence,
        output: *mut type_description_interfaces__srv__GetTypeDescription_Event__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__type_description_interfaces__srv__GetTypeDescription_Request(
    ) -> *const rosidl_message_type_support_t;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__type_description_interfaces__srv__GetTypeDescription_Response(
    ) -> *const rosidl_message_type_support_t;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__type_description_interfaces__srv__GetTypeDescription_Event(
    ) -> *const rosidl_message_type_support_t;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_service_type_support_handle__type_description_interfaces__srv__GetTypeDescription(
    ) -> *const rosidl_service_type_support_t;
}
extern "C" {
    pub fn rosidl_typesupport_c__create_service_event_message__type_description_interfaces__srv__GetTypeDescription(
        info: *const rosidl_service_introspection_info_t,
        allocator: *mut rcutils_allocator_t,
        request_message: *const ::std::os::raw::c_void,
        response_message: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rosidl_typesupport_c__destroy_service_event_message__type_description_interfaces__srv__GetTypeDescription(
        event_msg: *mut ::std::os::raw::c_void,
        allocator: *mut rcutils_allocator_t,
    ) -> bool;
}
extern "C" {
    pub static RCL_DISABLE_LOANED_MESSAGES_ENV_VAR: *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_node_impl_s {
    _unused: [u8; 0],
}
pub type rcl_node_impl_t = rcl_node_impl_s;
#[doc = " Structure which encapsulates a ROS Service."]
pub type rcl_service_t = rcl_service_s;
#[doc = " Structure which encapsulates a ROS Node."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_node_s {
    #[doc = " Context associated with this node."]
    pub context: *mut rcl_context_t,
    #[doc = " Private implementation pointer."]
    pub impl_: *mut rcl_node_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_node_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_node_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_node_s>(),
        16usize,
        concat!("Size of: ", stringify!(rcl_node_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_node_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_node_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_node_s),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_node_s),
            "::",
            stringify!(impl_)
        )
    );
}
#[doc = " Structure which encapsulates a ROS Node."]
pub type rcl_node_t = rcl_node_s;
extern "C" {
    #[doc = " Return a rcl_node_t struct with members initialized to `NULL`."]
    pub fn rcl_get_zero_initialized_node() -> rcl_node_t;
}
extern "C" {
    #[doc = " Initialize a ROS node.\n**\n* Calling this on a rcl_node_t makes it a valid node handle until rcl_shutdown\n* is called or until rcl_node_fini is called on it.\n*\n* After calling, the ROS node object can be used to create other middleware\n* primitives like publishers, services, parameters, etc.\n*\n* The name of the node must not be NULL and adhere to naming restrictions,\n* see the rmw_validate_node_name() function for rules.\n*\n* \\todo TODO(wjwwood): node name uniqueness is not yet enforced\n*\n* The name of the node cannot coincide with another node of the same name.\n* If a node of the same name is already in the domain, it will be shutdown.\n*\n* The namespace of the node should not be NULL and should also pass the\n* rmw_validate_namespace() function's rules.\n*\n* Additionally this function allows namespaces which lack a leading forward\n* slash.\n* Because there is no notion of a relative namespace, there is no difference\n* between a namespace which lacks a forward and the same namespace with a\n* leading forward slash.\n* Therefore, a namespace like ``\"foo/bar\"`` is automatically changed to\n* ``\"/foo/bar\"`` by this function.\n* Similarly, the namespace ``\"\"`` will implicitly become ``\"/\"`` which is a\n* valid namespace.\n*\n* \\todo TODO(wjwwood):\n*   Parameter infrastructure is currently initialized in the language specific\n*   client library, e.g. rclcpp for C++, but will be initialized here in the\n*   future. When that happens there will be an option to avoid parameter\n*   infrastructure with an option in the rcl_node_options_t struct.\n*\n* A node contains infrastructure for ROS parameters, which include advertising\n* publishers and service servers.\n* This function will create those external parameter interfaces even if\n* parameters are not used later.\n*\n* The rcl_node_t given must be allocated and zero initialized.\n* Passing an rcl_node_t which has already had this function called on it, more\n* recently than rcl_node_fini, will fail.\n* An allocated rcl_node_t with uninitialized memory is undefined behavior.\n*\n* Expected usage:\n*\n* ```c\n* rcl_context_t context = rcl_get_zero_initialized_context();\n* // ... initialize the context with rcl_init()\n* rcl_node_t node = rcl_get_zero_initialized_node();\n* rcl_node_options_t node_ops = rcl_node_get_default_options();\n* // ... node options customization\n* rcl_ret_t ret = rcl_node_init(&node, \"node_name\", \"/node_ns\", &context, &node_ops);\n* // ... error handling and then use the node, but eventually deinitialize it:\n* ret = rcl_node_fini(&node);\n* // ... error handling for rcl_node_fini()\n* ```\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | Yes\n* Lock-Free          | Yes [1]\n* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>\n*\n* \\pre the node handle must be allocated, zero initialized, and invalid\n* \\pre the context handle must be allocated, initialized, and valid\n* \\post the node handle is valid and can be used in other `rcl_*` functions\n*\n* \\param[inout] node a preallocated rcl_node_t\n* \\param[in] name the name of the node, must be a valid c-string\n* \\param[in] namespace_ the namespace of the node, must be a valid c-string\n* \\param[in] context the context instance with which the node should be\n*   associated\n* \\param[in] options the node options.\n*   The options are deep copied into the node.\n*   The caller is always responsible for freeing memory used options they\n*   pass in.\n* \\return #RCL_RET_OK if the node was initialized successfully, or\n* \\return #RCL_RET_ALREADY_INIT if the node has already be initialized, or\n* \\return #RCL_RET_NOT_INIT if the given context is invalid, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_NODE_INVALID_NAME if the name is invalid, or\n* \\return #RCL_RET_NODE_INVALID_NAMESPACE if the namespace_ is invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_node_init(
        node: *mut rcl_node_t,
        name: *const ::std::os::raw::c_char,
        namespace_: *const ::std::os::raw::c_char,
        context: *mut rcl_context_t,
        options: *const rcl_node_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a rcl_node_t.\n**\n* Destroys any automatically created infrastructure and deallocates memory.\n* After calling, the rcl_node_t can be safely deallocated.\n*\n* All middleware primitives created by the user, e.g. publishers, services, etc,\n* which were created from this node must be finalized using their respective\n* `rcl_*_fini()` functions before this is called.\n* \\sa rcl_publisher_fini()\n* \\sa rcl_subscription_fini()\n* \\sa rcl_client_fini()\n* \\sa rcl_service_fini()\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | Yes\n* Lock-Free          | Yes [1]\n* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>\n*\n* \\param[in] node rcl_node_t to be finalized\n* \\return #RCL_RET_OK if node was finalized successfully, or\n* \\return #RCL_RET_NODE_INVALID if the node pointer is null, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_node_fini(node: *mut rcl_node_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return `true` if the node is valid, else `false`.\n**\n* Also return `false` if the node pointer is `NULL` or the allocator is invalid.\n*\n* A node is invalid if:\n*   - the implementation is `NULL` (rcl_node_init not called or failed)\n*   - rcl_shutdown has been called since the node has been initialized\n*   - the node has been finalized with rcl_node_fini\n*\n* There is a possible validity race condition.\n*\n* Consider:\n*\n* ```c\n* assert(rcl_node_is_valid(node));  // <-- thread 1\n* rcl_shutdown();                   // <-- thread 2\n* // use node as if valid           // <-- thread 1\n* ```\n*\n* In the third line the node is now invalid, even though on the previous line\n* of thread 1 it was checked to be valid.\n* This is why this function is considered not thread-safe.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | Yes\n* Lock-Free          | Yes [1]\n* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>\n*\n* \\param[in] node rcl_node_t to be validated\n* \\return `true` if the node and allocator are valid, otherwise `false`.\n*/"]
    pub fn rcl_node_is_valid(node: *const rcl_node_t) -> bool;
}
extern "C" {
    #[doc = " Return true if node is valid, except for the context being valid.\n**\n* This is used in clean up functions that need to access the node, but do not\n* need use any functions with the context.\n*\n* It is identical to rcl_node_is_valid except it ignores the state of the\n* context associated with the node.\n* \\sa rcl_node_is_valid()\n*/"]
    pub fn rcl_node_is_valid_except_context(node: *const rcl_node_t) -> bool;
}
extern "C" {
    #[doc = " Return the name of the node.\n**\n* This function returns the node's internal name string.\n* This function can fail, and therefore return `NULL`, if:\n*   - node is `NULL`\n*   - node has not been initialized (the implementation is invalid)\n*\n* The returned string is only valid as long as the given rcl_node_t is valid.\n* The value of the string may change if the value in the rcl_node_t changes,\n* and therefore copying the string is recommended if this is a concern.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] node pointer to the node\n* \\return name string if successful, otherwise `NULL`\n*/"]
    pub fn rcl_node_get_name(node: *const rcl_node_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the namespace of the node.\n**\n* This function returns the node's internal namespace string.\n* This function can fail, and therefore return `NULL`, if:\n*   - node is `NULL`\n*   - node has not been initialized (the implementation is invalid)\n*\n* The returned string is only valid as long as the given rcl_node_t is valid.\n* The value of the string may change if the value in the rcl_node_t changes,\n* and therefore copying the string is recommended if this is a concern.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] node pointer to the node\n* \\return name string if successful, otherwise `NULL`\n*/"]
    pub fn rcl_node_get_namespace(node: *const rcl_node_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the fully qualified name of the node.\n**\n* This function returns the node's internal namespace and name combined string.\n* This function can fail, and therefore return `NULL`, if:\n*   - node is `NULL`\n*   - node has not been initialized (the implementation is invalid)\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] node pointer to the node\n* \\return fully qualified name string if successful, otherwise `NULL`\n*/"]
    pub fn rcl_node_get_fully_qualified_name(
        node: *const rcl_node_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the rcl node options.\n**\n* This function returns the node's internal options struct.\n* This function can fail, and therefore return `NULL`, if:\n*   - node is `NULL`\n*   - node has not been initialized (the implementation is invalid)\n*\n* The returned struct is only valid as long as the given rcl_node_t is valid.\n* The values in the struct may change if the options of the rcl_node_t changes,\n* and therefore copying the struct is recommended if this is a concern.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] node pointer to the node\n* \\return options struct if successful, otherwise `NULL`\n*/"]
    pub fn rcl_node_get_options(node: *const rcl_node_t) -> *const rcl_node_options_t;
}
extern "C" {
    #[doc = " Return the ROS domain ID that the node is using.\n**\n* This function returns the ROS domain ID that the node is in.\n*\n* This function should be used to determine what `domain_id` was used rather\n* than checking the domain_id field in the node options, because if\n* #RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID is used when creating the node then\n* it is not changed after creation, but this function will return the actual\n* `domain_id` used.\n*\n* The `domain_id` field must point to an allocated `size_t` object to which\n* the ROS domain ID will be written.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] node the handle to the node being queried\n* \\param[out] domain_id storage for the domain id\n* \\return #RCL_RET_OK if node the domain ID was retrieved successfully, or\n* \\return #RCL_RET_NODE_INVALID if the node is invalid, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_node_get_domain_id(node: *const rcl_node_t, domain_id: *mut usize) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the rmw node handle.\n**\n* The handle returned is a pointer to the internally held rmw handle.\n* This function can fail, and therefore return `NULL`, if:\n*   - node is `NULL`\n*   - node has not been initialized (the implementation is invalid)\n*\n* The returned handle is made invalid if the node is finalized or if\n* rcl_shutdown() is called.\n* The returned handle is not guaranteed to be valid for the life time of the\n* node as it may be finalized and recreated itself.\n* Therefore it is recommended to get the handle from the node using\n* this function each time it is needed and avoid use of the handle\n* concurrently with functions that might change it.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] node pointer to the rcl node\n* \\return rmw node handle if successful, otherwise `NULL`\n*/"]
    pub fn rcl_node_get_rmw_handle(node: *const rcl_node_t) -> *mut rmw_node_t;
}
extern "C" {
    #[doc = " Return the associated rcl instance id.\n**\n* This id is stored when rcl_node_init is called and can be compared with the\n* value returned by rcl_get_instance_id() to check if this node was created in\n* the current rcl context (since the latest call to rcl_init().\n*\n* This function can fail, and therefore return `0`, if:\n*   - node is `NULL`\n*   - node has not been initialized (the implementation is invalid)\n*\n* This function will succeed even if rcl_shutdown() has been called\n* since the node was created.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] node pointer to the rcl node\n* \\return rcl instance id captured during node init or `0` on error\n*/"]
    pub fn rcl_node_get_rcl_instance_id(node: *const rcl_node_t) -> u64;
}
extern "C" {
    #[doc = " Return a guard condition which is triggered when the ROS graph changes.\n**\n* The handle returned is a pointer to an internally held rcl guard condition.\n* This function can fail, and therefore return `NULL`, if:\n*   - node is `NULL`\n*   - node is invalid\n*\n* The returned handle is made invalid if the node is finialized or if\n* rcl_shutdown() is called.\n*\n* The guard condition will be triggered anytime a change to the ROS graph occurs.\n* A ROS graph change includes things like (but not limited to) a new publisher\n* advertises, a new subscription is created, a new service becomes available,\n* a subscription is canceled, etc.\n*\n* \\todo TODO(wjwwood): link to exhaustive list of graph events\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] node pointer to the rcl node\n* \\return rcl guard condition handle if successful, otherwise `NULL`\n*/"]
    pub fn rcl_node_get_graph_guard_condition(
        node: *const rcl_node_t,
    ) -> *const rcl_guard_condition_t;
}
extern "C" {
    #[doc = " Return the logger name of the node.\n**\n* This function returns the node's internal logger name string.\n* This function can fail, and therefore return `NULL`, if:\n*   - node is `NULL`\n*   - node has not been initialized (the implementation is invalid)\n*\n* The returned string is only valid as long as the given rcl_node_t is valid.\n* The value of the string may change if the value in the rcl_node_t changes,\n* and therefore copying the string is recommended if this is a concern.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] node pointer to the node\n* \\return logger_name string if successful, otherwise `NULL`\n*/"]
    pub fn rcl_node_get_logger_name(node: *const rcl_node_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Expand a given name into a fully-qualified topic name and apply remapping rules.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] node Node object. Its name, namespace, local/global command line arguments are used.\n* \\param[in] input_name Topic name to be expanded and remapped.\n* \\param[in] allocator The allocator to be used when creating the output topic.\n* \\param[in] is_service For services use `true`, for topics use `false`.\n* \\param[in] only_expand When `true`, remapping rules are ignored.\n* \\param[out] output_name Output char * pointer.\n* \\return #RCL_RET_OK if the topic name was expanded successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any of input_name, node_name, node_namespace\n*  or output_name are NULL, or\n* \\return #RCL_RET_INVALID_ARGUMENT if both local_args and global_args are NULL, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_TOPIC_NAME_INVALID if the given topic name is invalid\n*  (see rcl_validate_topic_name()), or\n* \\return #RCL_RET_NODE_INVALID_NAME if the given node name is invalid\n*  (see rmw_validate_node_name()), or\n* \\return #RCL_RET_NODE_INVALID_NAMESPACE if the given node namespace is invalid\n*  (see rmw_validate_namespace()), or\n* \\return #RCL_RET_UNKNOWN_SUBSTITUTION for unknown substitutions in name, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_node_resolve_name(
        node: *const rcl_node_t,
        input_name: *const ::std::os::raw::c_char,
        allocator: rcl_allocator_t,
        is_service: bool,
        only_expand: bool,
        output_name: *mut *mut ::std::os::raw::c_char,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Check if loaned message is disabled, according to the environment variable.\n**\n* If the `ROS_DISABLE_LOANED_MESSAGES` environment variable is set to \"1\",\n* `disable_loaned_message` will be set to true.\n*\n* \\param[out] disable_loaned_message Must not be NULL.\n* \\return #RCL_RET_INVALID_ARGUMENT if an argument is not valid, or\n* \\return #RCL_RET_ERROR if an unexpected error happened, or\n* \\return #RCL_RET_OK.\n*/"]
    pub fn rcl_get_disable_loaned_message(disable_loaned_message: *mut bool) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Initialize the node's ~/get_type_description service.\n**\n* This function initializes the node's ~/get_type_description service\n* which can be used to retrieve information about types used by the node's\n* publishers, subscribers, services or actions.\n*\n* Note that this will not register any callback for the service, client-level code\n* must register rcl_node_type_description_service_handle_request or a custom callback\n* to handle incoming requests, via that client's executor/waitset capabilities.\n*\n* This will initialize the node's type cache, if it has not been initialized already.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] node handle to the node for which to initialize the service\n* \\return #RCL_RET_OK if the service was successfully initialized, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ALREADY_INIT if the service is already initialized, or\n* \\return #RCL_RET_BAD_ALLOC if memory allocation for the service failed, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_node_type_description_service_init(node: *mut rcl_node_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalizes the node's ~/get_type_description service.\n**\n* This function finalizes the node's private ~/get_type_description service.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] node the handle to the node whose type cache should be initialized\n* \\return #RCL_RET_OK if service was deinitialized successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_SERVICE_INVALID if the service is invalid, or\n* \\return #RCL_RET_NODE_INVALID if the node is invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_node_type_description_service_fini(node: *mut rcl_node_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Returns a pointer to the node's ~/get_type_description service.\n**\n* On success, sets service_out to the initialized service.\n* rcl_node_type_description_service_init must be called before this.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] node the handle to the node\n* \\param[out] service_out Handle to pointer that will be set\n* \\return #RCL_RET_OK if valid service was returned successfully, or\n* \\return #RCL_RET_NODE_INVALID if node is invalid, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_NOT_INIT if the service hasn't yet been initialized, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_node_get_type_description_service(
        node: *const rcl_node_t,
        service_out: *mut *mut rcl_service_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Process a single pending request to the GetTypeDescription service.\n**\n* This function may be called to handle incoming requests by any client starting the service.\n* It is not intended to be called directly by users.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] node the handle to the node\n* \\param[in] request_header ID of the incoming request\n* \\param[in] request Request that came in to the service\n* \\param[out] response Allocated, uninitialized response to the request\n* \\return void\n*/"]
    pub fn rcl_node_type_description_service_handle_request(
        node: *mut rcl_node_t,
        request_header: *const rmw_request_id_t,
        request: *const type_description_interfaces__srv__GetTypeDescription_Request,
        response: *mut type_description_interfaces__srv__GetTypeDescription_Response,
    );
}
#[doc = " A single point in time, measured in nanoseconds since the Unix epoch."]
pub type rcl_time_point_value_t = rcutils_time_point_value_t;
#[doc = " A duration of time, measured in nanoseconds."]
pub type rcl_duration_value_t = rcutils_duration_value_t;
#[doc = " Clock uninitialized"]
pub const rcl_clock_type_e_RCL_CLOCK_UNINITIALIZED: rcl_clock_type_e = 0;
#[doc = " Use ROS time"]
pub const rcl_clock_type_e_RCL_ROS_TIME: rcl_clock_type_e = 1;
#[doc = " Use system time"]
pub const rcl_clock_type_e_RCL_SYSTEM_TIME: rcl_clock_type_e = 2;
#[doc = " Use a steady clock time"]
pub const rcl_clock_type_e_RCL_STEADY_TIME: rcl_clock_type_e = 3;
#[doc = " Time source type, used to indicate the source of a time measurement.\n**\n* RCL_ROS_TIME will report the latest value reported by a ROS time source, or\n* if a ROS time source is not active it reports the same as RCL_SYSTEM_TIME.\n* For more information about ROS time sources, refer to the design document:\n* http://design.ros2.org/articles/clock_and_time.html\n*\n* RCL_SYSTEM_TIME reports the same value as the system clock.\n*\n* RCL_STEADY_TIME reports a value from a monotonically increasing clock.\n*/"]
pub type rcl_clock_type_e = ::std::os::raw::c_uint;
#[doc = " Time source type, used to indicate the source of a time measurement.\n**\n* RCL_ROS_TIME will report the latest value reported by a ROS time source, or\n* if a ROS time source is not active it reports the same as RCL_SYSTEM_TIME.\n* For more information about ROS time sources, refer to the design document:\n* http://design.ros2.org/articles/clock_and_time.html\n*\n* RCL_SYSTEM_TIME reports the same value as the system clock.\n*\n* RCL_STEADY_TIME reports a value from a monotonically increasing clock.\n*/"]
pub use self::rcl_clock_type_e as rcl_clock_type_t;
#[doc = " A duration of time, measured in nanoseconds and its source."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_duration_s {
    #[doc = " Duration in nanoseconds and its source."]
    pub nanoseconds: rcl_duration_value_t,
}
#[test]
fn bindgen_test_layout_rcl_duration_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_duration_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_duration_s>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_duration_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_duration_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_duration_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nanoseconds) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_duration_s),
            "::",
            stringify!(nanoseconds)
        )
    );
}
#[doc = " A duration of time, measured in nanoseconds and its source."]
pub type rcl_duration_t = rcl_duration_s;
#[doc = " The source before and after the jump is ROS_TIME."]
pub const rcl_clock_change_e_RCL_ROS_TIME_NO_CHANGE: rcl_clock_change_e = 1;
#[doc = " The source switched to ROS_TIME from SYSTEM_TIME."]
pub const rcl_clock_change_e_RCL_ROS_TIME_ACTIVATED: rcl_clock_change_e = 2;
#[doc = " The source switched to SYSTEM_TIME from ROS_TIME."]
pub const rcl_clock_change_e_RCL_ROS_TIME_DEACTIVATED: rcl_clock_change_e = 3;
#[doc = " The source before and after the jump is SYSTEM_TIME."]
pub const rcl_clock_change_e_RCL_SYSTEM_TIME_NO_CHANGE: rcl_clock_change_e = 4;
#[doc = " Enumeration to describe the type of time jump."]
pub type rcl_clock_change_e = ::std::os::raw::c_uint;
#[doc = " Enumeration to describe the type of time jump."]
pub use self::rcl_clock_change_e as rcl_clock_change_t;
#[doc = " Struct to describe a jump in time."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_time_jump_s {
    #[doc = " Indicate whether or not the source of time changed."]
    pub clock_change: rcl_clock_change_t,
    #[doc = " The new time minus the last time before the jump."]
    pub delta: rcl_duration_t,
}
#[test]
fn bindgen_test_layout_rcl_time_jump_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_time_jump_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_time_jump_s>(),
        16usize,
        concat!("Size of: ", stringify!(rcl_time_jump_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_time_jump_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_time_jump_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clock_change) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_time_jump_s),
            "::",
            stringify!(clock_change)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_time_jump_s),
            "::",
            stringify!(delta)
        )
    );
}
#[doc = " Struct to describe a jump in time."]
pub type rcl_time_jump_t = rcl_time_jump_s;
#[doc = " Signature of a time jump callback.\n \\param[in] time_jump A description of the jump in time.\n \\param[in] before_jump Every jump callback is called twice: once before the clock changes and\n once after. This is true the first call and false the second.\n \\param[in] user_data A pointer given at callback registration which is passed to the callback."]
pub type rcl_jump_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        time_jump: *const rcl_time_jump_t,
        before_jump: bool,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Describe the prerequisites for calling a time jump callback."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_jump_threshold_s {
    #[doc = " True to call callback when the clock type changes."]
    pub on_clock_change: bool,
    #[doc = " A positive duration indicating the minimum jump forwards to be considered exceeded, or zero\n to disable."]
    pub min_forward: rcl_duration_t,
    #[doc = " A negative duration indicating the minimum jump backwards to be considered exceeded, or zero\n to disable."]
    pub min_backward: rcl_duration_t,
}
#[test]
fn bindgen_test_layout_rcl_jump_threshold_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_jump_threshold_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_jump_threshold_s>(),
        24usize,
        concat!("Size of: ", stringify!(rcl_jump_threshold_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_jump_threshold_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_jump_threshold_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_clock_change) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_jump_threshold_s),
            "::",
            stringify!(on_clock_change)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_forward) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_jump_threshold_s),
            "::",
            stringify!(min_forward)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_backward) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_jump_threshold_s),
            "::",
            stringify!(min_backward)
        )
    );
}
#[doc = " Describe the prerequisites for calling a time jump callback."]
pub type rcl_jump_threshold_t = rcl_jump_threshold_s;
#[doc = " Struct to describe an added callback."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_jump_callback_info_s {
    #[doc = " Callback to fucntion."]
    pub callback: rcl_jump_callback_t,
    #[doc = " Threshold to decide when to call the callback."]
    pub threshold: rcl_jump_threshold_t,
    #[doc = " Pointer passed to the callback."]
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rcl_jump_callback_info_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_jump_callback_info_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_jump_callback_info_s>(),
        40usize,
        concat!("Size of: ", stringify!(rcl_jump_callback_info_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_jump_callback_info_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_jump_callback_info_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_jump_callback_info_s),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threshold) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_jump_callback_info_s),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_jump_callback_info_s),
            "::",
            stringify!(user_data)
        )
    );
}
#[doc = " Struct to describe an added callback."]
pub type rcl_jump_callback_info_t = rcl_jump_callback_info_s;
#[doc = " Encapsulation of a time source."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_clock_s {
    #[doc = " Clock type"]
    pub type_: rcl_clock_type_t,
    #[doc = " An array of added jump callbacks."]
    pub jump_callbacks: *mut rcl_jump_callback_info_t,
    #[doc = " Number of callbacks in jump_callbacks."]
    pub num_jump_callbacks: usize,
    #[doc = " Pointer to get_now function"]
    pub get_now: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            now: *mut rcl_time_point_value_t,
        ) -> rcl_ret_t,
    >,
    #[doc = " Clock storage"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " Custom allocator used for internal allocations."]
    pub allocator: rcl_allocator_t,
}
#[test]
fn bindgen_test_layout_rcl_clock_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_clock_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_clock_s>(),
        80usize,
        concat!("Size of: ", stringify!(rcl_clock_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_clock_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_clock_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_clock_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jump_callbacks) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_clock_s),
            "::",
            stringify!(jump_callbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_jump_callbacks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_clock_s),
            "::",
            stringify!(num_jump_callbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_now) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_clock_s),
            "::",
            stringify!(get_now)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_clock_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_clock_s),
            "::",
            stringify!(allocator)
        )
    );
}
#[doc = " Encapsulation of a time source."]
pub type rcl_clock_t = rcl_clock_s;
#[doc = " A single point in time, measured in nanoseconds, the reference point is based on the source."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_time_point_s {
    #[doc = " Nanoseconds of the point in time"]
    pub nanoseconds: rcl_time_point_value_t,
    #[doc = " Clock type of the point in time"]
    pub clock_type: rcl_clock_type_t,
}
#[test]
fn bindgen_test_layout_rcl_time_point_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_time_point_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_time_point_s>(),
        16usize,
        concat!("Size of: ", stringify!(rcl_time_point_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_time_point_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_time_point_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nanoseconds) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_time_point_s),
            "::",
            stringify!(nanoseconds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clock_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_time_point_s),
            "::",
            stringify!(clock_type)
        )
    );
}
#[doc = " A single point in time, measured in nanoseconds, the reference point is based on the source."]
pub type rcl_time_point_t = rcl_time_point_s;
extern "C" {
    #[doc = " Check if the clock has started.\n**\n* This function returns true if the clock contains a time point value\n* that is non-zero.\n* Note that if data is uninitialized it may give a false positive.\n*\n* This function is primarily used to check if a clock using ROS time\n* has started. This is because it is possible that a simulator might be\n* initialized paused, causing ROS time to be 0 until it is unpaused.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] clock the handle to the clock which is being queried\n* \\return true if the clock has started, otherwise return false.\n*/"]
    pub fn rcl_clock_time_started(clock: *mut rcl_clock_t) -> bool;
}
extern "C" {
    #[doc = " Check if the clock has valid values.\n**\n* This function returns true if the time source appears to be valid.\n* It will check that the type is not uninitialized, and that pointers\n* are not invalid.\n* Note that if data is uninitialized it may give a false positive.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] clock the handle to the clock which is being queried\n* \\return true if the source is believed to be valid, otherwise return false.\n*/"]
    pub fn rcl_clock_valid(clock: *mut rcl_clock_t) -> bool;
}
extern "C" {
    #[doc = " Initialize a clock based on the passed type.\n**\n* This will allocate all necessary internal structures, and initialize variables.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes [1]\n* Thread-Safe        | No [2]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* <i>[1] If `clock_type` is #RCL_ROS_TIME</i>\n* <i>[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe.\n*        Thread-safety is also affected by that of the `allocator` object.</i>\n*\n* \\param[in] clock_type the type identifying the time source to provide\n* \\param[in] clock the handle to the clock which is being initialized\n* \\param[in] allocator The allocator to use for allocations\n* \\return #RCL_RET_OK if the time source was successfully initialized, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_clock_init(
        clock_type: rcl_clock_type_t,
        clock: *mut rcl_clock_t,
        allocator: *mut rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a clock.\n**\n* This will deallocate all necessary internal structures, and clean up any variables.\n* It can be combined with any of the init functions.\n*\n* Passing a clock with type #RCL_CLOCK_UNINITIALIZED will result in\n* #RCL_RET_INVALID_ARGUMENT being returned.\n*\n* This function is not thread-safe with any other function operating on the same\n* clock object.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No [1]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.\n*        Thread-safety is also affected by that of the `allocator` object associated with the\n*        `clock` object.</i>\n*\n* \\param[in] clock the handle to the clock which is being finalized\n* \\return #RCL_RET_OK if the time source was successfully finalized, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_clock_fini(clock: *mut rcl_clock_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Initialize a clock as a #RCL_ROS_TIME time source.\n**\n* This will allocate all necessary internal structures, and initialize variables.\n* It is specifically setting up a #RCL_ROS_TIME time source.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No [1]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* <i>[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe.\n*        Thread-safety is also affected by that of the `allocator` object.</i>\n*\n* \\param[in] clock the handle to the clock which is being initialized\n* \\param[in] allocator The allocator to use for allocations\n* \\return #RCL_RET_OK if the time source was successfully initialized, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_ros_clock_init(
        clock: *mut rcl_clock_t,
        allocator: *mut rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a clock as a #RCL_ROS_TIME time source.\n**\n* This will deallocate all necessary internal structures, and clean up any variables.\n* It is specifically setting up a #RCL_ROS_TIME time source. It is expected\n* to be paired with the init fuction.\n*\n* This function is not thread-safe with any other function operating on the same\n* clock object.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No [1]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.\n*        Thread-safety is also affected by that of the `allocator` object associated with the\n*        `clock` object.</i>\n*\n* \\param[in] clock the handle to the clock which is being initialized\n* \\return #RCL_RET_OK if the time source was successfully finalized, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_ros_clock_fini(clock: *mut rcl_clock_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Initialize a clock as a #RCL_STEADY_TIME time source.\n**\n* This will allocate all necessary internal structures, and initialize variables.\n* It is specifically setting up a #RCL_STEADY_TIME time source.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No [1]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.\n*        Thread-safety is also affected by that of the `allocator` object.</i>\n*\n* \\param[in] clock the handle to the clock which is being initialized\n* \\param[in] allocator The allocator to use for allocations\n* \\return #RCL_RET_OK if the time source was successfully initialized, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_steady_clock_init(
        clock: *mut rcl_clock_t,
        allocator: *mut rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a clock as a #RCL_STEADY_TIME time source.\n**\n* Finalize the clock as a #RCL_STEADY_TIME time source.\n*\n* This will deallocate all necessary internal structures, and clean up any variables.\n* It is specifically setting up a steady time source. It is expected to be\n* paired with the init fuction.\n*\n* This function is not thread-safe with any other function operating on the same\n* clock object.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No [1]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.\n*        Thread-safety is also affected by that of the `allocator` object associated with the\n*        `clock` object.</i>\n*\n* \\param[in] clock the handle to the clock which is being initialized\n* \\return #RCL_RET_OK if the time source was successfully finalized, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_steady_clock_fini(clock: *mut rcl_clock_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Initialize a clock as a #RCL_SYSTEM_TIME time source.\n**\n* Initialize the clock as a #RCL_SYSTEM_TIME time source.\n*\n* This will allocate all necessary internal structures, and initialize variables.\n* It is specifically setting up a system time source.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No [1]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.\n*        Thread-safety is also affected by that of the `allocator` object associated with the\n*        `clock` object.</i>\n*\n* \\param[in] clock the handle to the clock which is being initialized\n* \\param[in] allocator The allocator to use for allocations\n* \\return #RCL_RET_OK if the time source was successfully initialized, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_system_clock_init(
        clock: *mut rcl_clock_t,
        allocator: *mut rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a clock as a #RCL_SYSTEM_TIME time source.\n**\n* Finalize the clock as a #RCL_SYSTEM_TIME time source.\n*\n* This will deallocate all necessary internal structures, and clean up any variables.\n* It is specifically setting up a system time source. It is expected to be paired with\n* the init fuction.\n*\n* This function is not thread-safe with any function operating on the same clock object.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No [1]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.\n*        Thread-safety is also affected by that of the `allocator` object associated with the\n*        `clock` object.</i>\n*\n* \\param[in] clock the handle to the clock which is being initialized.\n* \\return #RCL_RET_OK if the time source was successfully finalized, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_system_clock_fini(clock: *mut rcl_clock_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Compute the difference between two time points\n**\n* This function takes two time points and computes the duration between them.\n* The two time points must be using the same time abstraction, and the\n* resultant duration will also be of the same abstraction.\n*\n* The value will be computed as duration = finish - start. If start is after\n* finish the duration will be negative.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] start The time point for the start of the duration.\n* \\param[in] finish The time point for the end of the duration.\n* \\param[out] delta The duration between the start and finish.\n* \\return #RCL_RET_OK if the difference was computed successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_difference_times(
        start: *const rcl_time_point_t,
        finish: *const rcl_time_point_t,
        delta: *mut rcl_duration_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Fill the time point value with the current value of the associated clock.\n**\n* This function will populate the data of the time_point_value object with the\n* current value from it's associated time abstraction.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Yes [1]\n* Lock-Free          | Yes\n*\n* <i>[1] If `clock` is of #RCL_ROS_TIME type.</i>\n*\n* \\param[in] clock The time source from which to set the value.\n* \\param[out] time_point_value The time_point value to populate.\n* \\return #RCL_RET_OK if the last call time was retrieved successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_clock_get_now(
        clock: *mut rcl_clock_t,
        time_point_value: *mut rcl_time_point_value_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Enable the ROS time abstraction override.\n**\n* This method will enable the ROS time abstraction override values,\n* such that the time source will report the set value instead of falling\n* back to system time.\n*\n* This function is not thread-safe with rcl_clock_add_jump_callback(),\n* nor rcl_clock_remove_jump_callback() functions when used on the same\n* clock object.\n*\n* <hr>\n* Attribute          | Adherence [1]\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No [2]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* <i>[1] Only applies to the function itself, as jump callbacks may not abide to it.</i>\n* <i>[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe.</i>\n*\n* \\param[in] clock The clock to enable.\n* \\return #RCL_RET_OK if the time source was enabled successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_enable_ros_time_override(clock: *mut rcl_clock_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Disable the ROS time abstraction override.\n**\n* This method will disable the #RCL_ROS_TIME time abstraction override values,\n* such that the time source will report the system time even if a custom\n* value has been set.\n*\n* This function is not thread-safe with rcl_clock_add_jump_callback(),\n* nor rcl_clock_remove_jump_callback() functions when used on the same\n* clock object.\n*\n* <hr>\n* Attribute          | Adherence [1]\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No [2]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* <i>[1] Only applies to the function itself, as jump callbacks may not abide to it.</i>\n* <i>[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe.</i>\n*\n* \\param[in] clock The clock to disable.\n* \\return #RCL_RET_OK if the time source was disabled successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_disable_ros_time_override(clock: *mut rcl_clock_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Check if the #RCL_ROS_TIME time source has the override enabled.\n**\n* This will populate the is_enabled object to indicate if the\n* time overide is enabled. If it is enabled, the set value will be returned.\n* Otherwise this time source will return the equivalent to system time abstraction.\n*\n* This function is not thread-safe with rcl_enable_ros_time_override() nor\n* rcl_disable_ros_time_override() functions when used on the same clock object.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No [1]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.</i>\n*\n* \\param[in] clock The clock to query.\n* \\param[out] is_enabled Whether the override is enabled..\n* \\return #RCL_RET_OK if the time source was queried successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_is_enabled_ros_time_override(
        clock: *mut rcl_clock_t,
        is_enabled: *mut bool,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Set the current time for this #RCL_ROS_TIME time source.\n**\n* This function will update the internal storage for the #RCL_ROS_TIME\n* time source.\n* If queried and override enabled the time source will return this value,\n* otherwise it will return the system time.\n*\n* This function is not thread-safe with rcl_clock_add_jump_callback(),\n* nor rcl_clock_remove_jump_callback() functions when used on the same\n* clock object.\n*\n* <hr>\n* Attribute          | Adherence [1]\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No [2]\n* Uses Atomics       | Yes\n* Lock-Free          | Yes\n*\n* <i>[1] Only applies to the function itself, as jump callbacks may not abide to it.</i>\n* <i>[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe.</i>\n*\n* \\param[in] clock The clock to update.\n* \\param[in] time_value The new current time.\n* \\return #RCL_RET_OK if the time source was set successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_set_ros_time_override(
        clock: *mut rcl_clock_t,
        time_value: rcl_time_point_value_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Add a callback to be called when a time jump exceeds a threshold.\n**\n* The callback is called twice when the threshold is exceeded: once before the clock is\n* updated, and once after.\n* The user_data pointer is passed to the callback as the last argument.\n* A callback and user_data pair must be unique among the callbacks added to a clock.\n*\n* This function is not thread-safe with rcl_clock_remove_jump_callback(),\n* rcl_enable_ros_time_override(), rcl_disable_ros_time_override() nor\n* rcl_set_ros_time_override() functions when used on the same clock object.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No [1]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.\n*        Thread-safety is also affected by that of the `allocator` object associated with the\n*        `clock` object.</i>\n*\n* \\param[in] clock A clock to add a jump callback to.\n* \\param[in] threshold Criteria indicating when to call the callback.\n* \\param[in] callback A callback to call.\n* \\param[in] user_data A pointer to be passed to the callback.\n* \\return #RCL_RET_OK if the callback was added successfully, or\n* \\return #RCL_RET_BAD_ALLOC if a memory allocation failed, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR an unspecified error occurs.\n*/"]
    pub fn rcl_clock_add_jump_callback(
        clock: *mut rcl_clock_t,
        threshold: rcl_jump_threshold_t,
        callback: rcl_jump_callback_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Remove a previously added time jump callback.\n**\n* This function is not thread-safe with rcl_clock_add_jump_callback()\n* rcl_enable_ros_time_override(), rcl_disable_ros_time_override() nor\n* rcl_set_ros_time_override() functions when used on the same clock object.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No [1]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.\n*        Thread-safety is also affected by that of the `allocator` object associated with the\n*        `clock` object.</i>\n*\n* \\param[in] clock The clock to remove a jump callback from.\n* \\param[in] callback The callback to call.\n* \\param[in] user_data A pointer to be passed to the callback.\n* \\return #RCL_RET_OK if the callback was added successfully, or\n* \\return #RCL_RET_BAD_ALLOC if a memory allocation failed, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR the callback was not found or an unspecified error occurs.\n*/"]
    pub fn rcl_clock_remove_jump_callback(
        clock: *mut rcl_clock_t,
        callback: rcl_jump_callback_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_publisher_impl_s {
    _unused: [u8; 0],
}
#[doc = " Internal rcl publisher implementation struct."]
pub type rcl_publisher_impl_t = rcl_publisher_impl_s;
#[doc = " Structure which encapsulates a ROS Publisher."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_publisher_s {
    #[doc = " Pointer to the publisher implementation"]
    pub impl_: *mut rcl_publisher_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_publisher_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_publisher_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_publisher_s>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_publisher_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_publisher_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_publisher_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_publisher_s),
            "::",
            stringify!(impl_)
        )
    );
}
#[doc = " Structure which encapsulates a ROS Publisher."]
pub type rcl_publisher_t = rcl_publisher_s;
#[doc = " Options available for a rcl publisher."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_publisher_options_s {
    #[doc = " Middleware quality of service settings for the publisher."]
    pub qos: rmw_qos_profile_t,
    #[doc = " Custom allocator for the publisher, used for incidental allocations.\n** For default behavior (malloc/free), use: rcl_get_default_allocator() */"]
    pub allocator: rcl_allocator_t,
    #[doc = " rmw specific publisher options, e.g. the rmw implementation specific payload."]
    pub rmw_publisher_options: rmw_publisher_options_t,
    #[doc = " Disable flag to LoanedMessage, initialized via environmental variable."]
    pub disable_loaned_message: bool,
}
#[test]
fn bindgen_test_layout_rcl_publisher_options_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_publisher_options_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_publisher_options_s>(),
        152usize,
        concat!("Size of: ", stringify!(rcl_publisher_options_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_publisher_options_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_publisher_options_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_publisher_options_s),
            "::",
            stringify!(qos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_publisher_options_s),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rmw_publisher_options) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_publisher_options_s),
            "::",
            stringify!(rmw_publisher_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disable_loaned_message) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_publisher_options_s),
            "::",
            stringify!(disable_loaned_message)
        )
    );
}
#[doc = " Options available for a rcl publisher."]
pub type rcl_publisher_options_t = rcl_publisher_options_s;
extern "C" {
    #[doc = " Return a rcl_publisher_t struct with members set to `NULL`.\n**\n* Should be called to get a null rcl_publisher_t before passing to\n* rcl_publisher_init().\n*/"]
    pub fn rcl_get_zero_initialized_publisher() -> rcl_publisher_t;
}
extern "C" {
    #[doc = " Initialize a rcl publisher.\n**\n* After calling this function on a rcl_publisher_t, it can be used to publish\n* messages of the given type to the given topic using rcl_publish().\n*\n* The given rcl_node_t must be valid and the resulting rcl_publisher_t is only\n* valid as long as the given rcl_node_t remains valid.\n*\n* The rosidl_message_type_support_t is obtained on a per .msg type basis.\n* When the user defines a ROS message, code is generated which provides the\n* required rosidl_message_type_support_t object.\n* This object can be obtained using a language appropriate mechanism.\n* \\todo TODO(wjwwood) write these instructions once and link to it instead\n*\n* For C, a macro can be used (for example `std_msgs/String`):\n*\n* ```c\n* #include <rosidl_runtime_c/message_type_support_struct.h>\n* #include <std_msgs/msg/string.h>\n* const rosidl_message_type_support_t * string_ts =\n*   ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);\n* ```\n*\n* For C++, a template function is used:\n*\n* ```cpp\n* #include <rosidl_typesupport_cpp/message_type_support.hpp>\n* #include <std_msgs/msg/string.hpp>\n* const rosidl_message_type_support_t * string_ts =\n*   rosidl_typesupport_cpp::get_message_type_support_handle<std_msgs::msg::String>();\n* ```\n*\n* The rosidl_message_type_support_t object contains message type specific\n* information used to publish messages.\n*\n* The topic name must be a c string which follows the topic and service name\n* format rules for unexpanded names, also known as non-fully qualified names:\n*\n* \\see rcl_expand_topic_name\n*\n* The options struct allows the user to set the quality of service settings as\n* well as a custom allocator which is used when initializing/finalizing the\n* publisher to allocate space for incidentals, e.g. the topic name string.\n*\n* Expected usage (for C messages):\n*\n* ```c\n* #include <rcl/rcl.h>\n* #include <rosidl_runtime_c/message_type_support_struct.h>\n* #include <std_msgs/msg/string.h>\n*\n* rcl_node_t node = rcl_get_zero_initialized_node();\n* rcl_node_options_t node_ops = rcl_node_get_default_options();\n* rcl_ret_t ret = rcl_node_init(&node, \"node_name\", \"/my_namespace\", &node_ops);\n* // ... error handling\n* const rosidl_message_type_support_t * ts = ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);\n* rcl_publisher_t publisher = rcl_get_zero_initialized_publisher();\n* rcl_publisher_options_t publisher_ops = rcl_publisher_get_default_options();\n* ret = rcl_publisher_init(&publisher, &node, ts, \"chatter\", &publisher_ops);\n* // ... error handling, and on shutdown do finalization:\n* ret = rcl_publisher_fini(&publisher, &node);\n* // ... error handling for rcl_publisher_fini()\n* ret = rcl_node_fini(&node);\n* // ... error handling for rcl_deinitialize_node()\n* ```\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] publisher preallocated publisher structure\n* \\param[in] node valid rcl node handle\n* \\param[in] type_support type support object for the topic's type\n* \\param[in] topic_name the name of the topic to publish on\n* \\param[in] options publisher options, including quality of service settings\n* \\return #RCL_RET_OK if the publisher was initialized successfully, or\n* \\return #RCL_RET_NODE_INVALID if the node is invalid, or\n* \\return #RCL_RET_ALREADY_INIT if the publisher is already initialized, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory fails, or\n* \\return #RCL_RET_TOPIC_NAME_INVALID if the given topic name is invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_publisher_init(
        publisher: *mut rcl_publisher_t,
        node: *const rcl_node_t,
        type_support: *const rosidl_message_type_support_t,
        topic_name: *const ::std::os::raw::c_char,
        options: *const rcl_publisher_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a rcl_publisher_t.\n**\n* After calling, the node will no longer be advertising that it is publishing\n* on this topic (assuming this is the only publisher on this topic).\n*\n* After calling, calls to rcl_publish will fail when using this publisher.\n* However, the given node handle is still valid.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] publisher handle to the publisher to be finalized\n* \\param[in] node a valid (not finalized) handle to the node used to create the publisher\n* \\return #RCL_RET_OK if publisher was finalized successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_PUBLISHER_INVALID if the publisher is invalid, or\n* \\return #RCL_RET_NODE_INVALID if the node is invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_publisher_fini(publisher: *mut rcl_publisher_t, node: *mut rcl_node_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the default publisher options in a rcl_publisher_options_t.\n**\n* The defaults are:\n*\n* - qos = rmw_qos_profile_default\n* - allocator = rcl_get_default_allocator()\n* - rmw_publisher_options = rmw_get_default_publisher_options()\n* - disable_loaned_message = false, true only if ROS_DISABLE_LOANED_MESSAGES=1\n*\n* \\return A structure with the default publisher options.\n*/"]
    pub fn rcl_publisher_get_default_options() -> rcl_publisher_options_t;
}
extern "C" {
    #[doc = " Borrow a loaned message.\n**\n* The memory allocated for the ros message belongs to the middleware and must not be deallocated\n* other than by a call to \\sa rcl_return_loaned_message_from_publisher.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No [0]\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* [0] the underlying middleware might allocate new memory or returns an existing chunk form a pool.\n* The function in rcl however does not allocate any additional memory.\n*\n* \\param[in] publisher Publisher to which the allocated message is associated.\n* \\param[in] type_support Typesupport to which the internal ros message is allocated.\n* \\param[out] ros_message The pointer to be filled to a valid ros message by the middleware.\n* \\return #RCL_RET_OK if the ros message was correctly initialized, or\n* \\return #RCL_RET_PUBLISHER_INVALID if the passed publisher is invalid, or\n* \\return #RCL_RET_INVALID_ARGUMENT if an argument other than the ros message is null, or\n* \\return #RCL_RET_BAD_ALLOC if the ros message could not be correctly created, or\n* \\return #RCL_RET_UNSUPPORTED if the middleware does not support that feature, or\n* \\return #RCL_RET_ERROR if an unexpected error occured.\n*/"]
    pub fn rcl_borrow_loaned_message(
        publisher: *const rcl_publisher_t,
        type_support: *const rosidl_message_type_support_t,
        ros_message: *mut *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a loaned message previously borrowed from a publisher.\n**\n* The ownership of the passed in ros message will be transferred back to the middleware.\n* The middleware might deallocate and destroy the message so that the pointer is no longer\n* guaranteed to be valid after that call.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] publisher Publisher to which the loaned message is associated.\n* \\param[in] loaned_message Loaned message to be deallocated and destroyed.\n* \\return #RCL_RET_OK if successful, or\n* \\return #RCL_RET_INVALID_ARGUMENT if an argument is null, or\n* \\return #RCL_RET_UNSUPPORTED if the middleware does not support that feature, or\n* \\return #RCL_RET_PUBLISHER_INVALID if the publisher is invalid, or\n* \\return #RCL_RET_ERROR if an unexpected error occurs and no message can be initialized.\n*/"]
    pub fn rcl_return_loaned_message_from_publisher(
        publisher: *const rcl_publisher_t,
        loaned_message: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Publish a ROS message on a topic using a publisher.\n**\n* It is the job of the caller to ensure that the type of the ros_message\n* parameter and the type associate with the publisher (via the type support)\n* match.\n* Passing a different type to publish produces undefined behavior and cannot\n* be checked by this function and therefore no deliberate error will occur.\n*\n* \\todo TODO(wjwwood):\n*   The blocking behavior of publish is a still a point of dispute.\n*   This section should be updated once the behavior is clearly defined.\n*   See: https://github.com/ros2/ros2/issues/255\n*\n* Calling rcl_publish() is a potentially blocking call.\n* When called rcl_publish() will immediately do any publishing related work,\n* including, but not limited to, converting the message into a different type,\n* serializing the message, collecting publish statistics, etc.\n* The last thing it will do is call the underlying middleware's publish\n* function which may or may not block based on the quality of service settings\n* given via the publisher options in rcl_publisher_init().\n* For example, if the reliability is set to reliable, then a publish may block\n* until space in the publish queue is available, but if the reliability is set\n* to best effort then it should not block.\n*\n* The ROS message given by the `ros_message` void pointer is always owned by\n* the calling code, but should remain constant during publish.\n*\n* This function is thread safe so long as access to both the publisher and the\n* `ros_message` is synchronized.\n* That means that calling rcl_publish() from multiple threads is allowed, but\n* calling rcl_publish() at the same time as non-thread safe publisher\n* functions is not, e.g. calling rcl_publish() and rcl_publisher_fini()\n* concurrently is not allowed.\n* The message cannot change during the rcl_publish() call.\n* Before calling rcl_publish() the message can change but after calling\n* rcl_publish() it depends on RMW implementation behavior.\n* The same `ros_message`, however, can be passed to multiple calls of\n* rcl_publish() simultaneously, even if the publishers differ.\n* The `ros_message` is unmodified by rcl_publish().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes [1]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] for unique pairs of publishers and messages, see above for more</i>\n*\n* \\param[in] publisher handle to the publisher which will do the publishing\n* \\param[in] ros_message type-erased pointer to the ROS message\n* \\param[in] allocation structure pointer, used for memory preallocation (may be NULL)\n* \\return #RCL_RET_OK if the message was published successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_PUBLISHER_INVALID if the publisher is invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_publish(
        publisher: *const rcl_publisher_t,
        ros_message: *const ::std::os::raw::c_void,
        allocation: *mut rmw_publisher_allocation_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Publish a serialized message on a topic using a publisher.\n**\n* It is the job of the caller to ensure that the type of the serialized message\n* parameter and the type associate with the publisher (via the type support)\n* match.\n* Even though this call to publish takes an already serialized serialized message,\n* the publisher has to register its type as a ROS known message type.\n* Passing a serialized message from a different type leads to undefined behavior on the subscriber side.\n* The publish call might be able to send any abitrary serialized message, it is however\n* not garantueed that the subscriber side successfully deserializes this byte stream.\n*\n* Apart from this, the `publish_serialized` function has the same behavior as rcl_publish()\n* expect that no serialization step is done.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes [1]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] for unique pairs of publishers and messages, see above for more</i>\n*\n* \\param[in] publisher handle to the publisher which will do the publishing\n* \\param[in] serialized_message  pointer to the already serialized message in raw form\n* \\param[in] allocation structure pointer, used for memory preallocation (may be NULL)\n* \\return #RCL_RET_OK if the message was published successfully, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_PUBLISHER_INVALID if the publisher is invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_publish_serialized_message(
        publisher: *const rcl_publisher_t,
        serialized_message: *const rcl_serialized_message_t,
        allocation: *mut rmw_publisher_allocation_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Publish a loaned message on a topic using a publisher.\n**\n* A previously borrowed loaned message can be sent via this call to rcl_publish_loaned_message().\n* By calling this function, the ownership of the loaned message is getting transferred back\n* to the middleware.\n* The pointer to the `ros_message` is not guaranteed to be valid after as the middleware\n* migth deallocate the memory for this message internally.\n* It is thus recommended to call this function only in combination with\n* \\sa rcl_borrow_loaned_message().\n*\n* Apart from this, the `publish_loaned_message` function has the same behavior as rcl_publish()\n* except that no serialization step is done.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No [0]\n* Thread-Safe        | Yes [1]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[0] the middleware might deallocate the loaned message.\n* The RCL function however does not allocate any memory.</i>\n* <i>[1] for unique pairs of publishers and messages, see above for more</i>\n*\n* \\param[in] publisher handle to the publisher which will do the publishing\n* \\param[in] ros_message  pointer to the previously borrow loaned message\n* \\param[in] allocation structure pointer, used for memory preallocation (may be NULL)\n* \\return #RCL_RET_OK if the message was published successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_PUBLISHER_INVALID if the publisher is invalid, or\n* \\return #RCL_RET_UNSUPPORTED if the middleware does not support that feature, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_publish_loaned_message(
        publisher: *const rcl_publisher_t,
        ros_message: *mut ::std::os::raw::c_void,
        allocation: *mut rmw_publisher_allocation_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Manually assert that this Publisher is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC)\n**\n* If the rmw Liveliness policy is set to RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC, the creator of\n* this publisher may manually call `assert_liveliness` at some point in time to signal to the rest\n* of the system that this Node is still alive.\n* This function must be called at least as often as the qos_profile's liveliness_lease_duration\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] publisher handle to the publisher that needs liveliness to be asserted\n* \\return #RCL_RET_OK if the liveliness assertion was completed successfully, or\n* \\return #RCL_RET_PUBLISHER_INVALID if the publisher is invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_publisher_assert_liveliness(publisher: *const rcl_publisher_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Wait until all published message data is acknowledged or until the specified timeout elapses.\n**\n* This function waits until all published message data were acknowledged by peer node or timeout.\n*\n* The timeout unit is nanoseconds.\n* If the timeout is negative then this function will block indefinitely until all published message\n* data were acknowledged.\n* If the timeout is 0 then this function will be non-blocking; checking all published message data\n* were acknowledged (If acknowledged, return RCL_RET_OK. Otherwise, return RCL_RET_TIMEOUT), but\n* not waiting.\n* If the timeout is greater than 0 then this function will return after that period of time has\n* elapsed (return RCL_RET_TIMEOUT) or all published message data were acknowledged (return\n* RCL_RET_OK).\n*\n* This function only waits for acknowledgments if the publisher's QOS profile is RELIABLE.\n* Otherwise this function will immediately return RCL_RET_OK.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | No\n*\n* \\param[in] publisher handle to the publisher that needs to wait for all acked.\n* \\param[in] timeout the duration to wait for all published message data were acknowledged, in\n*   nanoseconds.\n* \\return #RCL_RET_OK if successful, or\n* \\return #RCL_RET_TIMEOUT if timed out, or\n* \\return #RCL_RET_PUBLISHER_INVALID if publisher is invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs, or\n* \\return #RCL_RET_UNSUPPORTED if the middleware does not support that feature.\n*/"]
    pub fn rcl_publisher_wait_for_all_acked(
        publisher: *const rcl_publisher_t,
        timeout: rcl_duration_value_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the topic name for the publisher.\n**\n* This function returns the publisher's internal topic name string.\n* This function can fail, and therefore return `NULL`, if the:\n*   - publisher is `NULL`\n*   - publisher is invalid (never called init, called fini, or invalid node)\n*\n* The returned string is only valid as long as the rcl_publisher_t is valid.\n* The value of the string may change if the topic name changes, and therefore\n* copying the string is recommended if this is a concern.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] publisher pointer to the publisher\n* \\return name string if successful, otherwise `NULL`\n*/"]
    pub fn rcl_publisher_get_topic_name(
        publisher: *const rcl_publisher_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the rcl publisher options.\n**\n* This function returns the publisher's internal options struct.\n* This function can fail, and therefore return `NULL`, if the:\n*   - publisher is `NULL`\n*   - publisher is invalid (never called init, called fini, or invalid node)\n*\n* The returned struct is only valid as long as the rcl_publisher_t is valid.\n* The values in the struct may change if the options of the publisher change,\n* and therefore copying the struct is recommended if this is a concern.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] publisher pointer to the publisher\n* \\return options struct if successful, otherwise `NULL`\n*/"]
    pub fn rcl_publisher_get_options(
        publisher: *const rcl_publisher_t,
    ) -> *const rcl_publisher_options_t;
}
extern "C" {
    #[doc = " Return the rmw publisher handle.\n**\n* The handle returned is a pointer to the internally held rmw handle.\n* This function can fail, and therefore return `NULL`, if the:\n*   - publisher is `NULL`\n*   - publisher is invalid (never called init, called fini, or invalid node)\n*\n* The returned handle is made invalid if the publisher is finalized or if\n* rcl_shutdown() is called.\n* The returned handle is not guaranteed to be valid for the life time of the\n* publisher as it may be finalized and recreated itself.\n* Therefore it is recommended to get the handle from the publisher using\n* this function each time it is needed and avoid use of the handle\n* concurrently with functions that might change it.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] publisher pointer to the rcl publisher\n* \\return rmw publisher handle if successful, otherwise `NULL`\n*/"]
    pub fn rcl_publisher_get_rmw_handle(publisher: *const rcl_publisher_t) -> *mut rmw_publisher_t;
}
extern "C" {
    #[doc = " Return the context associated with this publisher.\n**\n* This function can fail, and therefore return `NULL`, if the:\n*   - publisher is `NULL`\n*   - publisher is invalid (never called init, called fini, etc.)\n*\n* The returned context is made invalid if the publisher is finalized or if\n* rcl_shutdown() is called.\n* Therefore it is recommended to get the handle from the publisher using\n* this function each time it is needed and avoid use of the handle\n* concurrently with functions that might change it.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] publisher pointer to the rcl publisher\n* \\return context if successful, otherwise `NULL`\n*/"]
    pub fn rcl_publisher_get_context(publisher: *const rcl_publisher_t) -> *mut rcl_context_t;
}
extern "C" {
    #[doc = " Return true if the publisher is valid, otherwise false.\n**\n* The bool returned is `false` if `publisher` is invalid.\n* The bool returned is `true` otherwise.\n* In the case where `false` is to be returned, an error message is set.\n* This function cannot fail.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] publisher pointer to the rcl publisher\n* \\return `true` if `publisher` is valid, otherwise `false`\n*/"]
    pub fn rcl_publisher_is_valid(publisher: *const rcl_publisher_t) -> bool;
}
extern "C" {
    #[doc = " Return true if the publisher is valid except the context, otherwise false.\n**\n* This is used in clean up functions that need to access the publisher, but do\n* not need use any functions with the context.\n*\n* It is identical to rcl_publisher_is_valid except it ignores the state of the\n* context associated with the publisher.\n* \\sa rcl_publisher_is_valid()\n*/"]
    pub fn rcl_publisher_is_valid_except_context(publisher: *const rcl_publisher_t) -> bool;
}
extern "C" {
    #[doc = " Get the number of subscriptions matched to a publisher.\n**\n* Used to get the internal count of subscriptions matched to a publisher.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] only if the underlying rmw doesn't make use of this feature </i>\n*\n* \\param[in] publisher pointer to the rcl publisher\n* \\param[out] subscription_count number of matched subscriptions\n* \\return #RCL_RET_OK if the count was retrieved, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_PUBLISHER_INVALID if the publisher is invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_publisher_get_subscription_count(
        publisher: *const rcl_publisher_t,
        subscription_count: *mut usize,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the actual qos settings of the publisher.\n**\n* Used to get the actual qos settings of the publisher.\n* The actual configuration applied when using RMW_*_SYSTEM_DEFAULT\n* can only be resolved after the creation of the publisher, and it\n* depends on the underlying rmw implementation.\n* If the underlying setting in use can't be represented in ROS terms,\n* it will be set to RMW_*_UNKNOWN.\n* The returned struct is only valid as long as the rcl_publisher_t is valid.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] publisher pointer to the rcl publisher\n* \\return qos struct if successful, otherwise `NULL`\n*/"]
    pub fn rcl_publisher_get_actual_qos(
        publisher: *const rcl_publisher_t,
    ) -> *const rmw_qos_profile_t;
}
extern "C" {
    #[doc = " Check if publisher instance can loan messages.\n**\n* Depending on the middleware and the message type, this will return true if the middleware\n* can allocate a ROS message instance.\n*/"]
    pub fn rcl_publisher_can_loan_messages(publisher: *const rcl_publisher_t) -> bool;
}
#[doc = " Common event callback type signature.\n**\n* Event callbacks of this type can be called in various scenarios, e.g.\n* data becomes available on a subscription, a QoS event has occurred, or\n* something similar.\n*\n* The user_data argument is given by the user when registering the callback,\n* and is given back to the callback each time so it can have associated,\n* user-defined state.\n*\n* The number_of_events argument indicates the number of events since the\n* callback was called.\n* This is most often 1, but can be > 1 when events occur before the callback\n* is registered.\n* It should never be 0.\n*\n* \\sa rmw_subscription_set_on_new_message_callback()\n* \\sa rmw_service_set_on_new_request_callback()\n* \\sa rmw_client_set_on_new_response_callback()\n* \\sa rmw_event_set_callback()\n*/"]
pub type rmw_event_callback_t = ::std::option::Option<
    unsafe extern "C" fn(user_data: *const ::std::os::raw::c_void, number_of_events: usize),
>;
pub type rcl_event_callback_t = rmw_event_callback_t;
pub type mbstate_t = __mbstate_t;
pub type char16_t = __uint_least16_t;
pub type char32_t = __uint_least32_t;
extern "C" {
    pub fn mbrtoc16(
        __pc16: *mut char16_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
        __p: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn c16rtomb(
        __s: *mut ::std::os::raw::c_char,
        __c16: char16_t,
        __ps: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mbrtoc32(
        __pc32: *mut char32_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
        __p: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn c32rtomb(
        __s: *mut ::std::os::raw::c_char,
        __c32: char32_t,
        __ps: *mut mbstate_t,
    ) -> usize;
}
pub type rosidl_dynamic_typesupport_member_id_t = usize;
#[doc = " Serialization Support\n This is the main structure that encompasses:\n   - impl - The library-specific objects or implementation details\n   - methods - The shared serialization support interface, populated with serialization\n     library-specific function pointers"]
pub type rosidl_dynamic_typesupport_serialization_support_t =
    rosidl_dynamic_typesupport_serialization_support_s;
#[doc = " Serialization Support Impl\n For anything necessary or useful for the operation of the serialization lib\n (e.g. singleton dynamic type and dynamic data factories)"]
pub type rosidl_dynamic_typesupport_serialization_support_impl_t =
    rosidl_dynamic_typesupport_serialization_support_impl_s;
#[doc = " This interface must be adopted by all downstream serialization library implementations"]
pub type rosidl_dynamic_typesupport_serialization_support_interface_t =
    rosidl_dynamic_typesupport_serialization_support_interface_s;
pub type rosidl_dynamic_typesupport_dynamic_type_builder_t =
    rosidl_dynamic_typesupport_dynamic_type_builder_s;
pub type rosidl_dynamic_typesupport_dynamic_type_builder_impl_t =
    rosidl_dynamic_typesupport_dynamic_type_builder_impl_s;
pub type rosidl_dynamic_typesupport_dynamic_type_t = rosidl_dynamic_typesupport_dynamic_type_s;
pub type rosidl_dynamic_typesupport_dynamic_type_impl_t =
    rosidl_dynamic_typesupport_dynamic_type_impl_s;
pub type rosidl_dynamic_typesupport_dynamic_data_t = rosidl_dynamic_typesupport_dynamic_data_s;
pub type rosidl_dynamic_typesupport_dynamic_data_impl_t =
    rosidl_dynamic_typesupport_dynamic_data_impl_s;
#[doc = " This interface must be adopted by all downstream serialization library implementations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_dynamic_typesupport_serialization_support_interface_s {
    #[doc = " Interfaces mimicking the XTypes spec (Section 7.5: Language Binding)\n https://www.omg.org/spec/DDS-XTypes/1.1/PDF\n\n Luckily for us, FastRTPS mimics the spec quite well"]
    pub allocator: rcutils_allocator_t,
    pub serialization_library_identifier: *const ::std::os::raw::c_char,
    pub serialization_support_impl_fini: ::std::option::Option<
        unsafe extern "C" fn(
            impl_: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
        ) -> rcutils_ret_t,
    >,
    pub serialization_support_interface_fini: ::std::option::Option<
        unsafe extern "C" fn(
            methods: *mut rosidl_dynamic_typesupport_serialization_support_interface_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_equals: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            type_: *const rosidl_dynamic_typesupport_dynamic_type_impl_t,
            other: *const rosidl_dynamic_typesupport_dynamic_type_impl_t,
            equals: *mut bool,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_get_member_count: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type: *const rosidl_dynamic_typesupport_dynamic_type_impl_t,
            member_count: *mut usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_init: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            allocator: *mut rcutils_allocator_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_clone: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            other: *const rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            allocator: *mut rcutils_allocator_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_fini: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_init_from_dynamic_type_builder: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            allocator: *mut rcutils_allocator_t,
            dynamic_type: *mut rosidl_dynamic_typesupport_dynamic_type_impl_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_clone: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            other: *const rosidl_dynamic_typesupport_dynamic_type_impl_t,
            allocator: *mut rcutils_allocator_t,
            dynamic_type: *mut rosidl_dynamic_typesupport_dynamic_type_impl_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_fini: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type: *mut rosidl_dynamic_typesupport_dynamic_type_impl_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_get_name: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type: *const rosidl_dynamic_typesupport_dynamic_type_impl_t,
            name: *mut *const ::std::os::raw::c_char,
            name_length: *mut usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_get_name: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *const rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            name: *mut *const ::std::os::raw::c_char,
            name_length: *mut usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_set_name: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_bool_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_byte_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_char_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_wchar_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_float32_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_float64_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_float128_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_int8_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_uint8_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_int16_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_uint16_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_int32_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_uint32_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_int64_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_uint64_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_string_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_wstring_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_fixed_string_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            string_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_fixed_wstring_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            wstring_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_bounded_string_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            string_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_bounded_wstring_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            wstring_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_bool_array_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            array_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_byte_array_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            array_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_char_array_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            array_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_wchar_array_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            array_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_float32_array_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            array_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_float64_array_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            array_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_float128_array_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            array_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_int8_array_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            array_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_uint8_array_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            array_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_int16_array_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            array_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_uint16_array_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            array_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_int32_array_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            array_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_uint32_array_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            array_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_int64_array_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            array_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_uint64_array_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            array_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_string_array_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            array_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_wstring_array_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            array_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_fixed_string_array_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            string_length: usize,
            array_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_fixed_wstring_array_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            wstring_length: usize,
            array_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_bounded_string_array_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            string_bound: usize,
            array_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_bounded_wstring_array_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            wstring_bound: usize,
            array_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_bool_unbounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_byte_unbounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_char_unbounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_wchar_unbounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_float32_unbounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_float64_unbounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_float128_unbounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_int8_unbounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_uint8_unbounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_int16_unbounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_uint16_unbounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_int32_unbounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_uint32_unbounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_int64_unbounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_uint64_unbounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_string_unbounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_wstring_unbounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_fixed_string_unbounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            string_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_fixed_wstring_unbounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            wstring_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_bounded_string_unbounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            string_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_bounded_wstring_unbounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            wstring_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_bool_bounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            sequence_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_byte_bounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            sequence_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_char_bounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            sequence_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_wchar_bounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            sequence_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_float32_bounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            sequence_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_float64_bounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            sequence_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_float128_bounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            sequence_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_int8_bounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            sequence_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_uint8_bounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            sequence_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_int16_bounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            sequence_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_uint16_bounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            sequence_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_int32_bounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            sequence_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_uint32_bounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            sequence_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_int64_bounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            sequence_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_uint64_bounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            sequence_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_string_bounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            sequence_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_wstring_bounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            sequence_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_fixed_string_bounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            string_length: usize,
            sequence_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_fixed_wstring_bounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            wstring_length: usize,
            sequence_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_bounded_string_bounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            string_bound: usize,
            sequence_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_bounded_wstring_bounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            wstring_bound: usize,
            sequence_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_complex_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            nested_struct: *mut rosidl_dynamic_typesupport_dynamic_type_impl_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_complex_array_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            nested_struct: *mut rosidl_dynamic_typesupport_dynamic_type_impl_t,
            array_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_complex_unbounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            nested_struct: *mut rosidl_dynamic_typesupport_dynamic_type_impl_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_complex_bounded_sequence_member: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            nested_struct: *mut rosidl_dynamic_typesupport_dynamic_type_impl_t,
            sequence_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_complex_member_builder: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            nested_struct_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_complex_array_member_builder: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            nested_struct_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            array_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_complex_unbounded_sequence_member_builder: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            nested_struct_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_type_builder_add_complex_bounded_sequence_member_builder: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            default_value: *const ::std::os::raw::c_char,
            default_value_length: usize,
            nested_struct_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            sequence_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_clear_all_values: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_clear_nonkey_values: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_clear_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_equals: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            other: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            equals: *mut bool,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_item_count: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            item_count: *mut usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_member_id_by_name: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            name: *const ::std::os::raw::c_char,
            name_length: usize,
            member_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_member_id_at_index: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            index: usize,
            member_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_array_index: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            index: usize,
            array_index: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_loan_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            allocator: *mut rcutils_allocator_t,
            loaned_dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_return_loaned_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            inner_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_name: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            name: *mut *const ::std::os::raw::c_char,
            name_length: *mut usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_init_from_dynamic_type_builder: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
            allocator: *mut rcutils_allocator_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_init_from_dynamic_type: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            type_: *mut rosidl_dynamic_typesupport_dynamic_type_impl_t,
            allocator: *mut rcutils_allocator_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_clone: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            other: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            allocator: *mut rcutils_allocator_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_fini: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_serialize: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            buffer: *mut rcutils_uint8_array_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_deserialize: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            buffer: *mut rcutils_uint8_array_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_bool_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *mut bool,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_byte_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *mut u8,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_char_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *mut ::std::os::raw::c_char,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_wchar_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *mut char16_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_float32_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *mut f32,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_float64_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *mut f64,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_float128_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *mut u128,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_int8_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *mut i8,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_uint8_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *mut u8,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_int16_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *mut i16,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_uint16_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *mut u16,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_int32_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *mut i32,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_uint32_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *mut u32,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_int64_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *mut i64,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_uint64_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *mut u64,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_string_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *mut *mut ::std::os::raw::c_char,
            value_length: *mut usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_wstring_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *mut *mut char16_t,
            value_length: *mut usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_fixed_string_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *mut *mut ::std::os::raw::c_char,
            value_length: *mut usize,
            string_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_fixed_wstring_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *mut *mut char16_t,
            value_length: *mut usize,
            wstring_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_bounded_string_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *mut *mut ::std::os::raw::c_char,
            value_length: *mut usize,
            string_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_bounded_wstring_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *mut *mut char16_t,
            value_length: *mut usize,
            wstring_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_set_bool_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: bool,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_set_byte_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: u8,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_set_char_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: ::std::os::raw::c_char,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_set_wchar_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: char16_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_set_float32_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: f32,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_set_float64_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: f64,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_set_float128_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: u128,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_set_int8_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: i8,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_set_uint8_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: u8,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_set_int16_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: i16,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_set_uint16_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: u16,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_set_int32_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: i32,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_set_uint32_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: u32,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_set_int64_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: i64,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_set_uint64_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: u64,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_set_string_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *const ::std::os::raw::c_char,
            value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_set_wstring_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *const char16_t,
            value_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_set_fixed_string_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *const ::std::os::raw::c_char,
            value_length: usize,
            string_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_set_fixed_wstring_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *const char16_t,
            value_length: usize,
            wstring_length: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_set_bounded_string_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *const ::std::os::raw::c_char,
            value_length: usize,
            string_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_set_bounded_wstring_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *const char16_t,
            value_length: usize,
            wstring_bound: usize,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_clear_sequence_data: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_remove_sequence_data: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_insert_sequence_data: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            out_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_insert_bool_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            value: bool,
            out_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_insert_byte_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            value: u8,
            out_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_insert_char_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            value: ::std::os::raw::c_char,
            out_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_insert_wchar_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            value: char16_t,
            out_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_insert_float32_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            value: f32,
            out_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_insert_float64_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            value: f64,
            out_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_insert_float128_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            value: u128,
            out_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_insert_int8_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            value: i8,
            out_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_insert_uint8_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            value: u8,
            out_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_insert_int16_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            value: i16,
            out_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_insert_uint16_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            value: u16,
            out_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_insert_int32_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            value: i32,
            out_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_insert_uint32_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            value: u32,
            out_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_insert_int64_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            value: i64,
            out_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_insert_uint64_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            value: u64,
            out_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_insert_string_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            value: *const ::std::os::raw::c_char,
            value_length: usize,
            out_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_insert_wstring_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            value: *const char16_t,
            value_length: usize,
            out_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_insert_fixed_string_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            value: *const ::std::os::raw::c_char,
            value_length: usize,
            string_length: usize,
            out_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_insert_fixed_wstring_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            value: *const char16_t,
            value_length: usize,
            wstring_length: usize,
            out_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_insert_bounded_string_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            value: *const ::std::os::raw::c_char,
            value_length: usize,
            string_bound: usize,
            out_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_insert_bounded_wstring_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            value: *const char16_t,
            value_length: usize,
            wstring_bound: usize,
            out_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_get_complex_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            allocator: *mut rcutils_allocator_t,
            value: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_set_complex_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            id: rosidl_dynamic_typesupport_member_id_t,
            value: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_insert_complex_value_copy: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            value: *const rosidl_dynamic_typesupport_dynamic_data_impl_t,
            out_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
    pub dynamic_data_insert_complex_value: ::std::option::Option<
        unsafe extern "C" fn(
            serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
            dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            value: *mut rosidl_dynamic_typesupport_dynamic_data_impl_t,
            out_id: *mut rosidl_dynamic_typesupport_member_id_t,
        ) -> rcutils_ret_t,
    >,
}
#[test]
fn bindgen_test_layout_rosidl_dynamic_typesupport_serialization_support_interface_s() {
    const UNINIT: ::std::mem::MaybeUninit<
        rosidl_dynamic_typesupport_serialization_support_interface_s,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_dynamic_typesupport_serialization_support_interface_s>(),
        1584usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_dynamic_typesupport_serialization_support_interface_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).serialization_library_identifier) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(serialization_library_identifier)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).serialization_support_impl_fini) as usize - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(serialization_support_impl_fini)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).serialization_support_interface_fini) as usize
                - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(serialization_support_interface_fini)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_type_equals) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_equals)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_get_member_count) as usize - ptr as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_get_member_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_type_builder_init) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_type_builder_clone) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_clone)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_type_builder_fini) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_fini)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_init_from_dynamic_type_builder) as usize
                - ptr as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_init_from_dynamic_type_builder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_type_clone) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_clone)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_type_fini) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_fini)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_type_get_name) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_get_name)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_get_name) as usize - ptr as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_get_name)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_set_name) as usize - ptr as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_set_name)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_bool_member) as usize
                - ptr as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_bool_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_byte_member) as usize
                - ptr as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_byte_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_char_member) as usize
                - ptr as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_char_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_wchar_member) as usize
                - ptr as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_wchar_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_float32_member) as usize
                - ptr as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_float32_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_float64_member) as usize
                - ptr as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_float64_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_float128_member) as usize
                - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_float128_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_int8_member) as usize
                - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_int8_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_uint8_member) as usize
                - ptr as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_uint8_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_int16_member) as usize
                - ptr as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_int16_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_uint16_member) as usize
                - ptr as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_uint16_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_int32_member) as usize
                - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_int32_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_uint32_member) as usize
                - ptr as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_uint32_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_int64_member) as usize
                - ptr as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_int64_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_uint64_member) as usize
                - ptr as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_uint64_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_string_member) as usize
                - ptr as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_string_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_wstring_member) as usize
                - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_wstring_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_fixed_string_member) as usize
                - ptr as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_fixed_string_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_fixed_wstring_member) as usize
                - ptr as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_fixed_wstring_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_bounded_string_member) as usize
                - ptr as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_bounded_string_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_bounded_wstring_member) as usize
                - ptr as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_bounded_wstring_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_bool_array_member) as usize
                - ptr as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_bool_array_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_byte_array_member) as usize
                - ptr as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_byte_array_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_char_array_member) as usize
                - ptr as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_char_array_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_wchar_array_member) as usize
                - ptr as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_wchar_array_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_float32_array_member) as usize
                - ptr as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_float32_array_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_float64_array_member) as usize
                - ptr as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_float64_array_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_float128_array_member) as usize
                - ptr as usize
        },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_float128_array_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_int8_array_member) as usize
                - ptr as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_int8_array_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_uint8_array_member) as usize
                - ptr as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_uint8_array_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_int16_array_member) as usize
                - ptr as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_int16_array_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_uint16_array_member) as usize
                - ptr as usize
        },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_uint16_array_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_int32_array_member) as usize
                - ptr as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_int32_array_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_uint32_array_member) as usize
                - ptr as usize
        },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_uint32_array_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_int64_array_member) as usize
                - ptr as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_int64_array_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_uint64_array_member) as usize
                - ptr as usize
        },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_uint64_array_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_string_array_member) as usize
                - ptr as usize
        },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_string_array_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_wstring_array_member) as usize
                - ptr as usize
        },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_wstring_array_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_fixed_string_array_member) as usize
                - ptr as usize
        },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_fixed_string_array_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_fixed_wstring_array_member)
                as usize
                - ptr as usize
        },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_fixed_wstring_array_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_bounded_string_array_member)
                as usize
                - ptr as usize
        },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_bounded_string_array_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_bounded_wstring_array_member)
                as usize
                - ptr as usize
        },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_bounded_wstring_array_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_bool_unbounded_sequence_member)
                as usize
                - ptr as usize
        },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_bool_unbounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_byte_unbounded_sequence_member)
                as usize
                - ptr as usize
        },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_byte_unbounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_char_unbounded_sequence_member)
                as usize
                - ptr as usize
        },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_char_unbounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_wchar_unbounded_sequence_member)
                as usize
                - ptr as usize
        },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_wchar_unbounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_float32_unbounded_sequence_member)
                as usize
                - ptr as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_float32_unbounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_float64_unbounded_sequence_member)
                as usize
                - ptr as usize
        },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_float64_unbounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_float128_unbounded_sequence_member)
                as usize
                - ptr as usize
        },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_float128_unbounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_int8_unbounded_sequence_member)
                as usize
                - ptr as usize
        },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_int8_unbounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_uint8_unbounded_sequence_member)
                as usize
                - ptr as usize
        },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_uint8_unbounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_int16_unbounded_sequence_member)
                as usize
                - ptr as usize
        },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_int16_unbounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_uint16_unbounded_sequence_member)
                as usize
                - ptr as usize
        },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_uint16_unbounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_int32_unbounded_sequence_member)
                as usize
                - ptr as usize
        },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_int32_unbounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_uint32_unbounded_sequence_member)
                as usize
                - ptr as usize
        },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_uint32_unbounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_int64_unbounded_sequence_member)
                as usize
                - ptr as usize
        },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_int64_unbounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_uint64_unbounded_sequence_member)
                as usize
                - ptr as usize
        },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_uint64_unbounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_string_unbounded_sequence_member)
                as usize
                - ptr as usize
        },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_string_unbounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_wstring_unbounded_sequence_member)
                as usize
                - ptr as usize
        },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_wstring_unbounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!(
                (*ptr).dynamic_type_builder_add_fixed_string_unbounded_sequence_member
            ) as usize
                - ptr as usize
        },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_fixed_string_unbounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!(
                (*ptr).dynamic_type_builder_add_fixed_wstring_unbounded_sequence_member
            ) as usize
                - ptr as usize
        },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_fixed_wstring_unbounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!(
                (*ptr).dynamic_type_builder_add_bounded_string_unbounded_sequence_member
            ) as usize
                - ptr as usize
        },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_bounded_string_unbounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!(
                (*ptr).dynamic_type_builder_add_bounded_wstring_unbounded_sequence_member
            ) as usize
                - ptr as usize
        },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_bounded_wstring_unbounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_bool_bounded_sequence_member)
                as usize
                - ptr as usize
        },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_bool_bounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_byte_bounded_sequence_member)
                as usize
                - ptr as usize
        },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_byte_bounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_char_bounded_sequence_member)
                as usize
                - ptr as usize
        },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_char_bounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_wchar_bounded_sequence_member)
                as usize
                - ptr as usize
        },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_wchar_bounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_float32_bounded_sequence_member)
                as usize
                - ptr as usize
        },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_float32_bounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_float64_bounded_sequence_member)
                as usize
                - ptr as usize
        },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_float64_bounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_float128_bounded_sequence_member)
                as usize
                - ptr as usize
        },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_float128_bounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_int8_bounded_sequence_member)
                as usize
                - ptr as usize
        },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_int8_bounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_uint8_bounded_sequence_member)
                as usize
                - ptr as usize
        },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_uint8_bounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_int16_bounded_sequence_member)
                as usize
                - ptr as usize
        },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_int16_bounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_uint16_bounded_sequence_member)
                as usize
                - ptr as usize
        },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_uint16_bounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_int32_bounded_sequence_member)
                as usize
                - ptr as usize
        },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_int32_bounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_uint32_bounded_sequence_member)
                as usize
                - ptr as usize
        },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_uint32_bounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_int64_bounded_sequence_member)
                as usize
                - ptr as usize
        },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_int64_bounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_uint64_bounded_sequence_member)
                as usize
                - ptr as usize
        },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_uint64_bounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_string_bounded_sequence_member)
                as usize
                - ptr as usize
        },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_string_bounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_wstring_bounded_sequence_member)
                as usize
                - ptr as usize
        },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_wstring_bounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!(
                (*ptr).dynamic_type_builder_add_fixed_string_bounded_sequence_member
            ) as usize
                - ptr as usize
        },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_fixed_string_bounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!(
                (*ptr).dynamic_type_builder_add_fixed_wstring_bounded_sequence_member
            ) as usize
                - ptr as usize
        },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_fixed_wstring_bounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!(
                (*ptr).dynamic_type_builder_add_bounded_string_bounded_sequence_member
            ) as usize
                - ptr as usize
        },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_bounded_string_bounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!(
                (*ptr).dynamic_type_builder_add_bounded_wstring_bounded_sequence_member
            ) as usize
                - ptr as usize
        },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_bounded_wstring_bounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_complex_member) as usize
                - ptr as usize
        },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_complex_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_complex_array_member) as usize
                - ptr as usize
        },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_complex_array_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_complex_unbounded_sequence_member)
                as usize
                - ptr as usize
        },
        840usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_complex_unbounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_complex_bounded_sequence_member)
                as usize
                - ptr as usize
        },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_complex_bounded_sequence_member)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_complex_member_builder) as usize
                - ptr as usize
        },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_complex_member_builder)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_type_builder_add_complex_array_member_builder)
                as usize
                - ptr as usize
        },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_complex_array_member_builder)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!(
                (*ptr).dynamic_type_builder_add_complex_unbounded_sequence_member_builder
            ) as usize
                - ptr as usize
        },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_complex_unbounded_sequence_member_builder)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!(
                (*ptr).dynamic_type_builder_add_complex_bounded_sequence_member_builder
            ) as usize
                - ptr as usize
        },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_type_builder_add_complex_bounded_sequence_member_builder)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_clear_all_values) as usize - ptr as usize
        },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_clear_all_values)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_clear_nonkey_values) as usize - ptr as usize
        },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_clear_nonkey_values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_data_clear_value) as usize - ptr as usize },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_clear_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_data_equals) as usize - ptr as usize },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_equals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_data_get_item_count) as usize - ptr as usize },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_item_count)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_get_member_id_by_name) as usize - ptr as usize
        },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_member_id_by_name)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_get_member_id_at_index) as usize - ptr as usize
        },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_member_id_at_index)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_get_array_index) as usize - ptr as usize
        },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_array_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_data_loan_value) as usize - ptr as usize },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_loan_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_return_loaned_value) as usize - ptr as usize
        },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_return_loaned_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_data_get_name) as usize - ptr as usize },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_name)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_init_from_dynamic_type_builder) as usize
                - ptr as usize
        },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_init_from_dynamic_type_builder)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_init_from_dynamic_type) as usize - ptr as usize
        },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_init_from_dynamic_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_data_clone) as usize - ptr as usize },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_clone)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_data_fini) as usize - ptr as usize },
        1000usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_fini)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_data_serialize) as usize - ptr as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_serialize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_data_deserialize) as usize - ptr as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_deserialize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_data_get_bool_value) as usize - ptr as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_bool_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_data_get_byte_value) as usize - ptr as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_byte_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_data_get_char_value) as usize - ptr as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_char_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_get_wchar_value) as usize - ptr as usize
        },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_wchar_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_get_float32_value) as usize - ptr as usize
        },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_float32_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_get_float64_value) as usize - ptr as usize
        },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_float64_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_get_float128_value) as usize - ptr as usize
        },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_float128_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_data_get_int8_value) as usize - ptr as usize },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_int8_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_get_uint8_value) as usize - ptr as usize
        },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_uint8_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_get_int16_value) as usize - ptr as usize
        },
        1096usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_int16_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_get_uint16_value) as usize - ptr as usize
        },
        1104usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_uint16_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_get_int32_value) as usize - ptr as usize
        },
        1112usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_int32_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_get_uint32_value) as usize - ptr as usize
        },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_uint32_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_get_int64_value) as usize - ptr as usize
        },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_int64_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_get_uint64_value) as usize - ptr as usize
        },
        1136usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_uint64_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_get_string_value) as usize - ptr as usize
        },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_string_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_get_wstring_value) as usize - ptr as usize
        },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_wstring_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_get_fixed_string_value) as usize - ptr as usize
        },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_fixed_string_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_get_fixed_wstring_value) as usize
                - ptr as usize
        },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_fixed_wstring_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_get_bounded_string_value) as usize
                - ptr as usize
        },
        1176usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_bounded_string_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_get_bounded_wstring_value) as usize
                - ptr as usize
        },
        1184usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_bounded_wstring_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_data_set_bool_value) as usize - ptr as usize },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_set_bool_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_data_set_byte_value) as usize - ptr as usize },
        1200usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_set_byte_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_data_set_char_value) as usize - ptr as usize },
        1208usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_set_char_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_set_wchar_value) as usize - ptr as usize
        },
        1216usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_set_wchar_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_set_float32_value) as usize - ptr as usize
        },
        1224usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_set_float32_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_set_float64_value) as usize - ptr as usize
        },
        1232usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_set_float64_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_set_float128_value) as usize - ptr as usize
        },
        1240usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_set_float128_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_data_set_int8_value) as usize - ptr as usize },
        1248usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_set_int8_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_set_uint8_value) as usize - ptr as usize
        },
        1256usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_set_uint8_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_set_int16_value) as usize - ptr as usize
        },
        1264usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_set_int16_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_set_uint16_value) as usize - ptr as usize
        },
        1272usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_set_uint16_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_set_int32_value) as usize - ptr as usize
        },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_set_int32_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_set_uint32_value) as usize - ptr as usize
        },
        1288usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_set_uint32_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_set_int64_value) as usize - ptr as usize
        },
        1296usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_set_int64_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_set_uint64_value) as usize - ptr as usize
        },
        1304usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_set_uint64_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_set_string_value) as usize - ptr as usize
        },
        1312usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_set_string_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_set_wstring_value) as usize - ptr as usize
        },
        1320usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_set_wstring_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_set_fixed_string_value) as usize - ptr as usize
        },
        1328usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_set_fixed_string_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_set_fixed_wstring_value) as usize
                - ptr as usize
        },
        1336usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_set_fixed_wstring_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_set_bounded_string_value) as usize
                - ptr as usize
        },
        1344usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_set_bounded_string_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_set_bounded_wstring_value) as usize
                - ptr as usize
        },
        1352usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_set_bounded_wstring_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_clear_sequence_data) as usize - ptr as usize
        },
        1360usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_clear_sequence_data)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_remove_sequence_data) as usize - ptr as usize
        },
        1368usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_remove_sequence_data)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_insert_sequence_data) as usize - ptr as usize
        },
        1376usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_insert_sequence_data)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_insert_bool_value) as usize - ptr as usize
        },
        1384usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_insert_bool_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_insert_byte_value) as usize - ptr as usize
        },
        1392usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_insert_byte_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_insert_char_value) as usize - ptr as usize
        },
        1400usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_insert_char_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_insert_wchar_value) as usize - ptr as usize
        },
        1408usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_insert_wchar_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_insert_float32_value) as usize - ptr as usize
        },
        1416usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_insert_float32_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_insert_float64_value) as usize - ptr as usize
        },
        1424usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_insert_float64_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_insert_float128_value) as usize - ptr as usize
        },
        1432usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_insert_float128_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_insert_int8_value) as usize - ptr as usize
        },
        1440usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_insert_int8_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_insert_uint8_value) as usize - ptr as usize
        },
        1448usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_insert_uint8_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_insert_int16_value) as usize - ptr as usize
        },
        1456usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_insert_int16_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_insert_uint16_value) as usize - ptr as usize
        },
        1464usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_insert_uint16_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_insert_int32_value) as usize - ptr as usize
        },
        1472usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_insert_int32_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_insert_uint32_value) as usize - ptr as usize
        },
        1480usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_insert_uint32_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_insert_int64_value) as usize - ptr as usize
        },
        1488usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_insert_int64_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_insert_uint64_value) as usize - ptr as usize
        },
        1496usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_insert_uint64_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_insert_string_value) as usize - ptr as usize
        },
        1504usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_insert_string_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_insert_wstring_value) as usize - ptr as usize
        },
        1512usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_insert_wstring_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_insert_fixed_string_value) as usize
                - ptr as usize
        },
        1520usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_insert_fixed_string_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_insert_fixed_wstring_value) as usize
                - ptr as usize
        },
        1528usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_insert_fixed_wstring_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_insert_bounded_string_value) as usize
                - ptr as usize
        },
        1536usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_insert_bounded_string_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_insert_bounded_wstring_value) as usize
                - ptr as usize
        },
        1544usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_insert_bounded_wstring_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_get_complex_value) as usize - ptr as usize
        },
        1552usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_get_complex_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_set_complex_value) as usize - ptr as usize
        },
        1560usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_set_complex_value)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_insert_complex_value_copy) as usize
                - ptr as usize
        },
        1568usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_insert_complex_value_copy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dynamic_data_insert_complex_value) as usize - ptr as usize
        },
        1576usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_interface_s),
            "::",
            stringify!(dynamic_data_insert_complex_value)
        )
    );
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_get_zero_initialized_serialization_support_interface(
    ) -> rosidl_dynamic_typesupport_serialization_support_interface_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_dynamic_typesupport_dynamic_data_impl_s {
    pub allocator: rcutils_allocator_t,
    pub handle: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rosidl_dynamic_typesupport_dynamic_data_impl_s() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_dynamic_typesupport_dynamic_data_impl_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_dynamic_typesupport_dynamic_data_impl_s>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_dynamic_typesupport_dynamic_data_impl_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_dynamic_typesupport_dynamic_data_impl_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_dynamic_typesupport_dynamic_data_impl_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_dynamic_data_impl_s),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_dynamic_data_impl_s),
            "::",
            stringify!(handle)
        )
    );
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_get_zero_initialized_dynamic_data_impl(
    ) -> rosidl_dynamic_typesupport_dynamic_data_impl_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_dynamic_typesupport_dynamic_data_s {
    pub allocator: rcutils_allocator_t,
    pub impl_: rosidl_dynamic_typesupport_dynamic_data_impl_t,
    pub serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_t,
}
#[test]
fn bindgen_test_layout_rosidl_dynamic_typesupport_dynamic_data_s() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_dynamic_typesupport_dynamic_data_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_dynamic_typesupport_dynamic_data_s>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_dynamic_typesupport_dynamic_data_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_dynamic_typesupport_dynamic_data_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_dynamic_typesupport_dynamic_data_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_dynamic_data_s),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_dynamic_data_s),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serialization_support) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_dynamic_data_s),
            "::",
            stringify!(serialization_support)
        )
    );
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_get_zero_initialized_dynamic_data(
    ) -> rosidl_dynamic_typesupport_dynamic_data_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_clear_all_values(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_clear_nonkey_values(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_clear_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_equals(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        other: *const rosidl_dynamic_typesupport_dynamic_data_t,
        equals: *mut bool,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_item_count(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        item_count: *mut usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_member_id_by_name(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        member_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_member_id_at_index(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        index: usize,
        member_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_array_index(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        index: usize,
        array_index: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_loan_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        allocator: *mut rcutils_allocator_t,
        loaned_dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_return_loaned_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        inner_dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_return_and_destroy_loaned_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        inner_dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_name(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        name: *mut *const ::std::os::raw::c_char,
        name_length: *mut usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_init_from_dynamic_type_builder(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        allocator: *mut rcutils_allocator_t,
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_init_from_dynamic_type(
        dynamic_type: *mut rosidl_dynamic_typesupport_dynamic_type_t,
        allocator: *mut rcutils_allocator_t,
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_clone(
        other_dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        allocator: *mut rcutils_allocator_t,
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_fini(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_destroy(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_serialize(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        buffer: *mut rcutils_uint8_array_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_deserialize(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        buffer: *mut rcutils_uint8_array_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_bool_value(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *mut bool,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_byte_value(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *mut ::std::os::raw::c_uchar,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_char_value(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *mut ::std::os::raw::c_char,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_wchar_value(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *mut char16_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_float32_value(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *mut f32,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_float64_value(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *mut f64,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_float128_value(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *mut u128,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_int8_value(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *mut i8,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_uint8_value(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *mut u8,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_int16_value(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *mut i16,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_uint16_value(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *mut u16,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_int32_value(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *mut i32,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_uint32_value(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *mut u32,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_int64_value(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *mut i64,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_uint64_value(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *mut u64,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_string_value(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *mut *mut ::std::os::raw::c_char,
        value_length: *mut usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_wstring_value(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *mut *mut char16_t,
        value_length: *mut usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_fixed_string_value(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *mut *mut ::std::os::raw::c_char,
        value_length: *mut usize,
        string_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_fixed_wstring_value(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *mut *mut char16_t,
        value_length: *mut usize,
        wstring_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_bounded_string_value(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *mut *mut ::std::os::raw::c_char,
        value_length: *mut usize,
        string_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_bounded_wstring_value(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *mut *mut char16_t,
        value_length: *mut usize,
        wstring_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_set_bool_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: bool,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_set_byte_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: ::std::os::raw::c_uchar,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_set_char_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: ::std::os::raw::c_char,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_set_wchar_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: char16_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_set_float32_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: f32,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_set_float64_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: f64,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_set_float128_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: u128,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_set_int8_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: i8,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_set_uint8_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: u8,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_set_int16_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: i16,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_set_uint16_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: u16,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_set_int32_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: i32,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_set_uint32_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: u32,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_set_int64_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: i64,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_set_uint64_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: u64,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_set_string_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *const ::std::os::raw::c_char,
        value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_set_wstring_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *const char16_t,
        value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_set_fixed_string_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *const ::std::os::raw::c_char,
        value_length: usize,
        string_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_set_fixed_wstring_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *const char16_t,
        value_length: usize,
        wstring_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_set_bounded_string_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *const ::std::os::raw::c_char,
        value_length: usize,
        string_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_set_bounded_wstring_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *const char16_t,
        value_length: usize,
        wstring_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_clear_sequence_data(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_remove_sequence_data(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_insert_sequence_data(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        out_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_insert_bool_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        value: bool,
        out_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_insert_byte_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        value: u8,
        out_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_insert_char_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        value: ::std::os::raw::c_char,
        out_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_insert_wchar_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        value: char16_t,
        out_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_insert_float32_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        value: f32,
        out_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_insert_float64_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        value: f64,
        out_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_insert_float128_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        value: u128,
        out_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_insert_int8_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        value: i8,
        out_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_insert_uint8_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        value: u8,
        out_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_insert_int16_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        value: i16,
        out_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_insert_uint16_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        value: u16,
        out_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_insert_int32_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        value: i32,
        out_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_insert_uint32_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        value: u32,
        out_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_insert_int64_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        value: i64,
        out_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_insert_uint64_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        value: u64,
        out_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_insert_string_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        value: *const ::std::os::raw::c_char,
        value_length: usize,
        out_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_insert_wstring_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        value: *const char16_t,
        value_length: usize,
        out_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_insert_fixed_string_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        value: *const ::std::os::raw::c_char,
        value_length: usize,
        string_length: usize,
        out_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_insert_fixed_wstring_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        value: *const char16_t,
        value_length: usize,
        wstring_length: usize,
        out_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_insert_bounded_string_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        value: *const ::std::os::raw::c_char,
        value_length: usize,
        string_bound: usize,
        out_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_insert_bounded_wstring_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        value: *const char16_t,
        value_length: usize,
        wstring_bound: usize,
        out_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_get_complex_value(
        dynamic_data: *const rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        allocator: *mut rcutils_allocator_t,
        value: *mut rosidl_dynamic_typesupport_dynamic_data_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_set_complex_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        value: *mut rosidl_dynamic_typesupport_dynamic_data_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_insert_complex_value_copy(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        value: *const rosidl_dynamic_typesupport_dynamic_data_t,
        out_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_data_insert_complex_value(
        dynamic_data: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        value: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        out_id: *mut rosidl_dynamic_typesupport_member_id_t,
    ) -> rcutils_ret_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_dynamic_typesupport_dynamic_type_builder_impl_s {
    pub allocator: rcutils_allocator_t,
    pub handle: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rosidl_dynamic_typesupport_dynamic_type_builder_impl_s() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_dynamic_typesupport_dynamic_type_builder_impl_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_dynamic_typesupport_dynamic_type_builder_impl_s>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_dynamic_typesupport_dynamic_type_builder_impl_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_dynamic_typesupport_dynamic_type_builder_impl_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_dynamic_typesupport_dynamic_type_builder_impl_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_dynamic_type_builder_impl_s),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_dynamic_type_builder_impl_s),
            "::",
            stringify!(handle)
        )
    );
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_get_zero_initialized_dynamic_type_builder_impl(
    ) -> rosidl_dynamic_typesupport_dynamic_type_builder_impl_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_dynamic_typesupport_dynamic_type_builder_s {
    pub allocator: rcutils_allocator_t,
    pub impl_: rosidl_dynamic_typesupport_dynamic_type_builder_impl_t,
    pub serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_t,
}
#[test]
fn bindgen_test_layout_rosidl_dynamic_typesupport_dynamic_type_builder_s() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_dynamic_typesupport_dynamic_type_builder_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_dynamic_typesupport_dynamic_type_builder_s>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_dynamic_typesupport_dynamic_type_builder_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_dynamic_typesupport_dynamic_type_builder_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_dynamic_typesupport_dynamic_type_builder_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_dynamic_type_builder_s),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_dynamic_type_builder_s),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serialization_support) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_dynamic_type_builder_s),
            "::",
            stringify!(serialization_support)
        )
    );
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_get_zero_initialized_dynamic_type_builder(
    ) -> rosidl_dynamic_typesupport_dynamic_type_builder_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_dynamic_typesupport_dynamic_type_impl_s {
    pub allocator: rcutils_allocator_t,
    pub handle: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rosidl_dynamic_typesupport_dynamic_type_impl_s() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_dynamic_typesupport_dynamic_type_impl_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_dynamic_typesupport_dynamic_type_impl_s>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_dynamic_typesupport_dynamic_type_impl_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_dynamic_typesupport_dynamic_type_impl_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_dynamic_typesupport_dynamic_type_impl_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_dynamic_type_impl_s),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_dynamic_type_impl_s),
            "::",
            stringify!(handle)
        )
    );
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_get_zero_initialized_dynamic_type_impl(
    ) -> rosidl_dynamic_typesupport_dynamic_type_impl_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_dynamic_typesupport_dynamic_type_s {
    pub allocator: rcutils_allocator_t,
    pub impl_: rosidl_dynamic_typesupport_dynamic_type_impl_t,
    pub serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_t,
}
#[test]
fn bindgen_test_layout_rosidl_dynamic_typesupport_dynamic_type_s() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_dynamic_typesupport_dynamic_type_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_dynamic_typesupport_dynamic_type_s>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_dynamic_typesupport_dynamic_type_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_dynamic_typesupport_dynamic_type_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_dynamic_typesupport_dynamic_type_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_dynamic_type_s),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_dynamic_type_s),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serialization_support) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_dynamic_type_s),
            "::",
            stringify!(serialization_support)
        )
    );
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_get_zero_initialized_dynamic_type(
    ) -> rosidl_dynamic_typesupport_dynamic_type_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_equals(
        dynamic_type: *const rosidl_dynamic_typesupport_dynamic_type_t,
        other: *const rosidl_dynamic_typesupport_dynamic_type_t,
        equals: *mut bool,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_get_member_count(
        dynamic_type: *const rosidl_dynamic_typesupport_dynamic_type_t,
        member_count: *mut usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_init(
        serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        allocator: *mut rcutils_allocator_t,
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_clone(
        other: *const rosidl_dynamic_typesupport_dynamic_type_builder_t,
        allocator: *mut rcutils_allocator_t,
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_init_from_description(
        serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_t,
        description: *const rosidl_runtime_c__type_description__TypeDescription,
        allocator: *mut rcutils_allocator_t,
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_fini(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_destroy(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_init_from_dynamic_type_builder(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        allocator: *mut rcutils_allocator_t,
        dynamic_type: *mut rosidl_dynamic_typesupport_dynamic_type_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_init_from_description(
        serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_t,
        description: *const rosidl_runtime_c__type_description__TypeDescription,
        allocator: *mut rcutils_allocator_t,
        dynamic_type: *mut rosidl_dynamic_typesupport_dynamic_type_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_clone(
        other: *const rosidl_dynamic_typesupport_dynamic_type_t,
        allocator: *mut rcutils_allocator_t,
        dynamic_type: *mut rosidl_dynamic_typesupport_dynamic_type_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_fini(
        dynamic_type: *mut rosidl_dynamic_typesupport_dynamic_type_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_destroy(
        dynamic_type: *mut rosidl_dynamic_typesupport_dynamic_type_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_get_name(
        dynamic_type: *const rosidl_dynamic_typesupport_dynamic_type_t,
        name: *mut *const ::std::os::raw::c_char,
        name_length: *mut usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_get_name(
        dynamic_type_builder: *const rosidl_dynamic_typesupport_dynamic_type_builder_t,
        name: *mut *const ::std::os::raw::c_char,
        name_length: *mut usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_set_name(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_bool_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_byte_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_char_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_wchar_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_float32_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_float64_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_float128_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_int8_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_uint8_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_int16_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_uint16_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_int32_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_uint32_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_int64_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_uint64_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_string_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_wstring_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_bounded_string_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        string_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_bounded_wstring_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        wstring_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_fixed_string_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        string_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_fixed_wstring_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        wstring_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_bool_array_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        array_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_byte_array_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        array_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_char_array_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        array_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_wchar_array_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        array_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_float32_array_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        array_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_float64_array_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        array_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_float128_array_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        array_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_int8_array_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        array_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_uint8_array_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        array_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_int16_array_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        array_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_uint16_array_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        array_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_int32_array_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        array_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_uint32_array_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        array_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_int64_array_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        array_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_uint64_array_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        array_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_string_array_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        array_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_wstring_array_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        array_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_bounded_string_array_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        string_bound: usize,
        array_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_bounded_wstring_array_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        wstring_bound: usize,
        array_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_fixed_string_array_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        string_length: usize,
        array_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_fixed_wstring_array_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        wstring_length: usize,
        array_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_bool_unbounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_byte_unbounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_char_unbounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_wchar_unbounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_float32_unbounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_float64_unbounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_float128_unbounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_int8_unbounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_uint8_unbounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_int16_unbounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_uint16_unbounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_int32_unbounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_uint32_unbounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_int64_unbounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_uint64_unbounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_string_unbounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_wstring_unbounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_bounded_string_unbounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        string_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_bounded_wstring_unbounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        wstring_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_fixed_string_unbounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        string_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_fixed_wstring_unbounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        wstring_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_bool_bounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        sequence_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_byte_bounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        sequence_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_char_bounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        sequence_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_wchar_bounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        sequence_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_float32_bounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        sequence_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_float64_bounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        sequence_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_float128_bounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        sequence_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_int8_bounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        sequence_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_uint8_bounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        sequence_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_int16_bounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        sequence_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_uint16_bounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        sequence_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_int32_bounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        sequence_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_uint32_bounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        sequence_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_int64_bounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        sequence_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_uint64_bounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        sequence_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_string_bounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        sequence_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_wstring_bounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        sequence_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_bounded_string_bounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        string_bound: usize,
        sequence_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_bounded_wstring_bounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        wstring_bound: usize,
        sequence_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_fixed_string_bounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        string_length: usize,
        sequence_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_fixed_wstring_bounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        wstring_length: usize,
        sequence_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_complex_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        nested_struct: *mut rosidl_dynamic_typesupport_dynamic_type_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_complex_array_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        nested_struct: *mut rosidl_dynamic_typesupport_dynamic_type_t,
        array_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_complex_unbounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        nested_struct: *mut rosidl_dynamic_typesupport_dynamic_type_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_complex_bounded_sequence_member(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        nested_struct: *mut rosidl_dynamic_typesupport_dynamic_type_t,
        sequence_bound: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_complex_member_builder(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        nested_struct_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_complex_array_member_builder(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        nested_struct_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        array_length: usize,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_complex_unbounded_sequence_member_builder(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        nested_struct_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_dynamic_type_builder_add_complex_bounded_sequence_member_builder(
        dynamic_type_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        id: rosidl_dynamic_typesupport_member_id_t,
        name: *const ::std::os::raw::c_char,
        name_length: usize,
        default_value: *const ::std::os::raw::c_char,
        default_value_length: usize,
        nested_struct_builder: *mut rosidl_dynamic_typesupport_dynamic_type_builder_t,
        sequence_bound: usize,
    ) -> rcutils_ret_t;
}
#[doc = " Serialization Support Impl\n For anything necessary or useful for the operation of the serialization lib\n (e.g. singleton dynamic type and dynamic data factories)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_dynamic_typesupport_serialization_support_impl_s {
    pub allocator: rcutils_allocator_t,
    pub serialization_library_identifier: *const ::std::os::raw::c_char,
    pub handle: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rosidl_dynamic_typesupport_serialization_support_impl_s() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_dynamic_typesupport_serialization_support_impl_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_dynamic_typesupport_serialization_support_impl_s>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_impl_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_dynamic_typesupport_serialization_support_impl_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_impl_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_impl_s),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).serialization_library_identifier) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_impl_s),
            "::",
            stringify!(serialization_library_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_impl_s),
            "::",
            stringify!(handle)
        )
    );
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_get_zero_initialized_serialization_support_impl(
    ) -> rosidl_dynamic_typesupport_serialization_support_impl_t;
}
#[doc = " Serialization Support\n This is the main structure that encompasses:\n   - impl - The library-specific objects or implementation details\n   - methods - The shared serialization support interface, populated with serialization\n     library-specific function pointers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_dynamic_typesupport_serialization_support_s {
    pub allocator: rcutils_allocator_t,
    pub serialization_library_identifier: *const ::std::os::raw::c_char,
    pub impl_: rosidl_dynamic_typesupport_serialization_support_impl_t,
    pub methods: rosidl_dynamic_typesupport_serialization_support_interface_t,
}
#[test]
fn bindgen_test_layout_rosidl_dynamic_typesupport_serialization_support_s() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_dynamic_typesupport_serialization_support_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_dynamic_typesupport_serialization_support_s>(),
        1688usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_dynamic_typesupport_serialization_support_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_s),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).serialization_library_identifier) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_s),
            "::",
            stringify!(serialization_library_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_s),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).methods) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_typesupport_serialization_support_s),
            "::",
            stringify!(methods)
        )
    );
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_get_zero_initialized_serialization_support(
    ) -> rosidl_dynamic_typesupport_serialization_support_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_serialization_support_get_library_identifier(
        serialization_support: *const rosidl_dynamic_typesupport_serialization_support_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_serialization_support_init(
        impl_: *mut rosidl_dynamic_typesupport_serialization_support_impl_t,
        methods: *mut rosidl_dynamic_typesupport_serialization_support_interface_t,
        allocator: *mut rcutils_allocator_t,
        serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub fn rosidl_dynamic_typesupport_serialization_support_fini(
        serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    pub static rosidl_dynamic_typesupport_c__identifier: *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the name of the rosidl_dynamic_typesupport_c identifier\n**\n* \\return Name of rosidl_dynamic_typesupport_c identifier\n*/"]
    pub fn rosidl_get_dynamic_typesupport_identifier() -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_dynamic_message_type_support_impl_s {
    pub allocator: rcutils_allocator_t,
    pub type_hash: rosidl_type_hash_t,
    pub type_description: rosidl_runtime_c__type_description__TypeDescription,
    pub type_description_sources: rosidl_runtime_c__type_description__TypeSource__Sequence,
    pub serialization_support: rosidl_dynamic_typesupport_serialization_support_t,
    pub dynamic_message_type: *mut rosidl_dynamic_typesupport_dynamic_type_t,
    pub dynamic_message: *mut rosidl_dynamic_typesupport_dynamic_data_t,
}
#[test]
fn bindgen_test_layout_rosidl_dynamic_message_type_support_impl_s() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_dynamic_message_type_support_impl_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_dynamic_message_type_support_impl_s>(),
        1880usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_dynamic_message_type_support_impl_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_dynamic_message_type_support_impl_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_dynamic_message_type_support_impl_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_message_type_support_impl_s),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_hash) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_message_type_support_impl_s),
            "::",
            stringify!(type_hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_description) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_message_type_support_impl_s),
            "::",
            stringify!(type_description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_description_sources) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_message_type_support_impl_s),
            "::",
            stringify!(type_description_sources)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serialization_support) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_message_type_support_impl_s),
            "::",
            stringify!(serialization_support)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_message_type) as usize - ptr as usize },
        1864usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_message_type_support_impl_s),
            "::",
            stringify!(dynamic_message_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_message) as usize - ptr as usize },
        1872usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_dynamic_message_type_support_impl_s),
            "::",
            stringify!(dynamic_message)
        )
    );
}
pub type rosidl_dynamic_message_type_support_impl_t = rosidl_dynamic_message_type_support_impl_s;
extern "C" {
    #[doc = " Initialize a dynamic type message type support with encapsulated message description\n**\n* Take note of the ownership rules for the returned struct and the `description` argument.\n*\n* The `rosidl_message_type_support_t *` returned from this function has different ownership rules\n* compared to the statically allocated `rosidl_message_type_support_t` structs from code-generated\n* types.\n*\n* The `type_hash`, `type_description`, `type_description_sources`, and `allocator` arguments are\n* copied.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*/"]
    pub fn rosidl_dynamic_message_type_support_handle_init(
        serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_t,
        type_hash: *const rosidl_type_hash_t,
        type_description: *const rosidl_runtime_c__type_description__TypeDescription,
        type_description_sources: *const rosidl_runtime_c__type_description__TypeSource__Sequence,
        allocator: *mut rcutils_allocator_t,
        ts: *mut rosidl_message_type_support_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Finalize a rosidl_message_type_support_t obtained with\n `rosidl_dynamic_message_type_support_handle_init()`, which has dynamically allocated members\n\n NOTE: Using this on a statically allocated typesupport will cause undefined behavior!\n       (Static memory will get freed in that case.)"]
    pub fn rosidl_dynamic_message_type_support_handle_fini(
        ts: *mut rosidl_message_type_support_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Initialized a `rosidl_dynamic_message_type_support_impl_t` with encapsulated message description\n**\n* The `type_hash`, `type_description`, `type_description_sources`, and `allocator` arguments are\n* copied.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*/"]
    pub fn rosidl_dynamic_message_type_support_handle_impl_init(
        serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_t,
        type_hash: *const rosidl_type_hash_t,
        type_description: *const rosidl_runtime_c__type_description__TypeDescription,
        type_description_sources: *const rosidl_runtime_c__type_description__TypeSource__Sequence,
        allocator: *mut rcutils_allocator_t,
        ts_impl: *mut rosidl_dynamic_message_type_support_impl_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Finalize a `rosidl_dynamic_message_type_support_impl_t`"]
    pub fn rosidl_dynamic_message_type_support_handle_impl_fini(
        ts_impl: *mut rosidl_dynamic_message_type_support_impl_t,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Return type_hash member in rosidl_dynamic_message_type_support_impl_t"]
    pub fn rosidl_get_dynamic_message_type_support_type_hash_function(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_type_hash_t;
}
extern "C" {
    #[doc = " Return description member in rosidl_dynamic_message_type_support_impl_t"]
    pub fn rosidl_get_dynamic_message_type_support_type_description_function(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeDescription;
}
extern "C" {
    #[doc = " Return type_description_sources member in rosidl_dynamic_message_type_support_impl_t"]
    pub fn rosidl_get_dynamic_message_type_support_type_description_sources_function(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource__Sequence;
}
#[doc = " `rmw_message_info_t.publication_sequence_number` is filled correctly\n by the rmw implementation."]
pub const rmw_feature_e_RMW_FEATURE_MESSAGE_INFO_PUBLICATION_SEQUENCE_NUMBER: rmw_feature_e = 0;
#[doc = " `rmw_message_info_t.reception_sequence_number` is filled correctly\n by the rmw implementation."]
pub const rmw_feature_e_RMW_FEATURE_MESSAGE_INFO_RECEPTION_SEQUENCE_NUMBER: rmw_feature_e = 1;
#[doc = " deferred description dynamic type rosidl_message_type_support_t structs are allowed, and the\n middleware MUST populate them on type discovery"]
pub const rmw_feature_e_RMW_MIDDLEWARE_SUPPORTS_TYPE_DISCOVERY: rmw_feature_e = 2;
#[doc = " dynamic type subscriptions will use take_dynamic_message_with_info()"]
pub const rmw_feature_e_RMW_MIDDLEWARE_CAN_TAKE_DYNAMIC_MESSAGE: rmw_feature_e = 3;
#[doc = " List of optional rmw features.\n**\n* Some of the features listed here might become mandatory in the feature, in which case all rmw\n* implementations should return `true`.\n*\n* There might be some optional features that are not listed here, but the goal is to have all of\n* them added.\n*/"]
pub type rmw_feature_e = ::std::os::raw::c_uint;
#[doc = " List of optional rmw features.\n**\n* Some of the features listed here might become mandatory in the feature, in which case all rmw\n* implementations should return `true`.\n*\n* There might be some optional features that are not listed here, but the goal is to have all of\n* them added.\n*/"]
pub use self::rmw_feature_e as rmw_feature_t;
extern "C" {
    #[doc = " Query if a feature is supported by the rmw implementation.\n**\n* \\return `true` if the rmw implementation supports the feature, `false` if not.\n*/"]
    pub fn rmw_feature_supported(feature: rmw_feature_t) -> bool;
}
extern "C" {
    #[doc = " Interfaces for runtime interface reflection"]
    pub fn rmw_take_dynamic_message(
        subscription: *const rmw_subscription_t,
        dynamic_message: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        taken: *mut bool,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    pub fn rmw_take_dynamic_message_with_info(
        subscription: *const rmw_subscription_t,
        dynamic_message: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        taken: *mut bool,
        message_info: *mut rmw_message_info_t,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    pub fn rmw_serialization_support_init(
        serialization_lib_name: *const ::std::os::raw::c_char,
        allocator: *mut rcutils_allocator_t,
        serialization_support: *mut rosidl_dynamic_typesupport_serialization_support_t,
    ) -> rmw_ret_t;
}
#[doc = " Structure to hold a sequence of ROS messages."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_message_sequence_s {
    #[doc = " Array of pointers to ROS messages."]
    pub data: *mut *mut ::std::os::raw::c_void,
    #[doc = " The number of valid entries in `data`."]
    pub size: usize,
    #[doc = " The total allocated capacity of the data array."]
    pub capacity: usize,
    #[doc = " The allocator used to allocate the data array."]
    pub allocator: *mut rcutils_allocator_t,
}
#[test]
fn bindgen_test_layout_rmw_message_sequence_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_message_sequence_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_message_sequence_s>(),
        32usize,
        concat!("Size of: ", stringify!(rmw_message_sequence_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_message_sequence_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_message_sequence_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_message_sequence_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_message_sequence_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_message_sequence_s),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_message_sequence_s),
            "::",
            stringify!(allocator)
        )
    );
}
#[doc = " Structure to hold a sequence of ROS messages."]
pub type rmw_message_sequence_t = rmw_message_sequence_s;
#[doc = " Structure to hold a sequence of message infos."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_message_info_sequence_s {
    #[doc = " Array of message info."]
    pub data: *mut rmw_message_info_t,
    #[doc = " The number of valid entries in data."]
    pub size: usize,
    #[doc = " The total allocated capacity of the data array."]
    pub capacity: usize,
    #[doc = " The allocator used to allocate the data array."]
    pub allocator: *mut rcutils_allocator_t,
}
#[test]
fn bindgen_test_layout_rmw_message_info_sequence_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_message_info_sequence_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_message_info_sequence_s>(),
        32usize,
        concat!("Size of: ", stringify!(rmw_message_info_sequence_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_message_info_sequence_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_message_info_sequence_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_message_info_sequence_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_message_info_sequence_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_message_info_sequence_s),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_message_info_sequence_s),
            "::",
            stringify!(allocator)
        )
    );
}
#[doc = " Structure to hold a sequence of message infos."]
pub type rmw_message_info_sequence_t = rmw_message_info_sequence_s;
extern "C" {
    #[doc = " Return an rmw_message_sequence_t struct with members initialized to `NULL`"]
    pub fn rmw_get_zero_initialized_message_sequence() -> rmw_message_sequence_t;
}
extern "C" {
    #[doc = " Initialize an rmw_message_sequence_t object.\n**\n* \\param[inout] sequence sequence object to be initialized.\n* \\param[in] size capacity of the sequence to be allocated.\n* \\param[in] allocator the allcator used to allocate memory.\n*/"]
    pub fn rmw_message_sequence_init(
        sequence: *mut rmw_message_sequence_t,
        size: usize,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Finalize an rmw_message_sequence_t object.\n**\n* The rmw_message_sequence_t struct has members which require memory to be allocated to them\n* before setting values.\n* This function reclaims any allocated resources within the object and zeroes out all other\n* members.\n*\n* Note: This will not call `fini` or deallocate the underlying message structures.\n*\n* \\param[inout] sequence sequence object to be finalized.\n*/"]
    pub fn rmw_message_sequence_fini(sequence: *mut rmw_message_sequence_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Return an rmw_message_info_sequence_t struct with members initialized to `NULL`"]
    pub fn rmw_get_zero_initialized_message_info_sequence() -> rmw_message_info_sequence_t;
}
extern "C" {
    #[doc = " Initialize an rmw_message_info_sequence_t object.\n**\n* \\param[inout] sequence sequence object to be initialized.\n* \\param[in] size capacity of the sequence to be allocated.\n* \\param[in] allocator the allcator used to allocate memory.\n*/"]
    pub fn rmw_message_info_sequence_init(
        sequence: *mut rmw_message_info_sequence_t,
        size: usize,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Finalize an rmw_message_sequence_t object.\n**\n* The rmw_message_sequence_t struct has members which require memory to be allocated to them\n* before setting values.\n* This function reclaims any allocated resources within the object and zeroes out all other\n* members.\n*\n* \\param[inout] sequence sequence object to be finalized.\n*/"]
    pub fn rmw_message_info_sequence_fini(sequence: *mut rmw_message_info_sequence_t) -> rmw_ret_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_subscription_impl_s {
    _unused: [u8; 0],
}
#[doc = " Internal rcl implementation struct."]
pub type rcl_subscription_impl_t = rcl_subscription_impl_s;
#[doc = " Structure which encapsulates a ROS Subscription."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_subscription_s {
    #[doc = " Pointer to the subscription implementation"]
    pub impl_: *mut rcl_subscription_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_subscription_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_subscription_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_subscription_s>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_subscription_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_subscription_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_subscription_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_subscription_s),
            "::",
            stringify!(impl_)
        )
    );
}
#[doc = " Structure which encapsulates a ROS Subscription."]
pub type rcl_subscription_t = rcl_subscription_s;
#[doc = " Options available for a rcl subscription."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_subscription_options_s {
    #[doc = " Middleware quality of service settings for the subscription."]
    pub qos: rmw_qos_profile_t,
    #[doc = " Custom allocator for the subscription, used for incidental allocations.\n** For default behavior (malloc/free), see: rcl_get_default_allocator() */"]
    pub allocator: rcl_allocator_t,
    #[doc = " rmw specific subscription options, e.g. the rmw implementation specific payload."]
    pub rmw_subscription_options: rmw_subscription_options_t,
    #[doc = " Disable flag to LoanedMessage, initialized via environmental variable."]
    pub disable_loaned_message: bool,
}
#[test]
fn bindgen_test_layout_rcl_subscription_options_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_subscription_options_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_subscription_options_s>(),
        160usize,
        concat!("Size of: ", stringify!(rcl_subscription_options_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_subscription_options_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_subscription_options_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_subscription_options_s),
            "::",
            stringify!(qos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_subscription_options_s),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rmw_subscription_options) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_subscription_options_s),
            "::",
            stringify!(rmw_subscription_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disable_loaned_message) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_subscription_options_s),
            "::",
            stringify!(disable_loaned_message)
        )
    );
}
#[doc = " Options available for a rcl subscription."]
pub type rcl_subscription_options_t = rcl_subscription_options_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_subscription_content_filter_options_s {
    pub rmw_subscription_content_filter_options: rmw_subscription_content_filter_options_t,
}
#[test]
fn bindgen_test_layout_rcl_subscription_content_filter_options_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_subscription_content_filter_options_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_subscription_content_filter_options_s>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(rcl_subscription_content_filter_options_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_subscription_content_filter_options_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rcl_subscription_content_filter_options_s)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).rmw_subscription_content_filter_options) as usize
                - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_subscription_content_filter_options_s),
            "::",
            stringify!(rmw_subscription_content_filter_options)
        )
    );
}
pub type rcl_subscription_content_filter_options_t = rcl_subscription_content_filter_options_s;
extern "C" {
    #[doc = " Return a rcl_subscription_t struct with members set to `NULL`.\n**\n* Should be called to get a null rcl_subscription_t before passing to\n* rcl_subscription_init().\n*/"]
    pub fn rcl_get_zero_initialized_subscription() -> rcl_subscription_t;
}
extern "C" {
    #[doc = " Initialize a ROS subscription.\n**\n* After calling this function on a rcl_subscription_t, it can be used to take\n* messages of the given type to the given topic using rcl_take().\n*\n* The given rcl_node_t must be valid and the resulting rcl_subscription_t is\n* only valid as long as the given rcl_node_t remains valid.\n*\n* The rosidl_message_type_support_t is obtained on a per .msg type basis.\n* When the user defines a ROS message, code is generated which provides the\n* required rosidl_message_type_support_t object.\n* This object can be obtained using a language appropriate mechanism.\n* \\todo TODO(wjwwood) write these instructions once and link to it instead\n* For C a macro can be used (for example `std_msgs/String`):\n*\n* ```c\n* #include <rosidl_runtime_c/message_type_support_struct.h>\n* #include <std_msgs/msg/string.h>\n* const rosidl_message_type_support_t * string_ts =\n*   ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);\n* ```\n*\n* For C++ a template function is used:\n*\n* ```cpp\n* #include <rosidl_typesupport_cpp/message_type_support.hpp>\n* #include <std_msgs/msgs/string.hpp>\n* using rosidl_typesupport_cpp::get_message_type_support_handle;\n* const rosidl_message_type_support_t * string_ts =\n*   get_message_type_support_handle<std_msgs::msg::String>();\n* ```\n*\n* The rosidl_message_type_support_t object contains message type specific\n* information used to publish messages.\n*\n* The topic name must be a c string which follows the topic and service name\n* format rules for unexpanded names, also known as non-fully qualified names:\n*\n* \\see rcl_expand_topic_name\n*\n* The options struct allows the user to set the quality of service settings as\n* well as a custom allocator which is used when (de)initializing the\n* subscription to allocate space for incidental things, e.g. the topic\n* name string.\n*\n* Expected usage (for C messages):\n*\n* ```c\n* #include <rcl/rcl.h>\n* #include <rosidl_runtime_c/message_type_support_struct.h>\n* #include <std_msgs/msg/string.h>\n*\n* rcl_node_t node = rcl_get_zero_initialized_node();\n* rcl_node_options_t node_ops = rcl_node_get_default_options();\n* rcl_ret_t ret = rcl_node_init(&node, \"node_name\", \"/my_namespace\", &node_ops);\n* // ... error handling\n* const rosidl_message_type_support_t * ts =\n*   ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);\n* rcl_subscription_t subscription = rcl_get_zero_initialized_subscription();\n* rcl_subscription_options_t subscription_ops = rcl_subscription_get_default_options();\n* ret = rcl_subscription_init(&subscription, &node, ts, \"chatter\", &subscription_ops);\n* // ... error handling, and when finished deinitialization\n* ret = rcl_subscription_fini(&subscription, &node);\n* // ... error handling for rcl_subscription_fini()\n* ret = rcl_node_fini(&node);\n* // ... error handling for rcl_node_fini()\n* ```\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[out] subscription preallocated subscription structure\n* \\param[in] node valid rcl node handle\n* \\param[in] type_support type support object for the topic's type\n* \\param[in] topic_name the name of the topic\n* \\param[in] options subscription options, including quality of service settings\n* \\return #RCL_RET_OK if subscription was initialized successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ALREADY_INIT if the subcription is already initialized, or\n* \\return #RCL_RET_NODE_INVALID if the node is invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_TOPIC_NAME_INVALID if the given topic name is invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_subscription_init(
        subscription: *mut rcl_subscription_t,
        node: *const rcl_node_t,
        type_support: *const rosidl_message_type_support_t,
        topic_name: *const ::std::os::raw::c_char,
        options: *const rcl_subscription_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a rcl_subscription_t.\n**\n* After calling, the node will no longer be subscribed on this topic\n* (assuming this is the only subscription on this topic in this node).\n*\n* After calling, calls to rcl_wait and rcl_take will fail when using this\n* subscription.\n* Additioanlly rcl_wait will be interrupted if currently blocking.\n* However, the given node handle is still valid.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] subscription handle to the subscription to be deinitialized\n* \\param[in] node a valid (not finalized) handle to the node used to create the subscription\n* \\return #RCL_RET_OK if subscription was deinitialized successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_SUBSCRIPTION_INVALID if the subscription is invalid, or\n* \\return #RCL_RET_NODE_INVALID if the node is invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_subscription_fini(
        subscription: *mut rcl_subscription_t,
        node: *mut rcl_node_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the default subscription options in a rcl_subscription_options_t.\n**\n* The defaults are:\n*\n* - qos = rmw_qos_profile_default\n* - allocator = rcl_get_default_allocator()\n* - rmw_subscription_options = rmw_get_default_subscription_options();\n* - disable_loaned_message = true, false only if ROS_DISABLE_LOANED_MESSAGES=0\n*\n* \\return A structure containing the default options for a subscription.\n*/"]
    pub fn rcl_subscription_get_default_options() -> rcl_subscription_options_t;
}
extern "C" {
    #[doc = " Reclaim resources held inside rcl_subscription_options_t structure.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | No\n*\n* \\param[in] option The structure which its resources have to be deallocated.\n* \\return `RCL_RET_OK` if the memory was successfully freed, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if option is NULL, or\n* \\return `RCL_RET_BAD_ALLOC` if deallocating memory fails.\n*/"]
    pub fn rcl_subscription_options_fini(option: *mut rcl_subscription_options_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Set the content filter options for the given subscription options.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | No\n*\n* \\param[in] filter_expression The filter expression is similar to the WHERE part of an SQL clause.\n* \\param[in] expression_parameters_argc The maximum of expression parameters argc is 100.\n* \\param[in] expression_parameter_argv The expression parameters argv are the tokens placeholder\n* parameters (i.e., \"%n\" tokens begin from 0) in the filter_expression.\n*\n* It can be NULL if there is no \"%n\" tokens placeholder in filter_expression.\n* \\param[out] options The subscription options to be set.\n* \\return `RCL_RET_OK` if set options successfully, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if arguments invalid, or\n* \\return `RCL_RET_BAD_ALLOC` if allocating memory fails.\n*/"]
    pub fn rcl_subscription_options_set_content_filter_options(
        filter_expression: *const ::std::os::raw::c_char,
        expression_parameters_argc: usize,
        expression_parameter_argv: *mut *const ::std::os::raw::c_char,
        options: *mut rcl_subscription_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the zero initialized subscription content filter options."]
    pub fn rcl_get_zero_initialized_subscription_content_filter_options(
    ) -> rcl_subscription_content_filter_options_t;
}
extern "C" {
    #[doc = " Initialize the content filter options for the given subscription options.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | No\n*\n* \\param[in] subscription the handle to the subscription.\n* \\param[in] filter_expression The filter expression is similar to the WHERE part of an SQL clause,\n* use empty (\"\") can reset (or clear) the content filter setting of a subscription.\n* \\param[in] expression_parameters_argc The maximum of expression parameters argc is 100.\n* \\param[in] expression_parameter_argv The expression parameters argv are the tokens placeholder\n* parameters (i.e., \"%n\" tokens begin from 0) in the filter_expression.\n*\n* It can be NULL if there is no \"%n\" tokens placeholder in filter_expression.\n* \\param[out] options The subscription options to be set.\n* \\return `RCL_RET_OK` if set options successfully, or\n* \\return `RCL_RET_SUBSCRIPTION_INVALID` if subscription is invalid, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if arguments invalid, or\n* \\return `RCL_RET_BAD_ALLOC` if allocating memory fails.\n*/"]
    pub fn rcl_subscription_content_filter_options_init(
        subscription: *const rcl_subscription_t,
        filter_expression: *const ::std::os::raw::c_char,
        expression_parameters_argc: usize,
        expression_parameter_argv: *mut *const ::std::os::raw::c_char,
        options: *mut rcl_subscription_content_filter_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Set the content filter options for the given subscription options.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | No\n*\n* \\param[in] subscription the handle to the subscription.\n* \\param[in] filter_expression The filter expression is similar to the WHERE part of an SQL clause,\n* use empty (\"\") can reset (or clear) the content filter setting of a subscription.\n* \\param[in] expression_parameters_argc The maximum of expression parameters argc is 100.\n* \\param[in] expression_parameter_argv The expression parameters argv are the tokens placeholder\n* parameters (i.e., \"%n\" tokens begin from 0) in the filter_expression.\n*\n* It can be NULL if there is no \"%n\" tokens placeholder in filter_expression.\n* \\param[out] options The subscription options to be set.\n* \\return `RCL_RET_OK` if set options successfully, or\n* \\return `RCL_RET_SUBSCRIPTION_INVALID` if subscription is invalid, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if arguments invalid, or\n* \\return `RCL_RET_BAD_ALLOC` if allocating memory fails.\n*/"]
    pub fn rcl_subscription_content_filter_options_set(
        subscription: *const rcl_subscription_t,
        filter_expression: *const ::std::os::raw::c_char,
        expression_parameters_argc: usize,
        expression_parameter_argv: *mut *const ::std::os::raw::c_char,
        options: *mut rcl_subscription_content_filter_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Reclaim rcl_subscription_content_filter_options_t structure.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | No\n*\n* \\param[in] subscription the handle to the subscription.\n* \\param[in] options The structure which its resources have to be deallocated.\n* \\return `RCL_RET_OK` if the memory was successfully freed, or\n* \\return `RCL_RET_SUBSCRIPTION_INVALID` if subscription is invalid, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if option is NULL, or\n*  if its allocator is invalid and the structure contains initialized memory.\n*/"]
    pub fn rcl_subscription_content_filter_options_fini(
        subscription: *const rcl_subscription_t,
        options: *mut rcl_subscription_content_filter_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Check if the content filtered topic feature is enabled in the subscription.\n**\n* Depending on the middleware and whether cft is enabled in the subscription.\n*\n* \\return `true` if the content filtered topic of `subscription` is enabled, otherwise `false`\n*/"]
    pub fn rcl_subscription_is_cft_enabled(subscription: *const rcl_subscription_t) -> bool;
}
extern "C" {
    #[doc = " Set the filter expression and expression parameters for the subscription.\n**\n* This function will set a filter expression and an array of expression parameters\n* for the given subscription.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n*\n* \\param[in] subscription The subscription to set content filter options.\n* \\param[in] options The rcl content filter options.\n* \\return `RCL_RET_OK` if the query was successful, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if `subscription` is NULL, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if `options` is NULL, or\n* \\return `RCL_RET_UNSUPPORTED` if the implementation does not support content filter topic, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_subscription_set_content_filter(
        subscription: *const rcl_subscription_t,
        options: *const rcl_subscription_content_filter_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Retrieve the filter expression of the subscription.\n**\n* This function will return an filter expression by the given subscription.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n*\n* \\param[in] subscription The subscription object to inspect.\n* \\param[out] options The rcl content filter options.\n*   It is up to the caller to finalize this options later on, using\n*   rcl_subscription_content_filter_options_fini().\n* \\return `RCL_RET_OK` if the query was successful, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if `subscription` is NULL, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if `options` is NULL, or\n* \\return `RCL_RET_BAD_ALLOC` if memory allocation fails, or\n* \\return `RCL_RET_UNSUPPORTED` if the implementation does not support content filter topic, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_subscription_get_content_filter(
        subscription: *const rcl_subscription_t,
        options: *mut rcl_subscription_content_filter_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take a ROS message from a topic using a rcl subscription.\n**\n* It is the job of the caller to ensure that the type of the ros_message\n* argument and the type associated with the subscription, via the type\n* support, match.\n* Passing a different type to rcl_take produces undefined behavior and cannot\n* be checked by this function and therefore no deliberate error will occur.\n*\n* TODO(wjwwood) blocking of take?\n* TODO(wjwwood) pre-, during-, and post-conditions for message ownership?\n* TODO(wjwwood) is rcl_take thread-safe?\n* TODO(wjwwood) Should there be an rcl_message_info_t?\n*\n* The ros_message pointer should point to an already allocated ROS message\n* struct of the correct type, into which the taken ROS message will be copied\n* if one is available.\n* If taken is false after calling, then the ROS message will be unmodified.\n*\n* The taken boolean may be false even if a wait set reports that the\n* subscription was ready to be taken from in some cases, e.g. when the\n* state of the subscription changes it may cause the wait set to wake up\n* but subsequent takes to fail to take anything.\n*\n* If allocation is required when taking the message, e.g. if space needs to\n* be allocated for a dynamically sized array in the target message, then the\n* allocator given in the subscription options is used.\n*\n* The rmw_message_info struct contains meta information about this particular\n* message instance, like what the GUID of the publisher which published it\n* originally or whether or not the message received from within the same\n* process.\n* The message_info argument should be an already allocated rmw_message_info_t\n* structure.\n* Passing `NULL` for message_info will result in the argument being ignored.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe [1]\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] only if required when filling the message, avoided for fixed sizes</i>\n*\n* \\param[in] subscription the handle to the subscription from which to take\n* \\param[inout] ros_message type-erased ptr to a allocated ROS message\n* \\param[out] message_info rmw struct which contains meta-data for the message\n* \\param[in] allocation structure pointer used for memory preallocation (may be NULL)\n* \\return #RCL_RET_OK if the message was taken, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_SUBSCRIPTION_INVALID if the subscription is invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_SUBSCRIPTION_TAKE_FAILED if take failed but no error\n*         occurred in the middleware, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_take(
        subscription: *const rcl_subscription_t,
        ros_message: *mut ::std::os::raw::c_void,
        message_info: *mut rmw_message_info_t,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take a sequence of messages from a topic using a rcl subscription.\n**\n* In contrast to rcl_take(), this function can take multiple messages at\n* the same time.\n* It is the job of the caller to ensure that the type of the message_sequence\n* argument and the type associated with the subscription, via the type\n* support, match.\n*\n* The message_sequence pointer should point to an already allocated sequence\n* of ROS messages of the correct type, into which the taken ROS messages will\n* be copied if messages are available.\n* The message_sequence `size` member will be set to the number of messages\n* correctly taken.\n*\n* The rmw_message_info_sequence struct contains meta information about the\n* corresponding message instance index.\n* The message_info_sequence argument should be an already allocated\n* rmw_message_info_sequence_t structure.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe [1]\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] only if storage in the serialized_message is insufficient</i>\n*\n* \\param[in] subscription the handle to the subscription from which to take.\n* \\param[in] count number of messages to attempt to take.\n* \\param[inout] message_sequence pointer to a (pre-allocated) message sequence.\n* \\param[inout] message_info_sequence pointer to a (pre-allocated) message info sequence.\n* \\param[in] allocation structure pointer used for memory preallocation (may be NULL)\n* \\return #RCL_RET_OK if one or more messages was taken, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_SUBSCRIPTION_INVALID if the subscription is invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_SUBSCRIPTION_TAKE_FAILED if take failed but no error\n*         occurred in the middleware, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_take_sequence(
        subscription: *const rcl_subscription_t,
        count: usize,
        message_sequence: *mut rmw_message_sequence_t,
        message_info_sequence: *mut rmw_message_info_sequence_t,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take a serialized raw message from a topic using a rcl subscription.\n**\n* In contrast to rcl_take(), this function stores the taken message in\n* its raw binary representation.\n* It is the job of the caller to ensure that the type associate with the subscription\n* matches, and can optionally be deserialized into its ROS message via, the correct\n* type support.\n* If the `serialized_message` parameter contains enough preallocated memory, the incoming\n* message can be taken without any additional memory allocation.\n* If not, the function will dynamically allocate enough memory for the message.\n* Passing a different type to rcl_take produces undefined behavior and cannot\n* be checked by this function and therefore no deliberate error will occur.\n*\n* Apart from the differences above, this function behaves like rcl_take().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe [1]\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] only if storage in the serialized_message is insufficient</i>\n*\n* \\param[in] subscription the handle to the subscription from which to take\n* \\param[inout] serialized_message pointer to a (pre-allocated) serialized message.\n* \\param[out] message_info rmw struct which contains meta-data for the message\n* \\param[in] allocation structure pointer used for memory preallocation (may be NULL)\n* \\return #RCL_RET_OK if the message was published, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_SUBSCRIPTION_INVALID if the subscription is invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_SUBSCRIPTION_TAKE_FAILED if take failed but no error\n*         occurred in the middleware, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_take_serialized_message(
        subscription: *const rcl_subscription_t,
        serialized_message: *mut rcl_serialized_message_t,
        message_info: *mut rmw_message_info_t,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take a dynamic type message from a topic using a rcl subscription.\n**\n* In contrast to rcl_take(), this function takes a dynamic type message with dynamic data taken\n* directly from the middleware.\n* It is the job of the caller to ensure that the type associated with the subscription\n* matches, and that the subscription uses the dynamic type rosidl_message_type_support_t.\n*\n* Apart from the differences above, this function behaves like rcl_take().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] subscription the handle to the subscription from which to take\n* \\param[inout] dynamic_message pointer to a (pre-allocated) dynamic type message.\n* \\param[out] message_info rmw struct which contains meta-data for the message\n* \\param[in] allocation structure pointer used for memory preallocation (may be NULL)\n* \\return #RCL_RET_OK if the message was taken, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_SUBSCRIPTION_INVALID if the subscription is invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_SUBSCRIPTION_TAKE_FAILED if take failed but no error\n*         occurred in the middleware, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_take_dynamic_message(
        subscription: *const rcl_subscription_t,
        dynamic_message: *mut rosidl_dynamic_typesupport_dynamic_data_t,
        message_info: *mut rmw_message_info_t,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take a loaned message from a topic using a rcl subscription.\n**\n* Depending on the middleware, incoming messages can be loaned to the user's callback\n* without further copying.\n* The implicit contract here is that the middleware owns the memory allocated for this message.\n* The user must not destroy the message, but rather has to return it with a call to\n* \\sa rcl_return_loaned_message to the middleware.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] subscription the handle to the subscription from which to take\n* \\param[inout] loaned_message a pointer to the loaned messages.\n* \\param[out] message_info rmw struct which contains meta-data for the message.\n* \\param[in] allocation structure pointer used for memory preallocation (may be NULL)\n* \\return #RCL_RET_OK if the loaned message sequence was taken, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_SUBSCRIPTION_INVALID if the subscription is invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_SUBSCRIPTION_TAKE_FAILED if take failed but no error\n*         occurred in the middleware, or\n* \\return #RCL_RET_UNSUPPORTED if the middleware does not support that feature, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_take_loaned_message(
        subscription: *const rcl_subscription_t,
        loaned_message: *mut *mut ::std::os::raw::c_void,
        message_info: *mut rmw_message_info_t,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a loaned message from a topic using a rcl subscription.\n**\n* If a loaned message was previously obtained from the middleware with a call to\n* \\sa rcl_take_loaned_message, this message has to be returned to indicate to the middleware\n* that the user no longer needs that memory.\n* The user must not delete the message.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] subscription the handle to the subscription from which to take\n* \\param[in] loaned_message a pointer to the loaned messages.\n* \\return #RCL_RET_OK if the message was published, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_SUBSCRIPTION_INVALID if the subscription is invalid, or\n* \\return #RCL_RET_UNSUPPORTED if the middleware does not support that feature, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_return_loaned_message_from_subscription(
        subscription: *const rcl_subscription_t,
        loaned_message: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the topic name for the subscription.\n**\n* This function returns the subscription's internal topic name string.\n* This function can fail, and therefore return `NULL`, if the:\n*   - subscription is `NULL`\n*   - subscription is invalid (never called init, called fini, or invalid)\n*\n* The returned string is only valid as long as the subscription is valid.\n* The value of the string may change if the topic name changes, and therefore\n* copying the string is recommended if this is a concern.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] subscription the pointer to the subscription\n* \\return name string if successful, otherwise `NULL`\n*/"]
    pub fn rcl_subscription_get_topic_name(
        subscription: *const rcl_subscription_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the rcl subscription options.\n**\n* This function returns the subscription's internal options struct.\n* This function can fail, and therefore return `NULL`, if the:\n*   - subscription is `NULL`\n*   - subscription is invalid (never called init, called fini, or invalid)\n*\n* The returned struct is only valid as long as the subscription is valid.\n* The values in the struct may change if the subscription's options change,\n* and therefore copying the struct is recommended if this is a concern.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] subscription pointer to the subscription\n* \\return options struct if successful, otherwise `NULL`\n*/"]
    pub fn rcl_subscription_get_options(
        subscription: *const rcl_subscription_t,
    ) -> *const rcl_subscription_options_t;
}
extern "C" {
    #[doc = " Return the rmw subscription handle.\n**\n* The handle returned is a pointer to the internally held rmw handle.\n* This function can fail, and therefore return `NULL`, if the:\n*   - subscription is `NULL`\n*   - subscription is invalid (never called init, called fini, or invalid)\n*\n* The returned handle is made invalid if the subscription is finalized or if\n* rcl_shutdown() is called.\n* The returned handle is not guaranteed to be valid for the life time of the\n* subscription as it may be finalized and recreated itself.\n* Therefore it is recommended to get the handle from the subscription using\n* this function each time it is needed and avoid use of the handle\n* concurrently with functions that might change it.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] subscription pointer to the rcl subscription\n* \\return rmw subscription handle if successful, otherwise `NULL`\n*/"]
    pub fn rcl_subscription_get_rmw_handle(
        subscription: *const rcl_subscription_t,
    ) -> *mut rmw_subscription_t;
}
extern "C" {
    #[doc = " Check that the subscription is valid.\n**\n* The bool returned is `false` if `subscription` is invalid.\n* The bool returned is `true` otherwise.\n* In the case where `false` is to be returned, an error message is set.\n* This function cannot fail.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] subscription pointer to the rcl subscription\n* \\return `true` if `subscription` is valid, otherwise `false`\n*/"]
    pub fn rcl_subscription_is_valid(subscription: *const rcl_subscription_t) -> bool;
}
extern "C" {
    #[doc = " Get the number of publishers matched to a subscription.\n**\n* Used to get the internal count of publishers matched to a subscription.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] only if the underlying rmw doesn't make use of this feature </i>\n*\n* \\param[in] subscription pointer to the rcl subscription\n* \\param[out] publisher_count number of matched publishers\n* \\return #RCL_RET_OK if the count was retrieved, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_SUBSCRIPTION_INVALID if the subscription is invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_subscription_get_publisher_count(
        subscription: *const rcl_subscription_t,
        publisher_count: *mut usize,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Get the actual qos settings of the subscription.\n**\n* Used to get the actual qos settings of the subscription.\n* The actual configuration applied when using RMW_*_SYSTEM_DEFAULT\n* can only be resolved after the creation of the subscription, and it\n* depends on the underlying rmw implementation.\n* If the underlying setting in use can't be represented in ROS terms,\n* it will be set to RMW_*_UNKNOWN.\n* The returned struct is only valid as long as the rcl_subscription_t is valid.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] subscription pointer to the rcl subscription\n* \\return qos struct if successful, otherwise `NULL`\n*/"]
    pub fn rcl_subscription_get_actual_qos(
        subscription: *const rcl_subscription_t,
    ) -> *const rmw_qos_profile_t;
}
extern "C" {
    #[doc = " Check if subscription instance can loan messages.\n**\n* Depending on the middleware and the message type, this will return true if the middleware\n* can allocate a ROS message instance.\n*\n* \\param[in] subscription The subscription instance to check for the ability to loan messages\n* \\return `true` if the subscription instance can loan messages, `false` otherwise.\n*/"]
    pub fn rcl_subscription_can_loan_messages(subscription: *const rcl_subscription_t) -> bool;
}
extern "C" {
    #[doc = " Set the on new message callback function for the subscription.\n**\n* This API sets the callback function to be called whenever the\n* subscription is notified about a new message.\n*\n* \\sa rmw_subscription_set_on_new_message_callback for details about this\n* function.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined</i>\n*\n* \\param[in] subscription The subscription on which to set the callback\n* \\param[in] callback The callback to be called when new messages arrive, may be NULL\n* \\param[in] user_data Given to the callback when called later, may be NULL\n* \\return `RCL_RET_OK` if successful, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if `subscription` is NULL, or\n* \\return `RCL_RET_UNSUPPORTED` if the API is not implemented in the dds implementation\n*/"]
    pub fn rcl_subscription_set_on_new_message_callback(
        subscription: *const rcl_subscription_t,
        callback: rcl_event_callback_t,
        user_data: *const ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
#[doc = " Introspection disabled"]
pub const rcl_service_introspection_state_e_RCL_SERVICE_INTROSPECTION_OFF:
    rcl_service_introspection_state_e = 0;
#[doc = " Introspect metadata only"]
pub const rcl_service_introspection_state_e_RCL_SERVICE_INTROSPECTION_METADATA:
    rcl_service_introspection_state_e = 1;
#[doc = " Introspection metadata and contents"]
pub const rcl_service_introspection_state_e_RCL_SERVICE_INTROSPECTION_CONTENTS:
    rcl_service_introspection_state_e = 2;
#[doc = " The introspection state for a client or service."]
pub type rcl_service_introspection_state_e = ::std::os::raw::c_uint;
#[doc = " The introspection state for a client or service."]
pub use self::rcl_service_introspection_state_e as rcl_service_introspection_state_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_client_impl_s {
    _unused: [u8; 0],
}
#[doc = " Internal rcl client implementation struct."]
pub type rcl_client_impl_t = rcl_client_impl_s;
#[doc = " Structure which encapsulates a ROS Client."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_client_s {
    #[doc = " Pointer to the client implementation"]
    pub impl_: *mut rcl_client_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_client_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_client_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_client_s>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_client_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_client_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_client_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_client_s),
            "::",
            stringify!(impl_)
        )
    );
}
#[doc = " Structure which encapsulates a ROS Client."]
pub type rcl_client_t = rcl_client_s;
#[doc = " Options available for a rcl_client_t."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_client_options_s {
    #[doc = " Middleware quality of service settings for the client."]
    pub qos: rmw_qos_profile_t,
    #[doc = " Custom allocator for the client, used for incidental allocations.\n** For default behavior (malloc/free), use: rcl_get_default_allocator() */"]
    pub allocator: rcl_allocator_t,
}
#[test]
fn bindgen_test_layout_rcl_client_options_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_client_options_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_client_options_s>(),
        128usize,
        concat!("Size of: ", stringify!(rcl_client_options_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_client_options_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_client_options_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_client_options_s),
            "::",
            stringify!(qos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_client_options_s),
            "::",
            stringify!(allocator)
        )
    );
}
#[doc = " Options available for a rcl_client_t."]
pub type rcl_client_options_t = rcl_client_options_s;
extern "C" {
    #[doc = " Return a rcl_client_t struct with members set to `NULL`.\n**\n* Should be called to get a null rcl_client_t before passing to\n* rcl_client_init().\n*/"]
    pub fn rcl_get_zero_initialized_client() -> rcl_client_t;
}
extern "C" {
    #[doc = " Initialize a rcl client.\n**\n* After calling this function on a rcl_client_t, it can be used to send\n* requests of the given type by calling rcl_send_request().\n* If the request is received by a (possibly remote) service and if the service\n* sends a response, the client can access the response through\n* rcl_take_response() once the response is available to the client.\n*\n* The given rcl_node_t must be valid and the resulting rcl_client_t is only\n* valid as long as the given rcl_node_t remains valid.\n*\n* The rosidl_service_type_support_t is obtained on a per `.srv` type basis.\n* When the user defines a ROS service, code is generated which provides the\n* required rosidl_service_type_support_t object.\n* This object can be obtained using a language appropriate mechanism.\n* \\todo TODO(wjwwood) write these instructions once and link to it instead\n*\n* For C, a macro can be used (for example `example_interfaces/AddTwoInts`):\n*\n* ```c\n* #include <rosidl_runtime_c/service_type_support_struct.h>\n* #include <example_interfaces/srv/add_two_ints.h>\n*\n* const rosidl_service_type_support_t * ts =\n*   ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);\n* ```\n*\n* For C++, a template function is used:\n*\n* ```cpp\n* #include <rosidl_typesupport_cpp/service_type_support.hpp>\n* #include <example_interfaces/srv/add_two_ints.hpp>\n*\n* using rosidl_typesupport_cpp::get_service_type_support_handle;\n* const rosidl_service_type_support_t * ts =\n*   get_service_type_support_handle<example_interfaces::srv::AddTwoInts>();\n* ```\n*\n* The rosidl_service_type_support_t object contains service type specific\n* information used to send or take requests and responses.\n*\n* The topic name must be a c string which follows the topic and service name\n* format rules for unexpanded names, also known as non-fully qualified names:\n*\n* \\see rcl_expand_topic_name\n*\n* The options struct allows the user to set the quality of service settings as\n* well as a custom allocator which is used when initializing/finalizing the\n* client to allocate space for incidentals, e.g. the service name string.\n*\n* Expected usage (for C services):\n*\n* ```c\n* #include <rcl/rcl.h>\n* #include <rosidl_runtime_c/service_type_support_struct.h>\n* #include <example_interfaces/srv/add_two_ints.h>\n*\n* rcl_node_t node = rcl_get_zero_initialized_node();\n* rcl_node_options_t node_ops = rcl_node_get_default_options();\n* rcl_ret_t ret = rcl_node_init(&node, \"node_name\", \"/my_namespace\", &node_ops);\n* // ... error handling\n* const rosidl_service_type_support_t * ts =\n*   ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);\n* rcl_client_t client = rcl_get_zero_initialized_client();\n* rcl_client_options_t client_ops = rcl_client_get_default_options();\n* ret = rcl_client_init(&client, &node, ts, \"add_two_ints\", &client_ops);\n* // ... error handling, and on shutdown do finalization:\n* ret = rcl_client_fini(&client, &node);\n* // ... error handling for rcl_client_fini()\n* ret = rcl_node_fini(&node);\n* // ... error handling for rcl_node_fini()\n* ```\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] client preallocated rcl_client_t structure\n* \\param[in] node valid rcl_node_t\n* \\param[in] type_support type support object for the service's type\n* \\param[in] service_name the name of the service to request\n* \\param[in] options client options, including quality of service settings\n* \\return #RCL_RET_OK if the client was initialized successfully, or\n* \\return #RCL_RET_NODE_INVALID if the node is invalid, or\n* \\return #RCL_RET_ALREADY_INIT if the client is already initialized, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory fails, or\n* \\return #RCL_RET_SERVICE_NAME_INVALID if the given service name is invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_client_init(
        client: *mut rcl_client_t,
        node: *const rcl_node_t,
        type_support: *const rosidl_service_type_support_t,
        service_name: *const ::std::os::raw::c_char,
        options: *const rcl_client_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a rcl_client_t.\n**\n* After calling this function, calls to rcl_send_request() and\n* rcl_take_response() will fail when using this client.\n* However, the given node handle is still valid.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] client handle to the client to be finalized\n* \\param[in] node a valid (not finalized) handle to the node used to create the client\n* \\return #RCL_RET_OK if client was finalized successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_NODE_INVALID if the node is invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_client_fini(client: *mut rcl_client_t, node: *mut rcl_node_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the default client options in a rcl_client_options_t.\n**\n* The defaults are:\n*\n* - qos = rmw_qos_profile_services_default\n* - allocator = rcl_get_default_allocator()\n*/"]
    pub fn rcl_client_get_default_options() -> rcl_client_options_t;
}
extern "C" {
    #[doc = " Send a ROS request using a client.\n**\n* It is the job of the caller to ensure that the type of the `ros_request`\n* parameter and the type associate with the client (via the type support)\n* match.\n* Passing a different type to `send_request` produces undefined behavior and\n* cannot be checked by this function and therefore no deliberate error will\n* occur.\n*\n* rcl_send_request() is an non-blocking call.\n*\n* The ROS request message given by the `ros_request` void pointer is always\n* owned by the calling code, but should remain constant during `send_request`.\n*\n* This function is thread safe so long as access to both the client and the\n* `ros_request` is synchronized.\n* That means that calling rcl_send_request() from multiple threads is allowed,\n* but calling rcl_send_request() at the same time as non-thread safe client\n* functions is not, e.g. calling rcl_send_request() and rcl_client_fini()\n* concurrently is not allowed.\n* The message cannot change during the rcl_send_request() call.\n* Before calling rcl_send_request() the message can change but after calling\n* rcl_send_request() it depends on RMW implementation behavior.\n* The same `ros_request`, however, can be passed to multiple calls of\n* rcl_send_request() simultaneously, even if the clients differ.\n* The `ros_request` is unmodified by rcl_send_request().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes [1]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] for unique pairs of clients and requests, see above for more</i>\n*\n* \\param[in] client handle to the client which will make the response\n* \\param[in] ros_request type-erased pointer to the ROS request message\n* \\param[out] sequence_number the sequence number\n* \\return #RCL_RET_OK if the request was sent successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_CLIENT_INVALID if the client is invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_send_request(
        client: *const rcl_client_t,
        ros_request: *const ::std::os::raw::c_void,
        sequence_number: *mut i64,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take a ROS response using a client\n**\n* It is the job of the caller to ensure that the type of the `ros_response`\n* parameter and the type associate with the client (via the type support)\n* match.\n* Passing a different type to take_response produces undefined behavior and\n* cannot be checked by this function and therefore no deliberate error will\n* occur.\n* The request_header is an rmw struct for meta-information about the request\n* sent (e.g. the sequence number).\n* The caller must provide a pointer to an allocated struct.\n* This function will populate the struct's fields.\n* `ros_response` should point to an already allocated ROS response message\n* struct of the correct type, into which the response from the service will be\n* copied.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe [1]\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] only if required when filling the message, avoided for fixed sizes</i>\n*\n* \\param[in] client handle to the client which will take the response\n* \\param[inout] request_header pointer to the request header\n* \\param[inout] ros_response type-erased pointer to the ROS response message\n* \\return #RCL_RET_OK if the response was taken successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_CLIENT_INVALID if the client is invalid, or\n* \\return #RCL_RET_CLIENT_TAKE_FAILED if take failed but no error occurred\n*         in the middleware, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_take_response_with_info(
        client: *const rcl_client_t,
        request_header: *mut rmw_service_info_t,
        ros_response: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " backwards compatibility function that takes a rmw_request_id_t only"]
    pub fn rcl_take_response(
        client: *const rcl_client_t,
        request_header: *mut rmw_request_id_t,
        ros_response: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the name of the service that this client will request a response from.\n**\n* This function returns the client's internal service name string.\n* This function can fail, and therefore return `NULL`, if the:\n*   - client is `NULL`\n*   - client is invalid (never called init, called fini, or invalid node)\n*\n* The returned string is only valid as long as the rcl_client_t is valid.\n* The value of the string may change if the service name changes, and therefore\n* copying the string is recommended if this is a concern.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] client pointer to the client\n* \\return name string if successful, otherwise `NULL`\n*/"]
    pub fn rcl_client_get_service_name(
        client: *const rcl_client_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the rcl client options.\n**\n* This function returns the client's internal options struct.\n* This function can fail, and therefore return `NULL`, if the:\n*   - client is `NULL`\n*   - client is invalid (never called init, called fini, or invalid node)\n*\n* The returned struct is only valid as long as the rcl_client_t is valid.\n* The values in the struct may change if the options of the client change,\n* and therefore copying the struct is recommended if this is a concern.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] client pointer to the client\n* \\return options struct if successful, otherwise `NULL`\n*/"]
    pub fn rcl_client_get_options(client: *const rcl_client_t) -> *const rcl_client_options_t;
}
extern "C" {
    #[doc = " Return the rmw client handle.\n**\n* The handle returned is a pointer to the internally held rmw handle.\n* This function can fail, and therefore return `NULL`, if the:\n*   - client is `NULL`\n*   - client is invalid (never called init, called fini, or invalid node)\n*\n* The returned handle is made invalid if the client is finalized or if\n* rcl_shutdown() is called.\n* The returned handle is not guaranteed to be valid for the life time of the\n* client as it may be finalized and recreated itself.\n* Therefore it is recommended to get the handle from the client using\n* this function each time it is needed and avoid use of the handle\n* concurrently with functions that might change it.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] client pointer to the rcl client\n* \\return rmw client handle if successful, otherwise `NULL`\n*/"]
    pub fn rcl_client_get_rmw_handle(client: *const rcl_client_t) -> *mut rmw_client_t;
}
extern "C" {
    #[doc = " Check that the client is valid.\n**\n* The bool returned is `false` if client is invalid.\n* The bool returned is `true` otherwise.\n* In the case where `false` is to be returned, an error message is set.\n* This function cannot fail.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] client pointer to the rcl client\n* \\return `true` if `client` is valid, otherwise `false`\n*/"]
    pub fn rcl_client_is_valid(client: *const rcl_client_t) -> bool;
}
extern "C" {
    #[doc = " Get the actual qos settings of the client's request publisher.\n**\n* Used to get the actual qos settings of the client's request publisher.\n* The actual configuration applied when using RMW_*_SYSTEM_DEFAULT\n* can only be resolved after the creation of the client, and it\n* depends on the underlying rmw implementation.\n* If the underlying setting in use can't be represented in ROS terms,\n* it will be set to RMW_*_UNKNOWN.\n* The returned struct is only valid as long as the rcl_client_t is valid.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] client pointer to the rcl client\n* \\return qos struct if successful, otherwise `NULL`\n*/"]
    pub fn rcl_client_request_publisher_get_actual_qos(
        client: *const rcl_client_t,
    ) -> *const rmw_qos_profile_t;
}
extern "C" {
    #[doc = " Get the actual qos settings of the client's response subscription.\n**\n* Used to get the actual qos settings of the client's response subscription.\n* The actual configuration applied when using RMW_*_SYSTEM_DEFAULT\n* can only be resolved after the creation of the client, and it\n* depends on the underlying rmw implementation.\n* If the underlying setting in use can't be represented in ROS terms,\n* it will be set to RMW_*_UNKNOWN.\n* The returned struct is only valid as long as the rcl_client_t is valid.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] client pointer to the rcl client\n* \\return qos struct if successful, otherwise `NULL`\n*/"]
    pub fn rcl_client_response_subscription_get_actual_qos(
        client: *const rcl_client_t,
    ) -> *const rmw_qos_profile_t;
}
extern "C" {
    #[doc = " Set the on new response callback function for the client.\n**\n* This API sets the callback function to be called whenever the\n* client is notified about a new response.\n*\n* \\sa rmw_client_set_on_new_response_callback for details about this function.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined</i>\n*\n* \\param[in] client The client on which to set the callback\n* \\param[in] callback The callback to be called when new responses arrive, may be NULL\n* \\param[in] user_data Given to the callback when called later, may be NULL\n* \\return `RCL_RET_OK` if callback was set to the listener, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if `client` is NULL, or\n* \\return `RCL_RET_UNSUPPORTED` if the API is not implemented in the dds implementation\n*/"]
    pub fn rcl_client_set_on_new_response_callback(
        client: *const rcl_client_t,
        callback: rcl_event_callback_t,
        user_data: *const ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Configures service introspection features for the client.\n**\n* Enables or disables service introspection features for this client.\n* If the introspection state is RCL_SERVICE_INTROSPECTION_OFF, then introspection will\n* be disabled.  If the state is RCL_SERVICE_INTROSPECTION_METADATA, the client metadata\n* will be published.  If the state is RCL_SERVICE_INTROSPECTION_CONTENTS, then the client\n* metadata and service request and response contents will be published.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined</i>\n*\n* \\param[in] client client on which to configure service introspection\n* \\param[in] node valid rcl_node_t to use to create the introspection publisher\n* \\param[in] clock valid rcl_clock_t to use to generate the introspection timestamps\n* \\param[in] type_support type support library associated with this client\n* \\param[in] publisher_options options to use when creating the introspection publisher\n* \\param[in] introspection_state rcl_service_introspection_state_t describing whether\n*            introspection should be OFF, METADATA, or CONTENTS\n* \\return #RCL_RET_OK if the call was successful, or\n* \\return #RCL_RET_ERROR if the event publisher is invalid, or\n* \\return #RCL_RET_NODE_INVALID if the given node is invalid, or\n* \\return #RCL_RET_INVALID_ARGUMENT if the client or node structure is invalid,\n* \\return #RCL_RET_BAD_ALLOC if a memory allocation failed\n*/"]
    pub fn rcl_client_configure_service_introspection(
        client: *mut rcl_client_t,
        node: *mut rcl_node_t,
        clock: *mut rcl_clock_t,
        type_support: *const rosidl_service_type_support_t,
        publisher_options: rcl_publisher_options_t,
        introspection_state: rcl_service_introspection_state_t,
    ) -> rcl_ret_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_service_impl_s {
    _unused: [u8; 0],
}
#[doc = " Internal rcl implementation struct."]
pub type rcl_service_impl_t = rcl_service_impl_s;
#[doc = " Structure which encapsulates a ROS Service."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_service_s {
    #[doc = " Pointer to the service implementation"]
    pub impl_: *mut rcl_service_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_service_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_service_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_service_s>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_service_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_service_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_service_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_service_s),
            "::",
            stringify!(impl_)
        )
    );
}
#[doc = " Options available for a rcl service."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_service_options_s {
    #[doc = " Middleware quality of service settings for the service."]
    pub qos: rmw_qos_profile_t,
    #[doc = " Custom allocator for the service, used for incidental allocations.\n** For default behavior (malloc/free), see: rcl_get_default_allocator() */"]
    pub allocator: rcl_allocator_t,
}
#[test]
fn bindgen_test_layout_rcl_service_options_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_service_options_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_service_options_s>(),
        128usize,
        concat!("Size of: ", stringify!(rcl_service_options_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_service_options_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_service_options_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_service_options_s),
            "::",
            stringify!(qos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_service_options_s),
            "::",
            stringify!(allocator)
        )
    );
}
#[doc = " Options available for a rcl service."]
pub type rcl_service_options_t = rcl_service_options_s;
extern "C" {
    #[doc = " Return a rcl_service_t struct with members set to `NULL`.\n**\n* Should be called to get a null rcl_service_t before passing to\n* rcl_service_init().\n*\n* \\return A structure with a zero initialized service.\n*/"]
    pub fn rcl_get_zero_initialized_service() -> rcl_service_t;
}
extern "C" {
    #[doc = " Initialize a rcl service.\n**\n* After calling this function on a rcl_service_t, it can be used to take\n* requests of the given type to the given topic using rcl_take_request().\n* It can also send a response to a request using rcl_send_response().\n*\n* The given rcl_node_t must be valid and the resulting rcl_service_t is\n* only valid as long as the given rcl_node_t remains valid.\n*\n* The rosidl_service_type_support_t is obtained on a per .srv type basis.\n* When the user defines a ROS service, code is generated which provides the\n* required rosidl_service_type_support_t object.\n* This object can be obtained using a language appropriate mechanism.\n* \\todo TODO(wjwwood) write these instructions once and link to it instead\n*\n* For C, a macro can be used (for example `example_interfaces/AddTwoInts`):\n*\n* ```c\n* #include <rosidl_runtime_c/service_type_support_struct.h>\n* #include <example_interfaces/srv/add_two_ints.h>\n* const rosidl_service_type_support_t * ts =\n*   ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);\n* ```\n*\n* For C++, a template function is used:\n*\n* ```cpp\n* #include <rosidl_runtime_cpp/service_type_support.hpp>\n* #include <example_interfaces/srv/add_two_ints.h>\n* using rosidl_typesupport_cpp::get_service_type_support_handle;\n* const rosidl_service_type_support_t * ts =\n*   get_service_type_support_handle<example_interfaces::srv::AddTwoInts>();\n* ```\n*\n* The rosidl_service_type_support_t object contains service type specific\n* information used to send or take requests and responses.\n*\n* The topic name must be a c string which follows the topic and service name\n* format rules for unexpanded names, also known as non-fully qualified names:\n*\n* \\see rcl_expand_topic_name\n*\n* The options struct allows the user to set the quality of service settings as\n* well as a custom allocator which is used when initializing/finalizing the\n* service to allocate space for incidentals, e.g. the service name string.\n*\n* Expected usage (for C services):\n*\n* ```c\n* #include <rcl/rcl.h>\n* #include <rosidl_runtime_c/service_type_support_struct.h>\n* #include <example_interfaces/srv/add_two_ints.h>\n*\n* rcl_node_t node = rcl_get_zero_initialized_node();\n* rcl_node_options_t node_ops = rcl_node_get_default_options();\n* rcl_ret_t ret = rcl_node_init(&node, \"node_name\", \"/my_namespace\", &node_ops);\n* // ... error handling\n* const rosidl_service_type_support_t * ts =\n*   ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);\n* rcl_service_t service = rcl_get_zero_initialized_service();\n* rcl_service_options_t service_ops = rcl_service_get_default_options();\n* ret = rcl_service_init(&service, &node, ts, \"add_two_ints\", &service_ops);\n* // ... error handling, and on shutdown do finalization:\n* ret = rcl_service_fini(&service, &node);\n* // ... error handling for rcl_service_fini()\n* ret = rcl_node_fini(&node);\n* // ... error handling for rcl_node_fini()\n* ```\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[out] service preallocated service structure\n* \\param[in] node valid rcl node handle\n* \\param[in] type_support type support object for the service's type\n* \\param[in] service_name the name of the service\n* \\param[in] options service options, including quality of service settings\n* \\return #RCL_RET_OK if service was initialized successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ALREADY_INIT if the service is already initialized, or\n* \\return #RCL_RET_NODE_INVALID if the node is invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_SERVICE_NAME_INVALID if the given service name is invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_service_init(
        service: *mut rcl_service_t,
        node: *const rcl_node_t,
        type_support: *const rosidl_service_type_support_t,
        service_name: *const ::std::os::raw::c_char,
        options: *const rcl_service_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a rcl_service_t.\n**\n* After calling, the node will no longer listen for requests for this service.\n* (assuming this is the only service of this type in this node).\n*\n* After calling, calls to rcl_wait(), rcl_take_request(), and\n* rcl_send_response() will fail when using this service.\n* Additionally rcl_wait() will be interrupted if currently blocking.\n* However, the given node handle is still valid.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] service handle to the service to be deinitialized\n* \\param[in] node a valid (not finalized) handle to the node used to create the service\n* \\return #RCL_RET_OK if service was deinitialized successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_SERVICE_INVALID if the service is invalid, or\n* \\return #RCL_RET_NODE_INVALID if the node is invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_service_fini(service: *mut rcl_service_t, node: *mut rcl_node_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the default service options in a rcl_service_options_t.\n**\n* The defaults are:\n*\n* - qos = rmw_qos_profile_services_default\n* - allocator = rcl_get_default_allocator()\n*/"]
    pub fn rcl_service_get_default_options() -> rcl_service_options_t;
}
extern "C" {
    #[doc = " Take a pending ROS request using a rcl service.\n**\n* It is the job of the caller to ensure that the type of the ros_request\n* argument and the type associate with the service, via the type\n* support, match.\n* Passing a different type to rcl_take produces undefined behavior and cannot\n* be checked by this function and therefore no deliberate error will occur.\n*\n* TODO(jacquelinekay) blocking of take?\n* TODO(jacquelinekay) pre-, during-, and post-conditions for message ownership?\n* TODO(jacquelinekay) is rcl_take_request thread-safe?\n* TODO(jacquelinekay) Should there be an rcl_request_id_t?\n*\n* The ros_request pointer should point to an already allocated ROS request message\n* struct of the correct type, into which the taken ROS request will be copied\n* if one is available.\n* If taken is false after calling, then the ROS request will be unmodified.\n*\n* If allocation is required when taking the request, e.g. if space needs to\n* be allocated for a dynamically sized array in the target message, then the\n* allocator given in the service options is used.\n*\n* request_header is a pointer to pre-allocated a rmw struct containing\n* meta-information about the request (e.g. the sequence number).\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe [1]\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] only if required when filling the request, avoided for fixed sizes</i>\n*\n* \\param[in] service the handle to the service from which to take\n* \\param[inout] request_header ptr to the struct holding metadata about the request\n* \\param[inout] ros_request type-erased ptr to an allocated ROS request message\n* \\return #RCL_RET_OK if the request was taken, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_SERVICE_INVALID if the service is invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_SERVICE_TAKE_FAILED if take failed but no error occurred\n*         in the middleware, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_take_request_with_info(
        service: *const rcl_service_t,
        request_header: *mut rmw_service_info_t,
        ros_request: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Backwards compatibility function to take a pending ROS request using a rcl service.\n**\n* This version takes a request ID only.  See rcl_take_request_with_info() for a full\n* explanation of what this does.\n*\n* \\param[in] service the handle to the service from which to take\n* \\param[inout] request_header ptr to the struct holding the id of the request\n* \\param[inout] ros_request type-erased ptr to an allocated ROS request message\n* \\return #RCL_RET_OK if the request was taken, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_SERVICE_INVALID if the service is invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_SERVICE_TAKE_FAILED if take failed but no error occurred\n*         in the middleware, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_take_request(
        service: *const rcl_service_t,
        request_header: *mut rmw_request_id_t,
        ros_request: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Send a ROS response to a client using a service.\n**\n* It is the job of the caller to ensure that the type of the `ros_response`\n* parameter and the type associate with the service (via the type support)\n* match.\n* Passing a different type to send_response produces undefined behavior and\n* cannot be checked by this function and therefore no deliberate error will\n* occur.\n*\n* send_response() is an non-blocking call.\n*\n* The ROS response message given by the `ros_response` void pointer is always\n* owned by the calling code, but should remain constant during\n* rcl_send_response().\n*\n* This function is thread safe so long as access to both the service and the\n* `ros_response` is synchronized.\n* That means that calling rcl_send_response() from multiple threads is\n* allowed, but calling rcl_send_response() at the same time as non-thread safe\n* service functions is not, e.g. calling rcl_send_response() and\n* rcl_service_fini() concurrently is not allowed.\n* The message cannot change during the rcl_send_response() call.\n* Before calling rcl_send_response() the message can change but after calling\n* rcl_send_response() it depends on RMW implementation behavior.\n* The same `ros_response`, however, can be passed to multiple calls of\n* rcl_send_response() simultaneously, even if the services differ.\n* The `ros_response` is unmodified by rcl_send_response().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes [1]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] for unique pairs of services and responses, see above for more</i>\n*\n* \\param[in] service handle to the service which will make the response\n* \\param[inout] response_header ptr to the struct holding metadata about the request ID\n* \\param[in] ros_response type-erased pointer to the ROS response message\n* \\return #RCL_RET_OK if the response was sent successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_SERVICE_INVALID if the service is invalid, or\n* \\return #RCL_RET_TIMEOUT if a response reader is not ready yet, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_send_response(
        service: *const rcl_service_t,
        response_header: *mut rmw_request_id_t,
        ros_response: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the topic name for the service.\n**\n* This function returns the service's internal topic name string.\n* This function can fail, and therefore return `NULL`, if the:\n*   - service is `NULL`\n*   - service is invalid (never called init, called fini, or invalid)\n*\n* The returned string is only valid as long as the service is valid.\n* The value of the string may change if the topic name changes, and therefore\n* copying the string is recommended if this is a concern.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] service the pointer to the service\n* \\return name string if successful, otherwise `NULL`\n*/"]
    pub fn rcl_service_get_service_name(
        service: *const rcl_service_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the rcl service options.\n**\n* This function returns the service's internal options struct.\n* This function can fail, and therefore return `NULL`, if the:\n*   - service is `NULL`\n*   - service is invalid (never called init, called fini, or invalid)\n*\n* The returned struct is only valid as long as the service is valid.\n* The values in the struct may change if the service's options change,\n* and therefore copying the struct is recommended if this is a concern.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] service pointer to the service\n* \\return options struct if successful, otherwise `NULL`\n*/"]
    pub fn rcl_service_get_options(service: *const rcl_service_t) -> *const rcl_service_options_t;
}
extern "C" {
    #[doc = " Return the rmw service handle.\n**\n* The handle returned is a pointer to the internally held rmw handle.\n* This function can fail, and therefore return `NULL`, if the:\n*   - service is `NULL`\n*   - service is invalid (never called init, called fini, or invalid)\n*\n* The returned handle is made invalid if the service is finalized or if\n* rcl_shutdown() is called.\n* The returned handle is not guaranteed to be valid for the life time of the\n* service as it may be finalized and recreated itself.\n* Therefore it is recommended to get the handle from the service using\n* this function each time it is needed and avoid use of the handle\n* concurrently with functions that might change it.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] service pointer to the rcl service\n* \\return rmw service handle if successful, otherwise `NULL`\n*/"]
    pub fn rcl_service_get_rmw_handle(service: *const rcl_service_t) -> *mut rmw_service_t;
}
extern "C" {
    #[doc = " Check that the service is valid.\n**\n* The bool returned is `false` if `service` is invalid.\n* The bool returned is `true` otherwise.\n* In the case where `false` is to be returned, an error message is set.\n* This function cannot fail.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] service pointer to the rcl service\n* \\return `true` if `service` is valid, otherwise `false`\n*/"]
    pub fn rcl_service_is_valid(service: *const rcl_service_t) -> bool;
}
extern "C" {
    #[doc = " Get the actual qos settings of the service's request subscription.\n**\n* Used to get the actual qos settings of the service's request subscription.\n* The actual configuration applied when using RMW_*_SYSTEM_DEFAULT\n* can only be resolved after the creation of the service, and it\n* depends on the underlying rmw implementation.\n* If the underlying setting in use can't be represented in ROS terms,\n* it will be set to RMW_*_UNKNOWN.\n* The returned struct is only valid as long as the rcl_service_t is valid.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] service pointer to the rcl service\n* \\return qos struct if successful, otherwise `NULL`\n*/"]
    pub fn rcl_service_request_subscription_get_actual_qos(
        service: *const rcl_service_t,
    ) -> *const rmw_qos_profile_t;
}
extern "C" {
    #[doc = " Get the actual qos settings of the service's response publisher.\n**\n* Used to get the actual qos settings of the service's response publisher.\n* The actual configuration applied when using RMW_*_SYSTEM_DEFAULT\n* can only be resolved after the creation of the service, and it\n* depends on the underlying rmw implementation.\n* If the underlying setting in use can't be represented in ROS terms,\n* it will be set to RMW_*_UNKNOWN.\n* The returned struct is only valid as long as the rcl_service_t is valid.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] service pointer to the rcl service\n* \\return qos struct if successful, otherwise `NULL`\n*/"]
    pub fn rcl_service_response_publisher_get_actual_qos(
        service: *const rcl_service_t,
    ) -> *const rmw_qos_profile_t;
}
extern "C" {
    #[doc = " Set the on new request callback function for the service.\n**\n* This API sets the callback function to be called whenever the\n* service is notified about a new request.\n*\n* \\sa rmw_service_set_on_new_request_callback for details about this function.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined</i>\n*\n* \\param[in] service The service on which to set the callback\n* \\param[in] callback The callback to be called when new requests arrive, may be NULL\n* \\param[in] user_data Given to the callback when called later, may be NULL\n* \\return `RCL_RET_OK` if callback was set to the listener, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if `service` is NULL, or\n* \\return `RCL_RET_UNSUPPORTED` if the API is not implemented in the dds implementation\n*/"]
    pub fn rcl_service_set_on_new_request_callback(
        service: *const rcl_service_t,
        callback: rcl_event_callback_t,
        user_data: *const ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Configure service introspection features for the service.\n**\n* Enables or disables service introspection features for this service.\n* If the introspection state is RCL_SERVICE_INTROSPECTION_OFF, then introspection will\n* be disabled.  If the state is RCL_SERVICE_INTROSPECTION_METADATA, the client metadata\n* will be published.  If the state is RCL_SERVICE_INTROSPECTION_CONTENTS, then the client\n* metadata and service request and response contents will be published.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined</i>\n*\n* \\param[in] service service on which to configure service introspection\n* \\param[in] node valid rcl_node_t to use to create the introspection publisher\n* \\param[in] clock valid rcl_clock_t to use to generate the introspection timestamps\n* \\param[in] type_support type support library associated with this service\n* \\param[in] publisher_options options to use when creating the introspection publisher\n* \\param[in] introspection_state rcl_service_introspection_state_t describing whether\n*            introspection should be OFF, METADATA, or CONTENTS\n* \\return #RCL_RET_OK if the call was successful, or\n* \\return #RCL_RET_ERROR if the event publisher is invalid, or\n* \\return #RCL_RET_NODE_INVALID if the given node is invalid, or\n* \\return #RCL_RET_INVALID_ARGUMENT if the client or node structure is invalid,\n* \\return #RCL_RET_BAD_ALLOC if a memory allocation failed\n*/"]
    pub fn rcl_service_configure_service_introspection(
        service: *mut rcl_service_t,
        node: *mut rcl_node_t,
        clock: *mut rcl_clock_t,
        type_support: *const rosidl_service_type_support_t,
        publisher_options: rcl_publisher_options_t,
        introspection_state: rcl_service_introspection_state_t,
    ) -> rcl_ret_t;
}
pub type rosidl_runtime_c__bound_handle_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_runtime_c__Sequence__bound,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const rosidl_runtime_c__Sequence__bound,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__Sequence__bound {
    #[doc = " String identifier for the type_support."]
    pub typesupport_identifier: *const ::std::os::raw::c_char,
    #[doc = " Pointer to type support handle function"]
    pub data: *const ::std::os::raw::c_void,
    pub func: rosidl_runtime_c__bound_handle_function,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__Sequence__bound() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__Sequence__bound> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__Sequence__bound>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__Sequence__bound))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__Sequence__bound>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__Sequence__bound)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).typesupport_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__Sequence__bound),
            "::",
            stringify!(typesupport_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__Sequence__bound),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__Sequence__bound),
            "::",
            stringify!(func)
        )
    );
}
extern "C" {
    #[doc = " Get the message bounds handle specific to this identifier.\n**\n* The handle's sequence bound is simply returned or if the parameters are NULL then an assert\n* will happen.\n*\n* \\param handle Handle to service type support\n* \\param identifier The identifier to get the handle for\n* \\return The associated sequence bound handle function.\n*/"]
    pub fn get_sequence_bound_handle(
        handle: *const rosidl_runtime_c__Sequence__bound,
        identifier: *const ::std::os::raw::c_char,
    ) -> *const rosidl_runtime_c__Sequence__bound;
}
extern "C" {
    #[doc = " Get the message bounds handle function specific to this identifier.\n**\n* If the identifier is the same as this handle function's identifier the handle is simply returned\n* or if the parameters are NULL then an assert will happen.\n*\n* \\param handle Handle to service type support\n* \\param identifier The identifier to get the handle function for\n* \\return if the identifier match's the handle's identifier then the handle's function\n*   is returned.\n*/"]
    pub fn get_sequence_bound_handle_function(
        handle: *const rosidl_runtime_c__Sequence__bound,
        identifier: *const ::std::os::raw::c_char,
    ) -> *const rosidl_runtime_c__Sequence__bound;
}
pub const rmw_event_type_e_RMW_EVENT_LIVELINESS_CHANGED: rmw_event_type_e = 0;
pub const rmw_event_type_e_RMW_EVENT_REQUESTED_DEADLINE_MISSED: rmw_event_type_e = 1;
pub const rmw_event_type_e_RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE: rmw_event_type_e = 2;
pub const rmw_event_type_e_RMW_EVENT_MESSAGE_LOST: rmw_event_type_e = 3;
pub const rmw_event_type_e_RMW_EVENT_SUBSCRIPTION_INCOMPATIBLE_TYPE: rmw_event_type_e = 4;
pub const rmw_event_type_e_RMW_EVENT_SUBSCRIPTION_MATCHED: rmw_event_type_e = 5;
pub const rmw_event_type_e_RMW_EVENT_LIVELINESS_LOST: rmw_event_type_e = 6;
pub const rmw_event_type_e_RMW_EVENT_OFFERED_DEADLINE_MISSED: rmw_event_type_e = 7;
pub const rmw_event_type_e_RMW_EVENT_OFFERED_QOS_INCOMPATIBLE: rmw_event_type_e = 8;
pub const rmw_event_type_e_RMW_EVENT_PUBLISHER_INCOMPATIBLE_TYPE: rmw_event_type_e = 9;
pub const rmw_event_type_e_RMW_EVENT_PUBLICATION_MATCHED: rmw_event_type_e = 10;
pub const rmw_event_type_e_RMW_EVENT_INVALID: rmw_event_type_e = 11;
#[doc = " Define publisher/subscription events"]
pub type rmw_event_type_e = ::std::os::raw::c_uint;
#[doc = " Define publisher/subscription events"]
pub use self::rmw_event_type_e as rmw_event_type_t;
#[doc = " Encapsulate the RMW event implementation, data, and type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_event_s {
    #[doc = " Implementation identifier, used to ensure two different implementations are not being mixed."]
    pub implementation_identifier: *const ::std::os::raw::c_char,
    #[doc = " Data specific to this event type from either the publisher or subscriber."]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " The event type that occurred."]
    pub event_type: rmw_event_type_t,
}
#[test]
fn bindgen_test_layout_rmw_event_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_event_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_event_s>(),
        24usize,
        concat!("Size of: ", stringify!(rmw_event_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_event_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_event_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).implementation_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_event_s),
            "::",
            stringify!(implementation_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_event_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_event_s),
            "::",
            stringify!(event_type)
        )
    );
}
#[doc = " Encapsulate the RMW event implementation, data, and type."]
pub type rmw_event_t = rmw_event_s;
extern "C" {
    #[doc = " Return a zero initialized event structure."]
    pub fn rmw_get_zero_initialized_event() -> rmw_event_t;
}
extern "C" {
    #[doc = " Initialize a rmw publisher event.\n**\n* \\param[inout] rmw_event to initialize\n* \\param[in] publisher to initialize with\n* \\param[inout] event_type for the event to initialize\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if invalid argument, or\n* \\return `RMW_RET_UNSUPPORTED` if event_type is not supported, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_publisher_event_init(
        rmw_event: *mut rmw_event_t,
        publisher: *const rmw_publisher_t,
        event_type: rmw_event_type_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Initialize a rmw subscription event.\n**\n* \\param[inout] rmw_event to initialize\n* \\param[in] subscription to initialize with\n* \\param[inout] event_type for the event to handle\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if invalid argument, or\n* \\return `RMW_RET_UNSUPPORTED` if event_type is not supported, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_subscription_event_init(
        rmw_event: *mut rmw_event_t,
        subscription: *const rmw_subscription_t,
        event_type: rmw_event_type_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Take an event from the event handle.\n**\n* \\param[in] event_handle event object to take from\n* \\param[inout] event_info event info object to write taken data into\n* \\param[out] taken boolean flag indicating if an event was taken or not\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_BAD_ALLOC` if memory allocation failed, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_take_event(
        event_handle: *const rmw_event_t,
        event_info: *mut ::std::os::raw::c_void,
        taken: *mut bool,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Finalize an rmw_event_t.\n**\n* \\param[in] event to finalize\n*/"]
    pub fn rmw_event_fini(event: *mut rmw_event_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Return a rmw_publisher_options_t initialized with default values."]
    pub fn rmw_get_default_publisher_options() -> rmw_publisher_options_t;
}
extern "C" {
    pub static rmw_qos_profile_sensor_data: rmw_qos_profile_t;
}
extern "C" {
    pub static rmw_qos_profile_parameters: rmw_qos_profile_t;
}
extern "C" {
    pub static rmw_qos_profile_default: rmw_qos_profile_t;
}
extern "C" {
    pub static rmw_qos_profile_services_default: rmw_qos_profile_t;
}
extern "C" {
    pub static rmw_qos_profile_parameter_events: rmw_qos_profile_t;
}
extern "C" {
    pub static rmw_qos_profile_system_default: rmw_qos_profile_t;
}
extern "C" {
    #[doc = " Match majority of endpoints currently available while maintaining the highest level of service\n**\n* Reliability, durability, deadline, liveliness, and liveliness lease duration policies will be\n* chosen at the time of creating a subscription or publisher.\n*\n* The actual QoS policy can be retrieved after the endpoint is created with\n* `rmw_get_subscriptions_info_by_topic` or `rmw_get_publishers_info_by_topic`.\n*\n* The middleware is not expected to update policies after creating a subscription or\n* publisher, even if one or more policies are incompatible with newly discovered endpoints.\n* Therefore, this profile should be used with care since non-deterministic behavior\n* can occur due to races with discovery.\n*/"]
    pub static rmw_qos_profile_best_available: rmw_qos_profile_t;
}
extern "C" {
    pub static rmw_qos_profile_unknown: rmw_qos_profile_t;
}
#[doc = " QoS policies are compatible"]
pub const rmw_qos_compatibility_type_e_RMW_QOS_COMPATIBILITY_OK: rmw_qos_compatibility_type_e = 0;
#[doc = " QoS policies may not be compatible"]
pub const rmw_qos_compatibility_type_e_RMW_QOS_COMPATIBILITY_WARNING: rmw_qos_compatibility_type_e =
    1;
#[doc = " QoS policies are not compatible"]
pub const rmw_qos_compatibility_type_e_RMW_QOS_COMPATIBILITY_ERROR: rmw_qos_compatibility_type_e =
    2;
pub type rmw_qos_compatibility_type_e = ::std::os::raw::c_uint;
pub use self::rmw_qos_compatibility_type_e as rmw_qos_compatibility_type_t;
extern "C" {
    #[doc = " Check if two QoS profiles are compatible.\n**\n* Two QoS profiles are compatible if a publisher and subcription\n* using the QoS policies can communicate with each other.\n*\n* If any of the profile policies has the value \"system default\" or \"unknown\", then it may not be\n* possible to determine the compatibilty.\n* In this case, the output parameter `compatibility` is set to `RMW_QOS_COMPATIBILITY_WARNING`\n* and `reason` is populated.\n*\n* If there is a compatibility warning or error, and a buffer is provided for `reason`, then an\n* explanation of all warnings and errors will be populated into the buffer, separated by\n* semi-colons (`;`).\n* Errors will appear before warnings in the string buffer.\n* If the provided buffer is not large enough, this function will still write to the buffer, up to\n* the `reason_size` number of characters.\n* Therefore, it is possible that not all errors and warnings are communicated if the buffer size limit\n* is reached.\n* A buffer size of 2048 should be more than enough to capture all possible errors and warnings.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] publisher_profile: The QoS profile used for a publisher.\n* \\param[in] subscription_profile: The QoS profile used for a subscription.\n* \\param[out] compatibility: `RMW_QOS_COMPATIBILITY_OK` if the QoS profiles are compatible, or\n*   `RMW_QOS_COMPATIBILITY_WARNING` if the QoS profiles might be compatible, or\n*   `RMW_QOS_COMPATIBILITY_ERROR` if the QoS profiles are not compatible.\n* \\param[out] reason: A detailed reason for a QoS incompatibility or potential incompatibility.\n*   Must be pre-allocated by the caller.\n*   This parameter is optional and may be set to `NULL` if the reason information is not\n*   desired.\n* \\param[in] reason_size: Size of the string buffer `reason`, if one is provided.\n*   If `reason` is `nullptr`, then this parameter must be zero.\n* \\return `RMW_RET_OK` if the check was successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `compatiblity` is `nullptr`, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `reason` is `NULL` and  `reason_size` is not zero, or\n* \\return `RMW_RET_ERROR` if there is an unexpected error.\n*/"]
    pub fn rmw_qos_profile_check_compatible(
        publisher_profile: rmw_qos_profile_t,
        subscription_profile: rmw_qos_profile_t,
        compatibility: *mut rmw_qos_compatibility_type_t,
        reason: *mut ::std::os::raw::c_char,
        reason_size: usize,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Return a rmw_subscription_options_t initialized with default values."]
    pub fn rmw_get_default_subscription_options() -> rmw_subscription_options_t;
}
extern "C" {
    #[doc = " Get the name of the rmw implementation being used\n**\n* \\return Name of rmw implementation\n*/"]
    pub fn rmw_get_implementation_identifier() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the unique serialization format for this middleware.\n**\n* Return the format in which binary data is serialized.\n* One middleware can only have one encoding.\n* In contrast to the implementation identifier, the serialization format can be equal between\n* multiple RMW implementations.\n* This means, that the same binary messages can be deserialized by RMW implementations with the\n* same format.\n* \\sa rmw_serialize\n* \\sa rmw_deserialize\n* \\return serialization format\n*/"]
    pub fn rmw_get_serialization_format() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Create a node and return a handle to that node.\n**\n* This function can fail, and therefore return `NULL`, if:\n*   - name is not a valid non-null node name\n*   - namespace_ is not a valid non-null namespace\n*   - context is not valid i.e. it is zero-initialized, or\n*     its implementation identifier does not match that of\n*     this API implementation, or has been invalidated by\n*     `rmw_shutdown()`\n*   - memory allocation fails during node creation\n*   - an unspecified error occurs\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No [1]\n* Lock-Free          | No [1]\n* <i>[1] rmw implementation defined, check the implementation documentation</i>\n*\n* This should be defined by the rmw implementation.\n*\n* \\param[in] context init context that this node should be associated with\n* \\param[in] name the node name\n* \\param[in] namespace_ the node namespace\n* \\return rmw node handle, or `NULL` if there was an error\n*/"]
    pub fn rmw_create_node(
        context: *mut rmw_context_t,
        name: *const ::std::os::raw::c_char,
        namespace_: *const ::std::os::raw::c_char,
    ) -> *mut rmw_node_t;
}
extern "C" {
    #[doc = " Finalize a given node handle, reclaim the resources, and deallocate the node handle.\n**\n* This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`\n* or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given node handle unchanged.\n* Otherwise, it will proceed despite errors, freeing as many resources as it can, including\n* the node handle. Usage of a deallocated node handle is undefined behavior.\n*\n* \\pre All publishers, subscribers, services, and clients created from this node must\n*   have been destroyed prior to this call. Some rmw implementations may verify this,\n*   returning `RMW_RET_ERROR` and setting a human readable error message if any entity\n*   created from this node has not yet been destroyed. However, this is not guaranteed\n*   and so callers should ensure that this is the case before calling this function.\n*\n* \\param[in] node the node handle to be destroyed\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if node is invalid, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation\n*   identifier does not match, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_destroy_node(node: *mut rmw_node_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " \\deprecated `rmw_node_assert_liveliness` implementation was removed.\n   If manual liveliness assertion is needed, use MANUAL_BY_TOPIC."]
    pub fn rmw_node_assert_liveliness(node: *const rmw_node_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Return a guard condition which is triggered when the ROS graph changes.\n**\n* The guard condition will be triggered anytime a change to the ROS graph occurs.\n* A ROS graph change occurs whenever:\n* - A node joins or leaves the ROS graph.\n*   This change will be reflected in rmw_get_node_names() and\n*   rmw_get_node_names_with_enclaves() outcome.\n* - A topic subscription joins or leaves the ROS graph.\n*   This change will be reflected in rmw_get_topic_names_and_types(),\n*   rmw_get_subscriber_names_and_types_by_node(), and\n*   rmw_get_subscriptions_info_by_topic() outcome.\n* - A topic publisher joins or leaves the ROS graph.\n*   This change will be reflected in rmw_get_topic_names_and_types(),\n*   rmw_get_publisher_names_and_types_by_node(), and\n*   rmw_get_publishers_info_by_topic() outcome.\n* - A topic subscription matches a topic publisher with compatible QoS policies.\n*   This change will be reflected in rmw_subscription_count_matched_publishers() outcome.\n* - A topic publisher matches a topic subscription with compatible QoS policies.\n*   This change will be reflected in rmw_publisher_count_matched_subscriptions() outcome.\n* - A service server joins or leaves the ROS graph.\n*   This change will be reflected in rmw_get_service_names_and_types() and\n*   rmw_get_service_names_and_types_by_node() outcome.\n* - A service client joins or leaves the ROS graph.\n*   This change will be reflected in rmw_get_service_names_and_types() and\n*   rmw_get_client_names_and_types_by_node() outcome.\n* - A service client matches a service server with compatible QoS policies.\n*   This change will be reflected in rmw_service_server_is_available() outcome.\n*\n* \\note The state of the ROS graph, and any changes that may take place,\n*   are reported as seen by the associated `node`.\n*\n* The guard condition is owned and internally held by the `node`.\n* It will be invalidated if `node` is finalized using rmw_destroy_node().\n* It is undefined behavior to use an invalidated guard condition.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\pre Given `node` must be a valid node handle, as returned by rmw_create_node().\n*\n* \\param[in] node Node to retrieve the guard condition from.\n* \\return Guard condition if successful, or `NULL` if\n*   `node` is `NULL`, or an unspecified error occurs.\n*/"]
    pub fn rmw_node_get_graph_guard_condition(
        node: *const rmw_node_t,
    ) -> *const rmw_guard_condition_t;
}
extern "C" {
    #[doc = " Initialize a publisher allocation to be used with later publications.\n**\n* This creates an allocation object that can be used in conjunction with\n* the rmw_publish method to perform more carefully control memory allocations.\n*\n* This will allow the middleware to preallocate the correct amount of memory\n* for a given message type and message bounds.\n* As allocation is performed in this method, it will not be necessary to allocate\n* in the `rmw_publish` method.\n*\n* \\param[in] type_support Type support of the message to be preallocated.\n* \\param[in] message_bounds Bounds structure of the message to be preallocated.\n* \\param[out] allocation Allocation structure to be passed to `rmw_publish`.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_UNSUPPORTED` if it's unimplemented\n* \\return `RMW_RET_INVALID_ARGUMENT` if an argument is null, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_init_publisher_allocation(
        type_support: *const rosidl_message_type_support_t,
        message_bounds: *const rosidl_runtime_c__Sequence__bound,
        allocation: *mut rmw_publisher_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Destroy a publisher allocation object.\n**\n* This deallocates any memory allocated by `rmw_init_publisher_allocation`.\n*\n* \\param[in] allocation Allocation object to be destroyed.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_UNSUPPORTED` if it's unimplemented\n* \\return `RMW_RET_INVALID_ARGUMENT` if argument is null, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_fini_publisher_allocation(allocation: *mut rmw_publisher_allocation_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Create a publisher and return a handle to that publisher.\n**\n* This function can fail, and therefore return `NULL`, if:\n*   - node is not a valid non-null handle for this rmw implementation,\n*     as returned by `rmw_create_node()`\n*   - type_support is a not valid non-null message type support, as returned by\n*     `ROSIDL_GET_MSG_TYPE_SUPPORT()`\n*   - topic_name is not a valid non-null topic name, according to\n*     `rmw_validate_full_topic_name()`\n*   - qos_profile is not a fully specified non-null profile i.e. no UNKNOWN policies\n*   - publisher_options is not a valid non-null option set, as returned by\n*     `rmw_get_default_publisher_options()`\n*   - memory allocation fails during publisher creation\n*   - an unspecified error occurs\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined, check the implementation documentation</i>\n*\n* \\param[in] node Handle to node with which to register this publisher\n* \\param[in] type_support Type support for the messages to be published\n* \\param[in] topic_name Name of the topic to publish to, often a fully qualified\n*   topic name unless `qos_profile` is configured to avoid ROS namespace conventions\n*   i.e. to create a native topic publisher\n* \\param[in] qos_profile QoS policies for this publisher\n* \\param[in] publisher_options Options to configure this publisher\n* \\return rmw publisher handle, or `NULL` if there was an error\n*/"]
    pub fn rmw_create_publisher(
        node: *const rmw_node_t,
        type_support: *const rosidl_message_type_support_t,
        topic_name: *const ::std::os::raw::c_char,
        qos_profile: *const rmw_qos_profile_t,
        publisher_options: *const rmw_publisher_options_t,
    ) -> *mut rmw_publisher_t;
}
extern "C" {
    #[doc = " Finalize a given publisher handle, reclaim the resources, and deallocate the publisher handle.\n**\n* This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`\n* or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given publisher handle unchanged.\n* Otherwise, it will proceed despite errors, freeing as many resources as it can, including\n* the publisher handle. Usage of a deallocated publisher handle is undefined behavior.\n*\n* \\pre Given node must be the one the publisher was registered with.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined, check the implementation documentation</i>\n*\n* \\param[in] node Handle to node with which the given publisher is registered\n* \\param[in] publisher Handle to publisher to be finalized\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if node or publisher is `NULL`, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if node or publisher\n*   implementation identifier does not match, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_destroy_publisher(
        node: *mut rmw_node_t,
        publisher: *mut rmw_publisher_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Borrow a loaned ROS message.\n**\n* This ROS message is owned by the middleware, that will keep it alive (i.e. in valid\n* memory space) until the caller publishes it using rmw_publish_loaned_message() or\n* returns it using rmw_return_loaned_message_from_publisher().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n*\n* <i>[1] implementation defined, check implementation documentation.</i>\n*\n* \\par Runtime behavior\n*   To borrow a ROS message is a synchronous operation.\n*   It is also non-blocking, but it is not guaranteed to be lock-free.\n*   Generally speaking, implementations may synchronize access to internal resources using\n*   locks but are not allowed to wait for events with no guaranteed time bound (barring\n*   the effects of starvation due to OS scheduling).\n*\n* \\par Memory allocation\n*   It is implementation defined whether memory will be allocated on borrow or not.\n*   Check the implementation documentation to learn about memory allocation\n*   guarantees when using ROS message loaning support.\n*\n* \\par Thread-safety\n*   Publishers are thread-safe objects, and so are all operations on them except for finalization.\n*   Therefore, it is safe to borrow ROS messages from the same publisher concurrently.\n*\n* \\pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().\n* \\pre Given `type_support` must be a valid `rosidl` message type support, matching the\n*   one registered with the `publisher` on creation.\n*\n* \\param[in] publisher Publisher to which the loaned ROS message will be associated.\n* \\param[in] type_support Message type support of the loaned ROS message.\n* \\param[out] ros_message Pointer to type erased ROS message loaned by the middleware.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `type_support` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `*ros_message` is not NULL (to prevent leaks), or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation identifier\n*   does not match this implementation, or\n* \\return `RMW_RET_UNSUPPORTED` if the implementation does not support ROS message loaning, or\n* \\return `RMW_RET_ERROR` if an unexpected error occured.\n*/"]
    pub fn rmw_borrow_loaned_message(
        publisher: *const rmw_publisher_t,
        type_support: *const rosidl_message_type_support_t,
        ros_message: *mut *mut ::std::os::raw::c_void,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Return a loaned message previously borrowed from a publisher.\n**\n* Tells the middleware that a borrowed ROS message is no longer needed by the caller.\n* Ownership of the ROS message is given back to the middleware.\n* If this function fails early due to a logical error, such as an invalid argument,\n* the loaned ROS message will be left unchanged.\n* Otherwise, ownership of the ROS message will be given back to the middleware.\n* It is up to the middleware what will be made of the returned ROS message.\n* It is undefined behavior to use a loaned ROS message after returning it.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n*\n* <i>[1] implementation defined, check implementation documentation.</i>\n*\n* \\par Runtime behavior\n*   To return a ROS message is a synchronous operation.\n*   It is also non-blocking, but it is not guaranteed to be lock-free.\n*   Generally speaking, implementations may synchronize access to internal resources using\n*   locks but are not allowed to wait for events with no guaranteed time bound (barring\n*   the effects of starvation due to OS scheduling).\n*\n* \\par Thread-safety\n*   Publishers are thread-safe objects, and so are all operations on them except for finalization.\n*   Therefore, it is safe to return borrowed ROS messages to the same publisher concurrently.\n*   However, since ownership of the loaned ROS message is given back to the middleware and\n*   this transfer is not synchronized, it is not safe to return the same loaned ROS message\n*   concurrently.\n*\n* \\pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().\n* \\pre Given `loaned_message` must have been previously borrowed from the same publisher\n*   using rmw_borrow_loaned_message().\n*\n* \\param[in] publisher Publisher to which the loaned ROS message is associated.\n* \\param[in] loaned_message Type erased loaned ROS message to be returned.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `loaned_message` is NULL, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation identifier\n*   does not match this implementation, or\n* \\return `RMW_RET_UNSUPPORTED` if the implementation does not support ROS message loaning, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs and no message can be initialized.\n*/"]
    pub fn rmw_return_loaned_message_from_publisher(
        publisher: *const rmw_publisher_t,
        loaned_message: *mut ::std::os::raw::c_void,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Publish a ROS message.\n**\n* Send a ROS message to all subscriptions with matching QoS policies using the given publisher.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n*\n* <i>[1] implementation defined, check implementation documentation.</i>\n*\n* \\par Runtime behavior\n*   It is implementation defined whether to publish a ROS message is a\n*   synchronous or asynchronous, blocking or non-blocking operation.\n*   However, asynchronous implementations are not allowed to access the\n*   given ROS message after this function returns.\n*   Check the implementation documentation to learn about publish behavior.\n*\n* \\par Memory allocation\n*   It is implementation defined whether memory will be allocated on publish or not.\n*   For instance, implementations that serialize ROS messages to send it over the\n*   wire may need to perform additional memory allocations when dealing with\n*   unbounded (dynamically-sized) fields.\n*   A publisher allocation, if provided, may or may not be used.\n*   Check the implementation documentation to learn about memory allocation\n*   guarantees when publishing ROS messages with and without publisher allocations.\n*\n* \\par Thread-safety\n*   Publishers are thread-safe objects, and so are all operations on them except for finalization.\n*   Therefore, it is safe to publish using the same publisher concurrently.\n*   However, when publishing regular ROS messages:\n*   - Access to the ROS message is read-only but it is not synchronized.\n*     Concurrent `ros_message` reads are safe, but concurrent reads and writes are not.\n*   - Access to the publisher allocation is not synchronized, unless specifically stated\n*     otherwise by the implementation.\n*     Thus, it is generally not safe to read or write `allocation` while rmw_publish() uses it.\n*     Check the implementation documentation to learn about publisher allocations' thread-safety.\n*\n* \\pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().\n* \\pre Given `ros_message` must be a valid message, whose type matches the message type\n*   support the `publisher` was registered with on creation.\n* \\pre If not NULL, given `allocation` must be a valid publisher allocation, initialized\n*   with rmw_publisher_allocation_init() with a message type support that matches the\n*   one registered with `publisher` on creation.\n*\n* \\param[in] publisher Publisher to be used to send message.\n* \\param[in] ros_message Type erased ROS message to be sent.\n* \\param[in] allocation Pre-allocated memory to be used. May be NULL.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation\n*   identifier does not match this implementation, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_publish(
        publisher: *const rmw_publisher_t,
        ros_message: *const ::std::os::raw::c_void,
        allocation: *mut rmw_publisher_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Publish a loaned ROS message.\n**\n* Send a previously borrowed ROS message to all subscriptions with matching QoS policies\n* using the given publisher, then return ROS message ownership to the middleware.\n*\n* If this function fails early due to a logical error, such as an invalid argument,\n* the loaned ROS message will be left unchanged.\n* Otherwise, ownership of the ROS message will be given back to the middleware.\n* It is up to the middleware what will be made of the returned ROS message.\n* It is undefined behavior to use a loaned ROS message after publishing it.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n*\n* <i>[1] implementation defined, check the implementation documentation.</i>\n*\n* \\par Runtime behavior\n*   It is implementation defined whether to publish a loaned ROS message is a\n*   synchronous or asynchronous, blocking or non-blocking operation.\n*   Check the implementation documentation to learn about publish behavior.\n*\n* \\par Memory allocation\n*   It is implementation defined whether memory will be allocated on publish or not.\n*   For instance, implementations that serialize ROS messages to send it over the\n*   wire may need to perform additional memory allocations when dealing with\n*   unbounded (dynamically-sized) fields.\n*   A publisher allocation, if provided, may or may not be used.\n*   Check the implementation documentation to learn about memory allocation\n*   guarantees when publishing loaned ROS messages with and without publisher allocations.\n*\n* \\par Thread-safety\n*   Publishers are thread-safe objects, and so are all operations on them except for finalization.\n*   Therefore, it is safe to publish using the same publisher concurrently.\n*   However, when publishing loaned ROS messages:\n*   - Ownership of the loaned ROS message is given back to the middleware.\n*     This transfer is not synchronized, and thus it is not safe to publish the\n*     same loaned ROS message concurrently.\n*   - Access to the publisher allocation is not synchronized, unless specifically stated\n*     otherwise by the implementation.\n*     Thus, it is generally not safe to read or write `allocation` while rmw_publish() uses it.\n*     Check the implementation documentation to learn about publisher allocations' thread-safety.\n*\n* \\pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().\n* \\pre Given `ros_message` must be a valid message, borrowed from the same publisher using\n*   rmw_borrow_loaned_message().\n* \\pre If not NULL, given `allocation` must be a valid publisher allocation, initialized\n*   with rmw_publisher_allocation_init() with a message type support that matches the\n*   one registered with `publisher` on creation.\n*\n* \\param[in] publisher Publisher to be used to send message.\n* \\param[in] ros_message Loaned type erased ROS message to be sent.\n* \\param[in] allocation Pre-allocated memory to be used. May be NULL.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation\n*   identifier does not match this implementation, or\n* \\return `RMW_RET_UNSUPPORTED` if the implementation does not support ROS message loaning, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_publish_loaned_message(
        publisher: *const rmw_publisher_t,
        ros_message: *mut ::std::os::raw::c_void,
        allocation: *mut rmw_publisher_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Retrieve the number of matched subscriptions to a publisher.\n**\n* Query the underlying middleware to determine how many subscriptions are\n* matched to a given publisher.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined, check the implementation documentation</i>\n*\n* \\param[in] publisher the publisher object to inspect\n* \\param[out] subscription_count the number of subscriptions matched\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if publisher\n*   implementation identifier does not match, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_publisher_count_matched_subscriptions(
        publisher: *const rmw_publisher_t,
        subscription_count: *mut usize,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Retrieve the actual qos settings of the publisher.\n**\n* Query the underlying middleware to determine the qos settings\n* of the publisher.\n* The actual configuration applied when using RMW_*_SYSTEM_DEFAULT\n* can only be resolved after the creation of the publisher, and it\n* depends on the underlying rmw implementation.\n* If the underlying setting in use can't be represented in ROS terms,\n* it will be set to RMW_*_UNKNOWN.\n*\n* \\note The value of avoid_ros_namespace_conventions field is not resolved\n*   with this function. The rcl function `rcl_publisher_get_actual_qos()`\n*   resolves it.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe [1]\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined, check the implementation documentation</i>\n*\n* \\param[in] publisher the publisher object to inspect\n* \\param[out] qos the actual qos settings\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if publisher\n*   implementation identifier does not match, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_publisher_get_actual_qos(
        publisher: *const rmw_publisher_t,
        qos: *mut rmw_qos_profile_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Publish a ROS message as a byte stream.\n**\n* Send a ROS message serialized as a byte stream to all subscriptions with\n* matching QoS policies using the given publisher.\n* A ROS message can be serialized manually using rmw_serialize().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n*\n* <i>[1] implementation defined, check the implementation documentation.</i>\n*\n* \\par Runtime behavior\n*   It is implementation defined whether to publish a loaned ROS message is a\n*   synchronous or asynchronous, blocking or non-blocking operation.\n*   However, asynchronous implementations are not allowed to access the\n*   given byte stream after this function returns.\n*   Check the implementation documentation to learn about publish behavior.\n*\n* \\par Memory allocation\n*   It is implementation defined whether memory will be allocated on publish or not.\n*   Even if a publisher allocation is provided, an implementation may ignore it.\n*   Check the implementation documentation to learn about memory allocation\n*   guarantees when publishing serialized messages with and without publisher allocations.\n*\n* \\par Thread-safety\n*   Publishers are thread-safe objects, and so are all operations on them except for finalization.\n*   Therefore, it is safe to publish using the same publisher concurrently.\n*   However, when publishing serialized ROS messages:\n*   - Access to the byte stream is read-only but it is not synchronized.\n*     Concurrent `serialized_message` reads are safe, but concurrent reads and writes are not.\n*   - Access to the publisher allocation is not synchronized, unless specifically stated\n*     otherwise by the implementation.\n*     Thus, it is generally not safe to read or write `allocation` while rmw_publish() uses it.\n*     Check the implementation documentation to learn about publisher allocations' thread-safety.\n*\n* \\pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().\n* \\pre Given `serialized_message` must be a valid serialized message, initialized by\n*   rmw_serialized_message_init() and containing the serialization of a ROS message whose\n*   type matches the message type support the `publisher` was registered with on creation.\n* \\pre If not NULL, given `allocation` must be a valid publisher allocation, initialized\n*   with rmw_publisher_allocation_init() with a message type support that matches the\n*   one registered with `publisher` on creation.\n*\n* \\param[in] publisher Publisher to be used to send message.\n* \\param[in] serialized_message Serialized ROS message to be sent.\n* \\param[in] allocation Pre-allocated memory to be used. May be NULL.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `serialized_message` is NULL, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation\n*   identifier does not match this implementation, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_publish_serialized_message(
        publisher: *const rmw_publisher_t,
        serialized_message: *const rmw_serialized_message_t,
        allocation: *mut rmw_publisher_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Compute the size of a serialized message.\n**\n* Given a message definition and bounds, compute the serialized size.\n*\n* \\param[in] type_support The type support of the message to compute.\n* \\param[in] message_bounds Artifical bounds to use on unbounded fields.\n* \\param[out] size The computed size of the serialized message.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or\n* \\return `RMW_RET_UNSUPPORTED` if it's unimplemented, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_get_serialized_message_size(
        type_support: *const rosidl_message_type_support_t,
        message_bounds: *const rosidl_runtime_c__Sequence__bound,
        size: *mut usize,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Manually assert that this Publisher is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC)\n**\n* If the rmw Liveliness policy is set to RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC, the creator of\n* this publisher may manually call `assert_liveliness` at some point in time to signal to the rest\n* of the system that this Node is still alive.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] publisher handle to the publisher that needs liveliness to be asserted\n* \\return `RMW_RET_OK` if the liveliness assertion was completed successfully, or\n* \\return `RMW_RET_ERROR` if an unspecified error occurs, or\n* \\return `RMW_RET_UNSUPPORTED` if the rmw implementation does not support asserting liveliness.\n*/"]
    pub fn rmw_publisher_assert_liveliness(publisher: *const rmw_publisher_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Wait until all published message data is acknowledged or until the specified timeout elapses.\n**\n* This function waits until all published message data were acknowledged by peer node or timeout.\n*\n* This function only works effectively while QOS profile of publisher is set to RELIABLE.\n* Otherwise this function will immediately return RMW_RET_OK.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe [1]\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined, check the implementation documentation</i>\n*\n* \\par Runtime behavior\n*   Waiting for all acknowledgments is synchronous operation.\n*   So the calling thread is blocked until all published message data is acknowledged or specified\n*   duration elapses.\n*\n* \\par Thread-Safety\n*   Publishers are thread-safe objects, and so are all operations on them except for finalization.\n*   Therefore, it is safe to call this function using the same publisher concurrently.\n*\n* \\pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().\n*\n* \\param[in] publisher handle to the publisher that needs to wait for all acked.\n* \\param[in] wait_timeout represents the maximum amount of time to wait for all published message\n*   data were acknowledged.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_TIMEOUT` if wait timed out, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `publisher` is `NULL`, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `publisher` implementation\n*   identifier does not match this implementation, or\n* \\return `RMW_RET_ERROR` if an unspecified error occurs, or\n* \\return `RMW_RET_UNSUPPORTED` if the rmw implementation is unimplemented.\n*/"]
    pub fn rmw_publisher_wait_for_all_acked(
        publisher: *const rmw_publisher_t,
        wait_timeout: rmw_time_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Serialize a ROS message into a rmw_serialized_message_t.\n**\n* The ROS message is serialized into a byte stream contained within the\n* rmw_serialized_message_t structure.\n* The serialization format depends on the underlying implementation.\n*\n* \\pre Given ROS message must be a valid non-null instance, initialized\n*   by the caller and matching the provided typesupport.\n* \\pre Given typesupport must be a valid non-null instance, as provided\n*   by `rosidl` APIs.\n* \\pre Given serialized message must be a valid non-null instance, initialized\n*   by the caller.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe [1]\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [2]\n* Lock-Free          | Maybe [2]\n* <i>[1] if the given serialized message does not have enough capacity to hold\n*        the ROS message serialization</i>\n* <i>[2] rmw implementation defined, check the implementation documentation</i>\n*\n* \\param[in] ros_message the typed ROS message\n* \\param[in] type_support the typesupport for the ROS message\n* \\param[out] serialized_message the destination for the serialize ROS message\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_BAD_ALLOC` if memory allocation failed, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_serialize(
        ros_message: *const ::std::os::raw::c_void,
        type_support: *const rosidl_message_type_support_t,
        serialized_message: *mut rmw_serialized_message_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Deserialize a ROS message.\n**\n* The given rmw_serialized_message_t's internal byte stream buffer is deserialized\n* into the given ROS message.\n* The serialization format expected in the rmw_serialized_message_t depends on the\n* underlying implementation.\n*\n* \\pre Given serialized message must be a valid non-null instance, such\n*   as that returned by `rmw_serialize()`, matching provided typesupport\n*   and ROS message.\n* \\pre Given typesupport must be a valid non-null instance, as provided\n*   by `rosidl` APIs.\n* \\pre Given ROS message must be a valid non-null instance, initialized\n*   by the caller.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe [1]\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [2]\n* Lock-Free          | Maybe [2]\n* <i>[1] if the given ROS message contains unbounded fields</i>\n* <i>[2] rmw implementation defined, check the implementation documentation</i>\n*\n* \\param[in] serialized_message the serialized message holding the byte stream\n* \\param[in] type_support the typesupport for the typed ros message\n* \\param[out] ros_message destination for the deserialized ROS message\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_BAD_ALLOC` if memory allocation failed, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_deserialize(
        serialized_message: *const rmw_serialized_message_t,
        type_support: *const rosidl_message_type_support_t,
        ros_message: *mut ::std::os::raw::c_void,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Initialize a subscription allocation to be used with later `take`s.\n**\n* This creates an allocation object that can be used in conjunction with\n* the rmw_take method to perform more carefully control memory allocations.\n*\n* This will allow the middleware to preallocate the correct amount of memory\n* for a given message type and message bounds.\n* As allocation is performed in this method, it will not be necessary to allocate\n* in the `rmw_take` method.\n*\n* \\param[in] type_support Type support of the message to be preallocated.\n* \\param[in] message_bounds Bounds structure of the message to be preallocated.\n* \\param[out] allocation Allocation structure to be passed to `rmw_take`.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_UNSUPPORTED` if it's unimplemented\n* \\return `RMW_RET_INVALID_ARGUMENT` if an argument is null, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_init_subscription_allocation(
        type_support: *const rosidl_message_type_support_t,
        message_bounds: *const rosidl_runtime_c__Sequence__bound,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Destroy a publisher allocation object.\n**\n* This deallocates memory allocated by `rmw_init_subscription_allocation`.\n*\n* \\param[in] allocation Allocation object to be destroyed.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_UNSUPPORTED` if it's unimplemented\n* \\return `RMW_RET_INVALID_ARGUMENT` if argument is null, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_fini_subscription_allocation(
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Create a subscription and return a handle to that subscription.\n**\n* This function can fail, and therefore return `NULL`, if:\n*   - node is not a valid non-null handle for this rmw implementation,\n*     as returned by `rmw_create_node()`\n*   - type_support is a not valid non-null message type support, as returned by\n*     `ROSIDL_GET_MSG_TYPE_SUPPORT()`\n*   - topic_name is not a valid non-null topic name, according to\n*     `rmw_validate_full_topic_name()` if ROS namespace conventions apply\n*   - qos_profile is not a fully specified non-null profile i.e. no UNKNOWN policies\n*   - subscription_options is not a valid non-null option set, such as the one\n*     returned by `rmw_get_default_subscription_options()`\n*   - memory allocation fails during subscription creation\n*   - an unspecified error occurs\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined, check the implementation documentation</i>\n*\n* \\param[in] node Handle to node with which to register this subscription\n* \\param[in] type_support Type support for the messages to be subscribed to\n* \\param[in] topic_name Name of the topic to subscribe to, often a fully qualified\n*   topic name unless `qos_profile` is configured to avoid ROS namespace conventions\n*   i.e. to create a native topic subscription\n* \\param[in] qos_policies QoS policies for this subscription\n* \\param[in] subscription_options Options for configuring this subscription\n* \\return rmw subscription handle, or `NULL` if there was an error\n*/"]
    pub fn rmw_create_subscription(
        node: *const rmw_node_t,
        type_support: *const rosidl_message_type_support_t,
        topic_name: *const ::std::os::raw::c_char,
        qos_policies: *const rmw_qos_profile_t,
        subscription_options: *const rmw_subscription_options_t,
    ) -> *mut rmw_subscription_t;
}
extern "C" {
    #[doc = " Finalize a given subscription handle, reclaim the resources, and deallocate the subscription\n handle.\n**\n* This function will return early if a logical error, namely `RMW_RET_INVALID_ARGUMENT`\n* or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given subscription handle\n* unchanged.\n* Otherwise, it will proceed despite errors, freeing as many resources as it can, including\n* the subscription handle, and return `RMW_RET_ERROR`. Usage of a deallocated subscription\n* handle is undefined behavior.\n*\n* \\pre Given node must be the one the subscription was registered with.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined, check the implementation documentation</i>\n*\n* \\param[in] node Handle to node with which the given subscription is registered\n* \\param[in] subscription Handle to subscription to be finalized\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if node or subscription is `NULL`, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if node or subscription\n*   implementation identifier does not match, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_destroy_subscription(
        node: *mut rmw_node_t,
        subscription: *mut rmw_subscription_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Retrieve the number of matched publishers to a subscription.\n**\n* Query the underlying middleware to determine how many publishers are\n* matched to a given subscription.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined, check the implementation documentation</i>\n*\n* \\param[in] subscription the subscription object to inspect\n* \\param[out] publisher_count the number of publishers matched\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if subscription\n*   implementation identifier does not match, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_subscription_count_matched_publishers(
        subscription: *const rmw_subscription_t,
        publisher_count: *mut usize,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Retrieve the actual qos settings of the subscription.\n**\n* Query the underlying middleware to determine the qos settings\n* of the subscription.\n* The actual configuration applied when using RMW_*_SYSTEM_DEFAULT\n* can only be resolved after the creation of the subscription, and it\n* depends on the underlying rmw implementation.\n* If the underlying setting in use can't be represented in ROS terms,\n* it will be set to RMW_*_UNKNOWN.\n*\n* \\note The value of avoid_ros_namespace_conventions field is not resolved\n*   with this function. The rcl function `rcl_subscription_get_actual_qos()`\n*   resolves it.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe [1]\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined, check the implementation documentation</i>\n*\n* \\param[in] subscription the subscription object to inspect\n* \\param[out] qos the actual qos settings\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if subscription\n*   implementation identifier does not match, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_subscription_get_actual_qos(
        subscription: *const rmw_subscription_t,
        qos: *mut rmw_qos_profile_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Set the content filter options for the subscription.\n**\n* This function will set a filter expression and an array of expression parameters\n* for the given subscription.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation defined, check the implementation documentation</i>\n*\n* \\param[in] subscription The subscription to set content filter options.\n* \\param[in] options The content filter options.\n*   Use `options.filter_expression` with an empty(\"\") string to\n*   reset/clean content filtered topic for the subscription.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if an argument is null, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation\n*   identifier does not match this implementation, or\n* \\return `RMW_RET_UNSUPPORTED` if the implementation does not support content filtered topic, or\n* \\return `RMW_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rmw_subscription_set_content_filter(
        subscription: *mut rmw_subscription_t,
        options: *const rmw_subscription_content_filter_options_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Retrieve the content filter options of the subscription.\n**\n* This function will return a content filter options by the given subscription.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation defined, check the implementation documentation</i>\n*\n* \\param[in] subscription The subscription object to inspect.\n* \\param[in] allocator Allocator to be used when populating the content filter options.\n* \\param[out] options The content filter options.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if an argument is null, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation\n*   identifier does not match this implementation, or\n* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n* \\return `RMW_RET_UNSUPPORTED` if the implementation does not support content filtered topic, or\n* \\return `RMW_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rmw_subscription_get_content_filter(
        subscription: *const rmw_subscription_t,
        allocator: *mut rcutils_allocator_t,
        options: *mut rmw_subscription_content_filter_options_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Take an incoming ROS message.\n**\n* Take a ROS message already received by the given subscription, removing it from internal queues.\n* This function will succeed even if no ROS message was received, but `taken` will be false.\n*\n* \\remarks The same ROS message cannot be taken twice.\n*   Callers do not have to deal with duplicates.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n*\n* <i>[1] implementation defined, check implementation documentation.</i>\n*\n* \\par Runtime behavior\n*   To take a ROS message is a synchronous operation.\n*   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,\n*   but it is not guaranteed to be lock-free.\n*   Generally speaking, implementations may synchronize access to internal resources using\n*   locks but are not allowed to wait for events with no guaranteed time bound (barring\n*   the effects of starvation due to OS scheduling).\n*\n* \\par Memory allocation\n*   It is implementation defined whether memory will be allocated on take or not.\n*   For instance, implementations that deserialize ROS messages received over\n*   the wire may need to perform additional memory allocations when dealing with\n*   unbounded (dynamically-sized) fields.\n*   A subscription allocation, if provided, may or may not be used.\n*   Check the implementation documentation to learn about memory allocation\n*   guarantees when taking ROS messages with and without subscription allocations.\n*\n* \\par Thread-safety\n*   Subscriptions are thread-safe objects, and so are all operations on them except for\n*   finalization.\n*   Therefore, it is safe to take from the same subscription concurrently.\n*   However, when taking regular ROS messages:\n*   - Access to the given ROS message is not synchronized.\n*     It is not safe to read or write `ros_message` while rmw_take() uses it.\n*   - Access to given primitive data-type arguments is not synchronized.\n*     It is not safe to read or write `taken` while rmw_take() uses it.\n*   - Access to the given subscription allocation is not synchronized,\n*     unless specifically stated otherwise by the implementation.\n*     Thus, it is generally not safe to read or write `allocation` while rmw_take() uses it.\n*     Check the implementation documentation to learn about subscription allocations'\n*     thread-safety.\n*\n* \\pre Given `subscription` must be a valid subscription, as returned\n*   by rmw_create_subscription().\n* \\pre Given `ros_message` must be a valid message, whose type matches the message type support\n*   registered with the `subscription` on creation.\n* \\pre If not NULL, given `allocation` must be a valid subscription allocation initialized\n*   with rmw_subscription_allocation_init() with a message type support that matches the\n*   one registered with the `subscription` on creation.\n* \\post Given `ros_message` will remain a valid message.\n*   It will be left unchanged if this function fails early due to a logical error, such as an\n*   invalid argument, or in an unknown yet valid state if it fails due to a runtime error.\n*   It will also be left unchanged if this function succeeds but `taken` is false.\n*\n* \\param[in] subscription Subscription to take message from.\n* \\param[out] ros_message Type erased ROS message to write to.\n* \\param[out] taken Boolean flag indicating if a ROS message was taken or not.\n* \\param[in] allocation Pre-allocated memory to be used. May be NULL.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription`\n*   implementation identifier does not match this implementation, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_take(
        subscription: *const rmw_subscription_t,
        ros_message: *mut ::std::os::raw::c_void,
        taken: *mut bool,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Take an incoming ROS message with its metadata.\n**\n* Same as rmw_take(), except it also takes ROS message metadata.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n*\n* <i>[1] implementation defined, check implementation documentation.</i>\n*\n* \\par Runtime behavior\n*   To take a ROS message with its metadata is a synchronous operation.\n*   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,\n*   but it is not guaranteed to be lock-free.\n*   Generally speaking, implementations may synchronize access to internal resources using\n*   locks but are not allowed to wait for events with no guaranteed time bound (barring\n*   the effects of starvation due to OS scheduling).\n*\n* \\par Memory allocation\n*   It is implementation defined whether memory will be allocated on take or not.\n*   For instance, implementations that deserialize ROS messages received over\n*   the wire may need to perform additional memory allocations when dealing with\n*   unbounded (dynamically-sized) fields.\n*   A subscription allocation, if provided, may or may not be used.\n*   Check the implementation documentation to learn about memory allocation\n*   guarantees when taking ROS messages with and without subscription allocations.\n*\n* \\par Thread-safety\n*   Subscriptions are thread-safe objects, and so are all operations on them except for\n*   finalization.\n*   Therefore, it is safe to take from the same subscription concurrently.\n*   However, when taking regular ROS messages with metadata:\n*   - Access to the given ROS message is not synchronized.\n*     It is not safe to read or write `ros_message` while rmw_take_with_info() uses it.\n*   - Access to given primitive data-type arguments is not synchronized.\n*     It is not safe to read or write `taken` while rmw_take_with_info() uses it.\n*   - Access to the given ROS message metadata is not synchronized.\n*     It is not safe to read or write `message_info` while rmw_take_with_info() uses it.\n*   - Access to the given subscription allocation is not synchronized,\n*     unless specifically stated otherwise by the implementation.\n*     Thus, it is generally not safe to read or write `allocation` while rmw_take_with_info()\n*     uses it.\n*     Check the implementation documentation to learn about subscription allocations'\n*     thread-safety.\n*\n* \\pre Given `subscription` must be a valid subscription, as returned\n*   by rmw_create_subscription().\n* \\pre Given `ros_message` must be a valid message, whose type matches\n*   the message type support registered with the `subscription` on creation.\n* \\pre If not NULL, given `allocation` must be a valid subscription allocation\n*   initialized with rmw_subscription_allocation_init() with a message type support\n*   that matches the one registered with the `subscription` on creation.\n* \\post Given `ros_message` will remain a valid message, and\n*   `message_info`, valid message metadata.\n*   Both will be left unchanged if this function fails early due to a logical error, such as\n*   an invalid argument, or in an unknown yet valid state if it fails due to a runtime error.\n*   Both will also be left unchanged if this function succeeds but `taken` is false.\n*\n* \\param[in] subscription Subscription to take ROS message from.\n* \\param[out] ros_message Type erased ROS message to write to.\n* \\param[out] taken Boolean flag indicating if a ROS message was taken or not.\n* \\param[out] message_info Taken ROS message metadata.\n* \\param[in] allocation Pre-allocated memory to be used. May be NULL.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `message_info` is NULL, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription`\n*   implementation identifier does not match this implementation, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_take_with_info(
        subscription: *const rmw_subscription_t,
        ros_message: *mut ::std::os::raw::c_void,
        taken: *mut bool,
        message_info: *mut rmw_message_info_t,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Take multiple incoming ROS messages with their metadata.\n**\n* Take a sequence of consecutive ROS messages already received by the given\n* subscription, removing them from internal queues.\n* While `count` ROS messages may be requested, fewer messages may have been\n* received by the subscription.\n* This function will only take what has been already received, and it will\n* succeed even if fewer (or zero) messages were received.\n* In this case, only currently available messages will be returned.\n* The `taken` output variable indicates the number of ROS messages actually taken.\n*\n* \\remarks Once taken, ROS messages in the sequence cannot be taken again.\n*   Callers do not have to deal with duplicates.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n*\n* <i>[1] implementation defined, check implementation documentation.</i>\n*\n* \\par Runtime behavior\n*   To take a sequence of ROS messages is a synchronous operation.\n*   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,\n*   but it is not guaranteed to be lock-free.\n*   Generally speaking, implementations may synchronize access to internal resources using\n*   locks but are not allowed to wait for events with no guaranteed time bound (barring\n*   the effects of starvation due to OS scheduling).\n*\n* \\par Memory allocation\n*   It is implementation defined whether memory will be allocated on take or not.\n*   For instance, implementations that deserialize ROS messages received over\n*   the wire may need to perform additional memory allocations when dealing with\n*   unbounded (dynamically-sized) fields.\n*   A subscription allocation, if provided, may or may not be used.\n*   Check the implementation documentation to learn about memory allocation\n*   guarantees when taking ROS messages with and without subscription allocations.\n*\n* \\par Thread-safety\n*   Subscriptions are thread-safe objects, and so are all operations on them except for\n*   finalization.\n*   Therefore, it is safe to take from the same subscription concurrently.\n*   Moreover, the sequence of ROS messages taken is guaranteed to be consecutive and to\n*   preserve the order in the subscription queues, despite any concurrent takes.\n*   However, when taking a sequence of ROS messages with metadata:\n*   - Access to the given ROS message sequence is not synchronized.\n*     It is not safe to read or write `message_sequence` while rmw_take_sequence() uses it.\n*   - Access to the given ROS message metadata sequence is not synchronized.\n*     It is not safe to read or write `message_info_sequence` while rmw_take_sequence() uses it.\n*   - Access to given primitive data-type arguments is not synchronized.\n*     It is not safe to read or write `taken` while rmw_take_sequence() uses it.\n*   - Access to the given subscription allocation is not synchronized,\n*     unless specifically stated otherwise by the implementation.\n*     Thus, it is generally not safe to read or write `allocation` while rmw_take_sequence()\n*     uses it.\n*     Check the implementation documentation to learn about subscription allocations'\n*     thread-safety.\n*\n* \\pre Given `subscription` must be a valid subscription, as returned\n*   by rmw_create_subscription().\n* \\pre Given `message_sequence` must be a valid message sequence, initialized\n*   by rmw_message_sequence_init() and populated with ROS messages whose\n*   type matches the message type support registered with the `subscription`\n*   on creation.\n* \\pre Given `message_info_sequence` must be a valid message metadata sequence,\n*   initialized by rmw_message_info_sequence_init().\n* \\pre If not NULL, given `allocation` must be a valid subscription allocation initialized\n*   with rmw_subscription_allocation_init() with a message type support that matches the\n*   one registered with `subscription` on creation.\n* \\post Given `message_sequence` will remain a valid message sequence, and\n*   `message_info_sequence`, a valid message metadata sequence.\n*   Both will be left unchanged if this function fails early due to a logical error, such as\n*   an invalid argument, or in an unknown yet valid state if it fails due to a runtime error.\n*   Both will also be left unchanged if this function succeeds but `taken` is zero.\n*\n* \\param[in] subscription Subscription to take ROS message from.\n* \\param[in] count Number of messages to attempt to take.\n* \\param[out] message_sequence Sequence of type erase ROS messages to write to.\n*   Message sequence capacity has to be enough to hold all requested messages\n*   i.e. capacity has to be equal or greater than `count`.\n*   It does not have to match that of `message_info_sequence`.\n* \\param[out] message_info_sequence Sequence of additional message metadata.\n*   Message info sequence capacity has to be enough to hold all requested messages\n*   metadata i.e. capacity has to be equal or greater than `count`.\n*   It does not have to match that of `message_sequence`.\n* \\param[out] taken Number of messages actually taken from subscription.\n* \\param[in] allocation Pre-allocated memory to use. May be NULL.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `message_sequence` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `message_info_sequence` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `count` is 0, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `message_sequence` capacity is less than `count`, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `message_info_sequence` capacity is less than `count`, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation\n*   identifier does not match this implementation, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_take_sequence(
        subscription: *const rmw_subscription_t,
        count: usize,
        message_sequence: *mut rmw_message_sequence_t,
        message_info_sequence: *mut rmw_message_info_sequence_t,
        taken: *mut usize,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Take an incoming ROS message as a byte stream.\n**\n* Take a ROS message already received by the given subscription, removing it from internal queues.\n* This function will succeed even if no ROS message was received, but `taken` will be false.\n* Unlike rmw_take(), the ROS message is taken in its serialized form, as a byte stream.\n* If needed, this byte stream can then be deserialized into a ROS message with rmw_deserialize().\n*\n* \\remarks The same ROS message, serialized or not, cannot be taken twice.\n*   Callers do not have to deal with duplicates.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n*\n* <i>[1] implementation defined, check implementation documentation.</i>\n*\n* \\par Runtime behavior\n*   To take a ROS message a byte stream is a synchronous operation.\n*   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,\n*   but it is not guaranteed to be lock-free.\n*   Generally speaking, implementations may synchronize access to internal resources using\n*   locks but are not allowed to wait for events with no guaranteed time bound (barring\n*   the effects of starvation due to OS scheduling).\n*\n* \\par Memory allocation\n*   It is implementation defined whether memory will be allocated on take or not.\n*   For instance, implementations may have to perform additional memory allocations\n*   when dealing with ROS messages that contain unbounded (dynamically-sized) fields\n*   i.e. these implementations may have to resize the given byte stream.\n*   A subscription allocation, if provided, may or may not be used.\n*   Check the implementation documentation to learn about memory allocation guarantees\n*   when taking serialized ROS messages with and without subscription allocations.\n* \\par\n*   For ROS messages that only contain bounded (fixed-size) fields, callers can query\n*   their size using rmw_get_serialized_message_size() and resize `serialized_message`\n*   using rmw_serialized_message_resize() accordingly to prevent byte stream resizing\n*   on take.\n*   Nonetheless, byte stream resizing is not guaranteed to be the sole memory operation.\n*\n* \\par Thread-safety\n*   Subscriptions are thread-safe objects, and so are all operations on them except for\n*   finalization.\n*   Therefore, it is safe to take from the same subscription concurrently.\n*   However, when taking serialized ROS messages:\n*   - Access to the given byte stream for serialized ROS messages is not synchronized.\n*     It is not safe to read or write `serialized_message` while\n*     rmw_take_serialized_message() uses it.\n*   - Access to given primitive data-type arguments is not synchronized.\n*     It is not safe to read or write `taken` while rmw_take_serialized_message() uses it.\n*   - Access to the given subscription allocation is not synchronized,\n*     unless specifically stated otherwise by the implementation.\n*     Thus, it is generally not safe to read or write `allocation` while\n*     rmw_take_serialized_message() uses it.\n*     Check the implementation documentation to learn about subscription allocations'\n*     thread-safety.\n*\n* \\pre Given `subscription` must be a valid subscription, as returned by\n*   rmw_create_subscription().\n* \\pre Given `serialized_message` must be a valid serialized message, initialized by\n*   rmw_serialized_message_init().\n* \\pre If not NULL, given `allocation` must be a valid subscription allocation initialized\n*   with rmw_subscription_allocation_init() with a message type support that matches the\n*   one registered with `subscription` on creation.\n* \\post Given `serialized_message` will remain a valid serialized message.\n*   It will be left unchanged if this function fails early due to a logical error,\n*   such as an invalid argument, or in an unknown yet valid state if it fails due to a\n*   runtime error.\n*   It will also be left unchanged if this function succeeds but `taken` is false.\n*\n* \\param[in] subscription Subscription to take ROS message from.\n* \\param[out] serialized_message Byte stream to write to.\n* \\param[out] taken Boolean flag indicating if a ROS message was taken or not.\n* \\param[in] allocation Pre-allocated memory to use. May be NULL.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `serialized_message` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation\n*   identifier does not match this implementation, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_take_serialized_message(
        subscription: *const rmw_subscription_t,
        serialized_message: *mut rmw_serialized_message_t,
        taken: *mut bool,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Take an incoming ROS message as a byte stream with its metadata.\n**\n* Same as rmw_take_serialized_message(), except it also takes ROS message metadata.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n*\n* <i>[1] implementation defined, check implementation documentation.</i>\n*\n* \\par Runtime behavior\n*   To take a ROS message a byte stream with its metadata is a synchronous operation.\n*   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,\n*   but it is not guaranteed to be lock-free.\n*   Generally speaking, implementations may synchronize access to internal resources using\n*   locks but are not allowed to wait for events with no guaranteed time bound (barring\n*   the effects of starvation due to OS scheduling).\n*\n* \\par Memory allocation\n*   It is implementation defined whether memory will be allocated on take or not.\n*   For instance, implementations may have to perform additional memory allocations\n*   when dealing with ROS messages that contain unbounded (dynamically-sized) fields\n*   i.e. these implementations may have to resize the given byte stream.\n*   A subscription allocation, if provided, may or may not be used.\n*   Check the implementation documentation to learn about memory allocation guarantees\n*   when taking serialized ROS messages with and without subscription allocations.\n* \\par\n*   For ROS messages that only contain bounded (fixed-size) fields, callers can query\n*   their size using rmw_get_serialized_message_size() and resize `serialized_message`\n*   using rmw_serialized_message_resize() accordingly to prevent byte stream resizing\n*   on take.\n*   Nonetheless, byte stream resizing is not guaranteed to be the sole memory operation.\n*\n* \\par Thread-safety\n*   Subscriptions are thread-safe objects, and so are all operations on them except for\n*   finalization.\n*   Therefore, it is safe to take from the same subscription concurrently.\n*   However, when taking serialized ROS messages with metadata:\n*   - Access to the given byte stream for serialized ROS messages is not synchronized.\n*     It is not safe to read or write `serialized_message` while\n*     rmw_take_serialized_message_with_info() uses it.\n*   - Access to the given ROS message metadata is not synchronized.\n*     It is not safe to read or write `message_info` while\n*     rmw_take_serialized_message_with_info() uses it.\n*   - Access to given primitive data-type arguments is not synchronized.\n*     It is not safe to read or write `taken` while rmw_take_serialized_message_with_info()\n*     uses it.\n*   - Access to the given subscription allocation is not synchronized,\n*     unless specifically stated otherwise by the implementation.\n*     Thus, it is generally not safe to read or write `allocation` while\n*     rmw_take_serialized_message_with_info() uses it.\n*     Check the implementation documentation to learn about subscription allocations'\n*     thread-safety.\n*\n* \\pre Given `serialized_message` must be a valid serialized message, initialized by\n*   rmw_serialized_message_init().\n* \\pre If not NULL, given `allocation` must be a valid subscription allocation initialized\n*   with rmw_subscription_allocation_init() with a message type support that matches the\n*   one registered with `subscription` on creation.\n* \\post Given `serialized_message` will remain a valid serialized message, and `message_info`,\n*   valid message metadata.\n*   Both will be left unchanged if this function fails early due to a logical error,\n*   such as an invalid argument, or in an unknown yet valid state if it fails due to a\n*   runtime error.\n*   It will also be left unchanged if this function succeeds but `taken` is false.\n*\n* \\param[in] subscription Subscription to take ROS message from.\n* \\param[out] serialized_message Byte stream to write to.\n* \\param[out] taken Boolean flag indicating if a ROS message was taken or not.\n* \\param[out] message_info Taken ROS message metadata.\n* \\param[in] allocation Pre-allocated memory to use. May be NULL.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `serialized_message` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `message_info` is NULL, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation\n*   identifier does not match this implementation, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_take_serialized_message_with_info(
        subscription: *const rmw_subscription_t,
        serialized_message: *mut rmw_serialized_message_t,
        taken: *mut bool,
        message_info: *mut rmw_message_info_t,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Take an incoming ROS message, loaned by the middleware.\n**\n* Take a ROS message already received by the given subscription, removing it from internal queues.\n* This function will succeed even if no ROS message was received, but `taken` will be false.\n* The loaned ROS message is owned by the middleware, which will keep it alive (i.e. in valid\n* memory space) until the caller returns it using rmw_return_loaned_message_from_subscription().\n*\n* \\remarks The same ROS message, loaned or not, cannot be taken twice.\n*   Callers do not have to deal with duplicates.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n*\n* <i>[1] implementation defined, check implementation documentation.</i>\n*\n* \\par Runtime behavior\n*   To take a loaned ROS message is a synchronous operation.\n*   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive\n*   nor for internal memory loaning pools, if any, to be replenished, but it is not\n*   guaranteed to be lock-free.\n*   Generally speaking, implementations may synchronize access to internal resources using\n*   locks but are not allowed to wait for events with no guaranteed time bound (barring\n*   the effects of starvation due to OS scheduling).\n*\n* \\par Memory allocation\n*   It is implementation defined whether memory will be allocated on take or not.\n*   For instance, implementations that deserialize ROS messages received over\n*   the wire may need to perform additional memory allocations when dealing with\n*   unbounded (dynamically-sized) fields.\n*   A subscription allocation, if provided, may or may not be used.\n*   Check the implementation documentation to learn about memory allocation\n*   guarantees when taking loaned ROS messages with and without subscription allocations.\n*\n* \\par Thread-safety\n*   Subscriptions are thread-safe objects, and so are all operations on them except for\n*   finalization.\n*   Therefore, it is safe to take from the same subscription concurrently.\n*   However, when taking loaned ROS messages:\n*   - Access to given primitive data-type arguments is not synchronized.\n*     It is not safe to read or write `taken` nor `loaned_message`\n*     while rmw_take_loaned_message() uses them.\n*   - Access to the given subscription allocation is not synchronized,\n*     unless specifically stated otherwise by the implementation.\n*     Thus, it is generally not safe to read or write `allocation` while\n*     rmw_take_loaned_message() uses it.\n*     Check the implementation documentation to learn about subscription allocations'\n*     thread-safety.\n*\n* \\pre Given `subscription` must be a valid subscription, as returned\n*   by rmw_create_subscription().\n* \\pre If not NULL, given `allocation` must be a valid subscription allocation initialized\n*   with rmw_subscription_allocation_init() with a message type support that matches the\n*   one registered with `subscription` on creation.\n* \\post Given `loaned_message` will remain unchanged, or point to a valid message if\n*   this function was successful and `taken` is true.\n*\n* \\param[in] subscription Subscription to take ROS message from.\n* \\param[inout] loaned_message Pointer to type erased ROS message taken\n*   and loaned by the middleware.\n* \\param[out] taken Boolean flag indicating if a ROS message was taken or not.\n* \\param[in] allocation Pre-allocated memory to use. May be NULL.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `loaned_message` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `*loaned_message` is not NULL (to prevent leaks), or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation\n*   identifier does not match this implementation, or\n* \\return `RMW_RET_UNSUPPORTED` if the implementation does not support loaned ROS messages, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_take_loaned_message(
        subscription: *const rmw_subscription_t,
        loaned_message: *mut *mut ::std::os::raw::c_void,
        taken: *mut bool,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Take a loaned message and with its additional message information.\n**\n* Same as rmw_take_loaned_message(), except it also takes ROS message metadata.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n*\n* <i>[1] implementation defined, check implementation documentation.</i>\n*\n* \\par Runtime behavior\n*   To take a loaned ROS message with its metadata is a synchronous operation.\n*   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive\n*   nor for internal memory loaning pools, if any, to be replenished, but it is not\n*   guaranteed to be lock-free.\n*   Generally speaking, implementations may synchronize access to internal resources using\n*   locks but are not allowed to wait for events with no guaranteed time bound (barring\n*   the effects of starvation due to OS scheduling).\n*\n* \\par Memory allocation\n*   It is implementation defined whether memory will be allocated on take or not.\n*   For instance, implementations that deserialize ROS messages received over\n*   the wire may need to perform additional memory allocations when dealing with\n*   unbounded (dynamically-sized) fields.\n*   A subscription allocation, if provided, may or may not be used.\n*   Check the implementation documentation to learn about memory allocation\n*   guarantees when taking loaned ROS messages with and without subscription allocations.\n*\n* \\par Thread-safety\n*   Subscriptions are thread-safe objects, and so are all operations on them except for\n*   finalization.\n*   Therefore, it is safe to take from the same subscription concurrently.\n*   However, when taking loaned ROS messages with metadata:\n*   - Access to given primitive data-type arguments is not synchronized.\n*     It is not safe to read or write `taken` nor `loaned_message`\n*     while rmw_take_loaned_message_with_info() uses them.\n*   - Access to the given ROS message metadata is not synchronized.\n*     It is not safe to read or write `message_info` while\n*     rmw_take_loaned_message_with_info() uses it.\n*   - Access to the given subscription allocation is not synchronized,\n*     unless specifically stated otherwise by the implementation.\n*     Thus, it is generally not safe to read or write `allocation` while\n*     rmw_take_loaned_message_with_info() uses it.\n*     Check the implementation documentation to learn about subscription allocations'\n*     thread-safety.\n*\n* \\pre Given `subscription` must be a valid subscription, as returned\n*   by rmw_create_subscription().\n* \\pre If not NULL, given `allocation` must be a valid subscription allocation initialized\n*   with rmw_subscription_allocation_init() with a message type support that matches the\n*   one registered with `subscription` on creation.\n* \\post Given `loaned_message` will remain unchanged, or point to a valid message if\n*   this function was successful and `taken` is true.\n* \\post Given `message_info` will remain valid message metadata.\n*   It will be left unchanged if this function fails early due to a logical error,\n*   such as an invalid argument, or in an unknown yet valid state if it fails due to a\n*   runtime error.\n*   It will also be left unchanged if this function succeeds but `taken` is false.\n*\n* \\param[in] subscription Subscription to take ROS message from.\n* \\param[inout] loaned_message Pointer to type erased ROS message taken\n*   and loaned by the middleware.\n* \\param[out] taken Boolean flag indicating if a ROS message was taken or not.\n* \\param[out] message_info Taken ROS message metadata.\n* \\param[in] allocation Pre-allocated memory to use. May be NULL.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `loaned_message` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `*loaned_message` is not NULL to prevent leaks, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `message_info` is NULL, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation\n*   identifier does not match this implementation, or\n* \\return `RMW_RET_UNSUPPORTED` if the implementation does not support loaned ROS messages, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_take_loaned_message_with_info(
        subscription: *const rmw_subscription_t,
        loaned_message: *mut *mut ::std::os::raw::c_void,
        taken: *mut bool,
        message_info: *mut rmw_message_info_t,
        allocation: *mut rmw_subscription_allocation_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Return a loaned ROS message previously taken from a subscription.\n**\n* Tells the middleware that previously loaned ROS message is no longer needed by the caller.\n* If this function fails early due to a logical error, such as an invalid argument,\n* the loaned ROS message will be left unchanged.\n* Otherwise, ownership of the ROS message will be given back to the middleware.\n* It is up to the middleware what will be made of the returned ROS message.\n* It is undefined behavior to use a loaned ROS message after returning it.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n*\n* <i>[1] implementation defined, check implementation documentation.</i>\n*\n* \\par Runtime behavior\n*   To return a loaned ROS message is a synchronous operation.\n*   It is also non-blocking, but it is not guaranteed to be lock-free.\n*   Generally speaking, implementations may synchronize access to internal resources using\n*   locks but are not allowed to wait for events with no guaranteed time bound (barring\n*   the effects of starvation due to OS scheduling).\n*\n* \\par Thread-safety\n*   Subscriptions are thread-safe objects, and so are all operations on them except for\n*   finalization.\n*   Therefore, it is safe to return loaned ROS messages to the same subscription concurrently.\n*   However, since ownership of the loaned ROS message is given back to middleware and this\n*   transfer is not synchronized, it is not safe to return the same loaned ROS message\n*   concurrently.\n*\n* \\pre Given `subscription` must be a valid subscription, as returned\n*   by rmw_create_subscription().\n* \\pre Given `loaned_message` must be a loaned ROS message, previously taken from\n*   `subscription` using rmw_take_loaned_message() or rmw_take_loaned_message_with_info().\n*\n* \\param[in] subscription Subscription the ROS message was taken and loaned from.\n* \\param[in] loaned_message Loaned type erased ROS message to be returned to the middleware.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `loaned_message` is NULL, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation\n*   identifier does not match this implementation, or\n* \\return `RMW_RET_UNSUPPORTED` if the implementation does not support loaned ROS messages, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_return_loaned_message_from_subscription(
        subscription: *const rmw_subscription_t,
        loaned_message: *mut ::std::os::raw::c_void,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Create a service client that can send requests to and receive replies from a service server.\n**\n* This function can fail, and therefore return `NULL`, if:\n*   - `node` is `NULL`, or\n*   - `node` does not belong to this implementation\n*      i.e. it does not have a matching implementation identifier, or\n*   - `type_support` is `NULL`, or\n*   - `service_name` is `NULL`, or\n*   - `service_name` is an empty string, or\n*   - (if ROS namespace conventions apply) `service_name` is invalid by\n*     rmw_validate_full_topic_name() definition, or\n*   - `qos_profile` is `NULL`, or\n*   - `qos_profile` has invalid or unknown policies, or\n*   - memory allocation fails during service client creation, or\n*   - an unspecified error occurs.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined, check the implementation documentation</i>\n*\n* \\pre Given `node` must be a valid node, as returned by rmw_create_node().\n* \\pre Given `type_support` must be a valid `rosidl` service type support, as\n*   returned by ROSIDL_GET_SRV_TYPE_SUPPORT().\n*\n* \\param[in] node Node with which to register this service client.\n* \\param[in] type_support Type support of the service to be used.\n* \\param[in] service_name Name of the service to be used, often a fully qualified\n*   service name unless `qos_profile` is configured to avoid ROS namespace conventions\n*   i.e. to create a native service client.\n* \\param[in] qos_policies QoS policies for this service client's connections.\n* \\return rmw service client handle, or `NULL` if there was an error.\n*/"]
    pub fn rmw_create_client(
        node: *const rmw_node_t,
        type_support: *const rosidl_service_type_support_t,
        service_name: *const ::std::os::raw::c_char,
        qos_policies: *const rmw_qos_profile_t,
    ) -> *mut rmw_client_t;
}
extern "C" {
    #[doc = " Destroy and unregister a service client from its node.\n**\n* This function will reclaim all associated resources, including the service client itself.\n* Use of a destroyed service client is undefined behavior.\n* This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`\n* or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given service client unchanged.\n* Otherwise, it will proceed despite errors.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined, check the implementation documentation</i>\n*\n* \\pre Given `node` must be the one the service client was registered with.\n* \\pre Given `client` must be a valid service client, as returned by rmw_create_service().\n*\n* \\param[in] node Node with which the given service client is registered.\n* \\param[in] client Service client to be destroyed.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `node` is `NULL`, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `client` is `NULL`, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node`\n*   implementation identifier does not match this implementation, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `client`\n*   implementation identifier does not match this implementation, or\n* \\return `RMW_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rmw_destroy_client(node: *mut rmw_node_t, client: *mut rmw_client_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Send a ROS service request.\n**\n* Send a ROS service request to one or more service servers, with matching QoS policies,\n* using the given client.\n*\n* \\note It is implementation defined how many service servers may get, and potentially react to,\n*   the same request, considering there may be more than one server for the same service\n*   in the ROS graph.\n*\n* On success, this function will return a sequence number.\n* It is up to callers to save the returned sequence number to pair the ROS service request\n* just sent with future ROS service responses (taken using rmw_take_response()).\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n*\n* <i>[1] implementation defined, check implementation documentation.</i>\n*\n* \\par Runtime behavior\n*   It is implementation defined whether sending a ROS service request is a\n*   synchronous or asynchronous, and blocking or non-blocking, operation.\n*   However, asynchronous implementations are not allowed to access the\n*   given ROS service request after this function returns.\n*   Check the implementation documentation to learn about request behavior.\n*\n* \\par Memory allocation\n*   It is implementation defined whether memory will be allocated on send or not.\n*   For instance, implementations that serialize ROS service requests may need to\n*   perform additional memory allocations when dealing with unbounded (dynamically-sized)\n*   fields.\n*\n* \\par Thread-safety\n*   Service clients are thread-safe objects, and so are all operations on them except for\n*   finalization.\n*   Therefore, it is safe to send requests using the same service client concurrently.\n*   However:\n*   - Access to the given ROS service request is read-only but it is not synchronized.\n*     Concurrent `ros_request` reads are safe, but concurrent reads and writes are not.\n*   - Access to given primitive data-type arguments is not synchronized.\n*     It is not safe to read or write `sequence_id` while rmw_send_request() uses it.\n*\n* \\pre Given `client` must be a valid client, as returned by rmw_create_client().\n* \\pre Given `ros_request` must be a valid service request, whose type matches the\n*   service type support registered with the `client` on creation.\n*\n* \\param[in] client Service client to send a request with.\n* \\param[in] ros_request ROS service request to be sent.\n* \\param[out] sequence_id Sequence number for the `ros_request` just sent\n*   i.e. a unique identification number for it, populated on success.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `client` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `ros_request` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `sequence_id` is NULL, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `client`\n*   implementation identifier does not match this implementation, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_send_request(
        client: *const rmw_client_t,
        ros_request: *const ::std::os::raw::c_void,
        sequence_id: *mut i64,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Take an incoming ROS service response.\n**\n* Take a ROS service response already received by the given service server, removing\n* it from internal queues.\n* The response header (i.e. its metadata), containing at least the writer guid and\n* sequence number, is also retrieved.\n* Both writer guid and sequence number allow callers to pair, potentially for each\n* remote service server, a ROS service response with its corresponding ROS service\n* request, previously sent using rmw_send_request().\n*\n* \\note It is implementation defined how many responses a given request may get,\n*   considering there may be more than one server for the same service in the ROS graph.\n*\n* This function will succeed even if no ROS service request was received,\n* but `taken` will be false.\n*\n* \\remarks The same ROS service response cannot be taken twice.\n*   Callers do not have to deal with duplicates.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n*\n* <i>[1] implementation defined, check implementation documentation.</i>\n*\n* \\par Runtime behavior\n*   Taking a ROS service response is a synchronous operation.\n*   It is also non-blocking, to the extent it will not wait for new ROS service responses\n*   to arrive, but it is not guaranteed to be lock-free.\n*   Generally speaking, implementations may synchronize access to internal resources using\n*   locks but are not allowed to wait for events with no guaranteed time bound (barring\n*   the effects of starvation due to OS scheduling).\n*\n* \\par Memory allocation\n*   It is implementation defined whether memory will be allocated on take or not.\n*   For instance, implementations that deserialize ROS service responses received over\n*   the wire may need to perform additional memory allocations when dealing with\n*   unbounded (dynamically-sized) fields.\n*\n* \\par Thread-safety\n*   Service clients are thread-safe objects, and so are all operations on them except for\n*   finalization.\n*   Therefore, it is safe to take responses from the same service client concurrently.\n*   However:\n*   - Access to the given ROS service response is not synchronized.\n*     It is not safe to read or write `ros_response` while rmw_take_request() uses it.\n*   - Access to the given ROS service response header is not synchronized.\n*     It is not safe to read or write `response_header` while rmw_take_response() uses it.\n*   - Access to given primitive data-type arguments is not synchronized.\n*     It is not safe to read or write `taken` while rmw_take_response() uses it.\n*\n* \\pre Given `client` must be a valid client, as returned by rmw_create_client().\n* \\pre Given `ros_response` must be a valid service response, whose type matches the\n*   service type support registered with the `client` on creation.\n* \\post Given `ros_response` will remain a valid service response.\n*   It will be left unchanged if this function fails early due to a logical error, such as an\n*   invalid argument, or in an unknown yet valid state if it fails due to a runtime error.\n*   It will also be left unchanged if this function succeeds but `taken` is false.\n*\n* \\param[in] client Service client to take response from.\n* \\param[out] request_header Service response header to write to.\n* \\param[out] ros_response Type erased ROS service response to write to.\n* \\param[out] taken Boolean flag indicating if a ROS service response was taken or not.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `client` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `response_header` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `ros_response` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `client`\n*   implementation identifier does not match this implementation, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_take_response(
        client: *const rmw_client_t,
        request_header: *mut rmw_service_info_t,
        ros_response: *mut ::std::os::raw::c_void,
        taken: *mut bool,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Retrieve the actual qos settings of the client's request publisher.\n**\n* Query the underlying middleware to determine the qos settings\n* of the client's request publisher.\n* The actual configuration applied when using RMW_*_SYSTEM_DEFAULT\n* can only be resolved after the creation of the client, and it\n* depends on the underlying rmw implementation.\n* If the underlying setting in use can't be represented in ROS terms,\n* it will be set to RMW_*_UNKNOWN.\n*\n* \\note The value of avoid_ros_namespace_conventions field is not resolved\n*   with this function. The rcl function `rcl_client_request_publisher_get_actual_qos()`\n*   resolves it.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe [1]\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined, check the implementation documentation</i>\n*\n* \\param[in] client the client object to inspect\n* \\param[out] qos the actual qos settings\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if client\n*   implementation identifier does not match, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_client_request_publisher_get_actual_qos(
        client: *const rmw_client_t,
        qos: *mut rmw_qos_profile_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Retrieve the actual qos settings of the client's response subscription.\n**\n* Query the underlying middleware to determine the qos settings\n* of the client's response subscription.\n* The actual configuration applied when using RMW_*_SYSTEM_DEFAULT\n* can only be resolved after the creation of the client, and it\n* depends on the underlying rmw implementation.\n* If the underlying setting in use can't be represented in ROS terms,\n* it will be set to RMW_*_UNKNOWN.\n*\n* \\note The value of avoid_ros_namespace_conventions field is not resolved\n*   with this function. The rcl function `rcl_client_request_publisher_get_actual_qos()`\n*   resolves it.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe [1]\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined, check the implementation documentation</i>\n*\n* \\param[in] client the client object to inspect\n* \\param[out] qos the actual qos settings\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if client\n*   implementation identifier does not match, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_client_response_subscription_get_actual_qos(
        client: *const rmw_client_t,
        qos: *mut rmw_qos_profile_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Create a service server that can receive requests from and send replies to a service client.\n**\n* This function can fail, and therefore return `NULL`, if:\n*   - `node` is `NULL`, or\n*   - `node` does not belong to this implementation\n*     i.e. it does not have a matching implementation identifier, or\n*   - `type_support` is `NULL`, or\n*   - `service_name` is `NULL`, or\n*   - `service_name` is an empty string, or\n*   - (if ROS namespace conventions apply) `service_name` is invalid by\n*     rmw_validate_full_topic_name() definition, or\n*   - `qos_profile` is `NULL`, or\n*   - `qos_profile` has invalid or unknown policies, or\n*   - memory allocation fails during service server creation, or\n*   - an unspecified error occurs\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined, check the implementation documentation</i>\n*\n* \\pre Given `node` must be a valid node, as returned by rmw_create_node().\n* \\pre Given `type_support` must be a valid `rosidl` service type support, as\n*   returned by ROSIDL_GET_SRV_TYPE_SUPPORT().\n*\n* \\param[in] node Node with which to register this service server.\n* \\param[in] type_support Type support of the service to be served.\n* \\param[in] service_name Name of the service to be served, often a fully qualified\n*   service name unless `qos_profile` is configured to avoid ROS namespace conventions\n*   i.e. to create a native service server.\n* \\param[in] qos_profile QoS policies for this service server's connections.\n* \\return rmw service handle, or `NULL` if there was an error.\n*/"]
    pub fn rmw_create_service(
        node: *const rmw_node_t,
        type_support: *const rosidl_service_type_support_t,
        service_name: *const ::std::os::raw::c_char,
        qos_profile: *const rmw_qos_profile_t,
    ) -> *mut rmw_service_t;
}
extern "C" {
    #[doc = " Destroy and unregister a service server from its node.\n**\n* This function will reclaim all associated resources, including the service server itself.\n* Use of a destroyed service server is undefined behavior.\n* This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`\n* or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given service server unchanged.\n* Otherwise, it will proceed despite errors.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined, check the implementation documentation</i>\n*\n* \\pre Given `node` must be the one the service server was registered with.\n* \\pre Given `service` must be a valid service server, as returned by rmw_create_service().\n*\n* \\param[in] node Node with which the given service server is registered.\n* \\param[in] service Service server to be destroyed.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `node` is `NULL`, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `service` is `NULL`, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node`\n*   implementation identifier does not match this implementation, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `service`\n*   implementation identifier does not match this implementation, or\n* \\return `RMW_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rmw_destroy_service(node: *mut rmw_node_t, service: *mut rmw_service_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Take an incoming ROS service request.\n**\n* Take a ROS service request already received by the given service server, removing\n* it from internal queues.\n* The request header (i.e. its metadata), containing at least the writer guid and\n* sequence number, is also retrieved.\n* Both writer guid and sequence number allow callers to pair, for each remote service\n* client, a ROS service request with its corresponding ROS service response, to be later\n* sent using rmw_send_response().\n*\n* This function will succeed even if no ROS service request was received,\n* but `taken` will be false.\n*\n* \\remarks The same ROS service request cannot be taken twice.\n*   Callers do not have to deal with duplicates.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n*\n* <i>[1] implementation defined, check implementation documentation.</i>\n*\n* \\par Runtime behavior\n*   Taking a ROS service request is a synchronous operation.\n*   It is also non-blocking, to the extent it will not wait for new ROS service requests\n*   to arrive, but it is not guaranteed to be lock-free.\n*   Generally speaking, implementations may synchronize access to internal resources using\n*   locks but are not allowed to wait for events with no guaranteed time bound (barring\n*   the effects of starvation due to OS scheduling).\n*\n* \\par Memory allocation\n*   It is implementation defined whether memory will be allocated on take or not.\n*   For instance, implementations that deserialize ROS service requests received over\n*   the wire may need to perform additional memory allocations when dealing with\n*   unbounded (dynamically-sized) fields.\n*\n* \\par Thread-safety\n*   Service servers are thread-safe objects, and so are all operations on them except for\n*   finalization.\n*   Therefore, it is safe to take requests from the same service server concurrently.\n*   However:\n*   - Access to the given ROS service request is not synchronized.\n*     It is not safe to read or write `ros_request` while rmw_take_request() uses it.\n*   - Access to the given ROS service request header is not synchronized.\n*     It is not safe to read or write `request_header` while rmw_take_request() uses it.\n*   - Access to given primitive data-type arguments is not synchronized.\n*     It is not safe to read or write `taken` while rmw_take_request() uses it.\n*\n* \\pre Given `service` must be a valid service, as returned by rmw_create_service().\n* \\pre Given `ros_request` must be a valid service request, whose type matches the\n*   service type support registered with the `service` on creation.\n* \\post Given `ros_request` will remain a valid service request.\n*   It will be left unchanged if this function fails early due to a logical error, such as an\n*   invalid argument, or in an unknown yet valid state if it fails due to a runtime error.\n*   It will also be left unchanged if this function succeeds but `taken` is false.\n*\n* \\param[in] service Service server to take request from.\n* \\param[out] request_header Service request header to write to.\n* \\param[out] ros_request Type erased ROS service request to write to.\n* \\param[out] taken Boolean flag indicating if a ROS service request was taken or not.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `service` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `request_header` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `ros_request` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `service`\n*   implementation identifier does not match this implementation, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_take_request(
        service: *const rmw_service_t,
        request_header: *mut rmw_service_info_t,
        ros_request: *mut ::std::os::raw::c_void,
        taken: *mut bool,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Send a ROS service response.\n**\n* Send a ROS service response to the service client, with matching QoS policies,\n* from which the previously taken ROS service request was originally sent.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n*\n* <i>[1] implementation defined, check implementation documentation.</i>\n*\n* \\par Runtime behavior\n*   It is implementation defined whether sending a ROS service response is a\n*   synchronous or asynchronous, and blocking or non-blocking, operation.\n*   However, asynchronous implementations are not allowed to access the\n*   given ROS service request after this function returns.\n*   Check the implementation documentation to learn about request behavior.\n*\n* \\par Memory allocation\n*   It is implementation defined whether memory will be allocated on send or not.\n*   For instance, implementations that serialize ROS service responses may need to\n*   perform additional memory allocations when dealing with unbounded (dynamically-sized)\n*   fields.\n*\n* \\par Thread-safety\n*   Service servers are thread-safe objects, and so are all operations on them except for\n*   finalization.\n*   Therefore, it is safe to send responses using the same service server concurrently.\n*   However:\n*   - Access to the given ROS service request header is read-only but it is not synchronized.\n*     Concurrent `request_header` reads are safe, but concurrent reads and writes are not.\n*   - Access to the given ROS service response is read-only but it is not synchronized.\n*     Concurrent `ros_request` reads are safe, but concurrent reads and writes are not.\n*\n* \\pre Given `service` must be a valid service server, as returned by rmw_create_service().\n* \\pre Given `request_header` must be the one previously taken along with the ROS service\n*   request to which we reply.\n* \\pre Given `ros_response` must be a valid service response, whose type matches the\n*   service type support registered with the `service` on creation.\n*\n* \\param[in] service Service server to send a response with.\n* \\param[in] request_header Service response header, same as the one taken\n*   with the corresponding ROS service request.\n* \\param[in] ros_response ROS service response to be sent.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `service` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `request_header` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `ros_response` is NULL, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `service`\n*   implementation identifier does not match this implementation, or\n* \\return `RMW_RET_TIMEOUT` if a response reader is not ready yet, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_send_response(
        service: *const rmw_service_t,
        request_header: *mut rmw_request_id_t,
        ros_response: *mut ::std::os::raw::c_void,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Retrieve the actual qos settings of the service's request subscription.\n**\n* Query the underlying middleware to determine the qos settings\n* of the service's request subscription.\n* The actual configuration applied when using RMW_*_SYSTEM_DEFAULT\n* can only be resolved after the creation of the service, and it\n* depends on the underlying rmw implementation.\n* If the underlying setting in use can't be represented in ROS terms,\n* it will be set to RMW_*_UNKNOWN.\n*\n* \\note The value of avoid_ros_namespace_conventions field is not resolved\n*   with this function. The rcl function `rcl_service_request_subscription_get_actual_qos()`\n*   resolves it.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe [1]\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined, check the implementation documentation</i>\n*\n* \\param[in] service the service object to inspect\n* \\param[out] qos the actual qos settings\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if service\n*   implementation identifier does not match, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_service_request_subscription_get_actual_qos(
        service: *const rmw_service_t,
        qos: *mut rmw_qos_profile_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Retrieve the actual qos settings of the service's response publisher.\n**\n* Query the underlying middleware to determine the qos settings\n* of the service's response publisher.\n* The actual configuration applied when using RMW_*_SYSTEM_DEFAULT\n* can only be resolved after the creation of the service, and it\n* depends on the underlying rmw implementation.\n* If the underlying setting in use can't be represented in ROS terms,\n* it will be set to RMW_*_UNKNOWN.\n*\n* \\note The value of avoid_ros_namespace_conventions field is not resolved\n*   with this function. The rcl function `rcl_service_request_subscription_get_actual_qos()`\n*   resolves it.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe [1]\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined, check the implementation documentation</i>\n*\n* \\param[in] service the service object to inspect\n* \\param[out] qos the actual qos settings\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if service\n*   implementation identifier does not match, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_service_response_publisher_get_actual_qos(
        service: *const rmw_service_t,
        qos: *mut rmw_qos_profile_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Create a guard condition and return a handle to that guard condition.\n**\n* This function can fail, and therefore return `NULL`, if:\n*   - context is `NULL`\n*   - context is invalid\n*   - memory allocation fails during guard condition creation\n*   - an unspecified error occurs\n*\n* The context must be non-null and valid, i.e. it has been initialized\n* by `rmw_init()` and has not been finalized by `rmw_shutdown()`.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No [1]\n* Lock-Free          | No [1]\n* <i>[1] rmw implementation defined, check the implementation documentation</i>\n*\n* This should be defined by the rmw implementation.\n*\n* \\param[in] context init context that this node should be associated with\n* \\return rmw guard condition handle or `NULL` if there was an error\n*/"]
    pub fn rmw_create_guard_condition(context: *mut rmw_context_t) -> *mut rmw_guard_condition_t;
}
extern "C" {
    #[doc = " Finalize a given guard condition handle, reclaim the resources, and deallocate the handle.\n**\n* \\param[in] guard_condition the guard condition handle to be destroyed\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if guard_condition is null, or\n* \\return `RMW_RET_ERROR` if an unexpected error occurs.\n*/"]
    pub fn rmw_destroy_guard_condition(guard_condition: *mut rmw_guard_condition_t) -> rmw_ret_t;
}
extern "C" {
    pub fn rmw_trigger_guard_condition(guard_condition: *const rmw_guard_condition_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Create a wait set to store conditions that the middleware can wait on.\n**\n* This function can fail, and therefore return `NULL`, if:\n*   - context is `NULL`\n*   - context is zero initialized, as provided by rmw_get_zero_initialized_context()\n*   - context does not belong to this implementation i.e. does not have a matching\n*     implementation identifier\n*   - memory allocation fails during wait set creation\n*   - an unspecified error occurs\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined, check the implementation documentation</i>\n*\n* \\par Thread-safety\n*   Contexts are thread-safe objects, and so are all operations on them except for finalization.\n*   Therefore, it is safe to create multiple wait sets in the same context concurrently.\n*\n* \\pre Given `context` must be a valid context, initialized by rmw_init().\n*\n* \\param[in] context Context to associate the wait set with.\n* \\param[in] max_conditions\n*   The maximum number of conditions that can be attached to, and stored by, the wait set.\n*   Can be set to zero (0) for the wait set to support an unbounded number of conditions.\n* \\return An rmw wait set, or `NULL` if an error occurred.\n*/"]
    pub fn rmw_create_wait_set(
        context: *mut rmw_context_t,
        max_conditions: usize,
    ) -> *mut rmw_wait_set_t;
}
extern "C" {
    #[doc = " Destroy a wait set.\n**\n* This function will reclaim all associated resources, including the wait set.\n* Use of a wait set after destruction is undefined behavior.\n* This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`\n* or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given wait set unchanged.\n* Otherwise, it will proceed despite errors.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined, check the implementation documentation</i>\n*\n* \\pre Given `wait_set` must be a valid wait set, as returned by rmw_create_wait_set().\n*\n* \\param[in] wait_set Wait set to be finalized.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `wait_set` is NULL, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `wait_set` implementation\n*   identifier does not match this implementation, or\n* \\return `RMW_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rmw_destroy_wait_set(wait_set: *mut rmw_wait_set_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Waits on sets of different entities and returns when one is ready.\n**\n* This function adds middleware-specific conditions to the wait set and waits\n* until one or more become ready, or until the timeout is reached.\n*\n* \\remark Elapsed time should be measured using a monotonic clock,\n*   though rmw implementations could use a different one.\n*   Timeout granularity is thus bound to that of the clock used by the underlying implementation,\n*   and to the platform-specific APIs used to sleep and/or wait.\n*\n* \\remark\n*   The amount of time this function actually waits may be either above or\n*   below the specified timeout.\n*\n* Arrays contain type-erased, middleware-specific conditions associated with\n* waitable entities, which this function casts and adds to the wait set.\n* `NULL` entries in arrays prior to wait are considered invalid.\n* When the wait is over, entries in each array that correspond to\n* conditions that were \\b not triggered are set to `NULL`.\n*\n* \\remark Arrays' memory management is external to this function.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe [1]\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined, check the implementation documentation</i>\n*\n* \\par Thread-safety\n*   To wait is a reentrant procedure, but:\n*   - It is not safe to use the same wait set to wait in two or more threads concurrently.\n*   - It is not safe to wait for the same entity using different wait sets in two or\n*     more threads concurrently.\n*   - Access to the given timeout is read-only but it is not synchronized.\n*     Concurrent `wait_timeout` reads are safe, but concurrent reads and writes are not.\n*\n* \\pre Given `wait_set` must be a valid wait set, as returned by rmw_create_wait_set().\n* \\pre All given entities must be associated with nodes that, in turn, were registered\n*   with the same context the given `wait_set` was registered with on creation.\n*\n* \\param[inout] subscriptions Array of subscriptions to wait on.\n*   Can be `NULL` if there are no subscriptions to wait on.\n* \\param[inout] guard_conditions Array of guard conditions to wait on\n*   Can be `NULL` if there are no guard conditions to wait on.\n* \\param[inout] services Array of services to wait on.\n*   Can be `NULL` if there are no services to wait on.\n* \\param[inout] clients Array of clients to wait on.\n*   Can be `NULL` if there are no clients to wait on.\n* \\param[inout] events Array of events to wait on.\n*   Can be `NULL` if there are no events to wait on.\n* \\param[in] wait_set Wait set to use for waiting.\n* \\param[in] wait_timeout If `NULL`, block indefinitely until an entity becomes ready.\n*   If zero, do not block -- check only for immediately available entities.\n*   Else, this represents the maximum amount of time to wait for an entity to become ready.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_TIMEOUT` if wait timed out, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `wait_set` is `NULL`, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if an array entry is `NULL`, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `wait_set` implementation\n*   identifier does not match this implementation, or\n* \\return `RMW_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rmw_wait(
        subscriptions: *mut rmw_subscriptions_t,
        guard_conditions: *mut rmw_guard_conditions_t,
        services: *mut rmw_services_t,
        clients: *mut rmw_clients_t,
        events: *mut rmw_events_t,
        wait_set: *mut rmw_wait_set_t,
        wait_timeout: *const rmw_time_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Return the name and namespace of all nodes in the ROS graph.\n**\n* This function will return an array of node names and an array of node namespaces,\n* as discovered so far by the given node.\n* The two arrays represent name and namespace pairs for each discovered node.\n* Both arrays will be the same length and the same index will refer to the same node.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation defined, check the implementation documentation</i>\n*\n* \\par Runtime behavior\n*   To query the ROS graph is a synchronous operation.\n*   It is also non-blocking, but it is not guaranteed to be lock-free.\n*   Generally speaking, implementations may synchronize access to internal resources using\n*   locks but are not allowed to wait for events with no guaranteed time bound (barring\n*   the effects of starvation due to OS scheduling).\n*\n* \\par Thread-safety\n*   Nodes are thread-safe objects, and so are all operations on them except for finalization.\n*   Therefore, it is safe to query the ROS graph using the same node concurrently.\n*   However, access to string arrays is not synchronized.\n*   It is not safe to read or write `node_names` nor `node_namespaces`\n*   while rmw_get_node_names() uses them.\n*\n* \\pre Given `node` must be a valid node handle, as returned by rmw_create_node().\n* \\pre Given `node_names` must be a valid string array, zero-initialized\n*   as returned by rcutils_get_zero_initialized_string_array().\n* \\pre Given `node_namespaces` must be a valid string array, zero-initialized\n*   as returned by rcutils_get_zero_initialized_string_array().\n* \\post Given `node_names` and `node_namespaces` will remain valid arrays.\n*   These will be left unchanged if this function fails early due to a logical error,\n*   such as an invalid argument, or in an unknown yet valid state if it fails due to\n*   a runtime error.\n*\n* \\param[in] node Node to query the ROS graph.\n* \\param[out] node_names Array of discovered node names, populated on success.\n*   It is up to the caller to finalize this array later on, using rcutils_string_array_fini().\n* \\param[out] node_namespaces Array of discovered node namespaces, populated on success.\n*   It is up to the caller to finalize this array later on, using rcutils_string_array_fini().\n* \\return `RMW_RET_OK` if the query was successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `node_names` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `node_names` is not a zero-initialized array, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `node_namespaces` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `node_namespaces` is not a zero-initialized array, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation\n*   identifier does not match this implementation, or\n* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n* \\return `RMW_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rmw_get_node_names(
        node: *const rmw_node_t,
        node_names: *mut rcutils_string_array_t,
        node_namespaces: *mut rcutils_string_array_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Return the name, namespae, and enclave name of all nodes in the ROS graph.\n**\n* This is similar to rmw_get_node_names(), but it also provides enclave names.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation defined, check the implementation documentation</i>\n*\n* \\par Runtime behavior\n*   To query the ROS graph is a synchronous operation.\n*   It is also non-blocking, but it is not guaranteed to be lock-free.\n*   Generally speaking, implementations may synchronize access to internal resources using\n*   locks but are not allowed to wait for events with no guaranteed time bound (barring\n*   the effects of starvation due to OS scheduling).\n*\n* \\par Thread-safety\n*   Nodes are thread-safe objects, and so are all operations on them except for finalization.\n*   Therefore, it is safe to query the ROS graph using the same node concurrently.\n*   However, access to string arrays is not synchronized.\n*   It is not safe to read or write `node_names`, `node_namespaces`, nor `enclaves`\n*   while rmw_get_node_names_with_enclaves() uses them.\n*\n* \\pre Given `node` must be a valid node handle, as returned by rmw_create_node().\n* \\pre Given `node_names` must be a valid string array, zero-initialized\n*   as returned by rcutils_get_zero_initialized_string_array().\n* \\pre Given `node_namespaces` must be a valid string array, zero-initialized\n*   as returned by rcutils_get_zero_initialized_string_array().\n* \\pre Given `enclaves` must be a zero-initialized string array,\n*   as returned by rcutils_get_zero_initialized_string_array().\n* \\post Given `node_names`, `node_namespaces`, and `enclaves` will remain valid arrays.\n*   These will be left unchanged if this function fails early due to a logical error,\n*   such as an invalid argument, or in an unknown yet valid state if it fails due to\n*   a runtime error.\n*\n* \\param[in] node Node to query the ROS graph.\n* \\param[out] node_names Array of discovered node names, populated on success.\n*   It is up to the caller to finalize this array later on, using rcutils_string_array_fini().\n* \\param[out] node_namespaces Array of discovered node namespaces, populated on success.\n*   It is up to the caller to finalize this array later on, using rcutils_string_array_fini().\n* \\param[out] enclaves Array of discovered node enclave names, populated on success.\n*   It is up to the caller to finalize this array later on, using rcutils_string_array_fini().\n* \\return `RMW_RET_OK` if the query was successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `node_names` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `node_names` is not a zero-initialized array, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `node_namespaces` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `node_namespaces` is not a zero-initialized array, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `enclaves` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `enclaves` is not a zero-initialized array, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation\n*   identifier does not match this implementation, or\n* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n* \\return `RMW_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rmw_get_node_names_with_enclaves(
        node: *const rmw_node_t,
        node_names: *mut rcutils_string_array_t,
        node_namespaces: *mut rcutils_string_array_t,
        enclaves: *mut rcutils_string_array_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Count the number of known publishers matching a topic name.\n**\n* This function returns the numbers of publishers of a given topic in the ROS graph,\n* as discovered so far by the given node.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation defined, check the implementation documentation</i>\n*\n* \\par Runtime behavior\n*   To query the ROS graph is a synchronous operation.\n*   It is also non-blocking, but it is not guaranteed to be lock-free.\n*   Generally speaking, implementations may synchronize access to internal resources using\n*   locks but are not allowed to wait for events with no guaranteed time bound (barring\n*   the effects of starvation due to OS scheduling).\n*\n* \\par Thread-safety\n*   Nodes are thread-safe objects, and so are all operations on them except for finalization.\n*   Therefore, it is safe to query the ROS graph using the same node concurrently.\n*   However, access to primitive data-type arguments is not synchronized.\n*   It is not safe to read or write `topic_name` or `count` while rmw_count_publishers()\n*   uses them.\n*\n* \\pre Given `node` must be a valid node handle, as returned by rmw_create_node().\n*\n* \\param[in] node Handle to node to use to query the ROS graph.\n* \\param[in] topic_name Fully qualified ROS topic name.\n* \\param[out] count Number of publishers matching the given topic name.\n* \\return `RMW_RET_OK` if the query was successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `topic_name` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `topic_name` is not a fully qualified topic name,\n*   by rmw_validate_full_topic_name() definition, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `count` is NULL, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation\n*   identifier does not match this implementation, or\n* \\return `RMW_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rmw_count_publishers(
        node: *const rmw_node_t,
        topic_name: *const ::std::os::raw::c_char,
        count: *mut usize,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Count the number of known subscribers matching a topic name.\n**\n* This function returns the numbers of subscribers of a given topic in the ROS graph,\n* as discovered so far by the given node.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation defined, check the implementation documentation</i>\n*\n* \\par Runtime behavior\n*   To query the ROS graph is a synchronous operation.\n*   It is also non-blocking, but it is not guaranteed to be lock-free.\n*   Generally speaking, implementations may synchronize access to internal resources using\n*   locks but are not allowed to wait for events with no guaranteed time bound (barring\n*   the effects of starvation due to OS scheduling).\n*\n* \\par Thread-safety\n*   Nodes are thread-safe objects, and so are all operations on them except for finalization.\n*   Therefore, it is to query the ROS graph using the same node concurrently.\n*   However, access to primitive data-type arguments is not synchronized.\n*   It is not safe to read or write `topic_name` or `count` while rmw_count_subscribers()\n*   uses them.\n*\n* \\pre Given `node` must be a valid node handle, as returned by rmw_create_node().\n*\n* \\param[in] node Handle to node to use to query the ROS graph.\n* \\param[in] topic_name Fully qualified ROS topic name.\n* \\param[out] count Number of subscribers matching the given topic name.\n* \\return `RMW_RET_OK` if the query was successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `topic_name` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `topic_name` is not a fully qualified topic name,\n*   by rmw_validate_full_topic_name() definition, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `count` is NULL, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation\n*   identifier does not match this implementation, or\n* \\return `RMW_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rmw_count_subscribers(
        node: *const rmw_node_t,
        topic_name: *const ::std::os::raw::c_char,
        count: *mut usize,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Count the number of known clients matching a service name.\n**\n* This function returns the numbers of clients of a given service in the ROS graph,\n* as discovered so far by the given node.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation defined, check the implementation documentation</i>\n*\n* \\par Runtime behavior\n*   To query the ROS graph is a synchronous operation.\n*   It is also non-blocking, but it is not guaranteed to be lock-free.\n*   Generally speaking, implementations may synchronize access to internal resources using\n*   locks but are not allowed to wait for events with no guaranteed time bound (barring\n*   the effects of starvation due to OS scheduling).\n*\n* \\par Thread-safety\n*   Nodes are thread-safe objects, and so are all operations on them except for finalization.\n*   Therefore, it is safe to query the ROS graph using the same node concurrently.\n*   However, access to primitive data-type arguments is not synchronized.\n*   It is not safe to read or write `service_name` or `count` while rmw_count_clients()\n*   uses them.\n*\n* \\pre Given `node` must be a valid node handle, as returned by rmw_create_node().\n*\n* \\param[in] node Handle to node to use to query the ROS graph.\n* \\param[in] service_name Fully qualified ROS topic name.\n* \\param[out] count Number of clients matching the given topic name.\n* \\return `RMW_RET_OK` if the query was successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `service_name` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `service_name` is not a fully qualified topic name,\n*   by rmw_validate_full_topic_name() definition, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `count` is NULL, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation\n*   identifier does not match this implementation, or\n* \\return `RMW_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rmw_count_clients(
        node: *const rmw_node_t,
        service_name: *const ::std::os::raw::c_char,
        count: *mut usize,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Count the number of known servers matching a service name.\n**\n* This function returns the numbers of servers of a given service in the ROS graph,\n* as discovered so far by the given node.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation defined, check the implementation documentation</i>\n*\n* \\par Runtime behavior\n*   To query the ROS graph is a synchronous operation.\n*   It is also non-blocking, but it is not guaranteed to be lock-free.\n*   Generally speaking, implementations may synchronize access to internal resources using\n*   locks but are not allowed to wait for events with no guaranteed time bound (barring\n*   the effects of starvation due to OS scheduling).\n*\n* \\par Thread-safety\n*   Nodes are thread-safe objects, and so are all operations on them except for finalization.\n*   Therefore, it is safe to query the ROS graph using the same node concurrently.\n*   However, access to primitive data-type arguments is not synchronized.\n*   It is not safe to read or write `service_name` or `count` while rmw_count_services()\n*   uses them.\n*\n* \\pre Given `node` must be a valid node handle, as returned by rmw_create_node().\n*\n* \\param[in] node Handle to node to use to query the ROS graph.\n* \\param[in] service_name Fully qualified ROS topic name.\n* \\param[out] count Number of services matching the given topic name.\n* \\return `RMW_RET_OK` if the query was successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `service_name` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `service_name` is not a fully qualified service name,\n*   by rmw_validate_full_topic_name() definition, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `count` is NULL, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation\n*   identifier does not match this implementation, or\n* \\return `RMW_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rmw_count_services(
        node: *const rmw_node_t,
        service_name: *const ::std::os::raw::c_char,
        count: *mut usize,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Get the globally unique identifier (GID) of a publisher.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n*\n* <i>[1] implementation defined, check implementation documentation.</i>\n*\n* \\par Thread-safety\n*   Publishers are thread-safe objects, and so are all operations on them except for\n*   finalization.\n*   Therefore, it is safe to get the unique identifier from the same publisher concurrently.\n*   However, access to the GID is not synchronized.\n*   It is not safe to read or write `gid` while rmw_get_gid_for_publisher() uses it.\n*\n* \\pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().\n*\n* This is expected to be globally unique within a ROS domain.\n* The identifier should be the same when reported both locally (where the entity was created)\n* and on remote hosts or processes.\n*\n* \\param[in] publisher Publisher to get a GID from.\n* \\param[out] gid Publisher's unique identifier, populated on success\n*   but left unchanged on failure.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `gid` is NULL, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `publisher` implementation\n*   identifier does not match this implementation, or\n* \\return `RMW_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rmw_get_gid_for_publisher(
        publisher: *const rmw_publisher_t,
        gid: *mut rmw_gid_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Get the globally unique identifier (GID) of a service client.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n*\n* <i>[1] implementation defined, check implementation documentation.</i>\n*\n* \\par Thread-safety\n*   Service clients are thread-safe objects, and so are all operations on them except for\n*   finalization.\n*   Therefore, it is safe to get the unique identifier from the same client concurrently.\n*   However, access to the GID is not synchronized.\n*   It is not safe to read or write `gid` while rmw_get_gid_for_client() uses it.\n*\n* \\pre Given `client` must be a valid service client, as returned by rmw_create_client().\n*\n* This is expected to be globally unique within a ROS domain.\n* The identifier should be the same when reported both locally (where the entity was created)\n* and on remote hosts or processes.\n* \\param[in] client Service client to get a GID from.\n* \\param[out] gid Service client's unique identifier, populated on success\n*   but left unchanged on failure.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `gid` is NULL, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `client` implementation\n*   identifier does not match this implementation, or\n* \\return `RMW_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rmw_get_gid_for_client(client: *const rmw_client_t, gid: *mut rmw_gid_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Check if two globally unique identifiers (GIDs) are equal.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n*\n* <i>[1] implementation defined, check implementation documentation.</i>\n*\n* \\par Thread-safety\n*   Unique identifier comparison is a reentrant function, but:\n*   - Access to both GIDs is read-only but it is not synchronized.\n*     Concurrent `gid1` and `gid2` reads are safe, but concurrent reads and writes are not.\n*   - Access to primitive data-type arguments is not synchronized.\n*     It is not safe to read or write `result` while rmw_compare_gids_equal() uses it.\n*\n* \\param[in] gid1 First unique identifier to compare.\n* \\param[in] gid2 Second unique identifier to compare.\n* \\param[out] result true if both GIDs are equal, false otherwise.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `gid1` or `gid2` is NULL, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation\n*   identifier of `gid1` or `gid2` does not match this implementation, or\n* \\return `RMW_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rmw_compare_gids_equal(
        gid1: *const rmw_gid_t,
        gid2: *const rmw_gid_t,
        result: *mut bool,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Check if a service server is available for the given service client.\n**\n* This function checks whether one or more service services matching the\n* given service client exist in the ROS graph, as discovered so far by the\n* given local node.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n*\n* <i>[1] implementation defined, check implementation documentation.</i>\n*\n* \\par Runtime behavior\n*   To query the ROS graph is a synchronous operation.\n*   It is also non-blocking, but it is not guaranteed to be lock-free.\n*   Generally speaking, implementations may synchronize access to internal resources using\n*   locks but are not allowed to wait for events with no guaranteed time bound (barring\n*   the effects of starvation due to OS scheduling).\n*\n* \\pre Given `node` must be a valid node, as returned by rmw_create_node().\n* \\pre Given `client` must be a valid client, as returned by rmw_create_client().\n* \\pre Given `node` must be the one the `client` was registered with.\n*\n* \\param[in] node Node to query the ROS graph.\n* \\param[in] client Service client to look for matching service servers.\n* \\param[out] is_available True if there is a service server available, else false.\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `node` is `NULL`, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `client` is `NULL`, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `is_available` is `NULL`, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation\n*   identifier of `node` or `client` does not match this implementation, or\n* \\return `RMW_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rmw_service_server_is_available(
        node: *const rmw_node_t,
        client: *const rmw_client_t,
        is_available: *mut bool,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Set the current log severity\n**\n* \\param[in] severity The log severity to set\n* \\return RMW_RET_OK if successful, otherwise an appropriate error code\n*/"]
    pub fn rmw_set_log_severity(severity: rmw_log_severity_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Set the on new message callback function for the subscription.\n**\n* This API sets the callback function to be called whenever the\n* subscription is notified about a new message.\n*\n* This callback is called for each new message received by the subscription.\n* If messages arrive before the callback is registered, the number_of_events\n* argument given to the callback may be > 1.\n*\n* The callback may be called from a thread that the rmw implementation\n* created, rather than a thread owned by the user, i.e. some thread other\n* than user owned threads calling rmw functions such as rmw_wait() or\n* rmw_publish().\n*\n* This function is thread-safe.\n* This is required of the rmw implementation because the callback may be called\n* from any middleware thread, and this function could be called by the user\n* at any time.\n*\n* \\param[in] subscription The subscription on which to set the callback\n* \\param[in] callback The callback to be called when new messages arrive,\n*   can be NULL to clear the registered callback\n* \\param[in] user_data Given to the callback when called later, may be NULL\n* \\return `RMW_RET_OK` if successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or\n* \\return `RMW_RET_UNSUPPORTED` if the API is not implemented in the dds implementation\n*/"]
    pub fn rmw_subscription_set_on_new_message_callback(
        subscription: *mut rmw_subscription_t,
        callback: rmw_event_callback_t,
        user_data: *const ::std::os::raw::c_void,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Set the on new request callback function for the service.\n**\n* This API sets the callback function to be called whenever the\n* service is notified about a new request.\n*\n* This callback is called for each new request received by the service.\n* If requests arrive before the callback is registered, the number_of_events\n* argument given to the callback may be > 1.\n*\n* The callback may be called from a thread that the rmw implementation\n* created, rather than a thread owned by the user, i.e. some thread other\n* than user owned threads calling rmw functions such as rmw_wait() or\n* rmw_send_request().\n*\n* This function is thread-safe.\n* This is required of the rmw implementation because the callback may be called\n* from any middleware thread, and this function could be called by the user\n* at any time.\n*\n* \\param[in] service The service on which to set the callback\n* \\param[in] callback The callback to be called when new requests arrive,\n*   can be NULL to clear the registered callback\n* \\param[in] user_data Given to the callback when called later, may be NULL\n* \\return `RMW_RET_OK` if callback was set to the listener, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `service` is NULL, or\n* \\return `RMW_RET_UNSUPPORTED` if the API is not implemented in the dds implementation\n*/"]
    pub fn rmw_service_set_on_new_request_callback(
        service: *mut rmw_service_t,
        callback: rmw_event_callback_t,
        user_data: *const ::std::os::raw::c_void,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Set the on new response callback function for the client.\n**\n* This API sets the callback function to be called whenever the\n* client is notified about a new response.\n*\n* This callback is called for each new response received by the client.\n* If responses arrive before the callback is registered, the number_of_events\n* argument given to the callback may be > 1.\n*\n* The callback may be called from a thread that the rmw implementation\n* created, rather than a thread owned by the user, i.e. some thread other\n* than user owned threads calling rmw functions such as rmw_wait() or\n* rmw_take_response().\n*\n* This function is thread-safe.\n* This is required of the rmw implementation because the callback may be called\n* from any middleware thread, and this function could be called by the user\n* at any time.\n*\n* \\param[in] client The client on which to set the callback\n* \\param[in] callback The callback to be called when new responses arrive,\n*   can be NULL to clear the registered callback\n* \\param[in] user_data Given to the callback when called later, may be NULL\n* \\return `RMW_RET_OK` if callback was set to the listener, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `client` is NULL, or\n* \\return `RMW_RET_UNSUPPORTED` if the API is not implemented in the dds implementation\n*/"]
    pub fn rmw_client_set_on_new_response_callback(
        client: *mut rmw_client_t,
        callback: rmw_event_callback_t,
        user_data: *const ::std::os::raw::c_void,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Set the callback function for the event.\n**\n* This API sets the callback function to be called whenever the\n* event is notified about a new instance of the event.\n*\n* For example, this could be called when incompatible QoS is detected, or\n* a deadline is missed, or any other QoS event.\n*\n* This callback is called for each new event that occurs for this rmw_event_t\n* instance.\n* If events occur before the callback is registered, the number_of_events\n* argument given to the callback may be > 1.\n*\n* The callback may be called from a thread that the rmw implementation\n* created, rather than a thread owned by the user, i.e. some thread other\n* than user owned threads calling rmw functions such as rmw_wait() or\n* rmw_publish().\n*\n* This function is thread-safe.\n* This is required of the rmw implementation because the callback may be called\n* from any middleware thread, and this function could be called by the user\n* at any time.\n*\n* \\param[in] event The event on which to set the callback\n* \\param[in] callback The callback to be called when new events occur,\n*   can be NULL to clear the registered callback\n* \\param[in] user_data Given to the callback when called later, may be NULL\n* \\return `RMW_RET_OK` if callback was set to the listener, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `event` is NULL, or\n* \\return `RMW_RET_UNSUPPORTED` if the API is not implemented in the dds implementation\n*/"]
    pub fn rmw_event_set_callback(
        event: *mut rmw_event_t,
        callback: rmw_event_callback_t,
        user_data: *const ::std::os::raw::c_void,
    ) -> rmw_ret_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_timer_impl_s {
    _unused: [u8; 0],
}
pub type rcl_timer_impl_t = rcl_timer_impl_s;
#[doc = " Structure which encapsulates a ROS Timer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_timer_s {
    #[doc = " Private implementation pointer."]
    pub impl_: *mut rcl_timer_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_timer_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_timer_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_timer_s>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_timer_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_timer_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_timer_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_timer_s),
            "::",
            stringify!(impl_)
        )
    );
}
#[doc = " Structure which encapsulates a ROS Timer."]
pub type rcl_timer_t = rcl_timer_s;
#[doc = " Structure which encapsulates the on reset callback data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_timer_on_reset_callback_data_s {
    pub on_reset_callback: rcl_event_callback_t,
    pub user_data: *const ::std::os::raw::c_void,
    pub reset_counter: usize,
}
#[test]
fn bindgen_test_layout_rcl_timer_on_reset_callback_data_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_timer_on_reset_callback_data_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_timer_on_reset_callback_data_s>(),
        24usize,
        concat!("Size of: ", stringify!(rcl_timer_on_reset_callback_data_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_timer_on_reset_callback_data_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rcl_timer_on_reset_callback_data_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_reset_callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_timer_on_reset_callback_data_s),
            "::",
            stringify!(on_reset_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_timer_on_reset_callback_data_s),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reset_counter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_timer_on_reset_callback_data_s),
            "::",
            stringify!(reset_counter)
        )
    );
}
#[doc = " Structure which encapsulates the on reset callback data"]
pub type rcl_timer_on_reset_callback_data_t = rcl_timer_on_reset_callback_data_s;
#[doc = " User callback signature for timers.\n**\n* The first argument the callback gets is a pointer to the timer.\n* This can be used to cancel the timer, query the time until the next\n* timer callback, exchange the callback with a different one, etc.\n*\n* The only caveat is that the function rcl_timer_get_time_since_last_call()\n* will return the time since just before this callback was called, not the\n* previous call.\n* Therefore the second argument given is the time since the previous callback\n* was called, because that information is no longer accessible via the timer.\n* The time since the last callback call is given in nanoseconds.\n*/"]
pub type rcl_timer_callback_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut rcl_timer_t, arg2: i64)>;
extern "C" {
    #[doc = " Return a zero initialized timer."]
    pub fn rcl_get_zero_initialized_timer() -> rcl_timer_t;
}
extern "C" {
    #[doc = " Initialize a timer.\n**\n* A timer consists of a clock, a callback function and a period.\n* A timer can be added to a wait set and waited on, such that the wait set\n* will wake up when a timer is ready to be executed.\n*\n* A timer simply holds state and does not automatically call callbacks.\n* It does not create any threads, register interrupts, or consume signals.\n* For blocking behavior it can be used in conjunction with a wait set and\n* rcl_wait().\n* When rcl_timer_is_ready() returns true, the timer must still be called\n* explicitly using rcl_timer_call().\n*\n* The timer handle must be a pointer to an allocated and zero initialized\n* rcl_timer_t struct.\n* Calling this function on an already initialized timer will fail.\n* Calling this function on a timer struct which has been allocated but not\n* zero initialized is undefined behavior.\n*\n* The clock handle must be a pointer to an initialized rcl_clock_t struct.\n* The life time of the clock must exceed the life time of the timer.\n*\n* The period is a non-negative duration (rather an absolute time in the\n* future).\n* If the period is `0` then it will always be ready.\n*\n* The callback is an optional argument.\n* Valid inputs are either a pointer to the function callback, or `NULL` to\n* indicate that no callback will be stored in rcl.\n* If the callback is `NULL`, the caller client library is responsible for\n* firing the timer callback.\n* Else, it must be a function which returns void and takes two arguments,\n* the first being a pointer to the associated timer, and the second a int64_t\n* which is the time since the previous call, or since the timer was created\n* if it is the first call to the callback.\n*\n* Expected usage:\n*\n* ```c\n* #include <rcl/rcl.h>\n*\n* void my_timer_callback(rcl_timer_t * timer, int64_t last_call_time)\n* {\n*   // Do timer work...\n*   // Optionally reconfigure, cancel, or reset the timer...\n* }\n*\n* rcl_context_t * context;  // initialized previously by rcl_init()...\n* rcl_clock_t clock;\n* rcl_allocator_t allocator = rcl_get_default_allocator();\n* rcl_ret_t ret = rcl_clock_init(RCL_STEADY_TIME, &clock, &allocator);\n* // ... error handling\n*\n* rcl_timer_t timer = rcl_get_zero_initialized_timer();\n* ret = rcl_timer_init(\n*   &timer, &clock, context, RCL_MS_TO_NS(100), my_timer_callback, allocator);\n* // ... error handling, use the timer with a wait set, or poll it manually, then cleanup\n* ret = rcl_timer_fini(&timer);\n* // ... error handling\n* ```\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | Yes\n* Lock-Free          | Yes [1][2][3]\n* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uintptr_t`</i>\n*\n* <i>[2] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>\n*\n* <i>[3] if `atomic_is_lock_free()` returns true for `atomic_bool`</i>\n*\n* \\param[inout] timer the timer handle to be initialized\n* \\param[in] clock the clock providing the current time\n* \\param[in] context the context that this timer is to be associated with\n* \\param[in] period the duration between calls to the callback in nanoseconds\n* \\param[in] callback the user defined function to be called every period\n* \\param[in] allocator the allocator to use for allocations\n* \\return #RCL_RET_OK if the timer was initialized successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ALREADY_INIT if the timer was already initialized, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_timer_init(
        timer: *mut rcl_timer_t,
        clock: *mut rcl_clock_t,
        context: *mut rcl_context_t,
        period: i64,
        callback: rcl_timer_callback_t,
        allocator: rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a timer.\n**\n* This function will deallocate any memory and make the timer invalid.\n*\n* A timer that is already invalid (zero initialized) or `NULL` will not fail.\n*\n* This function is not thread-safe with any rcl_timer_* functions used on the\n* same timer object.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | Yes\n* Lock-Free          | Yes [1][2][3]\n* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uintptr_t`</i>\n*\n* <i>[2] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>\n*\n* <i>[3] if `atomic_is_lock_free()` returns true for `atomic_bool`</i>\n*\n* \\param[inout] timer the handle to the timer to be finalized.\n* \\return #RCL_RET_OK if the timer was finalized successfully, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_timer_fini(timer: *mut rcl_timer_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Call the timer's callback and set the last call time.\n**\n* This function will call the callback and change the last call time even if\n* the timer's period has not yet elapsed.\n* It is up to the calling code to make sure the period has elapsed by first\n* calling rcl_timer_is_ready().\n* If the callback pointer is `NULL` (either set in init or exchanged after\n* initialized), no callback is fired.\n* However, this function should still be called by the client library to\n* update the state of the timer.\n* The order of operations in this command are as follows:\n*\n*  - Ensure the timer has not been canceled.\n*  - Get the current time into a temporary rcl_steady_time_point_t.\n*  - Exchange the current time with the last call time of the timer.\n*  - Call the callback, passing this timer and the time since the last call.\n*  - Return after the callback has completed.\n*\n* During the callback the timer can be canceled or have its period and/or\n* callback modified.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes [1]\n* Uses Atomics       | Yes\n* Lock-Free          | Yes [2]\n* <i>[1] user callback might not be thread-safe</i>\n*\n* <i>[2] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>\n*\n* \\param[inout] timer the handle to the timer to call\n* \\return #RCL_RET_OK if the timer was called successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_TIMER_INVALID if the timer->impl is invalid, or\n* \\return #RCL_RET_TIMER_CANCELED if the timer has been canceled, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_timer_call(timer: *mut rcl_timer_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Retrieve the clock of the timer.\n**\n* This function retrieves the clock pointer and copies it into the given variable.\n*\n* The clock argument must be a pointer to an already allocated rcl_clock_t *.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] timer the handle to the timer which is being queried\n* \\param[out] clock the rcl_clock_t * in which the clock is stored\n* \\return #RCL_RET_OK if the clock was retrieved successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_TIMER_INVALID if the timer is invalid.\n*/"]
    pub fn rcl_timer_clock(timer: *mut rcl_timer_t, clock: *mut *mut rcl_clock_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Calculates whether or not the timer should be called.\n**\n* The result is true if the time until next call is less than, or equal to, 0\n* and the timer has not been canceled.\n* Otherwise the result is false, indicating the timer should not be called.\n*\n* The is_ready argument must point to an allocated bool object, as the result\n* is copied into it.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Yes\n* Lock-Free          | Yes [1]\n* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>\n*\n* \\param[in] timer the handle to the timer which is being checked\n* \\param[out] is_ready the bool used to store the result of the calculation\n* \\return #RCL_RET_OK if the last call time was retrieved successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_TIMER_INVALID if the timer->impl is invalid, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_timer_is_ready(timer: *const rcl_timer_t, is_ready: *mut bool) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Calculate and retrieve the time until the next call in nanoseconds.\n**\n* This function calculates the time until the next call by adding the timer's\n* period to the last call time and subtracting that sum from the current time.\n* The calculated time until the next call can be positive, indicating that it\n* is not ready to be called as the period has not elapsed since the last call.\n* The calculated time until the next call can also be 0 or negative,\n* indicating that the period has elapsed since the last call and the timer\n* should be called.\n* A negative value indicates the timer call is overdue by that amount.\n*\n* The `time_until_next_call` argument must point to an allocated int64_t, as\n* the time until is copied into that instance.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Yes\n* Lock-Free          | Yes [1]\n* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>\n*\n* \\param[in] timer the handle to the timer that is being queried\n* \\param[out] time_until_next_call the output variable for the result\n* \\return #RCL_RET_OK if the timer until next call was successfully calculated, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_TIMER_INVALID if the timer->impl is invalid, or\n* \\return #RCL_RET_TIMER_CANCELED if the timer is canceled, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_timer_get_time_until_next_call(
        timer: *const rcl_timer_t,
        time_until_next_call: *mut i64,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Retrieve the time since the previous call to rcl_timer_call() occurred.\n**\n* This function calculates the time since the last call and copies it into\n* the given int64_t variable.\n*\n* Calling this function within a callback will not return the time since the\n* previous call but instead the time since the current callback was called.\n*\n* The time_since_last_call argument must be a pointer to an already allocated\n* int64_t.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Yes\n* Lock-Free          | Yes [1]\n* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>\n*\n* \\param[in] timer the handle to the timer which is being queried\n* \\param[out] time_since_last_call the struct in which the time is stored\n* \\return #RCL_RET_OK if the last call time was retrieved successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_TIMER_INVALID if the timer->impl is invalid, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_timer_get_time_since_last_call(
        timer: *const rcl_timer_t,
        time_since_last_call: *mut i64,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Retrieve the period of the timer.\n**\n* This function retrieves the period and copies it into the given variable.\n*\n* The period argument must be a pointer to an already allocated int64_t.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Yes\n* Lock-Free          | Yes [1]\n* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>\n*\n* \\param[in] timer the handle to the timer which is being queried\n* \\param[out] period the int64_t in which the period is stored\n* \\return #RCL_RET_OK if the period was retrieved successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_TIMER_INVALID if the timer->impl is invalid, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_timer_get_period(timer: *const rcl_timer_t, period: *mut i64) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Exchange the period of the timer and return the previous period.\n**\n* This function exchanges the period in the timer and copies the old one into\n* the given variable.\n*\n* Exchanging (changing) the period will not affect already waiting wait sets.\n*\n* The old_period argument must be a pointer to an already allocated int64_t.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Yes\n* Lock-Free          | Yes [1]\n* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>\n*\n* \\param[in] timer the handle to the timer which is being modified\n* \\param[out] new_period the int64_t to exchange into the timer\n* \\param[out] old_period the int64_t in which the previous period is stored\n* \\return #RCL_RET_OK if the period was retrieved successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_TIMER_INVALID if the timer->impl is invalid, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_timer_exchange_period(
        timer: *const rcl_timer_t,
        new_period: i64,
        old_period: *mut i64,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the current timer callback.\n**\n* This function can fail, and therefore return `NULL`, if:\n*   - timer is `NULL`\n*   - timer has not been initialized (the implementation is invalid)\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Yes\n* Lock-Free          | Yes [1]\n* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>\n*\n* \\param[in] timer handle to the timer from the callback should be returned\n* \\return function pointer to the callback, or `NULL` if an error occurred\n*/"]
    pub fn rcl_timer_get_callback(timer: *const rcl_timer_t) -> rcl_timer_callback_t;
}
extern "C" {
    #[doc = " Exchange the current timer callback and return the current callback.\n**\n* This function can fail, and therefore return `NULL`, if:\n*   - timer is `NULL`\n*   - timer has not been initialized (the implementation is invalid)\n*\n* This function can set callback to `NULL`, in which case the callback is\n* ignored when rcl_timer_call is called.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Yes\n* Lock-Free          | Yes [1]\n* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>\n*\n* \\param[inout] timer handle to the timer from the callback should be exchanged\n* \\param[in] new_callback the callback to be exchanged into the timer\n* \\return function pointer to the old callback, or `NULL` if an error occurred\n*/"]
    pub fn rcl_timer_exchange_callback(
        timer: *mut rcl_timer_t,
        new_callback: rcl_timer_callback_t,
    ) -> rcl_timer_callback_t;
}
extern "C" {
    #[doc = " Cancel a timer.\n**\n* When a timer is canceled, rcl_timer_is_ready() will return false for that\n* timer, and rcl_timer_call() will fail with RCL_RET_TIMER_CANCELED.\n*\n* A canceled timer can be reset with rcl_timer_reset(), and then used again.\n* Calling this function on an already canceled timer will succeed.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Yes\n* Lock-Free          | Yes [1]\n* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>\n*\n* \\param[inout] timer the timer to be canceled\n* \\return #RCL_RET_OK if the timer was canceled successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_TIMER_INVALID if the timer is invalid.\n*/"]
    pub fn rcl_timer_cancel(timer: *mut rcl_timer_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Retrieve the canceled state of a timer.\n**\n* If the timer is canceled true will be stored in the is_canceled argument.\n* Otherwise false will be stored in the is_canceled argument.\n*\n* The is_canceled argument must point to an allocated bool, as the result is\n* copied into this variable.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Yes\n* Lock-Free          | Yes [1]\n* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_bool`</i>\n*\n* \\param[in] timer the timer to be queried\n* \\param[out] is_canceled storage for the is canceled bool\n* \\return #RCL_RET_OK if the last call time was retrieved successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_TIMER_INVALID if the timer->impl is invalid, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_timer_is_canceled(timer: *const rcl_timer_t, is_canceled: *mut bool) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Reset a timer.\n**\n* This function can be called on a timer, canceled or not.\n* For all timers it will reset the last call time to now.\n* For canceled timers it will additionally make the timer not canceled.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Yes\n* Lock-Free          | Yes [1]\n* <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>\n*\n* \\param[inout] timer the timer to be reset\n* \\return #RCL_RET_OK if the timer was reset successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_TIMER_INVALID if the timer is invalid, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_timer_reset(timer: *mut rcl_timer_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the allocator for the timer.\n**\n* This function can fail, and therefore return `NULL`, if:\n*   - timer is `NULL`\n*   - timer has not been initialized (the implementation is invalid)\n*\n* The returned pointer is only valid as long as the timer object is valid.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] timer handle to the timer object\n* \\return pointer to the allocator, or `NULL` if an error occurred\n*/"]
    pub fn rcl_timer_get_allocator(timer: *const rcl_timer_t) -> *const rcl_allocator_t;
}
extern "C" {
    #[doc = " Retrieve a guard condition used by the timer to wake the waitset when using ROSTime.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] timer the timer to be queried\n* \\return `NULL` if the timer is invalid or does not have a guard condition, or\n* \\return a guard condition pointer.\n*/"]
    pub fn rcl_timer_get_guard_condition(timer: *const rcl_timer_t) -> *mut rcl_guard_condition_t;
}
extern "C" {
    #[doc = " Set the on reset callback function for the timer.\n**\n* This API sets the callback function to be called whenever the\n* timer is reset.\n* If the timer has already been reset, the callback will be called.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | No\n*\n* \\param[in] timer The handle to the timer on which to set the callback\n* \\param[in] on_reset_callback The callback to be called when timer is reset\n* \\param[in] user_data Given to the callback when called later, may be NULL\n* \\return `RCL_RET_OK` if successful, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if `timer` is NULL\n*/"]
    pub fn rcl_timer_set_on_reset_callback(
        timer: *const rcl_timer_t,
        on_reset_callback: rcl_event_callback_t,
        user_data: *const ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
pub const rcl_publisher_event_type_e_RCL_PUBLISHER_OFFERED_DEADLINE_MISSED:
    rcl_publisher_event_type_e = 0;
pub const rcl_publisher_event_type_e_RCL_PUBLISHER_LIVELINESS_LOST: rcl_publisher_event_type_e = 1;
pub const rcl_publisher_event_type_e_RCL_PUBLISHER_OFFERED_INCOMPATIBLE_QOS:
    rcl_publisher_event_type_e = 2;
pub const rcl_publisher_event_type_e_RCL_PUBLISHER_INCOMPATIBLE_TYPE: rcl_publisher_event_type_e =
    3;
pub const rcl_publisher_event_type_e_RCL_PUBLISHER_MATCHED: rcl_publisher_event_type_e = 4;
#[doc = " Enumeration of all of the publisher events that may fire."]
pub type rcl_publisher_event_type_e = ::std::os::raw::c_uint;
#[doc = " Enumeration of all of the publisher events that may fire."]
pub use self::rcl_publisher_event_type_e as rcl_publisher_event_type_t;
pub const rcl_subscription_event_type_e_RCL_SUBSCRIPTION_REQUESTED_DEADLINE_MISSED:
    rcl_subscription_event_type_e = 0;
pub const rcl_subscription_event_type_e_RCL_SUBSCRIPTION_LIVELINESS_CHANGED:
    rcl_subscription_event_type_e = 1;
pub const rcl_subscription_event_type_e_RCL_SUBSCRIPTION_REQUESTED_INCOMPATIBLE_QOS:
    rcl_subscription_event_type_e = 2;
pub const rcl_subscription_event_type_e_RCL_SUBSCRIPTION_MESSAGE_LOST:
    rcl_subscription_event_type_e = 3;
pub const rcl_subscription_event_type_e_RCL_SUBSCRIPTION_INCOMPATIBLE_TYPE:
    rcl_subscription_event_type_e = 4;
pub const rcl_subscription_event_type_e_RCL_SUBSCRIPTION_MATCHED: rcl_subscription_event_type_e = 5;
#[doc = " Enumeration of all of the subscription events that may fire."]
pub type rcl_subscription_event_type_e = ::std::os::raw::c_uint;
#[doc = " Enumeration of all of the subscription events that may fire."]
pub use self::rcl_subscription_event_type_e as rcl_subscription_event_type_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_event_impl_s {
    _unused: [u8; 0],
}
#[doc = " Internal rcl implementation struct."]
pub type rcl_event_impl_t = rcl_event_impl_s;
#[doc = " Structure which encapsulates a ROS QoS event handle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_event_s {
    #[doc = " Pointer to the event implementation"]
    pub impl_: *mut rcl_event_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_event_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_event_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_event_s>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_event_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_event_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_event_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_event_s),
            "::",
            stringify!(impl_)
        )
    );
}
#[doc = " Structure which encapsulates a ROS QoS event handle."]
pub type rcl_event_t = rcl_event_s;
extern "C" {
    #[doc = " Return a rcl_event_t struct with members set to `NULL`.\n**\n* Should be called to get a null rcl_event_t before passing to\n* rcl_event_init().\n*\n* \\return Zero initialized rcl_event_t.\n*/"]
    pub fn rcl_get_zero_initialized_event() -> rcl_event_t;
}
extern "C" {
    #[doc = " Initialize an rcl_event_t with a publisher.\n**\n* Fill the rcl_event_t with the publisher and desired event_type.\n*\n* \\param[in,out] event pointer to fill\n* \\param[in] publisher to get events from\n* \\param[in] event_type to listen for\n* \\return #RCL_RET_OK if the rcl_event_t is filled, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory fails, or\n* \\return #RCL_RET_UNSUPPORTED if event_type is not supported, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_publisher_event_init(
        event: *mut rcl_event_t,
        publisher: *const rcl_publisher_t,
        event_type: rcl_publisher_event_type_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Initialize an rcl_event_t with a subscription.\n**\n* Fill the rcl_event_t with the subscription and desired event_type.\n*\n* \\param[in,out] event pointer to fill\n* \\param[in] subscription to get events from\n* \\param[in] event_type to listen for\n* \\return #RCL_RET_OK if the rcl_event_t is filled, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory fails, or\n* \\return #RCL_RET_UNSUPPORTED if event_type is not supported, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_subscription_event_init(
        event: *mut rcl_event_t,
        subscription: *const rcl_subscription_t,
        event_type: rcl_subscription_event_type_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take an event from the event handle.\n\n \\param[in] event event object to take from\n \\param[in, out] event_info event info object to write taken data into\n \\return #RCL_RET_OK if successful, or\n \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n \\return #RCL_RET_BAD_ALLOC if memory allocation failed, or\n \\return #RCL_RET_EVENT_TAKE_FAILED if the take event failed, or\n \\return #RCL_RET_ERROR if an unexpected error occurs."]
    pub fn rcl_take_event(
        event: *const rcl_event_t,
        event_info: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize an event.\n\n \\param[in] event to finalize\n \\return #RCL_RET_OK if successful, or\n \\return #RCL_RET_EVENT_INVALID if event is null, or\n \\return #RCL_RET_ERROR if an unexpected error occurs."]
    pub fn rcl_event_fini(event: *mut rcl_event_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the rmw event handle.\n**\n* The handle returned is a pointer to the internally held rmw handle.\n* This function can fail, and therefore return `NULL`, if the:\n*   - event is `NULL`\n*   - event is invalid (never called init, called fini, or invalid node)\n*\n* The returned handle is made invalid if the event is finalized or if\n* rcl_shutdown() is called.\n* The returned handle is not guaranteed to be valid for the life time of the\n* event as it may be finalized and recreated itself.\n* Therefore it is recommended to get the handle from the event using\n* this function each time it is needed and avoid use of the handle\n* concurrently with functions that might change it.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] event pointer to the rcl event\n* \\return rmw event handle if successful, otherwise `NULL`\n*/"]
    pub fn rcl_event_get_rmw_handle(event: *const rcl_event_t) -> *mut rmw_event_t;
}
extern "C" {
    #[doc = " Check that the event is valid.\n**\n* The bool returned is `false` if `event` is invalid.\n* The bool returned is `true` otherwise.\n* In the case where `false` is to be returned, an error message is set.\n* This function cannot fail.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] event pointer to the rcl event\n* \\return `true` if `event` is valid, otherwise `false`\n*/"]
    pub fn rcl_event_is_valid(event: *const rcl_event_t) -> bool;
}
extern "C" {
    #[doc = " Set the callback function for the event.\n**\n* This API sets the callback function to be called whenever the\n* event is notified about a new instance of the event.\n*\n* \\sa rmw_event_set_callback for more details about this function.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined</i>\n*\n* \\param[in] event The event on which to set the callback\n* \\param[in] callback The callback to be called when new events occur, may be NULL\n* \\param[in] user_data Given to the callback when called later, may be NULL\n* \\return `RCL_RET_OK` if callback was set to the listener, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if `event` is NULL, or\n* \\return `RCL_RET_UNSUPPORTED` if the API is not implemented in the dds implementation\n*/"]
    pub fn rcl_event_set_callback(
        event: *const rcl_event_t,
        callback: rcl_event_callback_t,
        user_data: *const ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_wait_set_impl_s {
    _unused: [u8; 0],
}
pub type rcl_wait_set_impl_t = rcl_wait_set_impl_s;
#[doc = " Container for subscription's, guard condition's, etc to be waited on."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_wait_set_s {
    #[doc = " Storage for subscription pointers."]
    pub subscriptions: *mut *const rcl_subscription_t,
    #[doc = " Number of subscriptions"]
    pub size_of_subscriptions: usize,
    #[doc = " Storage for guard condition pointers."]
    pub guard_conditions: *mut *const rcl_guard_condition_t,
    #[doc = " Number of guard_conditions"]
    pub size_of_guard_conditions: usize,
    #[doc = " Storage for timer pointers."]
    pub timers: *mut *const rcl_timer_t,
    #[doc = " Number of timers"]
    pub size_of_timers: usize,
    #[doc = " Storage for client pointers."]
    pub clients: *mut *const rcl_client_t,
    #[doc = " Number of clients"]
    pub size_of_clients: usize,
    #[doc = " Storage for service pointers."]
    pub services: *mut *const rcl_service_t,
    #[doc = " Number of services"]
    pub size_of_services: usize,
    #[doc = " Storage for event pointers."]
    pub events: *mut *const rcl_event_t,
    #[doc = " Number of events"]
    pub size_of_events: usize,
    #[doc = " Implementation specific storage."]
    pub impl_: *mut rcl_wait_set_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_wait_set_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_wait_set_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_wait_set_s>(),
        104usize,
        concat!("Size of: ", stringify!(rcl_wait_set_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_wait_set_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_wait_set_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subscriptions) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_wait_set_s),
            "::",
            stringify!(subscriptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size_of_subscriptions) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_wait_set_s),
            "::",
            stringify!(size_of_subscriptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guard_conditions) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_wait_set_s),
            "::",
            stringify!(guard_conditions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size_of_guard_conditions) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_wait_set_s),
            "::",
            stringify!(size_of_guard_conditions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timers) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_wait_set_s),
            "::",
            stringify!(timers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size_of_timers) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_wait_set_s),
            "::",
            stringify!(size_of_timers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clients) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_wait_set_s),
            "::",
            stringify!(clients)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size_of_clients) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_wait_set_s),
            "::",
            stringify!(size_of_clients)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).services) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_wait_set_s),
            "::",
            stringify!(services)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size_of_services) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_wait_set_s),
            "::",
            stringify!(size_of_services)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_wait_set_s),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size_of_events) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_wait_set_s),
            "::",
            stringify!(size_of_events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_wait_set_s),
            "::",
            stringify!(impl_)
        )
    );
}
#[doc = " Container for subscription's, guard condition's, etc to be waited on."]
pub type rcl_wait_set_t = rcl_wait_set_s;
extern "C" {
    #[doc = " Return a rcl_wait_set_t struct with members set to `NULL`."]
    pub fn rcl_get_zero_initialized_wait_set() -> rcl_wait_set_t;
}
extern "C" {
    #[doc = " Initialize a rcl wait set with space for items to be waited on.\n**\n* This function allocates space for the subscriptions and other wait-able\n* entities that can be stored in the wait set.\n* It also sets the allocator to the given allocator and initializes the pruned\n* member to be false.\n*\n* The wait_set struct should be allocated and initialized to `NULL`.\n* If the wait_set is allocated but the memory is uninitialized the behavior is\n* undefined.\n* Calling this function on a wait set that has already been initialized will\n* result in an error.\n* A wait set can be reinitialized if rcl_wait_set_fini() was called on it.\n*\n* To use the default allocator use rcl_get_default_allocator().\n*\n* Expected usage:\n*\n* ```c\n* #include <rcl/wait.h>\n*\n* rcl_wait_set_t wait_set = rcl_get_zero_initialized_wait_set();\n* rcl_ret_t ret =\n*   rcl_wait_set_init(&wait_set, 42, 42, 42, 42, 42, &context, rcl_get_default_allocator());\n* // ... error handling, then use it, then call the matching fini:\n* ret = rcl_wait_set_fini(&wait_set);\n* // ... error handling\n* ```\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] wait_set the wait set struct to be initialized\n* \\param[in] number_of_subscriptions non-zero size of the subscriptions set\n* \\param[in] number_of_guard_conditions non-zero size of the guard conditions set\n* \\param[in] number_of_timers non-zero size of the timers set\n* \\param[in] number_of_clients non-zero size of the clients set\n* \\param[in] number_of_services non-zero size of the services set\n* \\param[in] number_of_events non-zero size of the events set\n* \\param[in] context the context that the wait set should be associated with\n* \\param[in] allocator the allocator to use when allocating space in the sets\n* \\return #RCL_RET_OK if the wait set is initialized successfully, or\n* \\return #RCL_RET_ALREADY_INIT if the wait set is not zero initialized, or\n* \\return #RCL_RET_NOT_INIT if the given context is invalid, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_WAIT_SET_INVALID if the wait set is not destroyed properly, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_wait_set_init(
        wait_set: *mut rcl_wait_set_t,
        number_of_subscriptions: usize,
        number_of_guard_conditions: usize,
        number_of_timers: usize,
        number_of_clients: usize,
        number_of_services: usize,
        number_of_events: usize,
        context: *mut rcl_context_t,
        allocator: rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a rcl wait set.\n**\n* Deallocates any memory in the wait set that was allocated in\n* rcl_wait_set_init() using the allocator given in the initialization.\n*\n* Calling this function on a zero initialized wait set will do nothing and\n* return RCL_RET_OK.\n* Calling this function on uninitialized memory results in undefined behavior.\n* After calling this function the wait set will once again be zero initialized\n* and so calling this function or rcl_wait_set_init() immediately after will\n* succeed.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] wait_set the wait set struct to be finalized.\n* \\return #RCL_RET_OK if the finalization was successful, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_WAIT_SET_INVALID if the wait set is not destroyed properly, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_wait_set_fini(wait_set: *mut rcl_wait_set_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Retrieve the wait set's allocator.\n**\n* The allocator must be an allocated rcl_allocator_t struct, as the result is\n* copied into this variable.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] wait_set the handle to the wait set\n* \\param[out] allocator the rcl_allocator_t struct to which the result is copied\n* \\return #RCL_RET_OK if the allocator was successfully retrieved, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_WAIT_SET_INVALID if the wait set is invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_wait_set_get_allocator(
        wait_set: *const rcl_wait_set_t,
        allocator: *mut rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Store a pointer to the given subscription in the next empty spot in the set.\n**\n* This function does not guarantee that the subscription is not already in the\n* wait set.\n*\n* Also add the rmw representation to the underlying rmw array and increment\n* the rmw array count.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] wait_set struct in which the subscription is to be stored\n* \\param[in] subscription the subscription to be added to the wait set\n* \\param[out] index the index of the added subscription in the storage container.\n*   This parameter is optional and can be set to `NULL` to be ignored.\n* \\return #RCL_RET_OK if added successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_WAIT_SET_INVALID if the wait set is zero initialized, or\n* \\return #RCL_RET_WAIT_SET_FULL if the subscription set is full, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_wait_set_add_subscription(
        wait_set: *mut rcl_wait_set_t,
        subscription: *const rcl_subscription_t,
        index: *mut usize,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Remove (sets to `NULL`) all entities in the wait set.\n**\n* This function should be used after passing using rcl_wait, but before\n* adding new entities to the set.\n* Sets all of the entries in the underlying rmw array to `NULL`, and sets the\n* count in the rmw array to `0`.\n*\n* Calling this on an uninitialized (zero initialized) wait set will fail.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] wait_set struct to have its entities cleared\n* \\return #RCL_RET_OK if cleared successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_WAIT_SET_INVALID if the wait set is zero initialized, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_wait_set_clear(wait_set: *mut rcl_wait_set_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Reallocate space for entities in the wait set.\n**\n* This function will deallocate and reallocate the memory for all entity sets.\n*\n* A size of 0 will just deallocate the memory and assign `NULL` to the array.\n*\n* Allocation and deallocation is done with the allocator given during the\n* wait set's initialization.\n*\n* After calling this function all values in the set will be set to `NULL`,\n* effectively the same as calling rcl_wait_set_clear().\n* Similarly, the underlying rmw representation is reallocated and reset:\n* all entries are set to `NULL` and the count is set to zero.\n*\n* If the requested size matches the current size, no allocation will be done.\n*\n* This can be called on an uninitialized (zero initialized) wait set.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] wait_set struct to be resized\n* \\param[in] subscriptions_size a size for the new subscriptions set\n* \\param[in] guard_conditions_size a size for the new guard conditions set\n* \\param[in] timers_size a size for the new timers set\n* \\param[in] clients_size a size for the new clients set\n* \\param[in] services_size a size for the new services set\n* \\param[in] events_size a size for the new events set\n* \\return #RCL_RET_OK if resized successfully, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_wait_set_resize(
        wait_set: *mut rcl_wait_set_t,
        subscriptions_size: usize,
        guard_conditions_size: usize,
        timers_size: usize,
        clients_size: usize,
        services_size: usize,
        events_size: usize,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Store a pointer to the guard condition in the next empty spot in the set.\n**\n* This function behaves exactly the same as for subscriptions.\n* \\see rcl_wait_set_add_subscription\n*/"]
    pub fn rcl_wait_set_add_guard_condition(
        wait_set: *mut rcl_wait_set_t,
        guard_condition: *const rcl_guard_condition_t,
        index: *mut usize,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Store a pointer to the timer in the next empty spot in the set.\n**\n* This function behaves exactly the same as for subscriptions.\n* \\see rcl_wait_set_add_subscription\n*/"]
    pub fn rcl_wait_set_add_timer(
        wait_set: *mut rcl_wait_set_t,
        timer: *const rcl_timer_t,
        index: *mut usize,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Store a pointer to the client in the next empty spot in the set.\n**\n* This function behaves exactly the same as for subscriptions.\n* \\see rcl_wait_set_add_subscription\n*/"]
    pub fn rcl_wait_set_add_client(
        wait_set: *mut rcl_wait_set_t,
        client: *const rcl_client_t,
        index: *mut usize,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Store a pointer to the service in the next empty spot in the set.\n**\n* This function behaves exactly the same as for subscriptions.\n* \\see rcl_wait_set_add_subscription\n*/"]
    pub fn rcl_wait_set_add_service(
        wait_set: *mut rcl_wait_set_t,
        service: *const rcl_service_t,
        index: *mut usize,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Store a pointer to the event in the next empty spot in the set.\n**\n* This function behaves exactly the same as for subscriptions.\n* \\see rcl_wait_set_add_subscription\n*/"]
    pub fn rcl_wait_set_add_event(
        wait_set: *mut rcl_wait_set_t,
        event: *const rcl_event_t,
        index: *mut usize,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Block until the wait set is ready or until the timeout has been exceeded.\n**\n* This function will collect the items in the rcl_wait_set_t and pass them\n* to the underlying rmw_wait function.\n*\n* The items in the wait set will be either left untouched or set to `NULL` after\n* this function returns.\n* Items that are not `NULL` are ready, where ready means different things based\n* on the type of the item.\n* For subscriptions this means there may be messages that can be taken, or\n* perhaps that the state of the subscriptions has changed, in which case\n* rcl_take may succeed but return with taken == false.\n* For guard conditions this means the guard condition was triggered.\n*\n* Expected usage:\n*\n* ```c\n* #include <rcl/rcl.h>\n*\n* // rcl_init() called successfully before here...\n* rcl_node_t node;  // initialize this, see rcl_node_init()\n* rcl_subscription_t sub1;  // initialize this, see rcl_subscription_init()\n* rcl_subscription_t sub2;  // initialize this, see rcl_subscription_init()\n* rcl_guard_condition_t gc1;  // initialize this, see rcl_guard_condition_init()\n* rcl_wait_set_t wait_set = rcl_get_zero_initialized_wait_set();\n* rcl_ret_t ret = rcl_wait_set_init(&wait_set, 2, 1, 0, 0, 0, rcl_get_default_allocator());\n* // ... error handling\n* do {\n*   ret = rcl_wait_set_clear(&wait_set);\n*   // ... error handling\n*   ret = rcl_wait_set_add_subscription(&wait_set, &sub1);\n*   // ... error handling\n*   ret = rcl_wait_set_add_subscription(&wait_set, &sub2);\n*   // ... error handling\n*   ret = rcl_wait_set_add_guard_condition(&wait_set, &gc1);\n*   // ... error handling\n*   ret = rcl_wait(&wait_set, RCL_MS_TO_NS(1000));  // 1000ms == 1s, passed as ns\n*   if (ret == RCL_RET_TIMEOUT) {\n*     continue;\n*   }\n*   for (int i = 0; i < wait_set.size_of_subscriptions; ++i) {\n*     if (wait_set.subscriptions[i]) {\n*       // The subscription is ready...\n*     }\n*   }\n*   for (int i = 0; i < wait_set.size_of_guard_conditions; ++i) {\n*     if (wait_set.guard_conditions[i]) {\n*       // The subscription is ready...\n*     }\n*   }\n* } while(check_some_condition());\n* // ... fini node, and subscriptions and guard conditions...\n* ret = rcl_wait_set_fini(&wait_set);\n* // ... error handling\n* ```\n*\n* The wait set struct must be allocated, initialized, and should have been\n* cleared and then filled with items, e.g. subscriptions and guard conditions.\n* Passing a wait set with no wait-able items in it will fail.\n* `NULL` items in the sets are ignored, e.g. it is valid to have as input:\n*  - `subscriptions[0]` = valid pointer\n*  - `subscriptions[1]` = `NULL`\n*  - `subscriptions[2]` = valid pointer\n*  - `size_of_subscriptions` = 3\n* Passing an uninitialized (zero initialized) wait set struct will fail.\n* Passing a wait set struct with uninitialized memory is undefined behavior.\n*\n* The unit of timeout is nanoseconds.\n* If the timeout is negative then this function will block indefinitely until\n* something in the wait set is valid or it is interrupted.\n* If the timeout is 0 then this function will be non-blocking; checking what's\n* ready now, but not waiting if nothing is ready yet.\n* If the timeout is greater than 0 then this function will return after\n* that period of time has elapsed or the wait set becomes ready, which ever\n* comes first.\n* Passing a timeout struct with uninitialized memory is undefined behavior.\n*\n* This function is thread-safe for unique wait sets with unique contents.\n* This function cannot operate on the same wait set in multiple threads, and\n* the wait sets may not share content.\n* For example, calling rcl_wait() in two threads on two different wait sets\n* that both contain a single, shared guard condition is undefined behavior.\n*\n* \\param[inout] wait_set the set of things to be waited on and to be pruned if not ready\n* \\param[in] timeout the duration to wait for the wait set to be ready, in nanoseconds\n* \\return #RCL_RET_OK something in the wait set became ready, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_WAIT_SET_INVALID if the wait set is zero initialized, or\n* \\return #RCL_RET_WAIT_SET_EMPTY if the wait set contains no items, or\n* \\return #RCL_RET_TIMEOUT if the timeout expired before something was ready, or\n* \\return #RCL_RET_ERROR an unspecified error occur.\n*/"]
    pub fn rcl_wait(wait_set: *mut rcl_wait_set_t, timeout: i64) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return `true` if the wait set is valid, else `false`.\n**\n* A wait set is invalid if:\n*   - the implementation is `NULL` (rcl_wait_set_init not called or failed)\n*   - the wait set has been finalized with rcl_wait_set_fini\n*\n* Also return `false` if the wait set pointer is `NULL`.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] wait_set the rcl_wait_set_t to be validated\n* \\return `true` if the wait_set is valid, otherwise `false`.\n*/"]
    pub fn rcl_wait_set_is_valid(wait_set: *const rcl_wait_set_t) -> bool;
}
#[doc = " The function signature to log messages."]
pub type rcl_logging_output_handler_t = rcutils_logging_output_handler_t;
extern "C" {
    #[doc = " Configure the logging system.\n**\n* This function should be called during the ROS initialization process.\n* It will add the enabled log output appenders to the root logger.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] global_args The global arguments for the system\n* \\param[in] allocator Used to allocate memory used by the logging system\n* \\return #RCL_RET_OK if successful, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR if a general error occurs\n*/"]
    pub fn rcl_logging_configure(
        global_args: *const rcl_arguments_t,
        allocator: *const rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Configure the logging system with the provided output handler.\n**\n* Similar to rcl_logging_configure, but it uses the provided output handler.\n* \\sa rcl_logging_configure\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] global_args The global arguments for the system\n* \\param[in] allocator Used to allocate memory used by the logging system\n* \\param[in] output_handler Output handler to be installed\n* \\return #RCL_RET_OK if successful, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n* \\return #RCL_RET_ERROR if a general error occurs\n*/"]
    pub fn rcl_logging_configure_with_output_handler(
        global_args: *const rcl_arguments_t,
        allocator: *const rcl_allocator_t,
        output_handler: rcl_logging_output_handler_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " This function should be called to tear down the logging setup by the configure function.\n\n <hr>\n Attribute          | Adherence\n ------------------ | -------------\n Allocates Memory   | No\n Thread-Safe        | No\n Uses Atomics       | No\n Lock-Free          | Yes\n\n \\return #RCL_RET_OK if successful.\n \\return #RCL_RET_ERROR if a general error occurs"]
    pub fn rcl_logging_fini() -> rcl_ret_t;
}
extern "C" {
    #[doc = " See if logging rosout is enabled.\n**\n* This function is meant to be used to check if logging rosout is enabled.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\return `TRUE` if logging rosout is enabled, or\n* \\return `FALSE` if logging rosout is disabled.\n*/"]
    pub fn rcl_logging_rosout_enabled() -> bool;
}
extern "C" {
    #[doc = " Default output handler used by rcl.\n**\n* This function can be wrapped in a language specific client library,\n* adding the necessary mutual exclusion protection there, and then use\n* rcl_logging_configure_with_output_handler() instead of\n* rcl_logging_configure().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] location The pointer to the location struct or NULL\n* \\param[in] severity The severity level\n* \\param[in] name The name of the logger, must be null terminated c string\n* \\param[in] timestamp The timestamp for when the log message was made\n* \\param[in] format The list of arguments to insert into the formatted log message\n* \\param[in] args argument for the string format\n*/"]
    pub fn rcl_logging_multiple_output_handler(
        location: *const rcutils_log_location_t,
        severity: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        timestamp: rcutils_time_point_value_t,
        format: *const ::std::os::raw::c_char,
        args: *mut va_list,
    );
}
#[doc = " Struct defined in msg/UUID in the package unique_identifier_msgs.\n**\n* A universally unique identifier (UUID).\n*\n*  http://en.wikipedia.org/wiki/Universally_unique_identifier\n*  http://tools.ietf.org/html/rfc4122.html\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unique_identifier_msgs__msg__UUID {
    pub uuid: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_unique_identifier_msgs__msg__UUID() {
    const UNINIT: ::std::mem::MaybeUninit<unique_identifier_msgs__msg__UUID> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<unique_identifier_msgs__msg__UUID>(),
        16usize,
        concat!("Size of: ", stringify!(unique_identifier_msgs__msg__UUID))
    );
    assert_eq!(
        ::std::mem::align_of::<unique_identifier_msgs__msg__UUID>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(unique_identifier_msgs__msg__UUID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unique_identifier_msgs__msg__UUID),
            "::",
            stringify!(uuid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unique_identifier_msgs__msg__UUID__Sequence {
    pub data: *mut unique_identifier_msgs__msg__UUID,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_unique_identifier_msgs__msg__UUID__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<unique_identifier_msgs__msg__UUID__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<unique_identifier_msgs__msg__UUID__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(unique_identifier_msgs__msg__UUID__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<unique_identifier_msgs__msg__UUID__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(unique_identifier_msgs__msg__UUID__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unique_identifier_msgs__msg__UUID__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(unique_identifier_msgs__msg__UUID__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(unique_identifier_msgs__msg__UUID__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[doc = " Struct defined in msg/GoalInfo in the package action_msgs.\n**\n* Goal ID\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_msgs__msg__GoalInfo {
    pub goal_id: unique_identifier_msgs__msg__UUID,
    #[doc = " Time when the goal was accepted"]
    pub stamp: builtin_interfaces__msg__Time,
}
#[test]
fn bindgen_test_layout_action_msgs__msg__GoalInfo() {
    const UNINIT: ::std::mem::MaybeUninit<action_msgs__msg__GoalInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<action_msgs__msg__GoalInfo>(),
        24usize,
        concat!("Size of: ", stringify!(action_msgs__msg__GoalInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<action_msgs__msg__GoalInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(action_msgs__msg__GoalInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).goal_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__msg__GoalInfo),
            "::",
            stringify!(goal_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__msg__GoalInfo),
            "::",
            stringify!(stamp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_msgs__msg__GoalInfo__Sequence {
    pub data: *mut action_msgs__msg__GoalInfo,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_action_msgs__msg__GoalInfo__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<action_msgs__msg__GoalInfo__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<action_msgs__msg__GoalInfo__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(action_msgs__msg__GoalInfo__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<action_msgs__msg__GoalInfo__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(action_msgs__msg__GoalInfo__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__msg__GoalInfo__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__msg__GoalInfo__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__msg__GoalInfo__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/GoalInfo message.\n**\n* If the init function is called twice for the same message without\n* calling fini inbetween previously allocated memory will be leaked.\n* \\param[in,out] msg The previously allocated message pointer.\n* Fields without a default value will not be initialized by this function.\n* You might want to call memset(msg, 0, sizeof(\n* action_msgs__msg__GoalInfo\n* )) before or use\n* action_msgs__msg__GoalInfo__create()\n* to allocate and initialize the message.\n* \\return true if initialization was successful, otherwise false\n*/"]
    pub fn action_msgs__msg__GoalInfo__init(msg: *mut action_msgs__msg__GoalInfo) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/GoalInfo message.\n**\n* \\param[in,out] msg The allocated message pointer.\n*/"]
    pub fn action_msgs__msg__GoalInfo__fini(msg: *mut action_msgs__msg__GoalInfo);
}
extern "C" {
    #[doc = " Create msg/GoalInfo message.\n**\n* It allocates the memory for the message, sets the memory to zero, and\n* calls\n* action_msgs__msg__GoalInfo__init().\n* \\return The pointer to the initialized message if successful,\n* otherwise NULL\n*/"]
    pub fn action_msgs__msg__GoalInfo__create() -> *mut action_msgs__msg__GoalInfo;
}
extern "C" {
    #[doc = " Destroy msg/GoalInfo message.\n**\n* It calls\n* action_msgs__msg__GoalInfo__fini()\n* and frees the memory of the message.\n* \\param[in,out] msg The allocated message pointer.\n*/"]
    pub fn action_msgs__msg__GoalInfo__destroy(msg: *mut action_msgs__msg__GoalInfo);
}
extern "C" {
    #[doc = " Check for msg/GoalInfo message equality.\n**\n* \\param[in] lhs The message on the left hand size of the equality operator.\n* \\param[in] rhs The message on the right hand size of the equality operator.\n* \\return true if messages are equal, otherwise false.\n*/"]
    pub fn action_msgs__msg__GoalInfo__are_equal(
        lhs: *const action_msgs__msg__GoalInfo,
        rhs: *const action_msgs__msg__GoalInfo,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/GoalInfo message.\n**\n* This functions performs a deep copy, as opposed to the shallow copy that\n* plain assignment yields.\n*\n* \\param[in] input The source message pointer.\n* \\param[out] output The target message pointer, which must\n*   have been initialized before calling this function.\n* \\return true if successful, or false if either pointer is null\n*   or memory allocation fails.\n*/"]
    pub fn action_msgs__msg__GoalInfo__copy(
        input: *const action_msgs__msg__GoalInfo,
        output: *mut action_msgs__msg__GoalInfo,
    ) -> bool;
}
extern "C" {
    #[doc = " Retrieve pointer to the hash of the description of this type."]
    pub fn action_msgs__msg__GoalInfo__get_type_hash(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_type_hash_t;
}
extern "C" {
    #[doc = " Retrieve pointer to the description of this type."]
    pub fn action_msgs__msg__GoalInfo__get_type_description(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeDescription;
}
extern "C" {
    #[doc = " Retrieve pointer to the single raw source text that defined this type."]
    pub fn action_msgs__msg__GoalInfo__get_individual_type_description_source(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource;
}
extern "C" {
    #[doc = " Retrieve pointer to the recursive raw sources that defined the description of this type."]
    pub fn action_msgs__msg__GoalInfo__get_type_description_sources(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource__Sequence;
}
extern "C" {
    #[doc = " Initialize array of msg/GoalInfo messages.\n**\n* It allocates the memory for the number of elements and calls\n* action_msgs__msg__GoalInfo__init()\n* for each element of the array.\n* \\param[in,out] array The allocated array pointer.\n* \\param[in] size The size / capacity of the array.\n* \\return true if initialization was successful, otherwise false\n* If the array pointer is valid and the size is zero it is guaranteed\n# to return true.\n*/"]
    pub fn action_msgs__msg__GoalInfo__Sequence__init(
        array: *mut action_msgs__msg__GoalInfo__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/GoalInfo messages.\n**\n* It calls\n* action_msgs__msg__GoalInfo__fini()\n* for each element of the array and frees the memory for the number of\n* elements.\n* \\param[in,out] array The initialized array pointer.\n*/"]
    pub fn action_msgs__msg__GoalInfo__Sequence__fini(
        array: *mut action_msgs__msg__GoalInfo__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/GoalInfo messages.\n**\n* It allocates the memory for the array and calls\n* action_msgs__msg__GoalInfo__Sequence__init().\n* \\param[in] size The size / capacity of the array.\n* \\return The pointer to the initialized array if successful, otherwise NULL\n*/"]
    pub fn action_msgs__msg__GoalInfo__Sequence__create(
        size: usize,
    ) -> *mut action_msgs__msg__GoalInfo__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/GoalInfo messages.\n**\n* It calls\n* action_msgs__msg__GoalInfo__Sequence__fini()\n* on the array,\n* and frees the memory of the array.\n* \\param[in,out] array The initialized array pointer.\n*/"]
    pub fn action_msgs__msg__GoalInfo__Sequence__destroy(
        array: *mut action_msgs__msg__GoalInfo__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/GoalInfo message array equality.\n**\n* \\param[in] lhs The message array on the left hand size of the equality operator.\n* \\param[in] rhs The message array on the right hand size of the equality operator.\n* \\return true if message arrays are equal in size and content, otherwise false.\n*/"]
    pub fn action_msgs__msg__GoalInfo__Sequence__are_equal(
        lhs: *const action_msgs__msg__GoalInfo__Sequence,
        rhs: *const action_msgs__msg__GoalInfo__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/GoalInfo messages.\n**\n* This functions performs a deep copy, as opposed to the shallow copy that\n* plain assignment yields.\n*\n* \\param[in] input The source array pointer.\n* \\param[out] output The target array pointer, which must\n*   have been initialized before calling this function.\n* \\return true if successful, or false if either pointer\n*   is null or memory allocation fails.\n*/"]
    pub fn action_msgs__msg__GoalInfo__Sequence__copy(
        input: *const action_msgs__msg__GoalInfo__Sequence,
        output: *mut action_msgs__msg__GoalInfo__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__action_msgs__msg__GoalInfo(
    ) -> *const rosidl_message_type_support_t;
}
pub const action_msgs__msg__GoalStatus__STATUS_UNKNOWN: _bindgen_ty_190 = 0;
#[doc = " Constant 'STATUS_UNKNOWN'.\n**\n* Indicates status has not been properly set.\n*/"]
pub type _bindgen_ty_190 = ::std::os::raw::c_uint;
pub const action_msgs__msg__GoalStatus__STATUS_ACCEPTED: _bindgen_ty_191 = 1;
#[doc = " Constant 'STATUS_ACCEPTED'.\n**\n* The goal has been accepted and is awaiting execution.\n*/"]
pub type _bindgen_ty_191 = ::std::os::raw::c_uint;
pub const action_msgs__msg__GoalStatus__STATUS_EXECUTING: _bindgen_ty_192 = 2;
#[doc = " Constant 'STATUS_EXECUTING'.\n**\n* The goal is currently being executed by the action server.\n*/"]
pub type _bindgen_ty_192 = ::std::os::raw::c_uint;
pub const action_msgs__msg__GoalStatus__STATUS_CANCELING: _bindgen_ty_193 = 3;
#[doc = " Constant 'STATUS_CANCELING'.\n**\n* The client has requested that the goal be canceled and the action server has\n* accepted the cancel request.\n*/"]
pub type _bindgen_ty_193 = ::std::os::raw::c_uint;
pub const action_msgs__msg__GoalStatus__STATUS_SUCCEEDED: _bindgen_ty_194 = 4;
#[doc = " Constant 'STATUS_SUCCEEDED'.\n**\n* The goal was achieved successfully by the action server.\n*/"]
pub type _bindgen_ty_194 = ::std::os::raw::c_uint;
pub const action_msgs__msg__GoalStatus__STATUS_CANCELED: _bindgen_ty_195 = 5;
#[doc = " Constant 'STATUS_CANCELED'.\n**\n* The goal was canceled after an external request from an action client.\n*/"]
pub type _bindgen_ty_195 = ::std::os::raw::c_uint;
pub const action_msgs__msg__GoalStatus__STATUS_ABORTED: _bindgen_ty_196 = 6;
#[doc = " Constant 'STATUS_ABORTED'.\n**\n* The goal was terminated by the action server without an external request.\n*/"]
pub type _bindgen_ty_196 = ::std::os::raw::c_uint;
#[doc = " Struct defined in msg/GoalStatus in the package action_msgs.\n**\n* An action goal can be in one of these states after it is accepted by an action\n* server.\n*\n* For more information, see http://design.ros2.org/articles/actions.html\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_msgs__msg__GoalStatus {
    #[doc = " Goal info (contains ID and timestamp)."]
    pub goal_info: action_msgs__msg__GoalInfo,
    #[doc = " Action goal state-machine status."]
    pub status: i8,
}
#[test]
fn bindgen_test_layout_action_msgs__msg__GoalStatus() {
    const UNINIT: ::std::mem::MaybeUninit<action_msgs__msg__GoalStatus> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<action_msgs__msg__GoalStatus>(),
        28usize,
        concat!("Size of: ", stringify!(action_msgs__msg__GoalStatus))
    );
    assert_eq!(
        ::std::mem::align_of::<action_msgs__msg__GoalStatus>(),
        4usize,
        concat!("Alignment of ", stringify!(action_msgs__msg__GoalStatus))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).goal_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__msg__GoalStatus),
            "::",
            stringify!(goal_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__msg__GoalStatus),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_msgs__msg__GoalStatus__Sequence {
    pub data: *mut action_msgs__msg__GoalStatus,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_action_msgs__msg__GoalStatus__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<action_msgs__msg__GoalStatus__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<action_msgs__msg__GoalStatus__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(action_msgs__msg__GoalStatus__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<action_msgs__msg__GoalStatus__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(action_msgs__msg__GoalStatus__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__msg__GoalStatus__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__msg__GoalStatus__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__msg__GoalStatus__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/GoalStatus message.\n**\n* If the init function is called twice for the same message without\n* calling fini inbetween previously allocated memory will be leaked.\n* \\param[in,out] msg The previously allocated message pointer.\n* Fields without a default value will not be initialized by this function.\n* You might want to call memset(msg, 0, sizeof(\n* action_msgs__msg__GoalStatus\n* )) before or use\n* action_msgs__msg__GoalStatus__create()\n* to allocate and initialize the message.\n* \\return true if initialization was successful, otherwise false\n*/"]
    pub fn action_msgs__msg__GoalStatus__init(msg: *mut action_msgs__msg__GoalStatus) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/GoalStatus message.\n**\n* \\param[in,out] msg The allocated message pointer.\n*/"]
    pub fn action_msgs__msg__GoalStatus__fini(msg: *mut action_msgs__msg__GoalStatus);
}
extern "C" {
    #[doc = " Create msg/GoalStatus message.\n**\n* It allocates the memory for the message, sets the memory to zero, and\n* calls\n* action_msgs__msg__GoalStatus__init().\n* \\return The pointer to the initialized message if successful,\n* otherwise NULL\n*/"]
    pub fn action_msgs__msg__GoalStatus__create() -> *mut action_msgs__msg__GoalStatus;
}
extern "C" {
    #[doc = " Destroy msg/GoalStatus message.\n**\n* It calls\n* action_msgs__msg__GoalStatus__fini()\n* and frees the memory of the message.\n* \\param[in,out] msg The allocated message pointer.\n*/"]
    pub fn action_msgs__msg__GoalStatus__destroy(msg: *mut action_msgs__msg__GoalStatus);
}
extern "C" {
    #[doc = " Check for msg/GoalStatus message equality.\n**\n* \\param[in] lhs The message on the left hand size of the equality operator.\n* \\param[in] rhs The message on the right hand size of the equality operator.\n* \\return true if messages are equal, otherwise false.\n*/"]
    pub fn action_msgs__msg__GoalStatus__are_equal(
        lhs: *const action_msgs__msg__GoalStatus,
        rhs: *const action_msgs__msg__GoalStatus,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/GoalStatus message.\n**\n* This functions performs a deep copy, as opposed to the shallow copy that\n* plain assignment yields.\n*\n* \\param[in] input The source message pointer.\n* \\param[out] output The target message pointer, which must\n*   have been initialized before calling this function.\n* \\return true if successful, or false if either pointer is null\n*   or memory allocation fails.\n*/"]
    pub fn action_msgs__msg__GoalStatus__copy(
        input: *const action_msgs__msg__GoalStatus,
        output: *mut action_msgs__msg__GoalStatus,
    ) -> bool;
}
extern "C" {
    #[doc = " Retrieve pointer to the hash of the description of this type."]
    pub fn action_msgs__msg__GoalStatus__get_type_hash(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_type_hash_t;
}
extern "C" {
    #[doc = " Retrieve pointer to the description of this type."]
    pub fn action_msgs__msg__GoalStatus__get_type_description(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeDescription;
}
extern "C" {
    #[doc = " Retrieve pointer to the single raw source text that defined this type."]
    pub fn action_msgs__msg__GoalStatus__get_individual_type_description_source(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource;
}
extern "C" {
    #[doc = " Retrieve pointer to the recursive raw sources that defined the description of this type."]
    pub fn action_msgs__msg__GoalStatus__get_type_description_sources(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource__Sequence;
}
extern "C" {
    #[doc = " Initialize array of msg/GoalStatus messages.\n**\n* It allocates the memory for the number of elements and calls\n* action_msgs__msg__GoalStatus__init()\n* for each element of the array.\n* \\param[in,out] array The allocated array pointer.\n* \\param[in] size The size / capacity of the array.\n* \\return true if initialization was successful, otherwise false\n* If the array pointer is valid and the size is zero it is guaranteed\n# to return true.\n*/"]
    pub fn action_msgs__msg__GoalStatus__Sequence__init(
        array: *mut action_msgs__msg__GoalStatus__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/GoalStatus messages.\n**\n* It calls\n* action_msgs__msg__GoalStatus__fini()\n* for each element of the array and frees the memory for the number of\n* elements.\n* \\param[in,out] array The initialized array pointer.\n*/"]
    pub fn action_msgs__msg__GoalStatus__Sequence__fini(
        array: *mut action_msgs__msg__GoalStatus__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/GoalStatus messages.\n**\n* It allocates the memory for the array and calls\n* action_msgs__msg__GoalStatus__Sequence__init().\n* \\param[in] size The size / capacity of the array.\n* \\return The pointer to the initialized array if successful, otherwise NULL\n*/"]
    pub fn action_msgs__msg__GoalStatus__Sequence__create(
        size: usize,
    ) -> *mut action_msgs__msg__GoalStatus__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/GoalStatus messages.\n**\n* It calls\n* action_msgs__msg__GoalStatus__Sequence__fini()\n* on the array,\n* and frees the memory of the array.\n* \\param[in,out] array The initialized array pointer.\n*/"]
    pub fn action_msgs__msg__GoalStatus__Sequence__destroy(
        array: *mut action_msgs__msg__GoalStatus__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/GoalStatus message array equality.\n**\n* \\param[in] lhs The message array on the left hand size of the equality operator.\n* \\param[in] rhs The message array on the right hand size of the equality operator.\n* \\return true if message arrays are equal in size and content, otherwise false.\n*/"]
    pub fn action_msgs__msg__GoalStatus__Sequence__are_equal(
        lhs: *const action_msgs__msg__GoalStatus__Sequence,
        rhs: *const action_msgs__msg__GoalStatus__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/GoalStatus messages.\n**\n* This functions performs a deep copy, as opposed to the shallow copy that\n* plain assignment yields.\n*\n* \\param[in] input The source array pointer.\n* \\param[out] output The target array pointer, which must\n*   have been initialized before calling this function.\n* \\return true if successful, or false if either pointer\n*   is null or memory allocation fails.\n*/"]
    pub fn action_msgs__msg__GoalStatus__Sequence__copy(
        input: *const action_msgs__msg__GoalStatus__Sequence,
        output: *mut action_msgs__msg__GoalStatus__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__action_msgs__msg__GoalStatus(
    ) -> *const rosidl_message_type_support_t;
}
#[doc = " Struct defined in msg/GoalStatusArray in the package action_msgs.\n**\n* An array of goal statuses.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_msgs__msg__GoalStatusArray {
    pub status_list: action_msgs__msg__GoalStatus__Sequence,
}
#[test]
fn bindgen_test_layout_action_msgs__msg__GoalStatusArray() {
    const UNINIT: ::std::mem::MaybeUninit<action_msgs__msg__GoalStatusArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<action_msgs__msg__GoalStatusArray>(),
        24usize,
        concat!("Size of: ", stringify!(action_msgs__msg__GoalStatusArray))
    );
    assert_eq!(
        ::std::mem::align_of::<action_msgs__msg__GoalStatusArray>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(action_msgs__msg__GoalStatusArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status_list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__msg__GoalStatusArray),
            "::",
            stringify!(status_list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_msgs__msg__GoalStatusArray__Sequence {
    pub data: *mut action_msgs__msg__GoalStatusArray,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_action_msgs__msg__GoalStatusArray__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<action_msgs__msg__GoalStatusArray__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<action_msgs__msg__GoalStatusArray__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(action_msgs__msg__GoalStatusArray__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<action_msgs__msg__GoalStatusArray__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(action_msgs__msg__GoalStatusArray__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__msg__GoalStatusArray__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__msg__GoalStatusArray__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__msg__GoalStatusArray__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/GoalStatusArray message.\n**\n* If the init function is called twice for the same message without\n* calling fini inbetween previously allocated memory will be leaked.\n* \\param[in,out] msg The previously allocated message pointer.\n* Fields without a default value will not be initialized by this function.\n* You might want to call memset(msg, 0, sizeof(\n* action_msgs__msg__GoalStatusArray\n* )) before or use\n* action_msgs__msg__GoalStatusArray__create()\n* to allocate and initialize the message.\n* \\return true if initialization was successful, otherwise false\n*/"]
    pub fn action_msgs__msg__GoalStatusArray__init(
        msg: *mut action_msgs__msg__GoalStatusArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/GoalStatusArray message.\n**\n* \\param[in,out] msg The allocated message pointer.\n*/"]
    pub fn action_msgs__msg__GoalStatusArray__fini(msg: *mut action_msgs__msg__GoalStatusArray);
}
extern "C" {
    #[doc = " Create msg/GoalStatusArray message.\n**\n* It allocates the memory for the message, sets the memory to zero, and\n* calls\n* action_msgs__msg__GoalStatusArray__init().\n* \\return The pointer to the initialized message if successful,\n* otherwise NULL\n*/"]
    pub fn action_msgs__msg__GoalStatusArray__create() -> *mut action_msgs__msg__GoalStatusArray;
}
extern "C" {
    #[doc = " Destroy msg/GoalStatusArray message.\n**\n* It calls\n* action_msgs__msg__GoalStatusArray__fini()\n* and frees the memory of the message.\n* \\param[in,out] msg The allocated message pointer.\n*/"]
    pub fn action_msgs__msg__GoalStatusArray__destroy(msg: *mut action_msgs__msg__GoalStatusArray);
}
extern "C" {
    #[doc = " Check for msg/GoalStatusArray message equality.\n**\n* \\param[in] lhs The message on the left hand size of the equality operator.\n* \\param[in] rhs The message on the right hand size of the equality operator.\n* \\return true if messages are equal, otherwise false.\n*/"]
    pub fn action_msgs__msg__GoalStatusArray__are_equal(
        lhs: *const action_msgs__msg__GoalStatusArray,
        rhs: *const action_msgs__msg__GoalStatusArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/GoalStatusArray message.\n**\n* This functions performs a deep copy, as opposed to the shallow copy that\n* plain assignment yields.\n*\n* \\param[in] input The source message pointer.\n* \\param[out] output The target message pointer, which must\n*   have been initialized before calling this function.\n* \\return true if successful, or false if either pointer is null\n*   or memory allocation fails.\n*/"]
    pub fn action_msgs__msg__GoalStatusArray__copy(
        input: *const action_msgs__msg__GoalStatusArray,
        output: *mut action_msgs__msg__GoalStatusArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Retrieve pointer to the hash of the description of this type."]
    pub fn action_msgs__msg__GoalStatusArray__get_type_hash(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_type_hash_t;
}
extern "C" {
    #[doc = " Retrieve pointer to the description of this type."]
    pub fn action_msgs__msg__GoalStatusArray__get_type_description(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeDescription;
}
extern "C" {
    #[doc = " Retrieve pointer to the single raw source text that defined this type."]
    pub fn action_msgs__msg__GoalStatusArray__get_individual_type_description_source(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource;
}
extern "C" {
    #[doc = " Retrieve pointer to the recursive raw sources that defined the description of this type."]
    pub fn action_msgs__msg__GoalStatusArray__get_type_description_sources(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource__Sequence;
}
extern "C" {
    #[doc = " Initialize array of msg/GoalStatusArray messages.\n**\n* It allocates the memory for the number of elements and calls\n* action_msgs__msg__GoalStatusArray__init()\n* for each element of the array.\n* \\param[in,out] array The allocated array pointer.\n* \\param[in] size The size / capacity of the array.\n* \\return true if initialization was successful, otherwise false\n* If the array pointer is valid and the size is zero it is guaranteed\n# to return true.\n*/"]
    pub fn action_msgs__msg__GoalStatusArray__Sequence__init(
        array: *mut action_msgs__msg__GoalStatusArray__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/GoalStatusArray messages.\n**\n* It calls\n* action_msgs__msg__GoalStatusArray__fini()\n* for each element of the array and frees the memory for the number of\n* elements.\n* \\param[in,out] array The initialized array pointer.\n*/"]
    pub fn action_msgs__msg__GoalStatusArray__Sequence__fini(
        array: *mut action_msgs__msg__GoalStatusArray__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/GoalStatusArray messages.\n**\n* It allocates the memory for the array and calls\n* action_msgs__msg__GoalStatusArray__Sequence__init().\n* \\param[in] size The size / capacity of the array.\n* \\return The pointer to the initialized array if successful, otherwise NULL\n*/"]
    pub fn action_msgs__msg__GoalStatusArray__Sequence__create(
        size: usize,
    ) -> *mut action_msgs__msg__GoalStatusArray__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/GoalStatusArray messages.\n**\n* It calls\n* action_msgs__msg__GoalStatusArray__Sequence__fini()\n* on the array,\n* and frees the memory of the array.\n* \\param[in,out] array The initialized array pointer.\n*/"]
    pub fn action_msgs__msg__GoalStatusArray__Sequence__destroy(
        array: *mut action_msgs__msg__GoalStatusArray__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/GoalStatusArray message array equality.\n**\n* \\param[in] lhs The message array on the left hand size of the equality operator.\n* \\param[in] rhs The message array on the right hand size of the equality operator.\n* \\return true if message arrays are equal in size and content, otherwise false.\n*/"]
    pub fn action_msgs__msg__GoalStatusArray__Sequence__are_equal(
        lhs: *const action_msgs__msg__GoalStatusArray__Sequence,
        rhs: *const action_msgs__msg__GoalStatusArray__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/GoalStatusArray messages.\n**\n* This functions performs a deep copy, as opposed to the shallow copy that\n* plain assignment yields.\n*\n* \\param[in] input The source array pointer.\n* \\param[out] output The target array pointer, which must\n*   have been initialized before calling this function.\n* \\return true if successful, or false if either pointer\n*   is null or memory allocation fails.\n*/"]
    pub fn action_msgs__msg__GoalStatusArray__Sequence__copy(
        input: *const action_msgs__msg__GoalStatusArray__Sequence,
        output: *mut action_msgs__msg__GoalStatusArray__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__action_msgs__msg__GoalStatusArray(
    ) -> *const rosidl_message_type_support_t;
}
#[doc = " Struct defined in srv/CancelGoal in the package action_msgs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_msgs__srv__CancelGoal_Request {
    #[doc = " Goal info describing the goals to cancel, see above."]
    pub goal_info: action_msgs__msg__GoalInfo,
}
#[test]
fn bindgen_test_layout_action_msgs__srv__CancelGoal_Request() {
    const UNINIT: ::std::mem::MaybeUninit<action_msgs__srv__CancelGoal_Request> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<action_msgs__srv__CancelGoal_Request>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(action_msgs__srv__CancelGoal_Request)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<action_msgs__srv__CancelGoal_Request>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(action_msgs__srv__CancelGoal_Request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).goal_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__srv__CancelGoal_Request),
            "::",
            stringify!(goal_info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_msgs__srv__CancelGoal_Request__Sequence {
    pub data: *mut action_msgs__srv__CancelGoal_Request,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_action_msgs__srv__CancelGoal_Request__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<action_msgs__srv__CancelGoal_Request__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<action_msgs__srv__CancelGoal_Request__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(action_msgs__srv__CancelGoal_Request__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<action_msgs__srv__CancelGoal_Request__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(action_msgs__srv__CancelGoal_Request__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__srv__CancelGoal_Request__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__srv__CancelGoal_Request__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__srv__CancelGoal_Request__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
pub const action_msgs__srv__CancelGoal_Response__ERROR_NONE: _bindgen_ty_197 = 0;
#[doc = " Constant 'ERROR_NONE'.\n**\n* Indicates the request was accepted without any errors.\n*\n* One or more goals have transitioned to the CANCELING state. The\n* goals_canceling list is not empty.\n*/"]
pub type _bindgen_ty_197 = ::std::os::raw::c_uint;
pub const action_msgs__srv__CancelGoal_Response__ERROR_REJECTED: _bindgen_ty_198 = 1;
#[doc = " Constant 'ERROR_REJECTED'.\n**\n* Indicates the request was rejected.\n*\n* No goals have transitioned to the CANCELING state. The goals_canceling list is\n* empty.\n*/"]
pub type _bindgen_ty_198 = ::std::os::raw::c_uint;
pub const action_msgs__srv__CancelGoal_Response__ERROR_UNKNOWN_GOAL_ID: _bindgen_ty_199 = 2;
#[doc = " Constant 'ERROR_UNKNOWN_GOAL_ID'.\n**\n* Indicates the requested goal ID does not exist.\n*\n* No goals have transitioned to the CANCELING state. The goals_canceling list is\n* empty.\n*/"]
pub type _bindgen_ty_199 = ::std::os::raw::c_uint;
pub const action_msgs__srv__CancelGoal_Response__ERROR_GOAL_TERMINATED: _bindgen_ty_200 = 3;
#[doc = " Constant 'ERROR_GOAL_TERMINATED'.\n**\n* Indicates the goal is not cancelable because it is already in a terminal state.\n*\n* No goals have transitioned to the CANCELING state. The goals_canceling list is\n* empty.\n*/"]
pub type _bindgen_ty_200 = ::std::os::raw::c_uint;
#[doc = " Struct defined in srv/CancelGoal in the package action_msgs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_msgs__srv__CancelGoal_Response {
    #[doc = " Return code, see above definitions."]
    pub return_code: i8,
    #[doc = " Goals that accepted the cancel request."]
    pub goals_canceling: action_msgs__msg__GoalInfo__Sequence,
}
#[test]
fn bindgen_test_layout_action_msgs__srv__CancelGoal_Response() {
    const UNINIT: ::std::mem::MaybeUninit<action_msgs__srv__CancelGoal_Response> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<action_msgs__srv__CancelGoal_Response>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(action_msgs__srv__CancelGoal_Response)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<action_msgs__srv__CancelGoal_Response>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(action_msgs__srv__CancelGoal_Response)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).return_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__srv__CancelGoal_Response),
            "::",
            stringify!(return_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).goals_canceling) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__srv__CancelGoal_Response),
            "::",
            stringify!(goals_canceling)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_msgs__srv__CancelGoal_Response__Sequence {
    pub data: *mut action_msgs__srv__CancelGoal_Response,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_action_msgs__srv__CancelGoal_Response__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<action_msgs__srv__CancelGoal_Response__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<action_msgs__srv__CancelGoal_Response__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(action_msgs__srv__CancelGoal_Response__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<action_msgs__srv__CancelGoal_Response__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(action_msgs__srv__CancelGoal_Response__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__srv__CancelGoal_Response__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__srv__CancelGoal_Response__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__srv__CancelGoal_Response__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
pub const action_msgs__srv__CancelGoal_Event__request__MAX_SIZE: _bindgen_ty_201 = 1;
pub type _bindgen_ty_201 = ::std::os::raw::c_uint;
pub const action_msgs__srv__CancelGoal_Event__response__MAX_SIZE: _bindgen_ty_202 = 1;
pub type _bindgen_ty_202 = ::std::os::raw::c_uint;
#[doc = " Struct defined in srv/CancelGoal in the package action_msgs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_msgs__srv__CancelGoal_Event {
    pub info: service_msgs__msg__ServiceEventInfo,
    pub request: action_msgs__srv__CancelGoal_Request__Sequence,
    pub response: action_msgs__srv__CancelGoal_Response__Sequence,
}
#[test]
fn bindgen_test_layout_action_msgs__srv__CancelGoal_Event() {
    const UNINIT: ::std::mem::MaybeUninit<action_msgs__srv__CancelGoal_Event> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<action_msgs__srv__CancelGoal_Event>(),
        88usize,
        concat!("Size of: ", stringify!(action_msgs__srv__CancelGoal_Event))
    );
    assert_eq!(
        ::std::mem::align_of::<action_msgs__srv__CancelGoal_Event>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(action_msgs__srv__CancelGoal_Event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__srv__CancelGoal_Event),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__srv__CancelGoal_Event),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__srv__CancelGoal_Event),
            "::",
            stringify!(response)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_msgs__srv__CancelGoal_Event__Sequence {
    pub data: *mut action_msgs__srv__CancelGoal_Event,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_action_msgs__srv__CancelGoal_Event__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<action_msgs__srv__CancelGoal_Event__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<action_msgs__srv__CancelGoal_Event__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(action_msgs__srv__CancelGoal_Event__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<action_msgs__srv__CancelGoal_Event__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(action_msgs__srv__CancelGoal_Event__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__srv__CancelGoal_Event__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__srv__CancelGoal_Event__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(action_msgs__srv__CancelGoal_Event__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Retrieve pointer to the hash of the description of this type."]
    pub fn action_msgs__srv__CancelGoal__get_type_hash(
        type_support: *const rosidl_service_type_support_t,
    ) -> *const rosidl_type_hash_t;
}
extern "C" {
    #[doc = " Retrieve pointer to the description of this type."]
    pub fn action_msgs__srv__CancelGoal__get_type_description(
        type_support: *const rosidl_service_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeDescription;
}
extern "C" {
    #[doc = " Retrieve pointer to the single raw source text that defined this type."]
    pub fn action_msgs__srv__CancelGoal__get_individual_type_description_source(
        type_support: *const rosidl_service_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource;
}
extern "C" {
    #[doc = " Retrieve pointer to the recursive raw sources that defined the description of this type."]
    pub fn action_msgs__srv__CancelGoal__get_type_description_sources(
        type_support: *const rosidl_service_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource__Sequence;
}
extern "C" {
    #[doc = " Initialize srv/CancelGoal message.\n**\n* If the init function is called twice for the same message without\n* calling fini inbetween previously allocated memory will be leaked.\n* \\param[in,out] msg The previously allocated message pointer.\n* Fields without a default value will not be initialized by this function.\n* You might want to call memset(msg, 0, sizeof(\n* action_msgs__srv__CancelGoal_Request\n* )) before or use\n* action_msgs__srv__CancelGoal_Request__create()\n* to allocate and initialize the message.\n* \\return true if initialization was successful, otherwise false\n*/"]
    pub fn action_msgs__srv__CancelGoal_Request__init(
        msg: *mut action_msgs__srv__CancelGoal_Request,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize srv/CancelGoal message.\n**\n* \\param[in,out] msg The allocated message pointer.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Request__fini(
        msg: *mut action_msgs__srv__CancelGoal_Request,
    );
}
extern "C" {
    #[doc = " Create srv/CancelGoal message.\n**\n* It allocates the memory for the message, sets the memory to zero, and\n* calls\n* action_msgs__srv__CancelGoal_Request__init().\n* \\return The pointer to the initialized message if successful,\n* otherwise NULL\n*/"]
    pub fn action_msgs__srv__CancelGoal_Request__create(
    ) -> *mut action_msgs__srv__CancelGoal_Request;
}
extern "C" {
    #[doc = " Destroy srv/CancelGoal message.\n**\n* It calls\n* action_msgs__srv__CancelGoal_Request__fini()\n* and frees the memory of the message.\n* \\param[in,out] msg The allocated message pointer.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Request__destroy(
        msg: *mut action_msgs__srv__CancelGoal_Request,
    );
}
extern "C" {
    #[doc = " Check for srv/CancelGoal message equality.\n**\n* \\param[in] lhs The message on the left hand size of the equality operator.\n* \\param[in] rhs The message on the right hand size of the equality operator.\n* \\return true if messages are equal, otherwise false.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Request__are_equal(
        lhs: *const action_msgs__srv__CancelGoal_Request,
        rhs: *const action_msgs__srv__CancelGoal_Request,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a srv/CancelGoal message.\n**\n* This functions performs a deep copy, as opposed to the shallow copy that\n* plain assignment yields.\n*\n* \\param[in] input The source message pointer.\n* \\param[out] output The target message pointer, which must\n*   have been initialized before calling this function.\n* \\return true if successful, or false if either pointer is null\n*   or memory allocation fails.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Request__copy(
        input: *const action_msgs__srv__CancelGoal_Request,
        output: *mut action_msgs__srv__CancelGoal_Request,
    ) -> bool;
}
extern "C" {
    #[doc = " Retrieve pointer to the hash of the description of this type."]
    pub fn action_msgs__srv__CancelGoal_Request__get_type_hash(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_type_hash_t;
}
extern "C" {
    #[doc = " Retrieve pointer to the description of this type."]
    pub fn action_msgs__srv__CancelGoal_Request__get_type_description(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeDescription;
}
extern "C" {
    #[doc = " Retrieve pointer to the single raw source text that defined this type."]
    pub fn action_msgs__srv__CancelGoal_Request__get_individual_type_description_source(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource;
}
extern "C" {
    #[doc = " Retrieve pointer to the recursive raw sources that defined the description of this type."]
    pub fn action_msgs__srv__CancelGoal_Request__get_type_description_sources(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource__Sequence;
}
extern "C" {
    #[doc = " Initialize array of srv/CancelGoal messages.\n**\n* It allocates the memory for the number of elements and calls\n* action_msgs__srv__CancelGoal_Request__init()\n* for each element of the array.\n* \\param[in,out] array The allocated array pointer.\n* \\param[in] size The size / capacity of the array.\n* \\return true if initialization was successful, otherwise false\n* If the array pointer is valid and the size is zero it is guaranteed\n# to return true.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Request__Sequence__init(
        array: *mut action_msgs__srv__CancelGoal_Request__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of srv/CancelGoal messages.\n**\n* It calls\n* action_msgs__srv__CancelGoal_Request__fini()\n* for each element of the array and frees the memory for the number of\n* elements.\n* \\param[in,out] array The initialized array pointer.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Request__Sequence__fini(
        array: *mut action_msgs__srv__CancelGoal_Request__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of srv/CancelGoal messages.\n**\n* It allocates the memory for the array and calls\n* action_msgs__srv__CancelGoal_Request__Sequence__init().\n* \\param[in] size The size / capacity of the array.\n* \\return The pointer to the initialized array if successful, otherwise NULL\n*/"]
    pub fn action_msgs__srv__CancelGoal_Request__Sequence__create(
        size: usize,
    ) -> *mut action_msgs__srv__CancelGoal_Request__Sequence;
}
extern "C" {
    #[doc = " Destroy array of srv/CancelGoal messages.\n**\n* It calls\n* action_msgs__srv__CancelGoal_Request__Sequence__fini()\n* on the array,\n* and frees the memory of the array.\n* \\param[in,out] array The initialized array pointer.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Request__Sequence__destroy(
        array: *mut action_msgs__srv__CancelGoal_Request__Sequence,
    );
}
extern "C" {
    #[doc = " Check for srv/CancelGoal message array equality.\n**\n* \\param[in] lhs The message array on the left hand size of the equality operator.\n* \\param[in] rhs The message array on the right hand size of the equality operator.\n* \\return true if message arrays are equal in size and content, otherwise false.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Request__Sequence__are_equal(
        lhs: *const action_msgs__srv__CancelGoal_Request__Sequence,
        rhs: *const action_msgs__srv__CancelGoal_Request__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of srv/CancelGoal messages.\n**\n* This functions performs a deep copy, as opposed to the shallow copy that\n* plain assignment yields.\n*\n* \\param[in] input The source array pointer.\n* \\param[out] output The target array pointer, which must\n*   have been initialized before calling this function.\n* \\return true if successful, or false if either pointer\n*   is null or memory allocation fails.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Request__Sequence__copy(
        input: *const action_msgs__srv__CancelGoal_Request__Sequence,
        output: *mut action_msgs__srv__CancelGoal_Request__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize srv/CancelGoal message.\n**\n* If the init function is called twice for the same message without\n* calling fini inbetween previously allocated memory will be leaked.\n* \\param[in,out] msg The previously allocated message pointer.\n* Fields without a default value will not be initialized by this function.\n* You might want to call memset(msg, 0, sizeof(\n* action_msgs__srv__CancelGoal_Response\n* )) before or use\n* action_msgs__srv__CancelGoal_Response__create()\n* to allocate and initialize the message.\n* \\return true if initialization was successful, otherwise false\n*/"]
    pub fn action_msgs__srv__CancelGoal_Response__init(
        msg: *mut action_msgs__srv__CancelGoal_Response,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize srv/CancelGoal message.\n**\n* \\param[in,out] msg The allocated message pointer.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Response__fini(
        msg: *mut action_msgs__srv__CancelGoal_Response,
    );
}
extern "C" {
    #[doc = " Create srv/CancelGoal message.\n**\n* It allocates the memory for the message, sets the memory to zero, and\n* calls\n* action_msgs__srv__CancelGoal_Response__init().\n* \\return The pointer to the initialized message if successful,\n* otherwise NULL\n*/"]
    pub fn action_msgs__srv__CancelGoal_Response__create(
    ) -> *mut action_msgs__srv__CancelGoal_Response;
}
extern "C" {
    #[doc = " Destroy srv/CancelGoal message.\n**\n* It calls\n* action_msgs__srv__CancelGoal_Response__fini()\n* and frees the memory of the message.\n* \\param[in,out] msg The allocated message pointer.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Response__destroy(
        msg: *mut action_msgs__srv__CancelGoal_Response,
    );
}
extern "C" {
    #[doc = " Check for srv/CancelGoal message equality.\n**\n* \\param[in] lhs The message on the left hand size of the equality operator.\n* \\param[in] rhs The message on the right hand size of the equality operator.\n* \\return true if messages are equal, otherwise false.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Response__are_equal(
        lhs: *const action_msgs__srv__CancelGoal_Response,
        rhs: *const action_msgs__srv__CancelGoal_Response,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a srv/CancelGoal message.\n**\n* This functions performs a deep copy, as opposed to the shallow copy that\n* plain assignment yields.\n*\n* \\param[in] input The source message pointer.\n* \\param[out] output The target message pointer, which must\n*   have been initialized before calling this function.\n* \\return true if successful, or false if either pointer is null\n*   or memory allocation fails.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Response__copy(
        input: *const action_msgs__srv__CancelGoal_Response,
        output: *mut action_msgs__srv__CancelGoal_Response,
    ) -> bool;
}
extern "C" {
    #[doc = " Retrieve pointer to the hash of the description of this type."]
    pub fn action_msgs__srv__CancelGoal_Response__get_type_hash(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_type_hash_t;
}
extern "C" {
    #[doc = " Retrieve pointer to the description of this type."]
    pub fn action_msgs__srv__CancelGoal_Response__get_type_description(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeDescription;
}
extern "C" {
    #[doc = " Retrieve pointer to the single raw source text that defined this type."]
    pub fn action_msgs__srv__CancelGoal_Response__get_individual_type_description_source(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource;
}
extern "C" {
    #[doc = " Retrieve pointer to the recursive raw sources that defined the description of this type."]
    pub fn action_msgs__srv__CancelGoal_Response__get_type_description_sources(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource__Sequence;
}
extern "C" {
    #[doc = " Initialize array of srv/CancelGoal messages.\n**\n* It allocates the memory for the number of elements and calls\n* action_msgs__srv__CancelGoal_Response__init()\n* for each element of the array.\n* \\param[in,out] array The allocated array pointer.\n* \\param[in] size The size / capacity of the array.\n* \\return true if initialization was successful, otherwise false\n* If the array pointer is valid and the size is zero it is guaranteed\n# to return true.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Response__Sequence__init(
        array: *mut action_msgs__srv__CancelGoal_Response__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of srv/CancelGoal messages.\n**\n* It calls\n* action_msgs__srv__CancelGoal_Response__fini()\n* for each element of the array and frees the memory for the number of\n* elements.\n* \\param[in,out] array The initialized array pointer.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Response__Sequence__fini(
        array: *mut action_msgs__srv__CancelGoal_Response__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of srv/CancelGoal messages.\n**\n* It allocates the memory for the array and calls\n* action_msgs__srv__CancelGoal_Response__Sequence__init().\n* \\param[in] size The size / capacity of the array.\n* \\return The pointer to the initialized array if successful, otherwise NULL\n*/"]
    pub fn action_msgs__srv__CancelGoal_Response__Sequence__create(
        size: usize,
    ) -> *mut action_msgs__srv__CancelGoal_Response__Sequence;
}
extern "C" {
    #[doc = " Destroy array of srv/CancelGoal messages.\n**\n* It calls\n* action_msgs__srv__CancelGoal_Response__Sequence__fini()\n* on the array,\n* and frees the memory of the array.\n* \\param[in,out] array The initialized array pointer.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Response__Sequence__destroy(
        array: *mut action_msgs__srv__CancelGoal_Response__Sequence,
    );
}
extern "C" {
    #[doc = " Check for srv/CancelGoal message array equality.\n**\n* \\param[in] lhs The message array on the left hand size of the equality operator.\n* \\param[in] rhs The message array on the right hand size of the equality operator.\n* \\return true if message arrays are equal in size and content, otherwise false.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Response__Sequence__are_equal(
        lhs: *const action_msgs__srv__CancelGoal_Response__Sequence,
        rhs: *const action_msgs__srv__CancelGoal_Response__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of srv/CancelGoal messages.\n**\n* This functions performs a deep copy, as opposed to the shallow copy that\n* plain assignment yields.\n*\n* \\param[in] input The source array pointer.\n* \\param[out] output The target array pointer, which must\n*   have been initialized before calling this function.\n* \\return true if successful, or false if either pointer\n*   is null or memory allocation fails.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Response__Sequence__copy(
        input: *const action_msgs__srv__CancelGoal_Response__Sequence,
        output: *mut action_msgs__srv__CancelGoal_Response__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize srv/CancelGoal message.\n**\n* If the init function is called twice for the same message without\n* calling fini inbetween previously allocated memory will be leaked.\n* \\param[in,out] msg The previously allocated message pointer.\n* Fields without a default value will not be initialized by this function.\n* You might want to call memset(msg, 0, sizeof(\n* action_msgs__srv__CancelGoal_Event\n* )) before or use\n* action_msgs__srv__CancelGoal_Event__create()\n* to allocate and initialize the message.\n* \\return true if initialization was successful, otherwise false\n*/"]
    pub fn action_msgs__srv__CancelGoal_Event__init(
        msg: *mut action_msgs__srv__CancelGoal_Event,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize srv/CancelGoal message.\n**\n* \\param[in,out] msg The allocated message pointer.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Event__fini(msg: *mut action_msgs__srv__CancelGoal_Event);
}
extern "C" {
    #[doc = " Create srv/CancelGoal message.\n**\n* It allocates the memory for the message, sets the memory to zero, and\n* calls\n* action_msgs__srv__CancelGoal_Event__init().\n* \\return The pointer to the initialized message if successful,\n* otherwise NULL\n*/"]
    pub fn action_msgs__srv__CancelGoal_Event__create() -> *mut action_msgs__srv__CancelGoal_Event;
}
extern "C" {
    #[doc = " Destroy srv/CancelGoal message.\n**\n* It calls\n* action_msgs__srv__CancelGoal_Event__fini()\n* and frees the memory of the message.\n* \\param[in,out] msg The allocated message pointer.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Event__destroy(
        msg: *mut action_msgs__srv__CancelGoal_Event,
    );
}
extern "C" {
    #[doc = " Check for srv/CancelGoal message equality.\n**\n* \\param[in] lhs The message on the left hand size of the equality operator.\n* \\param[in] rhs The message on the right hand size of the equality operator.\n* \\return true if messages are equal, otherwise false.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Event__are_equal(
        lhs: *const action_msgs__srv__CancelGoal_Event,
        rhs: *const action_msgs__srv__CancelGoal_Event,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a srv/CancelGoal message.\n**\n* This functions performs a deep copy, as opposed to the shallow copy that\n* plain assignment yields.\n*\n* \\param[in] input The source message pointer.\n* \\param[out] output The target message pointer, which must\n*   have been initialized before calling this function.\n* \\return true if successful, or false if either pointer is null\n*   or memory allocation fails.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Event__copy(
        input: *const action_msgs__srv__CancelGoal_Event,
        output: *mut action_msgs__srv__CancelGoal_Event,
    ) -> bool;
}
extern "C" {
    #[doc = " Retrieve pointer to the hash of the description of this type."]
    pub fn action_msgs__srv__CancelGoal_Event__get_type_hash(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_type_hash_t;
}
extern "C" {
    #[doc = " Retrieve pointer to the description of this type."]
    pub fn action_msgs__srv__CancelGoal_Event__get_type_description(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeDescription;
}
extern "C" {
    #[doc = " Retrieve pointer to the single raw source text that defined this type."]
    pub fn action_msgs__srv__CancelGoal_Event__get_individual_type_description_source(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource;
}
extern "C" {
    #[doc = " Retrieve pointer to the recursive raw sources that defined the description of this type."]
    pub fn action_msgs__srv__CancelGoal_Event__get_type_description_sources(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource__Sequence;
}
extern "C" {
    #[doc = " Initialize array of srv/CancelGoal messages.\n**\n* It allocates the memory for the number of elements and calls\n* action_msgs__srv__CancelGoal_Event__init()\n* for each element of the array.\n* \\param[in,out] array The allocated array pointer.\n* \\param[in] size The size / capacity of the array.\n* \\return true if initialization was successful, otherwise false\n* If the array pointer is valid and the size is zero it is guaranteed\n# to return true.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Event__Sequence__init(
        array: *mut action_msgs__srv__CancelGoal_Event__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of srv/CancelGoal messages.\n**\n* It calls\n* action_msgs__srv__CancelGoal_Event__fini()\n* for each element of the array and frees the memory for the number of\n* elements.\n* \\param[in,out] array The initialized array pointer.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Event__Sequence__fini(
        array: *mut action_msgs__srv__CancelGoal_Event__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of srv/CancelGoal messages.\n**\n* It allocates the memory for the array and calls\n* action_msgs__srv__CancelGoal_Event__Sequence__init().\n* \\param[in] size The size / capacity of the array.\n* \\return The pointer to the initialized array if successful, otherwise NULL\n*/"]
    pub fn action_msgs__srv__CancelGoal_Event__Sequence__create(
        size: usize,
    ) -> *mut action_msgs__srv__CancelGoal_Event__Sequence;
}
extern "C" {
    #[doc = " Destroy array of srv/CancelGoal messages.\n**\n* It calls\n* action_msgs__srv__CancelGoal_Event__Sequence__fini()\n* on the array,\n* and frees the memory of the array.\n* \\param[in,out] array The initialized array pointer.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Event__Sequence__destroy(
        array: *mut action_msgs__srv__CancelGoal_Event__Sequence,
    );
}
extern "C" {
    #[doc = " Check for srv/CancelGoal message array equality.\n**\n* \\param[in] lhs The message array on the left hand size of the equality operator.\n* \\param[in] rhs The message array on the right hand size of the equality operator.\n* \\return true if message arrays are equal in size and content, otherwise false.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Event__Sequence__are_equal(
        lhs: *const action_msgs__srv__CancelGoal_Event__Sequence,
        rhs: *const action_msgs__srv__CancelGoal_Event__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of srv/CancelGoal messages.\n**\n* This functions performs a deep copy, as opposed to the shallow copy that\n* plain assignment yields.\n*\n* \\param[in] input The source array pointer.\n* \\param[out] output The target array pointer, which must\n*   have been initialized before calling this function.\n* \\return true if successful, or false if either pointer\n*   is null or memory allocation fails.\n*/"]
    pub fn action_msgs__srv__CancelGoal_Event__Sequence__copy(
        input: *const action_msgs__srv__CancelGoal_Event__Sequence,
        output: *mut action_msgs__srv__CancelGoal_Event__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__action_msgs__srv__CancelGoal_Request(
    ) -> *const rosidl_message_type_support_t;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__action_msgs__srv__CancelGoal_Response(
    ) -> *const rosidl_message_type_support_t;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__action_msgs__srv__CancelGoal_Event(
    ) -> *const rosidl_message_type_support_t;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_service_type_support_handle__action_msgs__srv__CancelGoal(
    ) -> *const rosidl_service_type_support_t;
}
extern "C" {
    pub fn rosidl_typesupport_c__create_service_event_message__action_msgs__srv__CancelGoal(
        info: *const rosidl_service_introspection_info_t,
        allocator: *mut rcutils_allocator_t,
        request_message: *const ::std::os::raw::c_void,
        response_message: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rosidl_typesupport_c__destroy_service_event_message__action_msgs__srv__CancelGoal(
        event_msg: *mut ::std::os::raw::c_void,
        allocator: *mut rcutils_allocator_t,
    ) -> bool;
}
#[doc = " Struct defined in msg/GoalInfo in the package action_msgs.\n**\n* Goal ID\n*/"]
pub type rcl_action_goal_info_t = action_msgs__msg__GoalInfo;
#[doc = " Struct defined in msg/GoalStatus in the package action_msgs.\n**\n* An action goal can be in one of these states after it is accepted by an action\n* server.\n*\n* For more information, see http://design.ros2.org/articles/actions.html\n*/"]
pub type rcl_action_goal_status_t = action_msgs__msg__GoalStatus;
#[doc = " Struct with the action goal status array"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_action_goal_status_array_s {
    #[doc = " Goal status array message"]
    pub msg: action_msgs__msg__GoalStatusArray,
    #[doc = " Allocator used to initialize this struct."]
    pub allocator: rcl_allocator_t,
}
#[test]
fn bindgen_test_layout_rcl_action_goal_status_array_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_action_goal_status_array_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_action_goal_status_array_s>(),
        64usize,
        concat!("Size of: ", stringify!(rcl_action_goal_status_array_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_action_goal_status_array_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_action_goal_status_array_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_action_goal_status_array_s),
            "::",
            stringify!(msg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_action_goal_status_array_s),
            "::",
            stringify!(allocator)
        )
    );
}
#[doc = " Struct with the action goal status array"]
pub type rcl_action_goal_status_array_t = rcl_action_goal_status_array_s;
#[doc = " Struct defined in srv/CancelGoal in the package action_msgs."]
pub type rcl_action_cancel_request_t = action_msgs__srv__CancelGoal_Request;
#[doc = " Struct with the action cancel response"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_action_cancel_response_s {
    #[doc = " Cancel goal response message"]
    pub msg: action_msgs__srv__CancelGoal_Response,
    #[doc = " Allocator used to initialize this struct."]
    pub allocator: rcl_allocator_t,
}
#[test]
fn bindgen_test_layout_rcl_action_cancel_response_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_action_cancel_response_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_action_cancel_response_s>(),
        72usize,
        concat!("Size of: ", stringify!(rcl_action_cancel_response_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_action_cancel_response_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_action_cancel_response_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_action_cancel_response_s),
            "::",
            stringify!(msg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_action_cancel_response_s),
            "::",
            stringify!(allocator)
        )
    );
}
#[doc = " Struct with the action cancel response"]
pub type rcl_action_cancel_response_t = rcl_action_cancel_response_s;
#[doc = " Goal states"]
pub type rcl_action_goal_state_t = i8;
extern "C" {
    #[doc = " User friendly error messages for invalid trasntions"]
    pub static mut goal_state_descriptions: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut goal_event_descriptions: [*const ::std::os::raw::c_char; 0usize];
}
pub const rcl_action_goal_event_e_GOAL_EVENT_EXECUTE: rcl_action_goal_event_e = 0;
pub const rcl_action_goal_event_e_GOAL_EVENT_CANCEL_GOAL: rcl_action_goal_event_e = 1;
pub const rcl_action_goal_event_e_GOAL_EVENT_SUCCEED: rcl_action_goal_event_e = 2;
pub const rcl_action_goal_event_e_GOAL_EVENT_ABORT: rcl_action_goal_event_e = 3;
pub const rcl_action_goal_event_e_GOAL_EVENT_CANCELED: rcl_action_goal_event_e = 4;
pub const rcl_action_goal_event_e_GOAL_EVENT_NUM_EVENTS: rcl_action_goal_event_e = 5;
#[doc = " Goal state transition events"]
pub type rcl_action_goal_event_e = ::std::os::raw::c_uint;
#[doc = " Goal state transition events"]
pub use self::rcl_action_goal_event_e as rcl_action_goal_event_t;
extern "C" {
    #[doc = " Return a rcl_action_goal_info_t with members set to zero values."]
    pub fn rcl_action_get_zero_initialized_goal_info() -> rcl_action_goal_info_t;
}
extern "C" {
    #[doc = " Return a rcl_action_goal_status_array_t with members set to `NULL`.\n**\n* Should be called to get a null rcl_action_goal_status_array_t before passing to\n* rcl_action_server_get_goal_status_array().\n*/"]
    pub fn rcl_action_get_zero_initialized_goal_status_array() -> rcl_action_goal_status_array_t;
}
extern "C" {
    #[doc = " Return a rcl_action_cancel_request_t with members set to `NULL`.\n**\n* Should be called to get a null rcl_action_cancel_request_t before passing to\n*\n* rcl_action_cancel_request_init().\n*/"]
    pub fn rcl_action_get_zero_initialized_cancel_request() -> rcl_action_cancel_request_t;
}
extern "C" {
    #[doc = " Return a rcl_action_cancel_response_t with members set to `NULL`.\n**\n* Should be called to get a null rcl_action_cancel_response_t before passing to\n* rcl_action_cancel_response_init().\n*/"]
    pub fn rcl_action_get_zero_initialized_cancel_response() -> rcl_action_cancel_response_t;
}
extern "C" {
    #[doc = " Initialize a rcl_action_goal_status_array_t.\n**\n* After calling this function on a rcl_action_goal_status_array_t, it can be populated\n* and used to get and send status array messages with an action server using\n* rcl_action_get_goal_status_array() and rcl_action_publish_status() respectively.\n*\n* Example usage:\n*\n* ```c\n* #include <rcl/rcl.h>\n* #include <rcl_action/rcl_action.h>\n*\n* rcl_action_goal_status_array_t goal_status_array =\n*   rcl_action_get_zero_initialized_goal_status_array();\n* size_t num_status = 42;\n* ret = rcl_action_goal_status_array_init(\n*   &goal_status_array,\n*   num_status,\n*   rcl_get_default_allocator());\n* // ... error handling, and when done with message, finalize\n* ret = rcl_action_goal_status_array_fini(&goal_status_array, rcl_get_default_allocator());\n* // ... error handling\n* ```\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[out] status_array a preallocated, zero-initialized, goal status array message\n*   to be initialized.\n* \\param[in] num_status the number of status messages to allocate space for.\n*   Must be greater than zero\n* \\param[in] allocator a valid allocator\n* \\return `RCL_RET_OK` if cancel response was initialized successfully, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ALREADY_INIT` if the status array has already been initialized, or\n* \\return `RCL_RET_BAD_ALLOC` if allocating memory failed, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_goal_status_array_init(
        status_array: *mut rcl_action_goal_status_array_t,
        num_status: usize,
        allocator: rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a rcl_action_goal_status_array_t.\n**\n* After calling, the goal status array message will no longer be valid.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] status_array the goal status array message to be deinitialized\n* \\return `RCL_RET_OK` if the goal status array was deinitialized successfully, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_goal_status_array_fini(
        status_array: *mut rcl_action_goal_status_array_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Initialize a rcl_action_cancel_response_t.\n**\n* After calling this function on a rcl_action_cancel_response_t, it can be populated\n* and used to process cancel requests with an action server using\n* rcl_action_process_cancel_request().\n*\n* Example usage:\n*\n* ```c\n* #include <rcl/rcl.h>\n* #include <rcl_action/rcl_action.h>\n*\n* rcl_action_cancel_response_t cancel_response =\n*   rcl_action_get_zero_initialized_cancel_response();\n* size_t num_goals_canceling = 10;\n* ret = rcl_action_cancel_response_init(\n*   &cancel_response,\n*   num_goals_canceling,\n*   rcl_get_default_allocator());\n* // ... error handling, and when done processing response, finalize\n* ret = rcl_action_cancel_response_fini(&cancel_response, rcl_get_default_allocator());\n* // ... error handling\n* ```\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[out] cancel_response a preallocated, zero-initialized, cancel response message\n*   to be initialized.\n* \\param[in] num_goals_canceling the number of goals that are canceling to add to the response\n*   Must be greater than zero\n* \\param[in] allocator a valid allocator\n* \\return `RCL_RET_OK` if cancel response was initialized successfully, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ALREADY_INIT` if the cancel response has already been initialized, or\n* \\return `RCL_RET_BAD_ALLOC` if allocating memory failed, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_cancel_response_init(
        cancel_response: *mut rcl_action_cancel_response_t,
        num_goals_canceling: usize,
        allocator: rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a rcl_action_cancel_response_t.\n**\n* After calling, the cancel response message will no longer be valid.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] cancel_response the cancel response message to be deinitialized\n* \\return `RCL_RET_OK` if the cancel response was deinitialized successfully, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_cancel_response_fini(
        cancel_response: *mut rcl_action_cancel_response_t,
    ) -> rcl_ret_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_action_client_impl_s {
    _unused: [u8; 0],
}
#[doc = " Internal action client implementation struct."]
pub type rcl_action_client_impl_t = rcl_action_client_impl_s;
#[doc = " Structure which encapsulates a ROS action client."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_action_client_s {
    #[doc = " Pointer to the action client implementation"]
    pub impl_: *mut rcl_action_client_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_action_client_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_action_client_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_action_client_s>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_action_client_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_action_client_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_action_client_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_action_client_s),
            "::",
            stringify!(impl_)
        )
    );
}
#[doc = " Structure which encapsulates a ROS action client."]
pub type rcl_action_client_t = rcl_action_client_s;
#[doc = " Options available for a rcl_action_client_t."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_action_client_options_s {
    #[doc = " Middleware quality of service settings for the action client.\n Goal service quality of service"]
    pub goal_service_qos: rmw_qos_profile_t,
    #[doc = " Result service quality of service"]
    pub result_service_qos: rmw_qos_profile_t,
    #[doc = " Cancel service quality of service"]
    pub cancel_service_qos: rmw_qos_profile_t,
    #[doc = " Feedback topic quality of service"]
    pub feedback_topic_qos: rmw_qos_profile_t,
    #[doc = " Status topic quality of service"]
    pub status_topic_qos: rmw_qos_profile_t,
    #[doc = " Custom allocator for the action client, used for incidental allocations.\n** For default behavior (malloc/free), see: rcl_get_default_allocator() */"]
    pub allocator: rcl_allocator_t,
}
#[test]
fn bindgen_test_layout_rcl_action_client_options_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_action_client_options_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_action_client_options_s>(),
        480usize,
        concat!("Size of: ", stringify!(rcl_action_client_options_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_action_client_options_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_action_client_options_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).goal_service_qos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_action_client_options_s),
            "::",
            stringify!(goal_service_qos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result_service_qos) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_action_client_options_s),
            "::",
            stringify!(result_service_qos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cancel_service_qos) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_action_client_options_s),
            "::",
            stringify!(cancel_service_qos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).feedback_topic_qos) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_action_client_options_s),
            "::",
            stringify!(feedback_topic_qos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status_topic_qos) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_action_client_options_s),
            "::",
            stringify!(status_topic_qos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_action_client_options_s),
            "::",
            stringify!(allocator)
        )
    );
}
#[doc = " Options available for a rcl_action_client_t."]
pub type rcl_action_client_options_t = rcl_action_client_options_s;
extern "C" {
    #[doc = " Return a rcl_action_client_t struct with members set to `NULL`.\n**\n* Should be called to get a null rcl_action_client_t before passing to\n* rcl_action_client_init().\n*/"]
    pub fn rcl_action_get_zero_initialized_client() -> rcl_action_client_t;
}
extern "C" {
    #[doc = " Initialize a rcl_action_client_t.\n**\n* After calling this function on a rcl_action_client_t, it can be used to send\n* goals of the given type to the given topic using rcl_action_send_goal_request().\n* If a goal request is sent to a (possibly remote) server and if the server\n* sends a response, the client can access the response with\n* rcl_take_goal_response() once the response is available.\n*\n* After a goal request has been accepted, the rcl_action_client_t associated with the\n* goal can perform the following operations:\n*\n* - Send a request for the result with rcl_action_send_result_request().\n* If the server sends a response when the goal terminates, the result can be accessed\n* with rcl_action_take_result_response(), once the response is available.\n* - Send a cancel request for the goal with rcl_action_send_cancel_request().\n* If the server sends a response to a cancel request, the client can access the\n* response with rcl_action_take_cancel_response() once the response is available.\n* - Take feedback about the goal with rcl_action_take_feedback().\n*\n* A rcl_action_client_t can be used to access the current status of all accepted goals\n* communicated by the action server with rcl_action_take_status().\n*\n* The given rcl_node_t must be valid and the resulting rcl_action_client_t is\n* only valid as long as the given rcl_node_t remains valid.\n*\n* The rosidl_action_type_support_t is obtained on a per .action type basis.\n* When the user defines a ROS action, code is generated which provides the\n* required rosidl_action_type_support_t object.\n* This object can be obtained using a language appropriate mechanism.\n*\n* \\todo TODO(jacobperron) write these instructions once and link to it instead\n*\n* For C, a macro can be used (for example `example_interfaces/Fibonacci`):\n*\n* ```c\n* #include <rosidl_runtime_c/action_type_support_struct.h>\n* #include <example_interfaces/action/fibonacci.h>\n* const rosidl_action_type_support_t * ts =\n*   ROSIDL_GET_ACTION_TYPE_SUPPORT(example_interfaces, Fibonacci);\n* ```\n*\n* For C++, a template function is used:\n*\n* ```cpp\n* #include <rosidl_runtime_cpp/action_type_support.hpp>\n* #include <example_interfaces/action/fibonacci.h>\n* using rosidl_typesupport_cpp::get_action_type_support_handle;\n* const rosidl_action_type_support_t * ts =\n*   get_action_type_support_handle<example_interfaces::action::Fibonacci>();\n* ```\n*\n* The rosidl_action_type_support_t object contains action type specific\n* information used to send or take goals, results, and feedback.\n*\n* The topic name must be a c string that follows the topic and service name\n* format rules for unexpanded names, also known as non-fully qualified names:\n*\n* \\see rcl_expand_topic_name\n*\n* The options struct allows the user to set the quality of service settings as\n* well as a custom allocator that is used when initializing/finalizing the\n* client to allocate space for incidentals, e.g. the action client name string.\n*\n* Expected usage (for C action clients):\n*\n* ```c\n* #include <rcl/rcl.h>\n* #include <rcl_action/action_client.h>\n* #include <rosidl_runtime_c/action_type_support_struct.h>\n* #include <example_interfaces/action/fibonacci.h>\n*\n* rcl_node_t node = rcl_get_zero_initialized_node();\n* rcl_node_options_t node_ops = rcl_node_get_default_options();\n* rcl_ret_t ret = rcl_node_init(&node, \"node_name\", \"/my_namespace\", &node_ops);\n* // ... error handling\n* const rosidl_action_type_support_t * ts =\n*   ROSIDL_GET_ACTION_TYPE_SUPPORT(example_interfaces, Fibonacci);\n* rcl_action_client_t action_client = rcl_action_get_zero_initialized_client();\n* rcl_action_client_options_t action_client_ops = rcl_action_client_get_default_options();\n* ret = rcl_action_client_init(&action_client, &node, ts, \"fibonacci\", &action_client_ops);\n* // ... error handling, and on shutdown do finalization:\n* ret = rcl_action_client_fini(&action_client, &node);\n* // ... error handling for rcl_action_client_fini()\n* ret = rcl_node_fini(&node);\n* // ... error handling for rcl_node_fini()\n* ```\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[out] action_client a preallocated, zero-initialized action client structure\n*   to be initialized\n* \\param[in] node valid rcl node handle\n* \\param[in] type_support type support object for the action's type\n* \\param[in] action_name the name of the action\n* \\param[in] options action_client options, including quality of service settings\n* \\return `RCL_RET_OK` if action_client was initialized successfully, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_NODE_INVALID` if the node is invalid, or\n* \\return `RCL_RET_ALREADY_INIT` if the action client is already initialized, or\n* \\return `RCL_RET_BAD_ALLOC` if allocating memory failed, or\n* \\return `RCL_RET_ACTION_NAME_INVALID` if the given action name is invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_client_init(
        action_client: *mut rcl_action_client_t,
        node: *mut rcl_node_t,
        type_support: *const rosidl_action_type_support_t,
        action_name: *const ::std::os::raw::c_char,
        options: *const rcl_action_client_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a rcl_action_client_t.\n**\n* After calling, the node will no longer listen for goals for this action client\n* (assuming this is the only action client of this type in this node).\n*\n* After calling, calls to rcl_wait(), rcl_action_send_goal_request(),\n* rcl_action_take_goal_response(), rcl_action_send_cancel_request(),\n* rcl_action_take_cancel_response(), rcl_action_send_result_request(),\n* rcl_action_take_result_response(), rcl_action_take_feedback(), and\n* rcl_action_take_status(), will fail when using this action client.\n*\n* Additionally, rcl_wait() will be interrupted if currently blocking.\n*\n* The given node handle is still valid.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] action_client handle to the action_client to be deinitialized\n* \\param[in] node handle to the node used to create the action client\n* \\return `RCL_RET_OK` if the action client was deinitialized successfully, or\n* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action client is invalid, or\n* \\return `RCL_RET_NODE_INVALID` if the node is invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_client_fini(
        action_client: *mut rcl_action_client_t,
        node: *mut rcl_node_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the default action client options in a rcl_action_client_options_t.\n**\n* The defaults are:\n*\n* - goal_service_qos = rmw_qos_profile_services_default;\n* - result_service_qos = rmw_qos_profile_services_default;\n* - cancel_service_qos = rmw_qos_profile_services_default;\n* - feedback_topic_qos = rmw_qos_profile_default;\n* - status_topic_qos = rcl_action_qos_profile_status_default;\n* - allocator = rcl_get_default_allocator()\n*/"]
    pub fn rcl_action_client_get_default_options() -> rcl_action_client_options_t;
}
extern "C" {
    #[doc = " Check if an action server is available for the given action client.\n**\n* This function will return true for is_available if there is an action server\n* available for the given action client.\n*\n* The node parameter must not be `NULL`, and must point to a valid node.\n*\n* The client parameter must not be `NULL`, and must point to a valid client.\n*\n* The given client and node must match, i.e. the client must have been created\n* using the given node.\n*\n* The is_available parameter must not be `NULL`, and must point a bool variable.\n* The result of the check will be stored in the is_available parameter.\n*\n* In the event that error handling needs to allocate memory, this function\n* will try to use the node's allocator.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation may need to protect the data structure with a lock</i>\n*\n* \\param[in] node the handle to the node being used to query the ROS graph\n* \\param[in] client the handle to the action client being queried\n* \\param[out] is_available set to true if there is an action server available, else false\n* \\return `RCL_RET_OK` if successful (regardless of the action server availability), or\n* \\return `RCL_RET_NODE_INVALID` if the node is invalid, or\n* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action client is invalid, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_server_is_available(
        node: *const rcl_node_t,
        client: *const rcl_action_client_t,
        is_available: *mut bool,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Send a ROS goal using a rcl_action_client_t.\n**\n* This is a non-blocking call.\n*\n* The caller is responsible for ensuring that the type of `ros_goal_request`\n* and the type associate with the client (via the type support) match.\n* Passing a different type produces undefined behavior and cannot be checked\n* by this function and therefore no deliberate error will occur.\n*\n* The ROS goal message given by the `ros_goal_request` void pointer is always\n* owned by the calling code, but should remain constant during execution of this\n* function. i.e. The message cannot change during the rcl_action_send_goal_request() call.\n* Before calling rcl_action_send_goal_request() the message can change but after calling\n* rcl_action_send_goal_request() it depends on RMW implementation behavior.\n* The same `ros_goal_request` can be passed to multiple calls of this function\n* simultaneously, even if the action clients differ.\n*\n* This function is thread safe so long as access to both the rcl_action_client_t\n* and the `ros_goal_request` are synchronized.\n* That means that calling rcl_action_send_goal_request() from multiple threads is allowed,\n* but calling rcl_action_send_goal_request() at the same time as non-thread safe action\n* client functions is not, e.g. calling rcl_action_send_goal_request() and\n* rcl_action_client_fini() concurrently is not allowed.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes [1]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] for unique pairs of clients and goals, see above for more</i>\n*\n* \\param[in] action_client handle to the client that will make the goal request\n* \\param[in] ros_goal_request pointer to the ROS goal message\n* \\param[out] sequence_number pointer to the goal request sequence number\n* \\return `RCL_RET_OK` if the request was sent successfully, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the client is invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_send_goal_request(
        action_client: *const rcl_action_client_t,
        ros_goal_request: *const ::std::os::raw::c_void,
        sequence_number: *mut i64,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take a response for a goal request from an action server using a rcl_action_client_t.\n**\n* \\todo TODO(jacobperron) blocking of take?\n*\n* \\todo TODO(jacobperron) pre-, during-, and post-conditions for message ownership?\n*\n* \\todo TODO(jacobperron) is this thread-safe?\n*\n* The caller is responsible for ensuring that the type of `ros_goal_response`\n* and the type associate with the client (via the type support) match.\n* Passing a different type produces undefined behavior and cannot be checked\n* by this function and therefore no deliberate error will occur.\n*\n* The caller must provide a pointer to an allocated message for the `ros_goal_response`.\n* If the take is successful, this function will populate the fields of `ros_goal_response`.\n* The ROS message given by the `ros_goal_response` void pointer is always\n* owned by the calling code, but should remain constant during execution of this\n* function. i.e. The message cannot change during the rcl_action_send_goal_response() call.\n* Before calling rcl_action_send_goal_response() the message can change but after calling\n* rcl_action_send_goal_response() it depends on RMW implementation behavior.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] action_client handle to the client that will take the goal response\n* \\param[out] response_header pointer to the goal response header\n* \\param[out] ros_goal_response pointer to the response of a goal request\n* \\return `RCL_RET_OK` if the response was taken successfully, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action client is invalid, or\n* \\return `RCL_RET_ACTION_CLIENT_TAKE_FAILED` if take failed but no error occurred\n*         in the middleware, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_take_goal_response(
        action_client: *const rcl_action_client_t,
        response_header: *mut rmw_request_id_t,
        ros_goal_response: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take a ROS feedback message for an active goal associated with a rcl_action_client_t.\n**\n* The caller is responsible for ensuring that the type of `ros_feedback`\n* and the type associate with the client (via the type support) match.\n* Passing a different type produces undefined behavior and cannot be checked\n* by this function and therefore no deliberate error will occur.\n*\n* \\todo TODO(jacobperron) blocking of take?\n*\n* \\todo TODO(jacobperron) pre-, during-, and post-conditions for message ownership?\n*\n* \\todo TODO(jacobperron) is this thread-safe?\n*\n* `ros_feedback` should point to a preallocated ROS message struct of the\n* correct type.\n* If feedback is successfully taken, the feedback message is copied to into the\n* `ros_feedback` struct.\n*\n* If allocation is required when taking the feedback, e.g. if space needs to\n* be allocated for a dynamically sized array in the target message, then the\n* allocator given in the action client options is used.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe [1]\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] only if required when filling the feedback message, avoided for fixed sizes</i>\n*\n* \\param[in] action_client handle to the client that will take action feedback\n* \\param[out] ros_feedback pointer to the ROS feedback message.\n* \\return `RCL_RET_OK` if the response was taken successfully, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action client is invalid, or\n* \\return `RCL_RET_BAD_ALLOC` if allocating memory failed, or\n* \\return `RCL_RET_ACTION_CLIENT_TAKE_FAILED` if take failed but no error occurred\n*         in the middleware, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_take_feedback(
        action_client: *const rcl_action_client_t,
        ros_feedback: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take a ROS status message using a rcl_action_client_t.\n**\n* The caller is responsible for ensuring that the type of `ros_status_array`\n* and the type associate with the client (via the type support) match.\n* Passing a different type produces undefined behavior and cannot be checked\n* by this function and therefore no deliberate error will occur.\n*\n* \\todo TODO(jacobperron) blocking of take?\n*\n* \\todo TODO(jacobperron) pre-, during-, and post-conditions for message ownership?\n*\n* \\todo TODO(jacobperron) is this thread-safe?\n*\n* The caller is responsible for allocating the `ros_status_array` struct with a\n* zero-initialization (the internal array should not be allocated).\n* If there is a successful take, then `ros_status_array` is populated\n* with the allocator given in the action client options.\n* It is the callers responsibility to deallocate the `ros_status_array` struct using\n* the allocator given in the action client options.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] action_client handle to the client that will take status message\n* \\param[out] ros_status_array pointer to ROS aciton_msgs/StatusArray message that\n*   will be populated with information about goals that have accepted the cancel request.\n* \\return `RCL_RET_OK` if the response was taken successfully, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action client is invalid, or\n* \\return `RCL_RET_BAD_ALLOC` if allocating memory failed, or\n* \\return `RCL_RET_ACTION_CLIENT_TAKE_FAILED` if take failed but no error occurred\n*         in the middleware, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_take_status(
        action_client: *const rcl_action_client_t,
        ros_status_array: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Send a request for the result of a completed goal associated with a rcl_action_client_t.\n**\n* This is a non-blocking call.\n*\n* The caller is responsible for ensuring that the type of `ros_result_request`\n* and the type associate with the client (via the type support) match.\n* Passing a different type produces undefined behavior and cannot be checked\n* by this function and therefore no deliberate error will occur.\n*\n* The ROS message given by the `ros_result_request` void pointer is always\n* owned by the calling code, but should remain constant during execution of this\n* function. i.e. The message cannot change during the rcl_action_send_result_request() call.\n* Before calling rcl_action_send_result_request() the message can change but after calling\n* rcl_action_send_result_request() it depends on RMW implementation behavior.\n* The same `ros_result_request` can be passed to multiple calls of this function\n* simultaneously, even if the action clients differ.\n*\n* This function is thread safe so long as access to both the rcl_action_client_t\n* and the `ros_result_request` are synchronized.\n* That means that calling rcl_action_send_result_request() from multiple threads is allowed,\n* but calling rcl_action_send_result_request() at the same time as non-thread safe action\n* client functions is not, e.g. calling rcl_action_send_result_request() and\n* rcl_action_client_fini() concurrently is not allowed.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes [1]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] for unique pairs of clients and result requests, see above for more</i>\n\n* \\param[in] action_client handle to the client that will send the result request\n* \\param[in] ros_result_request pointer to a ROS result request message\n* \\param[out] sequence_number pointer to the result request sequence number\n* \\return `RCL_RET_OK` if the request was sent successfully, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action client is invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_send_result_request(
        action_client: *const rcl_action_client_t,
        ros_result_request: *const ::std::os::raw::c_void,
        sequence_number: *mut i64,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take a ROS result message for a completed goal associated with a rcl_action_client_t.\n**\n* \\todo TODO(jacobperron) blocking of take?\n*\n* \\todo TODO(jacobperron) pre-, during-, and post-conditions for message ownership?\n*\n* \\todo TODO(jacobperron) is this thread-safe?\n*\n* The caller is responsible for ensuring that the type of `ros_result_response`\n* and the type associate with the client (via the type support) match.\n* Passing a different type produces undefined behavior and cannot be checked\n* by this function and therefore no deliberate error will occur.\n*\n* The caller must provide a pointer to an allocated message for the `ros_result_response`.\n* If the take is successful, this function will populate the fields of `ros_result_response`.\n* The ROS message given by the `ros_result_response` void pointer is always\n* owned by the calling code, but should remain constant during execution of this\n* function. i.e. The message cannot change during the rcl_action_take_result_response() call.\n* Before calling rcl_action_take_result_response() the message can change but after calling\n* rcl_action_take_result_response() it depends on RMW implementation behavior.\n*\n* If allocation is required when taking the result, e.g. if space needs to\n* be allocated for a dynamically sized array in the target message, then the\n* allocator given in the action client options is used.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe [1]\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] only if required when filling the result response message, avoided for fixed sizes</i>\n*\n* \\param[in] action_client handle to the client that will take the result response\n* \\param[out] response_header pointer to the result response header\n* \\param[out] ros_result preallocated, zero-initialized, struct where the ROS\n*   result message is copied.\n* \\return `RCL_RET_OK` if the response was taken successfully, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action client is invalid, or\n* \\return `RCL_RET_BAD_ALLOC` if allocating memory failed, or\n* \\return `RCL_RET_ACTION_CLIENT_TAKE_FAILED` if take failed but no error occurred\n*         in the middleware, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_take_result_response(
        action_client: *const rcl_action_client_t,
        response_header: *mut rmw_request_id_t,
        ros_result: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Send a cancel request for a goal using a rcl_action_client_t.\n**\n* This is a non-blocking call.\n*\n* The caller is responsible for ensuring that the type of `ros_cancel_request`\n* and the type associate with the client (via the type support) match.\n* Passing a different type produces undefined behavior and cannot be checked\n* by this function and therefore no deliberate error will occur.\n*\n* The following cancel policy applies based on the goal ID and the timestamp provided\n* by the `ros_cancel_request` message:\n*\n* - If the goal ID is zero and timestamp is zero, cancel all goals.\n* - If the goal ID is zero and timestamp is not zero, cancel all goals accepted\n*   at or before the timestamp.\n* - If the goal ID is not zero and timestamp is zero, cancel the goal with the\n*   given ID regardless of the time it was accepted.\n* - If the goal ID is not zero and timestamp is not zero, cancel the goal with the\n*   given ID and all goals accepted at or before the timestamp.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] action_client handle to the client that will make the cancel request\n* \\param[in] ros_cancel_request pointer the ROS cancel request message\n* \\param[out] sequence_number pointer to the cancel request sequence number\n* \\return `RCL_RET_OK` if the response was taken successfully, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action client is invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_send_cancel_request(
        action_client: *const rcl_action_client_t,
        ros_cancel_request: *const ::std::os::raw::c_void,
        sequence_number: *mut i64,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take a cancel response using a rcl_action_client_t.\n**\n* \\todo TODO(jacobperron) blocking of take?\n*\n* \\todo TODO(jacobperron) pre-, during-, and post-conditions for message ownership?\n*\n* \\todo TODO(jacobperron) is this thread-safe?\n*\n* The caller is responsible for ensuring that the type of `ros_cancel_response`\n* and the type associate with the client (via the type support) match.\n* Passing a different type produces undefined behavior and cannot be checked\n* by this function and therefore no deliberate error will occur.\n\n* The caller is responsible for allocating the `ros_cancel_response` message\n* with a zero-initialization (the internal array should not be allocated).\n* If a successful response is taken, then `ros_cancel_response` is populated\n* using the allocator given in the action client options.\n* It is the callers responsibility to deallocate `ros_cancel_response` using\n* the allocator given in the action client options.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] action_client handle to the client that will take the cancel response\n* \\param[out] response_header pointer to the cancel response header\n* \\param[out] ros_cancel_response a zero-initialized ROS cancel response message where\n*   the cancel response is copied.\n* \\return `RCL_RET_OK` if the response was taken successfully, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action client is invalid, or\n* \\return `RCL_RET_BAD_ALLOC` if allocating memory failed, or\n* \\return `RCL_RET_ACTION_CLIENT_TAKE_FAILED` if take failed but no error occurred\n*         in the middleware, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_take_cancel_response(
        action_client: *const rcl_action_client_t,
        response_header: *mut rmw_request_id_t,
        ros_cancel_response: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the name of the action for a rcl_action_client_t.\n**\n* This function returns the action client's name string.\n* This function can fail, and therefore return `NULL`, if the:\n*   - action client is `NULL`\n*   - action client is invalid (never called init, called fini, or invalid)\n*\n* The returned string is only valid as long as the action client is valid.\n* The value of the string may change if the topic name changes, and therefore\n* copying the string is recommended if this is a concern.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] action_client the pointer to the action client\n* \\return name string if successful, otherwise `NULL`\n*/"]
    pub fn rcl_action_client_get_action_name(
        action_client: *const rcl_action_client_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the options for a rcl_action_client_t.\n**\n* This function returns the action client's internal options struct.\n* This function can fail, and therefore return `NULL`, if the:\n*   - action client is `NULL`\n*   - action client is invalid (never called init, called fini, or invalid)\n*\n* The returned struct is only valid as long as the action client is valid.\n* The values in the struct may change if the action client's options change,\n* and therefore copying the struct is recommended if this is a concern.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] action_client pointer to the action client\n* \\return options struct if successful, otherwise `NULL`\n*/"]
    pub fn rcl_action_client_get_options(
        action_client: *const rcl_action_client_t,
    ) -> *const rcl_action_client_options_t;
}
extern "C" {
    #[doc = " Check that a rcl_action_client_t is valid.\n**\n* The bool returned is `false` if `action_client` is invalid.\n* The bool returned is `true` otherwise.\n* In the case where `false` is to be returned, an error message is set.\n* This function cannot fail.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] action_client pointer to the rcl action client\n* \\return `true` if `action_client` is valid, otherwise `false`\n*/"]
    pub fn rcl_action_client_is_valid(action_client: *const rcl_action_client_t) -> bool;
}
extern "C" {
    pub fn rcl_action_client_set_goal_client_callback(
        action_client: *const rcl_action_client_t,
        callback: rcl_event_callback_t,
        user_data: *const ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_client_set_cancel_client_callback(
        action_client: *const rcl_action_client_t,
        callback: rcl_event_callback_t,
        user_data: *const ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_client_set_result_client_callback(
        action_client: *const rcl_action_client_t,
        callback: rcl_event_callback_t,
        user_data: *const ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_client_set_feedback_subscription_callback(
        action_client: *const rcl_action_client_t,
        callback: rcl_event_callback_t,
        user_data: *const ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_client_set_status_subscription_callback(
        action_client: *const rcl_action_client_t,
        callback: rcl_event_callback_t,
        user_data: *const ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Transition a goal from one state to the next.\n**\n* Given a goal state and a goal event, return the next state.\n*\n* \\param[in] state the state to transition from\n* \\param[in] event the event triggering a transition\n* \\return the next goal state if the transition is valid, or\n* \\return `GOAL_STATE_UNKNOWN` if the transition is invalid or an error occured\n*/"]
    pub fn rcl_action_transition_goal_state(
        state: rcl_action_goal_state_t,
        event: rcl_action_goal_event_t,
    ) -> rcl_action_goal_state_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_action_goal_handle_impl_s {
    _unused: [u8; 0],
}
#[doc = " Internal rcl action goal implementation struct."]
pub type rcl_action_goal_handle_impl_t = rcl_action_goal_handle_impl_s;
#[doc = " Goal handle for an action."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_action_goal_handle_s {
    #[doc = " Pointer to the action goal handle implementation"]
    pub impl_: *mut rcl_action_goal_handle_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_action_goal_handle_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_action_goal_handle_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_action_goal_handle_s>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_action_goal_handle_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_action_goal_handle_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_action_goal_handle_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_action_goal_handle_s),
            "::",
            stringify!(impl_)
        )
    );
}
#[doc = " Goal handle for an action."]
pub type rcl_action_goal_handle_t = rcl_action_goal_handle_s;
extern "C" {
    #[doc = " Return a rcl_action_goal_handle_t struct with members set to `NULL`.\n**\n* Should be called to get a null rcl_action_goal_handle_t before passing to\n* rcl_action_goal_handle_init().\n*/"]
    pub fn rcl_action_get_zero_initialized_goal_handle() -> rcl_action_goal_handle_t;
}
extern "C" {
    #[doc = " Initialize a rcl_action_goal_handle_t.\n**\n* After calling this function on a rcl_action_goal_handle_t, it can be used to update the\n* goals state with rcl_action_update_goal_state().\n* It can also be used to query the state of the goal with\n* rcl_action_goal_handle_get_message() and rcl_action_goal_handle_is_active().\n* Goal information can be accessed with rcl_action_goal_handle_get_message() and\n* rcl_action_goal_handle_get_info().\n*\n* Goal handles are typically initialized and finalized by action servers.\n* I.e. The allocator should be provided by the action server.\n* Goal handles are created with rcl_action_accept_new_goal() and destroyed with\n* rcl_action_clear_expired_goals() or rcl_action_server_fini().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[out] goal_handle preallocated, zero-initialized, goal handle structure\n*   to be initialized\n* \\param[in] goal_info information about the goal to be copied to the goal handle\n* \\param[in] allocator a valid allocator used to initialized the goal handle\n* \\return `RCL_RET_OK` if goal_handle was initialized successfully, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if the allocator is invalid, or\n* \\return `RCL_RET_ACTION_GOAL_HANDLE_INVALID` if the goal handle is invalid, or\n* \\return `RCL_RET_ALREADY_INIT` if the goal handle has already been initialized, or\n* \\return `RCL_RET_BAD_ALLOC` if allocating memory failed\n*/"]
    pub fn rcl_action_goal_handle_init(
        goal_handle: *mut rcl_action_goal_handle_t,
        goal_info: *const rcl_action_goal_info_t,
        allocator: rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a rcl_action_goal_handle_t.\n**\n* After calling, rcl_action_goal_handle_t will no longer be valid and\n* rcl_action_server_t will no longer track the goal associated with the goal handle.\n*\n* After calling, calls to rcl_action_publish_feedback(), rcl_action_publish_status(),\n* rcl_action_update_goal_state(), rcl_action_goal_handle_get_status(),\n* rcl_action_goal_handle_is_active(), rcl_action_goal_handle_get_message(), and\n* rcl_action_goal_handle_get_info() will fail when using this goal handle.\n*\n* However, the given action server is still valid.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] goal_handle struct to be deinitialized\n* \\return `RCL_RET_OK` if the goal handle was deinitialized successfully, or\n* \\return `RCL_RET_ACTION_GOAL_HANDLE_INVALID` if the goal handle is invalid, or\n*/"]
    pub fn rcl_action_goal_handle_fini(goal_handle: *mut rcl_action_goal_handle_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Update a goal state with a rcl_action_goal_handle_t and an event.\n**\n* This is a non-blocking call.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] goal_handle struct containing goal state to transition\n* \\param[in] goal_event the event used to transition the goal state\n* \\return `RCL_RET_OK` if the goal state was updated successfully, or\n* \\return `RCL_RET_ACTION_GOAL_EVENT_INVALID` if the goal event is invalid, or\n* \\return `RCL_RET_ACTION_GOAL_HANDLE_INVALID` if the goal handle is invalid, or\n*/"]
    pub fn rcl_action_update_goal_state(
        goal_handle: *mut rcl_action_goal_handle_t,
        goal_event: rcl_action_goal_event_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the ID of a goal using a rcl_action_goal_handle_t.\n**\n* This is a non-blocking call.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] goal_handle struct containing the goal and meta\n* \\param[out] goal_info a preallocated struct where the goal info is copied\n* \\return `RCL_RET_OK` if the goal ID was accessed successfully, or\n* \\return `RCL_RET_ACTION_GOAL_HANDLE_INVALID` if the goal handle is invalid, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if the goal_info argument is invalid\n*/"]
    pub fn rcl_action_goal_handle_get_info(
        goal_handle: *const rcl_action_goal_handle_t,
        goal_info: *mut rcl_action_goal_info_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the status of a goal.\n**\n* This is a non-blocking call.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] goal_handle struct containing the goal and metadata\n* \\param[out] status a preallocated struct where the goal status is copied\n* \\return `RCL_RET_OK` if the goal ID was accessed successfully, or\n* \\return `RCL_RET_ACTION_GOAL_HANDLE_INVALID` if the goal handle is invalid, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if the status argument is invalid\n*/"]
    pub fn rcl_action_goal_handle_get_status(
        goal_handle: *const rcl_action_goal_handle_t,
        status: *mut rcl_action_goal_state_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Check if a goal is active using a rcl_action_goal_handle_t.\n**\n* This is a non-blocking call.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] goal_handle struct containing the goal and metadata\n* \\return `true` if the goal is in one of the following states: ACCEPTED, EXECUTING, or CANCELING, or\n* \\return `false` if the goal handle pointer is invalid, or\n* \\return `false` otherwise\n*/"]
    pub fn rcl_action_goal_handle_is_active(goal_handle: *const rcl_action_goal_handle_t) -> bool;
}
extern "C" {
    #[doc = " Check if a goal can be transitioned to CANCELING in its current state.\n**\n* This is a non-blocking call.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] goal_handle struct containing the goal and metadata\n* \\return `true` if the goal can be transitioned to CANCELING from its current state, or\n* \\return `false` if the goal handle pointer is invalid, or\n* \\return `false` otherwise\n*/"]
    pub fn rcl_action_goal_handle_is_cancelable(
        goal_handle: *const rcl_action_goal_handle_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Check if a rcl_action_goal_handle_t is valid.\n**\n* This is a non-blocking call.\n*\n* A goal handle is invalid if:\n*   - the implementation is `NULL` (rcl_action_goal_handle_init() not called or failed)\n*   - rcl_shutdown() has been called since the goal handle has been initialized\n*   - the goal handle has been finalized with rcl_action_goal_handle_fini()\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] goal_handle struct to evaluate as valid or not\n* \\return `true` if the goal handle is valid, or\n* \\return `false` if the goal handle pointer is null, or\n* \\return `false` otherwise\n*/"]
    pub fn rcl_action_goal_handle_is_valid(goal_handle: *const rcl_action_goal_handle_t) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_action_server_impl_s {
    _unused: [u8; 0],
}
#[doc = " Internal rcl_action implementation struct."]
pub type rcl_action_server_impl_t = rcl_action_server_impl_s;
#[doc = " Structure which encapsulates a ROS Action Server."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_action_server_s {
    #[doc = " Pointer to the action server implementation"]
    pub impl_: *mut rcl_action_server_impl_t,
}
#[test]
fn bindgen_test_layout_rcl_action_server_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_action_server_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_action_server_s>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_action_server_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_action_server_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_action_server_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_action_server_s),
            "::",
            stringify!(impl_)
        )
    );
}
#[doc = " Structure which encapsulates a ROS Action Server."]
pub type rcl_action_server_t = rcl_action_server_s;
#[doc = " Options available for a rcl_action_server_t."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcl_action_server_options_s {
    #[doc = " Middleware quality of service settings for the action server.\n Goal service quality of service"]
    pub goal_service_qos: rmw_qos_profile_t,
    #[doc = " Cancel service quality of service"]
    pub cancel_service_qos: rmw_qos_profile_t,
    #[doc = " Result service quality of service"]
    pub result_service_qos: rmw_qos_profile_t,
    #[doc = " Feedback topic quality of service"]
    pub feedback_topic_qos: rmw_qos_profile_t,
    #[doc = " Status topic quality of service"]
    pub status_topic_qos: rmw_qos_profile_t,
    #[doc = " Custom allocator for the action server, used for incidental allocations.\n** For default behavior (malloc/free), see: rcl_get_default_allocator() */"]
    pub allocator: rcl_allocator_t,
    #[doc = " Goal handles that have results longer than this time are deallocated."]
    pub result_timeout: rcl_duration_t,
}
#[test]
fn bindgen_test_layout_rcl_action_server_options_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_action_server_options_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_action_server_options_s>(),
        488usize,
        concat!("Size of: ", stringify!(rcl_action_server_options_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_action_server_options_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_action_server_options_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).goal_service_qos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_action_server_options_s),
            "::",
            stringify!(goal_service_qos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cancel_service_qos) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_action_server_options_s),
            "::",
            stringify!(cancel_service_qos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result_service_qos) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_action_server_options_s),
            "::",
            stringify!(result_service_qos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).feedback_topic_qos) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_action_server_options_s),
            "::",
            stringify!(feedback_topic_qos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status_topic_qos) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_action_server_options_s),
            "::",
            stringify!(status_topic_qos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_action_server_options_s),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result_timeout) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_action_server_options_s),
            "::",
            stringify!(result_timeout)
        )
    );
}
#[doc = " Options available for a rcl_action_server_t."]
pub type rcl_action_server_options_t = rcl_action_server_options_s;
extern "C" {
    #[doc = " Return a rcl_action_server_t struct with members set to `NULL`.\n**\n* Should be called to get a null rcl_action_server_t before passing to\n* rcl_action_server_init().\n*/"]
    pub fn rcl_action_get_zero_initialized_server() -> rcl_action_server_t;
}
extern "C" {
    #[doc = " Initialize an action server.\n**\n* After calling this function on a rcl_action_server_t, it can be used to take\n* goals of the given type for the given action name using rcl_action_take_goal_request()\n* and take cancel requests with rcl_action_take_cancel_request().\n* It can also send a result for a request using rcl_action_send_result() or\n* rcl_action_send_cancel_response().\n*\n* After accepting a goal with rcl_action_take_goal_request(), the action server can\n* be used to send feedback with rcl_action_publish_feedback() and send status\n* messages with rcl_action_publish_status().\n*\n* The given rcl_node_t must be valid and the resulting rcl_action_server_t is\n* only valid as long as the given rcl_node_t remains valid.\n*\n* The give rcl_clock_t must be valid and the resulting rcl_ction_server_t is\n* only valid as long ast he given rcl_clock_t remains valid.\n*\n* The rosidl_action_type_support_t is obtained on a per .action type basis.\n* When the user defines a ROS action, code is generated which provides the\n* required rosidl_action_type_support_t object.\n* This object can be obtained using a language appropriate mechanism.\n* \\todo TODO(jacobperron) write these instructions once and link to it instead\n*\n* For C, a macro can be used (for example `example_interfaces/Fibonacci`):\n*\n* ```c\n* #include <rosidl_runtime_c/action_type_support_struct.h>\n* #include <example_interfaces/action/fibonacci.h>\n* const rosidl_action_type_support_t * ts =\n*   ROSIDL_GET_ACTION_TYPE_SUPPORT(example_interfaces, Fibonacci);\n* ```\n*\n* For C++, a template function is used:\n*\n* ```cpp\n* #include <rosidl_runtime_cpp/action_type_support.hpp>\n* #include <example_interfaces/action/fibonacci.h>\n* using rosidl_typesupport_cpp::get_action_type_support_handle;\n* const rosidl_action_type_support_t * ts =\n*   get_action_type_support_handle<example_interfaces::action::Fibonacci>();\n* ```\n*\n* The rosidl_action_type_support_t object contains action type specific\n* information used to send or take goals, results, and feedback.\n*\n* The topic name must be a c string that follows the topic and service name\n* format rules for unexpanded names, also known as non-fully qualified names:\n*\n* \\see rcl_expand_topic_name\n*\n* The options struct allows the user to set the quality of service settings as\n* well as a custom allocator that is used when initializing/finalizing the\n* client to allocate space for incidentals, e.g. the action server name string.\n*\n* Expected usage (for C action servers):\n*\n* ```c\n* #include <rcl/rcl.h>\n* #include <rcl_action/rcl_action.h>\n* #include <rosidl_runtime_c/action_type_support_struct.h>\n* #include <example_interfaces/action/fibonacci.h>\n*\n* rcl_node_t node = rcl_get_zero_initialized_node();\n* rcl_node_options_t node_ops = rcl_node_get_default_options();\n* rcl_ret_t ret = rcl_node_init(&node, \"node_name\", \"/my_namespace\", &node_ops);\n* // ... error handling\n* const rosidl_action_type_support_t * ts =\n*   ROSIDL_GET_ACTION_TYPE_SUPPORT(example_interfaces, Fibonacci);\n* rcl_action_server_t action_server = rcl_action_get_zero_initialized_server();\n* rcl_action_server_options_t action_server_ops = rcl_action_server_get_default_options();\n* ret = rcl_action_server_init(&action_server, &node, ts, \"fibonacci\", &action_server_ops);\n* // ... error handling, and on shutdown do finalization:\n* ret = rcl_action_server_fini(&action_server, &node);\n* // ... error handling for rcl_action_server_fini()\n* ret = rcl_node_fini(&node);\n* // ... error handling for rcl_node_fini()\n* ```\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[out] action_server handle to a preallocated, zero-initialized action server structure\n*   to be initialized.\n* \\param[in] node valid node handle\n* \\param[in] clock valid clock handle\n* \\param[in] type_support type support object for the action's type\n* \\param[in] action_name the name of the action\n* \\param[in] options action_server options, including quality of service settings\n* \\return `RCL_RET_OK` if action_server was initialized successfully, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_NODE_INVALID` if the node is invalid, or\n* \\return `RCL_RET_BAD_ALLOC` if allocating memory failed, or\n* \\return `RCL_RET_ACTION_NAME_INVALID` if the given action name is invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_server_init(
        action_server: *mut rcl_action_server_t,
        node: *mut rcl_node_t,
        clock: *mut rcl_clock_t,
        type_support: *const rosidl_action_type_support_t,
        action_name: *const ::std::os::raw::c_char,
        options: *const rcl_action_server_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize an action server.\n**\n* After calling, the node will no longer listen to services and topics for this action server.\n* (assuming this is the only action server of this type in this node).\n*\n* After calling, calls to rcl_wait(), rcl_action_take_goal_request(),\n* rcl_action_take_cancel_request(), rcl_action_publish_feedback(),\n* rcl_action_publish_status(), rcl_action_send_result(), and\n* rcl_action_send_cancel_response() will fail when using this action server.\n* Additionally, rcl_wait() will be interrupted if currently blocking.\n* However, the given node handle is still valid.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] action_server handle to the action_server to be deinitialized\n* \\param[in] node handle to the node used to create the action server\n* \\return `RCL_RET_OK` if the action server was deinitialized successfully, or\n* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server pointer is null, or\n* \\return `RCL_RET_NODE_INVALID` if the node is invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_server_fini(
        action_server: *mut rcl_action_server_t,
        node: *mut rcl_node_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the default action server options in a rcl_action_server_options_t.\n**\n* The defaults are:\n*\n* - goal_service_qos = rmw_qos_profile_services_default;\n* - cancel_service_qos = rmw_qos_profile_services_default;\n* - result_service_qos = rmw_qos_profile_services_default;\n* - feedback_topic_qos = rmw_qos_profile_default;\n* - status_topic_qos = rcl_action_qos_profile_status_default;\n* - allocator = rcl_get_default_allocator();\n* - result_timeout = RCUTILS_S_TO_NS(10);  // 10 seconds\n*/"]
    pub fn rcl_action_server_get_default_options() -> rcl_action_server_options_t;
}
extern "C" {
    #[doc = " Take a pending ROS goal using an action server.\n**\n* \\todo TODO(jacobperron) blocking of take?\n*\n* \\todo TODO(jacobperron) pre-, during-, and post-conditions for message ownership?\n*\n* \\todo TODO(jacobperron) is this thread-safe?\n*\n* The caller is responsible for ensuring that the type of `ros_goal_request`\n* and the type associate with the client (via the type support) match.\n* Passing a different type produces undefined behavior and cannot be checked\n* by this function and therefore no deliberate error will occur.\n*\n* `ros_goal_request` should point to a preallocated, zero-initialized,\n* ROS goal message.\n* If a goal request is taken successfully, it will be copied into `ros_goal_request`.\n*\n* If allocation is required when taking the request, e.g. if space needs to\n* be allocated for a dynamically sized array in the target message, then the\n* allocator given in the action server options is used.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe [1]\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] only if required when filling the request, avoided for fixed sizes</i>\n*\n* \\param[in] action_server handle to the action server that will take the request\n* \\param[out] request_header pointer to the goal request header\n* \\param[out] ros_goal_request a preallocated, zero-initialized, ROS goal request message\n*   where the request is copied\n* \\return `RCL_RET_OK` if the request was taken, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or\n* \\return `RCL_RET_BAD_ALLOC` if allocating memory failed, or\n* \\return `RCL_RET_ACTION_SERVER_TAKE_FAILED` if take failed but no error occurred\n*         in the middleware, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_take_goal_request(
        action_server: *const rcl_action_server_t,
        request_header: *mut rmw_request_id_t,
        ros_goal_request: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Send a response for a goal request to an action client using an action server.\n**\n* This is a non-blocking call.\n*\n* The caller is responsible for ensuring that the type of `ros_goal_response`\n* and the type associate with the client (via the type support) match.\n* Passing a different type produces undefined behavior and cannot be checked\n* by this function and therefore no deliberate error will occur.\n*\n* If the caller intends to send an 'accepted' response, before calling this function\n* the caller should use rcl_action_accept_new_goal() to get a rcl_action_goal_handle_t\n* for future interaction with the goal (e.g. publishing feedback and canceling the goal).\n*\n* This function is thread safe so long as access to both the action server and the\n* `ros_goal_response` are synchronized.\n* That means that calling rcl_action_send_goal_response() from multiple threads is\n* allowed, but calling rcl_action_send_goal_response() at the same time as non-thread safe\n* action server functions is not, e.g. calling rcl_action_send_goal_response() and\n* rcl_action_server_fini() concurrently is not allowed.\n* Before calling rcl_action_send_goal_response() the `ros_goal_request` can change and\n* after calling rcl_action_send_goal_response() the `ros_goal_request` can change, but it\n* cannot be changed during the rcl_action_send_goal_response() call.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes [1]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] for unique pairs of action servers and responses, see above for more</i>\n*\n* \\param[in] action_server handle to the action server that will make the goal response\n* \\param[in] response_header pointer to the goal response header\n* \\param[in] ros_goal_response a ROS goal response message to send\n* \\return `RCL_RET_OK` if the response was sent successfully, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_send_goal_response(
        action_server: *const rcl_action_server_t,
        response_header: *mut rmw_request_id_t,
        ros_goal_response: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Accept a new goal using an action server.\n**\n* This is a non-blocking call.\n*\n* Creates and returns a new goal handle.\n* The action server starts tracking it internally.\n* If a failure occurs, `NULL` is returned and an error message is set.\n* Possible reasons for failure:\n*   - action server is invalid\n*   - goal info is invalid\n*   - goal ID is already being tracked by the action server\n*   - memory allocation failure\n*\n* This function should be called after receiving a new goal request with\n* rcl_action_take_goal_request() and before sending a response with\n* rcl_action_send_goal_response().\n*\n* After calling this function, the action server will start tracking the goal.\n* The pointer to the goal handle becomes invalid after `rcl_action_server_fini()` is called.\n* The caller becomes responsible for finalizing the goal handle later.\n*\n* Example usage:\n*\n* ```c\n* #include <rcl/rcl_action.h>\n*\n* // ... init an action server\n* // Take a goal request (client library type)\n* rcl_ret_t ret = rcl_action_take_goal_request(&action_server, &goal_request);\n* // ... error handling\n* // If the goal is accepted, then tell the action server\n* // First, create a goal info message\n* rcl_action_goal_info_t goal_info = rcl_action_get_zero_initialized_goal_info();\n* // ... populate goal_info.uuid (unique_identifier_msgs/UUID)\n* // ... populate goal_info.stamp (builtin_interfaces/Time)\n* rcl_action_goal_handle_t * goal_handle = rcl_action_accept_new_goal(&action_server, &goal_info);\n* // ... error_handling\n* // ... Populate goal response (client library type)\n* ret = rcl_action_send_goal_response(&action_server, &goal_response);\n* // ... error handling, and sometime before shutdown finalize goal info message\n* ret = rcl_action_goal_info_fini(&goal_info, &action_server);\n* ```\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] action_server handle to the action server that is accepting the goal\n* \\param[in] goal_info a message containing info about the goal being accepted\n* \\return a pointer to a new goal handle representing the accepted goal, or\n* \\return `NULL` if a failure occured.\n*/"]
    pub fn rcl_action_accept_new_goal(
        action_server: *mut rcl_action_server_t,
        goal_info: *const rcl_action_goal_info_t,
    ) -> *mut rcl_action_goal_handle_t;
}
extern "C" {
    #[doc = " Publish a ROS feedback message for an active goal using an action server.\n**\n* The caller is responsible for ensuring that the type of `ros_feedback`\n* and the type associate with the client (via the type support) match.\n* Passing a different type produces undefined behavior and cannot be checked\n* by this function and therefore no deliberate error will occur.\n*\n* This function acts like a ROS publisher and is potentially a blocking call.\n* \\see rcl_publish()\n*\n* This function is thread safe so long as access to both the action server and\n* `ros_feedback` is synchronized.\n* That means that calling rcl_action_publish_feedback() from multiple threads\n* is allowed, but calling rcl_action_publish_feedback() at the same time as\n* non-thread safe action server functions is not, e.g. calling\n* rcl_action_publish_feedback() and rcl_action_server_fini() concurrently is not\n* allowed.\n*\n* Before calling rcl_action_publish_feedback() the `ros_feedback` message ca\n* change and after calling rcl_action_publish_feedback() the `ros_feedback` message\n* can change, but it cannot be changed during the publish call.\n* The same `ros_feedback` can be passed to multiple calls of\n* rcl_action_publish_feedback() simultaneously, even if the action servers differ.\n* `ros_feedback` is unmodified by rcl_action_publish_feedback().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes [1]\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] for unique pairs of action servers and feedback, see above for more</i>\n*\n* \\param[in] action_server handle to the action server that will publish the feedback\n* \\param[in] ros_feedback a ROS message containing the goal feedback\n* \\return `RCL_RET_OK` if the response was sent successfully, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs. *\n*/"]
    pub fn rcl_action_publish_feedback(
        action_server: *const rcl_action_server_t,
        ros_feedback: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get a status array message for accepted goals associated with an action server.\n**\n* The provided `status_message` should be zero-initialized with\n* rcl_action_get_zero_initialized_goal_status_array() before calling this function.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] action_server handle to the action server that will publish the status message\n* \\param[out] status_message an action_msgs/StatusArray ROS message\n* \\return `RCL_RET_OK` if the response was sent successfully, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_get_goal_status_array(
        action_server: *const rcl_action_server_t,
        status_message: *mut rcl_action_goal_status_array_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Publish a status array message for accepted goals associated with an action server.\n**\n* This function acts like a ROS publisher and is potentially a blocking call.\n* \\see rcl_publish()\n*\n* A status array message associated with the action server can be created with\n* rcl_action_get_goal_status_array().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] action_server handle to the action server that will publish the status message\n* \\param[in] status_message an action_msgs/StatusArray ROS message to publish\n* \\return `RCL_RET_OK` if the response was sent successfully, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_publish_status(
        action_server: *const rcl_action_server_t,
        status_message: *const ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take a pending result request using an action server.\n**\n* \\todo TODO(jacobperron) blocking of take?\n*\n* \\todo TODO(jacobperron) pre-, during-, and post-conditions for message ownership?\n*\n* \\todo TODO(jacobperron) is this thread-safe?\n*\n* The caller is responsible for ensuring that the type of `ros_result_request`\n* and the type associate with the client (via the type support) match.\n* Passing a different type produces undefined behavior and cannot be checked\n* by this function and therefore no deliberate error will occur.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] action_server handle to the action server that will take the result request\n* \\param[out] request_header pointer to the result request header\n* \\param[out] ros_result_request a preallocated ROS result request message where the\n*   request is copied.\n* \\return `RCL_RET_OK` if the response was sent successfully, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or\n* \\return `RCL_RET_ACTION_SERVER_TAKE_FAILED` if take failed but no error occurred\n*         in the middleware, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_take_result_request(
        action_server: *const rcl_action_server_t,
        request_header: *mut rmw_request_id_t,
        ros_result_request: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Send a result response using an action server.\n**\n* This is a non-blocking call.\n*\n* The caller is responsible for ensuring that the type of `ros_result_response`\n* and the type associate with the client (via the type support) match.\n* Passing a different type produces undefined behavior and cannot be checked\n* by this function and therefore no deliberate error will occur.\n*\n* Before calling this function, the caller should use rcl_action_update_goal_state()\n* to update the goals state to the appropriate terminal state.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] action_server handle to the action server that will send the result response\n* \\param[in] response_header pointer to the result response header\n* \\param[in] ros_result_response a ROS result response message to send\n* \\return `RCL_RET_OK` if the response was sent successfully, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_send_result_response(
        action_server: *const rcl_action_server_t,
        response_header: *mut rmw_request_id_t,
        ros_result_response: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Expires goals associated with an action server.\n**\n* A goal is 'expired' if it has been in a terminal state (has a result) for longer\n* than some duration.\n* The timeout duration is set as part of the action server options.\n*\n* If a negative timeout value if provided, then goal results never expire (kept forever).\n* If a timeout of zero is set, then goal results are discarded immediately (ie. goal\n* results are discarded whenever this function is called).\n*\n* Expired goals are removed from the internal array of goal handles.\n* rcl_action_server_goal_exists() will return false for any goals that have expired.\n*\n* \\attention If one or more goals are expired then a previously returned goal handle\n* array from rcl_action_server_get_goal_handles() becomes invalid.\n*\n* `expired_goals`, `expired_goals_capacity` and `num_expired` are optional arguments.\n* If set to (`NULL`, 0u, `NULL`) then they are not used.\n* To use them allocate an array with size equal to the maximum number of goals that you want to\n* expire.\n* Pass the number of goals the array can hold in as `expired_goals_capacity`.\n* This function will set `num_expired` to the number of goals that were expired.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Maybe[1]\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n* <i>[1] if one or more goals expires, then the internal goal handle array may be\n* resized or deallocated</i>\n*\n* \\param[in] action_server handle to the action server from which expired goals\n*   will be cleared.\n* \\param[inout] expired_goals the identifiers of goals that expired, or set to `NULL` if unused\n* \\param[inout] expired_goals_capacity the allocated size of `expired_goals`, or 0 if unused\n* \\param[out] num_expired the number of expired goals, or set to `NULL` if unused\n* \\return `RCL_RET_OK` if the response was sent successfully, or\n* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_BAD_ALLOC` if allocating memory failed, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_expire_goals(
        action_server: *const rcl_action_server_t,
        expired_goals: *mut rcl_action_goal_info_t,
        expired_goals_capacity: usize,
        num_expired: *mut usize,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Notifies action server that a goal handle reached a terminal state.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] action_server handle to the action server\n* \\return `RCL_RET_OK` if everything is ok, or\n* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_notify_goal_done(action_server: *const rcl_action_server_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Take a pending cancel request using an action server.\n**\n* \\todo TODO(jacobperron) blocking of take?\n*\n* \\todo TODO(jacobperron) pre-, during-, and post-conditions for message ownership?\n*\n* \\todo TODO(jacobperron) is this thread-safe?\n*\n* The caller is responsible for ensuring that the type of `ros_cancel_request`_\n* and the type associate with the client (via the type support) match.\n* Passing a different type produces undefined behavior and cannot be checked\n* by this function and therefore no deliberate error will occur.\n*\n* After receiving a successful cancel request, the appropriate goals can be\n* transitioned to the state CANCELING using rcl_action_process_cancel_request().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] action_server handle to the action server that will take the cancel request\n* \\param[out] request_header pointer to the cancel request header\n* \\param[out] ros_cancel_request a preallocated ROS cancel request where the request\n*   message is copied\n* \\return `RCL_RET_OK` if the response was sent successfully, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or\n* \\return `RCL_RET_ACTION_SERVER_TAKE_FAILED` if take failed but no error occurred\n*         in the middleware, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_take_cancel_request(
        action_server: *const rcl_action_server_t,
        request_header: *mut rmw_request_id_t,
        ros_cancel_request: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Process a cancel request using an action server.\n**\n* This is a non-blocking call.\n*\n* This function will compute a list of goals that a cancelation request is attempting to cancel.\n* It does not change the state of any goal.\n* The following cancel policy applies based on the goal ID and the timestamp\n* contained in the cancel request:\n*\n* - If the goal ID is zero and timestamp is zero, cancel all goals.\n* - If the goal ID is zero and timestamp is not zero, cancel all goals accepted\n*   at or before the timestamp.\n* - If the goal ID is not zero and timestamp is zero, cancel the goal with the\n*   given ID regardless of the time it was accepted.\n* - If the goal ID is not zero and timestamp is not zero, cancel the goal with the\n*   given ID and all goals accepted at or before the timestamp.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] action_server handle to the action server that will process the cancel request\n* \\param[in] cancel_request a C-typed ROS cancel request to process\n* \\param[out] cancel_response a zero-initialized cancel response struct\n*   where the goal info of goals which should be cancelled are copied\n* \\return `RCL_RET_OK` if the response was sent successfully, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or\n* \\return `RCL_RET_BAD_ALLOC` if allocating memory failed, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_process_cancel_request(
        action_server: *const rcl_action_server_t,
        cancel_request: *const rcl_action_cancel_request_t,
        cancel_response: *mut rcl_action_cancel_response_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Send a cancel response using an action server.\n**\n* This is a non-blocking call.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] action_server handle to the action server that will send the cancel response\n* \\param[in] response_header pointer to the cancel response header\n* \\param[in] ros_cancel_response a ROS cancel response to send\n* \\return `RCL_RET_OK` if the request was taken, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_send_cancel_response(
        action_server: *const rcl_action_server_t,
        response_header: *mut rmw_request_id_t,
        ros_cancel_response: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the action name for an action server.\n**\n* This function returns the action server's internal topic name string.\n* This function can fail, and therefore return `NULL`, if the:\n*   - action server is `NULL`\n*   - action server is invalid (e.g. never called init or called fini)\n*\n* The returned string is only valid as long as the action server is valid.\n* The value of the string may change if the topic name changes, and therefore\n* copying the string is recommended if this is a concern.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] action_server pointer to the action server\n* \\return name string if successful, or\n* \\return `NULL` otherwise.\n*/"]
    pub fn rcl_action_server_get_action_name(
        action_server: *const rcl_action_server_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the rcl_action_server_options_t for an action server.\n**\n* This function returns the action server's internal options struct.\n* This function can fail, and therefore return `NULL`, if the:\n*   - action server is `NULL`\n*   - action server is invalid (e.g. never called init or called fini)\n*\n* The returned struct is only valid as long as the action server is valid.\n* The values in the struct may change if the action server's options change,\n* and therefore copying the struct is recommended if this is a concern.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] action_server handle to the action server\n* \\return options struct if successful, or\n* \\return `NULL` otherwise.\n*/"]
    pub fn rcl_action_server_get_options(
        action_server: *const rcl_action_server_t,
    ) -> *const rcl_action_server_options_t;
}
extern "C" {
    #[doc = " Get the goal handles for all goals an action server is tracking.\n**\n* A pointer to the internally held array of pointers to goal handle structs is returned\n* along with the number of items in the array.\n*\n* The returned handle is made invalid if the action server is finalized, if\n* rcl_shutdown() is called, or if rcl_action_expire_goals() is called and one or more\n* goals are expired.\n* The returned handle is not guaranteed to be valid for the life time of the\n* action server as it may be finalized and recreated itself.\n* Therefore, it is recommended to get the handle from the action server using\n* this function each time it is needed and avoid use of the handle\n* concurrently with functions that might change it.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] action_server handle to the action server\n* \\param[out] goal_handles is set to the array of pointers to goal handles if successful.\n* \\param[out] num_goals is set to the number of goals in the returned array if successful,\n*   not set otherwise.\n* \\return `RCL_RET_OK` if successful, or\n* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_server_get_goal_handles(
        action_server: *const rcl_action_server_t,
        goal_handles: *mut *mut *mut rcl_action_goal_handle_t,
        num_goals: *mut usize,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Check if a goal is already being tracked by an action server.\n**\n* Checks whether or not a goal is being tracked in the internal goal array.\n* The goal state has no effect on the return value.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] action_server handle to the action server\n* \\param[in] goal_info handle to a struct containing the goal ID to check for\n* \\return `true` if `action_server` is currently tracking a goal with the provided goal ID, or\n* \\return `false` otherwise.\n*/"]
    pub fn rcl_action_server_goal_exists(
        action_server: *const rcl_action_server_t,
        goal_info: *const rcl_action_goal_info_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Check if an action server is valid.\n**\n* In the case where `false` is returned (ie. the action server is invalid),\n* an error message is set.\n*\n* This function cannot fail.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] action_server handle to the action server\n* \\return `true` if `action_server` is valid, or\n* \\return `false` otherwise.\n*/"]
    pub fn rcl_action_server_is_valid(action_server: *const rcl_action_server_t) -> bool;
}
extern "C" {
    #[doc = " Check if an action server is valid without erroring if the library is shutting down.\n**\n* In the case where `false` is returned (ie. the action server is invalid),\n* an error message is set.\n*\n* This function cannot fail.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] action_server handle to the action server\n* \\return `true` if `action_server` is valid, or\n* \\return `false` otherwise.\n*/"]
    pub fn rcl_action_server_is_valid_except_context(
        action_server: *const rcl_action_server_t,
    ) -> bool;
}
extern "C" {
    pub fn rcl_action_server_set_goal_service_callback(
        action_server: *const rcl_action_server_t,
        callback: rcl_event_callback_t,
        user_data: *const ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_server_set_cancel_service_callback(
        action_server: *const rcl_action_server_t,
        callback: rcl_event_callback_t,
        user_data: *const ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_server_set_result_service_callback(
        action_server: *const rcl_action_server_t,
        callback: rcl_event_callback_t,
        user_data: *const ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    pub static rcl_action_qos_profile_status_default: rmw_qos_profile_t;
}
#[doc = " Associative array of topic or service names and types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_names_and_types_s {
    #[doc = " Array of names"]
    pub names: rcutils_string_array_t,
    #[doc = " Dynamic array of arrays of type names, with the same length as `names`"]
    pub types: *mut rcutils_string_array_t,
}
#[test]
fn bindgen_test_layout_rmw_names_and_types_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_names_and_types_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_names_and_types_s>(),
        64usize,
        concat!("Size of: ", stringify!(rmw_names_and_types_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_names_and_types_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_names_and_types_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).names) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_names_and_types_s),
            "::",
            stringify!(names)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).types) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_names_and_types_s),
            "::",
            stringify!(types)
        )
    );
}
#[doc = " Associative array of topic or service names and types."]
pub type rmw_names_and_types_t = rmw_names_and_types_s;
extern "C" {
    #[doc = " Return a zero initialized array of names and types."]
    pub fn rmw_get_zero_initialized_names_and_types() -> rmw_names_and_types_t;
}
extern "C" {
    #[doc = " Check that the given `names_and_types` array is zero initialized.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Access to the array of names and types is read-only, but it is not synchronized.\n*   Concurrent `names_and_types` reads are safe, but concurrent reads and writes are not.\n*\n* \\param[in] names_and_types Array to be checked.\n* \\return RMW_RET_OK if array is zero initialized, RMW_RET_INVALID_ARGUMENT otherwise.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_names_and_types_check_zero(names_and_types: *mut rmw_names_and_types_t)
        -> rmw_ret_t;
}
extern "C" {
    #[doc = " Initialize an array of names and types.\n**\n* This function initializes the string array for the names and allocates space\n* for all the string arrays for the types according to the given size, but\n* it does not initialize the string array for each setup of types.\n* However, the string arrays for each set of types is zero initialized.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Initialization is a reentrant procedure, but:\n*   - Access to arrays of names and types is not synchronized.\n*     It is not safe to read or write `names_and_types` during initialization.\n*   - The default allocators are thread-safe objects, but any custom `allocator` may not be.\n*     Check your allocator documentation for further reference.\n*\n* \\param[inout] names_and_types Array to be initialized on success,\n*   but left unchanged on failure.\n* \\param[in] size Size of the array.\n* \\param[in] allocator Allocator to be used to populate `names_and_types`.\n* \\returns `RMW_RET_OK` if successful, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `names_and_types` is NULL, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `names_and_types` is not\n*   a zero initialized array, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `allocator` is invalid,\n*   by rcutils_allocator_is_valid() definition, or\n* \\returns `RMW_BAD_ALLOC` if memory allocation fails, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_names_and_types_init(
        names_and_types: *mut rmw_names_and_types_t,
        size: usize,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Finalize an array of names and types.\n**\n* This function deallocates the string array of names and the array of string arrays of types,\n* and zero initializes the given array.\n* If a logical error, such as `RMW_RET_INVALID_ARGUMENT`, ensues, this function will return\n* early, leaving the given array unchanged.\n* Otherwise, it will proceed despite errors.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Finalization is a reentrant procedure, but access to arrays of names and types\n*   is not synchronized.\n*   It is not safe to read or write `names_and_types` during initialization.\n*\n* \\param[inout] names_and_types Array to be finalized.\n* \\returns `RMW_RET_OK` if successful, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `names_and_types` is NULL, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_names_and_types_fini(names_and_types: *mut rmw_names_and_types_t) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Return all topic names and types in the ROS graph.\n**\n* This function returns an array of all topic names and types in the ROS graph\n* i.e. for which a publisher and/or a subscription exists, as discovered so far\n* by the given local node.\n*\n* Unless `no_demangle` is true, some demangling and filtering may take place when\n* listing topics as implemented by the middleware.\n* Whether demangling applies or not, and how it applies, depends on the underlying\n* implementation.\n* See http://design.ros2.org/articles/topic_and_service_names.html for an example\n* on how it is used in DDS and RTPS based implementations.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | Yes\n* Uses Atomics       | Maybe [1]\n* Lock-Free          | Maybe [1]\n* <i>[1] rmw implementation defined, check the implementation documentation</i>\n*\n* \\par Runtime behavior\n*   To query the ROS graph is a synchronous operation.\n*   It is also non-blocking, but it is not guaranteed to be lock-free.\n*   Generally speaking, implementations may synchronize access to internal resources using\n*   locks but are not allowed to wait for events with no guaranteed time bound (barring\n*   the effects of starvation due to OS scheduling).\n*\n* \\par Thread-safety\n*   Nodes are thread-safe objects, and so are all operations on them except for finalization.\n*   Therefore, it is safe to query the ROS graph using the same node concurrently.\n*   However, when querying topic names and types:\n*   - Access to the array of names and types is not synchronized.\n*     It is not safe to read or write `topic_names_and_types`\n*     while rmw_get_topic_names_and_types() uses it.\n*   - The default allocators are thread-safe objects, but any custom `allocator` may not be.\n*     Check your allocator documentation for further reference.\n*\n* \\pre Given `node` must be a valid node handle, as returned by rmw_create_node().\n* \\pre Given `topic_names_and_types` must be a zero-initialized array of names and types,\n*   as returned by rmw_get_zero_initialized_names_and_types().\n*\n* \\param[in] node Node to query the ROS graph.\n* \\param[in] allocator Allocator to be used when populating the `topic_names_and_types` array.\n* \\param[in] no_demangle Whether to demangle all topic names following ROS conventions or not.\n* \\param[out] topic_names_and_types Array of topic names and their types,\n*   populated on success but left unchanged on failure.\n*   If populated, it is up to the caller to finalize this array later on\n*   using rmw_names_and_types_fini().\n* \\return `RMW_RET_OK` if the query was successful, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `allocator` is not valid, by rcutils_allocator_is_valid()\n*   definition, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `topic_names_and_types` is NULL, or\n* \\return `RMW_RET_INVALID_ARGUMENT` if `topic_names_and_types` is not a\n*   zero-initialized array, or\n* \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation\n*   identifier does not match this implementation, or\n* \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n* \\return `RMW_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rmw_get_topic_names_and_types(
        node: *const rmw_node_t,
        allocator: *mut rcutils_allocator_t,
        no_demangle: bool,
        topic_names_and_types: *mut rmw_names_and_types_t,
    ) -> rmw_ret_t;
}
#[doc = " A data structure that encapsulates the node name, node namespace,\n topic_type, gid, and qos_profile of publishers and subscriptions\n for a topic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_topic_endpoint_info_s {
    #[doc = " Name of the node"]
    pub node_name: *const ::std::os::raw::c_char,
    #[doc = " Namespace of the node"]
    pub node_namespace: *const ::std::os::raw::c_char,
    #[doc = " The associated topic type's name"]
    pub topic_type: *const ::std::os::raw::c_char,
    #[doc = " Hashed value for topic type's description"]
    pub topic_type_hash: rosidl_type_hash_t,
    #[doc = " The endpoint type"]
    pub endpoint_type: rmw_endpoint_type_t,
    #[doc = " The GID of the endpoint"]
    pub endpoint_gid: [u8; 16usize],
    #[doc = " QoS profile of the endpoint"]
    pub qos_profile: rmw_qos_profile_t,
}
#[test]
fn bindgen_test_layout_rmw_topic_endpoint_info_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_topic_endpoint_info_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_topic_endpoint_info_s>(),
        168usize,
        concat!("Size of: ", stringify!(rmw_topic_endpoint_info_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_topic_endpoint_info_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_topic_endpoint_info_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_topic_endpoint_info_s),
            "::",
            stringify!(node_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_namespace) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_topic_endpoint_info_s),
            "::",
            stringify!(node_namespace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topic_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_topic_endpoint_info_s),
            "::",
            stringify!(topic_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topic_type_hash) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_topic_endpoint_info_s),
            "::",
            stringify!(topic_type_hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint_type) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_topic_endpoint_info_s),
            "::",
            stringify!(endpoint_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint_gid) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_topic_endpoint_info_s),
            "::",
            stringify!(endpoint_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qos_profile) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_topic_endpoint_info_s),
            "::",
            stringify!(qos_profile)
        )
    );
}
#[doc = " A data structure that encapsulates the node name, node namespace,\n topic_type, gid, and qos_profile of publishers and subscriptions\n for a topic."]
pub type rmw_topic_endpoint_info_t = rmw_topic_endpoint_info_s;
extern "C" {
    #[doc = " Return zero initialized topic endpoint info data structure.\n**\n* Endpoint type will be invalid.\n* Endpoint QoS profile will be the system default.\n*/"]
    pub fn rmw_get_zero_initialized_topic_endpoint_info() -> rmw_topic_endpoint_info_t;
}
extern "C" {
    #[doc = " Finalize a topic endpoint info data structure.\n**\n* Deallocates all allocated members of the given data structure,\n* and then zero initializes it.\n* If a logical error, such as `RMW_RET_INVALID_ARGUMENT`, ensues, this function\n* will return early, leaving the given data structure unchanged.\n* Otherwise, it will proceed despite errors.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Finalization is a reentrant procedure, but:\n*   - Access to the topic endpoint info data structure is not synchronized.\n*     It is not safe to read or write `topic_endpoint` during finalization.\n*   - The default allocators are thread-safe objects, but any custom `allocator` may not be.\n*     Check your allocator documentation for further reference.\n*\n* \\param[inout] topic_endpoint_info Data structure to be finalized.\n* \\param[in] allocator Allocator used to populate the given `topic_endpoint_info`.\n* \\returns `RMW_RET_OK` if successful, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `allocator` is invalid,\n*   by rcutils_allocator_is_valid() definition, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_topic_endpoint_info_fini(
        topic_endpoint_info: *mut rmw_topic_endpoint_info_t,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Set the topic type in the given topic endpoint info data structure.\n**\n* Allocates memory and copies the value of the `topic_type`\n* argument to set the data structure's `topic_type` member.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Setting a member is a reentrant procedure, but:\n*   - Access to the topic endpoint info data structure is not synchronized.\n*     It is not safe to read or write the `topic_type` member of the given `topic_endpoint`\n*     while setting it.\n*   - Access to C-style string arguments is read-only but it is not synchronized.\n*     Concurrent `topic_type` reads are safe, but concurrent reads and writes are not.\n*   - The default allocators are thread-safe objects, but any custom `allocator` may not be.\n*     Check your allocator documentation for further reference.\n*\n* \\pre Given `topic_type` is a valid C-style string i.e. NULL terminated.\n*\n* \\param[inout] topic_endpoint_info Data structure to be populated.\n* \\param[in] topic_type Type name to be set.\n* \\param[in] allocator Allocator to be used.\n* \\returns `RMW_RET_OK` if successful, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_type` is NULL, or\n* \\returns `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_topic_endpoint_info_set_topic_type(
        topic_endpoint_info: *mut rmw_topic_endpoint_info_t,
        topic_type: *const ::std::os::raw::c_char,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Set the topic type hash in the given topic endpoint info data structure.\n**\n* Assigns the value of the `topic_type_hash` argument to the data structure's\n* `topic_type_hash` member.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Setting a member is a reentrant procedure, but:\n*   - Access to the topic endpoint info data structure is not synchronized.\n*     It is not safe to read or write the `topic_type_hash` member of the given `topic_endpoint`\n*     while setting it.\n*     Concurrent `topic_type_hash` reads are safe, but concurrent reads and writes are not.\n*\n* \\param[inout] topic_endpoint_info Data structure to be populated.\n* \\param[in] topic_type_hash Topic type hash to be copied.\n* \\returns `RMW_RET_OK` if successful, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_type_hash` is NULL, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_topic_endpoint_info_set_topic_type_hash(
        topic_endpoint_info: *mut rmw_topic_endpoint_info_t,
        type_hash: *const rosidl_type_hash_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Set the node name in the given topic endpoint info data structure.\n**\n* Allocates memory and copies the value of the `node_name`\n* argument to set the data structure's `node_name` member.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Setting a member is a reentrant procedure, but:\n*   - Access to the topic endpoint info data structure is not synchronized.\n*     It is not safe to read or write the `node_name` member of the given `topic_endpoint`\n*     while setting it.\n*   - Access to C-style string arguments is read-only but it is not synchronized.\n*     Concurrent `node_name` reads are safe, but concurrent reads and writes are not.\n*   - The default allocators are thread-safe objects, but any custom `allocator` may not be.\n*     Check your allocator documentation for further reference.\n*\n* \\pre Given `node_name` is a valid C-style string i.e. NULL terminated.\n*\n* \\param[inout] topic_endpoint_info Data structure to be populated.\n* \\param[in] node_name Node name to be set.\n* \\param[in] allocator Allocator to be used.\n* \\returns `RMW_RET_OK` if successful, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `node_name` is NULL, or\n* \\returns `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_topic_endpoint_info_set_node_name(
        topic_endpoint_info: *mut rmw_topic_endpoint_info_t,
        node_name: *const ::std::os::raw::c_char,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Set the node namespace in the given topic endpoint info data structure.\n**\n* Allocates memory and copies the value of the `node_namespace`\n* argument to set the data structure's `node_namespace` member.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Setting a member is a reentrant procedure, but:\n*   - Access to the topic endpoint info data structure is not synchronized.\n*     It is not safe to read or write the `node_namespace` member of the given `topic_endpoint`\n*     while setting it.\n*   - Access to C-style string arguments is read-only but it is not synchronized.\n*     Concurrent `node_namespace` reads are safe, but concurrent reads and writes are not.\n*   - The default allocators are thread-safe objects, but any custom `allocator` may not be.\n*     Check your allocator documentation for further reference.\n*\n* \\pre Given `node_namespace` is a valid C-style string i.e. NULL terminated.\n*\n* \\param[inout] topic_endpoint_info Data structure to be populated.\n* \\param[in] node_namespace Node namespace to be set.\n* \\param[in] allocator Allocator to be used.\n* \\returns `RMW_RET_OK` if successful, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `node_namespace` is NULL, or\n* \\returns `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_topic_endpoint_info_set_node_namespace(
        topic_endpoint_info: *mut rmw_topic_endpoint_info_t,
        node_namespace: *const ::std::os::raw::c_char,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Set the endpoint type in the given topic endpoint info data structure.\n**\n* Assigns the value of the `type` argument to the data structure's\n* `endpoint_type` member.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Setting a member is a reentrant procedure, but access to the\n*   topic endpoint info data structure is not synchronized.\n*   It is not safe to read or write the `endpoint_type` member of the\n*   given `topic_endpoint` while setting it.\n*\n* \\param[inout] topic_endpoint_info Data structure to be populated.\n* \\param[in] type Endpoint type to be set.\n* \\returns `RMW_RET_OK` if successful, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_topic_endpoint_info_set_endpoint_type(
        topic_endpoint_info: *mut rmw_topic_endpoint_info_t,
        type_: rmw_endpoint_type_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Set the endpoint gid in the given topic endpoint info data structure.\n**\n* Copies the value of the `gid` argument to the data structure's\n* `endpoint_gid` member.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Setting a member is a reentrant procedure, but access to the\n*   topic endpoint info data structure is not synchronized.\n*   It is not safe to read or write the `gid` member of the\n*   given `topic_endpoint` while setting it.\n*\n* \\param[inout] topic_endpoint_info Data structure to be populated.\n* \\param[in] gid Endpoint gid to be set.\n* \\param[in] size Size of the given `gid`.\n* \\returns `RMW_RET_OK` if successful, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `gid` is NULL, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `size` is greater than RMW_GID_STORAGE_SIZE, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_topic_endpoint_info_set_gid(
        topic_endpoint_info: *mut rmw_topic_endpoint_info_t,
        gid: *const u8,
        size: usize,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Set the endpoint QoS profile in the given topic endpoint info data structure.\n**\n* Assigns the value of the `qos_profile` argument to the data structure's\n* `qos_profile` member.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Setting a member is a reentrant procedure, but access to the\n*   topic endpoint info data structure is not synchronized.\n*   It is not safe to read or write the `qos_profile` member of the\n*   given `topic_endpoint` while setting it.\n*\n* \\param[inout] topic_endpoint_info Data structure to be populated.\n* \\param[in] qos_profile QoS profile to be set.\n* \\returns `RMW_RET_OK` if successful, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `qos_profile` is NULL, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_topic_endpoint_info_set_qos_profile(
        topic_endpoint_info: *mut rmw_topic_endpoint_info_t,
        qos_profile: *const rmw_qos_profile_t,
    ) -> rmw_ret_t;
}
#[doc = " Array of topic endpoint information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_topic_endpoint_info_array_s {
    #[doc = " Size of the array."]
    pub size: usize,
    #[doc = " Contiguous storage for topic endpoint information elements."]
    pub info_array: *mut rmw_topic_endpoint_info_t,
}
#[test]
fn bindgen_test_layout_rmw_topic_endpoint_info_array_s() {
    const UNINIT: ::std::mem::MaybeUninit<rmw_topic_endpoint_info_array_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rmw_topic_endpoint_info_array_s>(),
        16usize,
        concat!("Size of: ", stringify!(rmw_topic_endpoint_info_array_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rmw_topic_endpoint_info_array_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rmw_topic_endpoint_info_array_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_topic_endpoint_info_array_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info_array) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rmw_topic_endpoint_info_array_s),
            "::",
            stringify!(info_array)
        )
    );
}
#[doc = " Array of topic endpoint information"]
pub type rmw_topic_endpoint_info_array_t = rmw_topic_endpoint_info_array_s;
extern "C" {
    #[doc = " Return a zero initialized array of topic endpoint information."]
    pub fn rmw_get_zero_initialized_topic_endpoint_info_array() -> rmw_topic_endpoint_info_array_t;
}
extern "C" {
    #[doc = " Check that the given `topic_endpoint_info_array` is zero initialized.\n**\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Access to the array of topic endpoint information is read-only, but it is not synchronized.\n*   Concurrent `topic_endpoint_info_array` reads are safe, but concurrent reads\n*   and writes are not.\n*\n* \\param[in] topic_endpoint_info_array Array to be checked.\n* \\returns `RMW_RET_OK` if array is zero initialized, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info_array` is NULL, or\n* \\returns `RMW_RET_ERROR` if `topic_endpoint_info_array` is not zero initialized.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_topic_endpoint_info_array_check_zero(
        topic_endpoint_info_array: *mut rmw_topic_endpoint_info_array_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Initialize an array of topic endpoint information.\n**\n* This function allocates space to hold `size` topic endpoint information elements.\n* Both `info_array` and `size` members are updated accordingly.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Initialization is a reentrant procedure, but:\n*   - Access to the array of topic endpoint information is not synchronized.\n*     It is not safe to read or write `topic_endpoint_info_array` during initialization.\n*   - The default allocators are thread-safe objects, but any custom `allocator` may not be.\n*     Check your allocator documentation for further reference.\n*\n* \\param[inout] topic_endpoint_info_array Array to be initialized on success,\n*   but left unchanged on failure.\n* \\param[in] size Size of the array.\n* \\param[in] allocator Allocator to be used to populate `names_and_types`.\n* \\returns `RMW_RET_OK` if successful, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info_array` is NULL, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info_array` is not\n*   a zero initialized array, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `allocator` is invalid,\n*   by rcutils_allocator_is_valid() definition, or\n* \\returns `RMW_BAD_ALLOC` if memory allocation fails, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_topic_endpoint_info_array_init_with_size(
        topic_endpoint_info_array: *mut rmw_topic_endpoint_info_array_t,
        size: usize,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
extern "C" {
    #[doc = " Finalize an array of topic endpoint information.\n**\n* This function deallocates the given array storage, and then zero initializes it.\n* If a logical error, such as `RMW_RET_INVALID_ARGUMENT`, ensues, this function will\n* return early, leaving the given array unchanged.\n* Otherwise, it will proceed despite errors.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\par Thread-safety\n*   Finalization is a reentrant procedure, but:\n*   - Access to the array of topic endpoint information is not synchronized.\n*     It is not safe to read or write `topic_endpoint_info_array` during finalization.\n*   - The default allocators are thread-safe objects, but any custom `allocator` may not be.\n*     Check your allocator documentation for further reference.\n*\n* \\pre Given `allocator` must be the same used to initialize the given `topic_endpoint_info_array`.\n*\n* \\param[inout] topic_endpoint_info_array object to be finalized.\n* \\param[in] allocator Allocator used to populate the given `topic_endpoint_info_array`.\n* \\returns `RMW_RET_OK` if successful, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info_array` is NULL, or\n* \\returns `RMW_RET_INVALID_ARGUMENT` if `allocator` is invalid,\n*   by rcutils_allocator_is_valid() definition, or\n* \\returns `RMW_RET_ERROR` when an unspecified error occurs.\n* \\remark This function sets the RMW error state on failure.\n*/"]
    pub fn rmw_topic_endpoint_info_array_fini(
        topic_endpoint_info_array: *mut rmw_topic_endpoint_info_array_t,
        allocator: *mut rcutils_allocator_t,
    ) -> rmw_ret_t;
}
#[doc = " A structure that contains topic names and types."]
pub type rcl_names_and_types_t = rmw_names_and_types_t;
#[doc = " A structure that encapsulates the node name, node namespace,\n topic type, gid, and qos_profile or publishers and subscriptions\n for a topic."]
pub type rcl_topic_endpoint_info_t = rmw_topic_endpoint_info_t;
#[doc = " An array of topic endpoint information."]
pub type rcl_topic_endpoint_info_array_t = rmw_topic_endpoint_info_array_t;
extern "C" {
    #[doc = " Return a list of topic names and types for publishers associated with a node.\n**\n* The `node` parameter must point to a valid node.\n*\n* The `topic_names_and_types` parameter must be allocated and zero initialized.\n* This function allocates memory for the returned list of names and types and so it is the\n* callers responsibility to pass `topic_names_and_types` to rcl_names_and_types_fini()\n* when it is no longer needed.\n* Failing to do so will result in leaked memory.\n*\n* There may be some demangling that occurs when listing the names from the middleware\n* implementation.\n* If the `no_demangle` argument is set to `true`, then this will be avoided and the names will be\n* returned as they appear to the middleware.\n*\n* \\see rmw_get_topic_names_and_types for more details on no_demangle\n*\n* The returned names are not automatically remapped by this function.\n* Attempting to create publishers or subscribers using names returned by this function may not\n* result in the desired topic name being used depending on the remap rules in use.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation may need to protect the data structure with a lock</i>\n*\n* \\param[in] node the handle to the node being used to query the ROS graph\n* \\param[in] allocator allocator to be used when allocating space for strings\n* \\param[in] no_demangle if true, list all topics without any demangling\n* \\param[in] node_name the node name of the topics to return\n* \\param[in] node_namespace the node namespace of the topics to return\n* \\param[out] topic_names_and_types list of topic names and their types\n* \\return #RCL_RET_OK if the query was successful, or\n* \\return #RCL_RET_NODE_INVALID if the node is invalid, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_NODE_INVALID_NAME if the node name is invalid, or\n* \\return #RCL_RET_NODE_INVALID_NAMESPACE if the node namespace is invalid, or\n* \\return #RCL_RET_NODE_NAME_NON_EXISTENT if the node name wasn't found, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_get_publisher_names_and_types_by_node(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        no_demangle: bool,
        node_name: *const ::std::os::raw::c_char,
        node_namespace: *const ::std::os::raw::c_char,
        topic_names_and_types: *mut rcl_names_and_types_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a list of topic names and types for subscriptions associated with a node.\n**\n* The `node` parameter must point to a valid node.\n*\n* The `topic_names_and_types` parameter must be allocated and zero initialized.\n* This function allocates memory for the returned list of names and types and so it is the\n* callers responsibility to pass `topic_names_and_types` to rcl_names_and_types_fini()\n* when it is no longer needed.\n* Failing to do so will result in leaked memory.\n*\n* \\see rcl_get_publisher_names_and_types_by_node for details on the `no_demangle` parameter.\n*\n* The returned names are not automatically remapped by this function.\n* Attempting to create publishers or subscribers using names returned by this function may not\n* result in the desired topic name being used depending on the remap rules in use.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation may need to protect the data structure with a lock</i>\n*\n* \\param[in] node the handle to the node being used to query the ROS graph\n* \\param[in] allocator allocator to be used when allocating space for strings\n* \\param[in] no_demangle if true, list all topics without any demangling\n* \\param[in] node_name the node name of the topics to return\n* \\param[in] node_namespace the node namespace of the topics to return\n* \\param[out] topic_names_and_types list of topic names and their types\n* \\return #RCL_RET_OK if the query was successful, or\n* \\return #RCL_RET_NODE_INVALID if the node is invalid, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_NODE_INVALID_NAME if the node name is invalid, or\n* \\return #RCL_RET_NODE_INVALID_NAMESPACE if the node namespace is invalid, or\n* \\return #RCL_RET_NODE_NAME_NON_EXISTENT if the node name wasn't found, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_get_subscriber_names_and_types_by_node(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        no_demangle: bool,
        node_name: *const ::std::os::raw::c_char,
        node_namespace: *const ::std::os::raw::c_char,
        topic_names_and_types: *mut rcl_names_and_types_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a list of service names and types associated with a node.\n**\n* The `node` parameter must point to a valid node.\n*\n* The `service_names_and_types` parameter must be allocated and zero initialized.\n* This function allocates memory for the returned list of names and types and so it is the\n* callers responsibility to pass `service_names_and_types` to rcl_names_and_types_fini()\n* when it is no longer needed.\n* Failing to do so will result in leaked memory.\n*\n* \\see rcl_get_publisher_names_and_types_by_node for details on the `no_demangle` parameter.\n*\n* The returned names are not automatically remapped by this function.\n* Attempting to create service clients using names returned by this function may not\n* result in the desired service name being used depending on the remap rules in use.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation may need to protect the data structure with a lock</i>\n*\n* \\param[in] node the handle to the node being used to query the ROS graph\n* \\param[in] allocator allocator to be used when allocating space for strings\n* \\param[in] node_name the node name of the services to return\n* \\param[in] node_namespace the node namespace of the services to return\n* \\param[out] service_names_and_types list of service names and their types\n* \\return #RCL_RET_OK if the query was successful, or\n* \\return #RCL_RET_NODE_INVALID if the node is invalid, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_NODE_INVALID_NAME if the node name is invalid, or\n* \\return #RCL_RET_NODE_INVALID_NAMESPACE if the node namespace is invalid, or\n* \\return #RCL_RET_NODE_NAME_NON_EXISTENT if the node name wasn't found, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_get_service_names_and_types_by_node(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        node_name: *const ::std::os::raw::c_char,
        node_namespace: *const ::std::os::raw::c_char,
        service_names_and_types: *mut rcl_names_and_types_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a list of service client names and types associated with a node.\n**\n* The `node` parameter must point to a valid node.\n*\n* The `service_names_and_types` parameter must be allocated and zero initialized.\n* This function allocates memory for the returned list of names and types and so it is the\n* callers responsibility to pass `service_names_and_types` to rcl_names_and_types_fini()\n* when it is no longer needed.\n* Failing to do so will result in leaked memory.\n*\n* \\see rcl_get_publisher_names_and_types_by_node for details on the `no_demangle` parameter.\n*\n* The returned names are not automatically remapped by this function.\n* Attempting to create service servers using names returned by this function may not\n* result in the desired service name being used depending on the remap rules in use.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation may need to protect the data structure with a lock</i>\n*\n* \\param[in] node the handle to the node being used to query the ROS graph\n* \\param[in] allocator allocator to be used when allocating space for strings\n* \\param[in] node_name the node name of the services to return\n* \\param[in] node_namespace the node namespace of the services to return\n* \\param[out] service_names_and_types list of service client names and their types\n* \\return #RCL_RET_OK if the query was successful, or\n* \\return #RCL_RET_NODE_INVALID if the node is invalid, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_NODE_INVALID_NAME if the node name is invalid, or\n* \\return #RCL_RET_NODE_INVALID_NAMESPACE if the node namespace is invalid, or\n* \\return #RCL_RET_NODE_NAME_NON_EXISTENT if the node name wasn't found, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_get_client_names_and_types_by_node(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        node_name: *const ::std::os::raw::c_char,
        node_namespace: *const ::std::os::raw::c_char,
        service_names_and_types: *mut rcl_names_and_types_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a list of topic names and their types.\n**\n* The `node` parameter must point to a valid node.\n*\n* The `topic_names_and_types` parameter must be allocated and zero initialized.\n* This function allocates memory for the returned list of names and types and so it is the\n* callers responsibility to pass `topic_names_and_types` to rcl_names_and_types_fini()\n* when it is no longer needed.\n* Failing to do so will result in leaked memory.\n*\n* \\see rcl_get_publisher_names_and_types_by_node for details on the `no_demangle` parameter.\n*\n* The returned names are not automatically remapped by this function.\n* Attempting to create publishers or subscribers using names returned by this function may not\n* result in the desired topic name being used depending on the remap rules in use.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation may need to protect the data structure with a lock</i>\n*\n* \\param[in] node the handle to the node being used to query the ROS graph\n* \\param[in] allocator allocator to be used when allocating space for strings\n* \\param[in] no_demangle if true, list all topics without any demangling\n* \\param[out] topic_names_and_types list of topic names and their types\n* \\return #RCL_RET_OK if the query was successful, or\n* \\return #RCL_RET_NODE_INVALID if the node is invalid, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_NODE_INVALID_NAME if the node name is invalid, or\n* \\return #RCL_RET_NODE_INVALID_NAMESPACE if the node namespace is invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_get_topic_names_and_types(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        no_demangle: bool,
        topic_names_and_types: *mut rcl_names_and_types_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a list of service names and their types.\n**\n* The `node` parameter must point to a valid node.\n*\n* The `service_names_and_types` parameter must be allocated and zero initialized.\n* This function allocates memory for the returned list of names and types and so it is the\n* callers responsibility to pass `service_names_and_types` to rcl_names_and_types_fini()\n* when it is no longer needed.\n* Failing to do so will result in leaked memory.\n*\n* The returned names are not automatically remapped by this function.\n* Attempting to create clients or services using names returned by this function may not result in\n* the desired service name being used depending on the remap rules in use.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation may need to protect the data structure with a lock</i>\n*\n* \\param[in] node the handle to the node being used to query the ROS graph\n* \\param[in] allocator allocator to be used when allocating space for strings\n* \\param[out] service_names_and_types list of service names and their types\n* \\return #RCL_RET_OK if the query was successful, or\n* \\return #RCL_RET_NODE_INVALID if the node is invalid, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_get_service_names_and_types(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        service_names_and_types: *mut rcl_names_and_types_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Initialize a rcl_names_and_types_t object.\n**\n* This function initializes the string array for the names and allocates space\n* for all the string arrays for the types according to the given size, but\n* it does not initialize the string array for each set of types.\n* However, the string arrays for each set of types is zero initialized.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] names_and_types object to be initialized\n* \\param[in] size the number of names and sets of types to be stored\n* \\param[in] allocator to be used to allocate and deallocate memory\n* \\return #RCL_RET_OK on success, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCL_RET_ERROR when an unspecified error occurs.\n*/"]
    pub fn rcl_names_and_types_init(
        names_and_types: *mut rcl_names_and_types_t,
        size: usize,
        allocator: *mut rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Finalize a rcl_names_and_types_t object.\n**\n* The object is populated when given to one of the rcl_get_*_names_and_types()\n* functions.\n* This function reclaims any resources allocated during population.\n*\n* The `names_and_types` parameter must not be `NULL`, and must point to an\n* already allocated rcl_names_and_types_t struct that was previously\n* passed to a successful rcl_get_*_names_and_types() function call.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] names_and_types struct to be finalized\n* \\return #RCL_RET_OK if successful, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_names_and_types_fini(names_and_types: *mut rcl_names_and_types_t) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a list of available nodes in the ROS graph.\n**\n* The `node` parameter must point to a valid node.\n*\n* The `node_names` parameter must be allocated and zero initialized.\n* `node_names` is the output for this function, and contains allocated memory.\n* Use rcutils_get_zero_initialized_string_array() for initializing an empty\n* rcutils_string_array_t struct.\n* This `node_names` struct should therefore be passed to rcutils_string_array_fini()\n* when it is no longer needed.\n* Failing to do so will result in leaked memory.\n*\n* Example:\n*\n* ```c\n* rcutils_string_array_t node_names =\n*   rcutils_get_zero_initialized_string_array();\n* rcl_ret_t ret = rcl_get_node_names(node, &node_names);\n* if (ret != RCL_RET_OK) {\n*   // ... error handling\n* }\n* // ... use the node_names struct, and when done:\n* rcutils_ret_t rcutils_ret = rcutils_string_array_fini(&node_names);\n* if (rcutils_ret != RCUTILS_RET_OK) {\n*   // ... error handling\n* }\n* ```\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation may need to protect the data structure with a lock</i>\n*\n* \\param[in] node the handle to the node being used to query the ROS graph\n* \\param[in] allocator used to control allocation and deallocation of names\n* \\param[out] node_names struct storing discovered node names\n* \\param[out] node_namespaces struct storing discovered node namespaces\n* \\return #RCL_RET_OK if the query was successful, or\n* \\return #RCL_RET_BAD_ALLOC if an error occurred while allocating memory, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_NODE_INVALID_NAME if a node with an invalid name is detected, or\n* \\return #RCL_RET_NODE_INVALID_NAMESPACE if a node with an invalid namespace is detected, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_get_node_names(
        node: *const rcl_node_t,
        allocator: rcl_allocator_t,
        node_names: *mut rcutils_string_array_t,
        node_namespaces: *mut rcutils_string_array_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a list of available nodes in the ROS graph, including their enclave names.\n**\n* An rcl_get_node_names() equivalent, but including in its output the enclave\n* name the node is using.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Maybe [1]\n* <i>[1] RMW implementation in use may need to protect the data structure with a lock</i>\n*\n* \\param[in] node the handle to the node being used to query the ROS graph\n* \\param[in] allocator used to control allocation and deallocation of names\n* \\param[out] node_names struct storing discovered node names\n* \\param[out] node_namespaces struct storing discovered node namespaces\n* \\param[out] enclaves struct storing discovered node enclaves\n* \\return #RCL_RET_OK if the query was successful, or\n* \\return #RCL_RET_BAD_ALLOC if an error occurred while allocating memory, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_get_node_names_with_enclaves(
        node: *const rcl_node_t,
        allocator: rcl_allocator_t,
        node_names: *mut rcutils_string_array_t,
        node_namespaces: *mut rcutils_string_array_t,
        enclaves: *mut rcutils_string_array_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the number of publishers on a given topic.\n**\n* The `node` parameter must point to a valid node.\n*\n* The `topic_name` parameter must not be `NULL`, and must not be an empty string.\n* It should also follow the topic name rules.\n* \\todo TODO(wjwwood): link to the topic name rules.\n*\n* The `count` parameter must point to a valid bool.\n* The `count` parameter is the output for this function and will be set.\n*\n* In the event that error handling needs to allocate memory, this function\n* will try to use the node's allocator.\n*\n* The topic name is not automatically remapped by this function.\n* If there is a publisher created with topic name `foo` and remap rule `foo:=bar` then calling\n* this with `topic_name` set to `bar` will return a count of 1, and with `topic_name` set to `foo`\n* will return a count of 0.\n* /sa rcl_remap_topic_name()\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation may need to protect the data structure with a lock</i>\n*\n* \\param[in] node the handle to the node being used to query the ROS graph\n* \\param[in] topic_name the name of the topic in question\n* \\param[out] count number of publishers on the given topic\n* \\return #RCL_RET_OK if the query was successful, or\n* \\return #RCL_RET_NODE_INVALID if the node is invalid, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_count_publishers(
        node: *const rcl_node_t,
        topic_name: *const ::std::os::raw::c_char,
        count: *mut usize,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return the number of subscriptions on a given topic.\n**\n* The `node` parameter must point to a valid node.\n*\n* The `topic_name` parameter must not be `NULL`, and must not be an empty string.\n* It should also follow the topic name rules.\n* \\todo TODO(wjwwood): link to the topic name rules.\n*\n* The `count` parameter must point to a valid bool.\n* The `count` parameter is the output for this function and will be set.\n*\n* In the event that error handling needs to allocate memory, this function\n* will try to use the node's allocator.\n*\n* The topic name is not automatically remapped by this function.\n* If there is a subscriber created with topic name `foo` and remap rule `foo:=bar` then calling\n* this with `topic_name` set to `bar` will return a count of 1, and with `topic_name` set to `foo`\n* will return a count of 0.\n* /sa rcl_remap_topic_name()\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation may need to protect the data structure with a lock</i>\n*\n* \\param[in] node the handle to the node being used to query the ROS graph\n* \\param[in] topic_name the name of the topic in question\n* \\param[out] count number of subscriptions on the given topic\n* \\return #RCL_RET_OK if the query was successful, or\n* \\return #RCL_RET_NODE_INVALID if the node is invalid, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_count_subscribers(
        node: *const rcl_node_t,
        topic_name: *const ::std::os::raw::c_char,
        count: *mut usize,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Wait for there to be a specified number of publishers on a given topic.\n**\n* The `node` parameter must point to a valid node.\n* The nodes graph guard condition is used by this function, and therefore the caller should\n* take care not to use the guard condition concurrently in any other wait sets.\n*\n* The `allocator` parameter must point to a valid allocator.\n*\n* The `topic_name` parameter must not be `NULL`, and must not be an empty string.\n* It should also follow the topic name rules.\n*\n* This function blocks and will return when the number of publishers for `topic_name`\n* is greater than or equal to the `count` parameter, or the specified `timeout` is reached.\n*\n* The `timeout` parameter is in nanoseconds.\n* The timeout is based on system time elapsed.\n* A negative value disables the timeout (i.e. this function blocks until the number of\n* publishers is greater than or equals to `count`).\n*\n* The `success` parameter must point to a valid bool.\n* The `success` parameter is the output for this function and will be set.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation may need to protect the data structure with a lock</i>\n*\n* \\param[in] node the handle to the node being used to query the ROS graph\n* \\param[in] allocator to allocate space for the rcl_wait_set_t used to wait for graph events\n* \\param[in] topic_name the name of the topic in question\n* \\param[in] count number of publishers to wait for\n* \\param[in] timeout maximum duration to wait for publishers\n* \\param[out] success `true` if the number of publishers is equal to or greater than count, or\n*   `false` if a timeout occurred waiting for publishers.\n* \\return #RCL_RET_OK if there was no errors, or\n* \\return #RCL_RET_NODE_INVALID if the node is invalid, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_TIMEOUT if a timeout occurs before the number of publishers is detected, or\n* \\return #RCL_RET_ERROR if an unspecified error occurred.\n*/"]
    pub fn rcl_wait_for_publishers(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        topic_name: *const ::std::os::raw::c_char,
        count: usize,
        timeout: rcutils_duration_value_t,
        success: *mut bool,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Wait for there to be a specified number of subscribers on a given topic.\n**\n* \\see rcl_wait_for_publishers\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation may need to protect the data structure with a lock</i>\n*\n* \\param[in] node the handle to the node being used to query the ROS graph\n* \\param[in] allocator to allocate space for the rcl_wait_set_t used to wait for graph events\n* \\param[in] topic_name the name of the topic in question\n* \\param[in] count number of subscribers to wait for\n* \\param[in] timeout maximum duration to wait for subscribers\n* \\param[out] success `true` if the number of subscribers is equal to or greater than count, or\n*   `false` if a timeout occurred waiting for subscribers.\n* \\return #RCL_RET_OK if there was no errors, or\n* \\return #RCL_RET_NODE_INVALID if the node is invalid, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_TIMEOUT if a timeout occurs before the number of subscribers is detected, or\n* \\return #RCL_RET_ERROR if an unspecified error occurred.\n*/"]
    pub fn rcl_wait_for_subscribers(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        topic_name: *const ::std::os::raw::c_char,
        count: usize,
        timeout: rcutils_duration_value_t,
        success: *mut bool,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a list of all publishers to a topic.\n**\n* The `node` parameter must point to a valid node.\n*\n* The `topic_name` parameter must not be `NULL`.\n*\n* When the `no_mangle` parameter is `true`, the provided `topic_name` should be a valid topic name\n* for the middleware (useful when combining ROS with native middleware (e.g. DDS) apps).\n* When the `no_mangle` parameter is `false`, the provided `topic_name` should follow\n* ROS topic name conventions.\n* In either case, the topic name should always be fully qualified.\n*\n* Each element in the `publishers_info` array will contain the node name, node namespace,\n* topic type, gid and the qos profile of the publisher.\n* It is the responsibility of the caller to ensure that `publishers_info` parameter points\n* to a valid struct of type rcl_topic_endpoint_info_array_t.\n* The `count` field inside the struct must be set to 0 and the `info_array` field inside\n* the struct must be set to null.\n* \\see rmw_get_zero_initialized_topic_endpoint_info_array\n*\n* The `allocator` will be used to allocate memory to the `info_array` member\n* inside of `publishers_info`.\n* Moreover, every const char * member inside of\n* rmw_topic_endpoint_info_t will be assigned a copied value on allocated memory.\n* \\see rmw_topic_endpoint_info_set_node_name and the likes.\n* However, it is the responsibility of the caller to\n* reclaim any allocated resources to `publishers_info` to avoid leaking memory.\n* \\see rmw_topic_endpoint_info_array_fini\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation may need to protect the data structure with a lock</i>\n*\n* \\param[in] node the handle to the node being used to query the ROS graph\n* \\param[in] allocator allocator to be used when allocating space for\n*            the array inside publishers_info\n* \\param[in] topic_name the name of the topic in question\n* \\param[in] no_mangle if `true`, `topic_name` needs to be a valid middleware topic name,\n*            otherwise it should be a valid ROS topic name\n* \\param[out] publishers_info a struct representing a list of publisher information\n* \\return #RCL_RET_OK if the query was successful, or\n* \\return #RCL_RET_NODE_INVALID if the node is invalid, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_get_publishers_info_by_topic(
        node: *const rcl_node_t,
        allocator: *mut rcutils_allocator_t,
        topic_name: *const ::std::os::raw::c_char,
        no_mangle: bool,
        publishers_info: *mut rcl_topic_endpoint_info_array_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a list of all subscriptions to a topic.\n**\n* The `node` parameter must point to a valid node.\n*\n* The `topic_name` parameter must not be `NULL`.\n*\n* When the `no_mangle` parameter is `true`, the provided `topic_name` should be a valid topic name\n* for the middleware (useful when combining ROS with native middleware (e.g. DDS) apps).\n* When the `no_mangle` parameter is `false`, the provided `topic_name` should follow\n* ROS topic name conventions.\n* In either case, the topic name should always be fully qualified.\n*\n* Each element in the `subscriptions_info` array will contain the node name, node namespace,\n* topic type, gid and the qos profile of the subscription.\n* It is the responsibility of the caller to ensure that `subscriptions_info` parameter points\n* to a valid struct of type rcl_topic_endpoint_info_array_t.\n* The `count` field inside the struct must be set to 0 and the `info_array` field inside\n* the struct must be set to null.\n* \\see rmw_get_zero_initialized_topic_endpoint_info_array\n*\n* The `allocator` will be used to allocate memory to the `info_array` member\n* inside of `subscriptions_info`.\n* Moreover, every const char * member inside of\n* rmw_topic_endpoint_info_t will be assigned a copied value on allocated memory.\n* \\see rmw_topic_endpoint_info_set_node_name and the likes.\n* However, it is the responsibility of the caller to\n* reclaim any allocated resources to `subscriptions_info` to avoid leaking memory.\n* \\see rmw_topic_endpoint_info_array_fini\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation may need to protect the data structure with a lock</i>\n*\n* \\param[in] node the handle to the node being used to query the ROS graph\n* \\param[in] allocator allocator to be used when allocating space for\n*            the array inside publishers_info\n* \\param[in] topic_name the name of the topic in question\n* \\param[in] no_mangle if `true`, `topic_name` needs to be a valid middleware topic name,\n*            otherwise it should be a valid ROS topic name\n* \\param[out] subscriptions_info a struct representing a list of subscriptions information\n* \\return #RCL_RET_OK if the query was successful, or\n* \\return #RCL_RET_NODE_INVALID if the node is invalid, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_BAD_ALLOC if memory allocation fails, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_get_subscriptions_info_by_topic(
        node: *const rcl_node_t,
        allocator: *mut rcutils_allocator_t,
        topic_name: *const ::std::os::raw::c_char,
        no_mangle: bool,
        subscriptions_info: *mut rcl_topic_endpoint_info_array_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Check if a service server is available for the given service client.\n**\n* This function will return true for `is_available` if there is a service server\n* available for the given client.\n*\n* The `node` parameter must point to a valid node.\n*\n* The `client` parameter must point to a valid client.\n*\n* The given client and node must match, i.e. the client must have been created\n* using the given node.\n*\n* The `is_available` parameter must not be `NULL`, and must point a bool variable.\n* The result of the check will be stored in the `is_available` parameter.\n*\n* In the event that error handling needs to allocate memory, this function\n* will try to use the node's allocator.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation may need to protect the data structure with a lock</i>\n*\n* \\param[in] node the handle to the node being used to query the ROS graph\n* \\param[in] client the handle to the service client being queried\n* \\param[out] is_available set to true if there is a service server available, else false\n* \\return #RCL_RET_OK if the check was made successfully (regardless of the service readiness), or\n* \\return #RCL_RET_NODE_INVALID if the node is invalid, or\n* \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n* \\return #RCL_RET_ERROR if an unspecified error occurs.\n*/"]
    pub fn rcl_service_server_is_available(
        node: *const rcl_node_t,
        client: *const rcl_client_t,
        is_available: *mut bool,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get a list of action names and types for action clients associated with a node.\n**\n* The `node` parameter must point to a valid node.\n*\n* The `action_names_and_types` parameter must be allocated and zero initialized.\n* This function allocates memory for the returned list of names and types and so it is the\n* callers responsibility to pass `action_names_and_types` to rcl_names_and_types_fini()\n* when it is no longer needed.\n* Failing to do so will result in leaked memory.\n*\n* The returned names are not automatically remapped by this function.\n* Attempting to create action clients or action servers with names returned by this function may\n* not result in the desired action name depending on the remap rules in use.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation may need to protect the data structure with a lock</i>\n*\n* \\param[in] node the handle to the node being used to query the ROS graph\n* \\param[in] allocator allocator for allocating space for strings\n* \\param[in] node_name the node name of the actions to return\n* \\param[in] node_namespace the node namespace of the actions to return\n* \\param[out] action_names_and_types list of action names and their types\n* \\return `RCL_RET_OK` if the query was successful, or\n* \\return `RCL_RET_NODE_INVALID` if the node is invalid, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_get_client_names_and_types_by_node(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        node_name: *const ::std::os::raw::c_char,
        node_namespace: *const ::std::os::raw::c_char,
        action_names_and_types: *mut rcl_names_and_types_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get a list of action names and types for action servers associated with a node.\n**\n* This function returns a list of action names and types for action servers associated with\n* the provided node name.\n*\n* The `node` parameter must point to a valid node.\n*\n* The `action_names_and_types` parameter must be allocated and zero initialized.\n* This function allocates memory for the returned list of names and types and so it is the\n* callers responsibility to pass `action_names_and_types` to rcl_names_and_types_fini()\n* when it is no longer needed.\n* Failing to do so will result in leaked memory.\n*\n* The returned names are not automatically remapped by this function.\n* Attempting to create action clients or action servers with names returned by this function may\n* not result in the desired action name depending on the remap rules in use.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation may need to protect the data structure with a lock</i>\n*\n* \\param[in] node the handle to the node being used to query the ROS graph\n* \\param[in] allocator allocator for allocating space for strings\n* \\param[in] node_name the node name of the actions to return\n* \\param[in] node_namespace the node namespace of the actions to return\n* \\param[out] action_names_and_types list of action names and their types\n* \\return `RCL_RET_OK` if the query was successful, or\n* \\return `RCL_RET_NODE_INVALID` if the node is invalid, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_get_server_names_and_types_by_node(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        node_name: *const ::std::os::raw::c_char,
        node_namespace: *const ::std::os::raw::c_char,
        action_names_and_types: *mut rcl_names_and_types_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Return a list of action names and their types.\n**\n* This function returns a list of action names and types in the ROS graph.\n*\n* The `node` parameter must point to a valid node.\n*\n* The `action_names_and_types` parameter must be allocated and zero initialized.\n* This function allocates memory for the returned list of names and types and so it is the\n* callers responsibility to pass `action_names_and_types` to rcl_names_and_types_fini()\n* when it is no longer needed.\n* Failing to do so will result in leaked memory.\n*\n* The returned names are not automatically remapped by this function.\n* Attempting to create action clients or action servers with names returned by this function may\n* not result in the desired action name depending on the remap rules in use.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Maybe [1]\n* <i>[1] implementation may need to protect the data structure with a lock</i>\n*\n* \\param[in] node the handle to the node being used to query the ROS graph\n* \\param[in] allocator allocator for allocating space for strings\n* \\param[out] action_names_and_types list of action names and types\n* \\return `RCL_RET_OK` if the query was successful, or\n* \\return `RCL_RET_NODE_INVALID` if the node is invalid, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_get_names_and_types(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        action_names_and_types: *mut rcl_names_and_types_t,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Add a rcl_action_client_t to a wait set.\n**\n* This function will add the underlying service clients and subscribers to the wait set.\n*\n* This function behaves similar to adding subscriptions to the wait set, but will add\n* five entities:\n*\n* - Three service clients\n* - Two subscriptions\n*\n* \\see rcl_wait_set_add_subscription\n*\n* If this function fails for any reason, `client_index` and `subscription_index` are not set.\n* It is also possible the provided wait set is left in an inconsistent state (e.g. some\n* of the clients and subscriptions were added to the wait set, but not all).\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] wait_set struct where action client service client and subscription\n*   are to be stored\n* \\param[in] action_client the action client to be added to the wait set\n* \\param[out] client_index the starting index in the wait set's client container where\n*   the action clients underlying service clients were added. Optionally, set to `NULL`\n*   if ignored.\n* \\param[out] subscription_index the starting index in the wait set's subscription container\n*   where the action clients underlying subscriptions were added. Optionally, set to `NULL`\n*   if ignored.\n* \\return `RCL_RET_OK` if added successfully, or\n* \\return `RCL_RET_WAIT_SET_INVALID` if the wait set is zero initialized, or\n* \\return `RCL_RET_WAIT_SET_FULL` if the subscription set is full, or\n* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action client is invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_wait_set_add_action_client(
        wait_set: *mut rcl_wait_set_t,
        action_client: *const rcl_action_client_t,
        client_index: *mut usize,
        subscription_index: *mut usize,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Add a rcl_action_server_t to a wait set.\n**\n* This function will add the underlying services to the wait set.\n*\n* This function behaves similar to adding services to the wait set, but will add\n* three services.\n*\n* \\see rcl_wait_set_add_service\n*\n* * If this function fails for any reason, `service_index` is not set.\n* It is also possible the provided wait set is left in an inconsistent state (e.g. some\n* of the clients and subscribers were added to the wait set, but not all).\n\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | Yes\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[inout] wait_set struct where action server services are to be stored\n* \\param[in] action_server the action server to be added to the wait set\n* \\param[out] service_index the starting index in the wait set's service container where\n*   the action servers underlying services were added. Optionally, set to `NULL`\n*   if ignored.\n* \\return `RCL_RET_OK` if added successfully, or\n* \\return `RCL_RET_WAIT_SET_INVALID` if the wait set is zero initialized, or\n* \\return `RCL_RET_WAIT_SET_FULL` if the subscription set is full, or\n* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_wait_set_add_action_server(
        wait_set: *mut rcl_wait_set_t,
        action_server: *const rcl_action_server_t,
        service_index: *mut usize,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the number of wait set entities associated with a rcl_action_client_t.\n**\n* Returns the number of entities that are added to the wait set if\n* rcl_action_wait_set_add_action_client() is called.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] action_client an action client to query\n* \\param[out] num_subscriptions the number of subscriptions added when the action client\n*   is added to the wait set\n* \\param[out] num_guard_conditions the number of guard conditions added when the action client\n*   is added to the wait set\n* \\param[out] num_timers the number of timers added when the action client\n*   is added to the wait set\n* \\param[out] num_clients the number of clients added when the action client\n*   is added to the wait set\n* \\param[out] num_services the number of services added when the action client\n*   is added to the wait set\n* \\return `RCL_RET_OK` if call is successful, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action client is invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_client_wait_set_get_num_entities(
        action_client: *const rcl_action_client_t,
        num_subscriptions: *mut usize,
        num_guard_conditions: *mut usize,
        num_timers: *mut usize,
        num_clients: *mut usize,
        num_services: *mut usize,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the number of wait set entities associated with a rcl_action_server_t.\n**\n* Returns the number of entities that are added to the wait set if\n* rcl_action_wait_set_add_action_server() is called.\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] action_server an action server to query\n* \\param[out] num_subscriptions the number of subscriptions added when the action server\n*   is added to the wait set\n* \\param[out] num_guard_conditions the number of guard conditions added when the action server\n*   is added to the wait set\n* \\param[out] num_timers the number of timers added when the action server\n*   is added to the wait set\n* \\param[out] num_clients the number of clients added when the action server\n*   is added to the wait set\n* \\param[out] num_services the number of services added when the action server\n*   is added to the wait set\n* \\return `RCL_RET_OK` if call is successful, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ACTION_SERVER_INVALID` if the action server is invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_server_wait_set_get_num_entities(
        action_server: *const rcl_action_server_t,
        num_subscriptions: *mut usize,
        num_guard_conditions: *mut usize,
        num_timers: *mut usize,
        num_clients: *mut usize,
        num_services: *mut usize,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the wait set entities that are ready for a rcl_action_client_t.\n**\n* The caller can use this function to determine the relevant action client functions\n* to call: rcl_action_take_feedback(), rcl_action_take_status(),\n* rcl_action_take_goal_response(), rcl_action_take_cancel_response(), or\n* rcl_action_take_result_response().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] wait_set struct where action server services are to be stored\n* \\param[in] action_client an action client to query\n* \\param[out] is_feedback_ready `true` if there is a feedback message ready to take,\n*   `false` otherwise\n* \\param[out] is_status_ready `true` if there is a status message ready to take,\n*   `false` otherwise\n* \\param[out] is_goal_response_ready `true` if there is a goal response message ready\n*   to take, `false` otherwise\n* \\param[out] is_cancel_response_ready `true` if there is a cancel response message ready\n*   to take, `false` otherwise\n* \\param[out] is_result_response_ready `true` if there is a result response message ready\n*   to take, `false` otherwise\n* \\return `RCL_RET_OK` if call is successful, or\n* \\return `RCL_RET_WAIT_SET_INVALID` if the wait set is invalid, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action client is invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_client_wait_set_get_entities_ready(
        wait_set: *const rcl_wait_set_t,
        action_client: *const rcl_action_client_t,
        is_feedback_ready: *mut bool,
        is_status_ready: *mut bool,
        is_goal_response_ready: *mut bool,
        is_cancel_response_ready: *mut bool,
        is_result_response_ready: *mut bool,
    ) -> rcl_ret_t;
}
extern "C" {
    #[doc = " Get the wait set entities that are ready for a rcl_action_server_t.\n**\n* The caller can use this function to determine the relevant action server functions\n* to call: rcl_action_take_goal_request(), rcl_action_take_cancel_request(), or\n* rcl_action_take_result_request().\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | No\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*\n* \\param[in] wait_set struct where action server services are to be stored\n* \\param[in] action_server an action server to query\n* \\param[out] is_goal_request_ready `true` if there is a goal request message ready\n*   to take, `false` otherwise\n* \\param[out] is_cancel_request_ready `true` if there is a cancel request message ready\n*   to take, `false` otherwise\n* \\param[out] is_result_request_ready `true` if there is a result request message ready\n*   to take, `false` otherwise\n* \\param[out] is_goal_expired `true` if there is a goal that expired, `false` otherwise\n* \\return `RCL_RET_OK` if call is successful, or\n* \\return `RCL_RET_WAIT_SET_INVALID` if the wait set is invalid, or\n* \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n* \\return `RCL_RET_ACTION_CLIENT_INVALID` if the action server is invalid, or\n* \\return `RCL_RET_ERROR` if an unspecified error occurs.\n*/"]
    pub fn rcl_action_server_wait_set_get_entities_ready(
        wait_set: *const rcl_wait_set_t,
        action_server: *const rcl_action_server_t,
        is_goal_request_ready: *mut bool,
        is_cancel_request_ready: *mut bool,
        is_result_request_ready: *mut bool,
        is_goal_expired: *mut bool,
    ) -> rcl_ret_t;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
