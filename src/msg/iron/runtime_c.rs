use crate::rcl::{rosidl_message_type_support_t, rosidl_service_type_support_t};
/* automatically generated by rust-bindgen 0.69.4 */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const RCUTILS_HAS_NONNULL: u32 = 1;
pub const RCUTILS_RET_OK: u32 = 0;
pub const RCUTILS_RET_WARN: u32 = 1;
pub const RCUTILS_RET_ERROR: u32 = 2;
pub const RCUTILS_RET_BAD_ALLOC: u32 = 10;
pub const RCUTILS_RET_INVALID_ARGUMENT: u32 = 11;
pub const RCUTILS_RET_NOT_ENOUGH_SPACE: u32 = 12;
pub const RCUTILS_RET_NOT_INITIALIZED: u32 = 13;
pub const RCUTILS_RET_NOT_FOUND: u32 = 14;
pub const RCUTILS_RET_STRING_MAP_ALREADY_INIT: u32 = 30;
pub const RCUTILS_RET_STRING_MAP_INVALID: u32 = 31;
pub const RCUTILS_RET_STRING_KEY_NOT_FOUND: u32 = 32;
pub const RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID: u32 = 40;
pub const RCUTILS_RET_LOGGING_SEVERITY_STRING_INVALID: u32 = 41;
pub const RCUTILS_RET_HASH_MAP_NO_MORE_ENTRIES: u32 = 50;
pub const RCUTILS_SHA256_BLOCK_SIZE: u32 = 32;
pub const ROSIDL_TYPE_HASH_VERSION_UNSET: u32 = 0;
pub const ROSIDL_TYPE_HASH_SIZE: u32 = 32;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " Struct defined in msg/Time in the package builtin_interfaces.\n**\n* This message communicates ROS Time defined here:\n* https://design.ros2.org/articles/clock_and_time.html\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct builtin_interfaces__msg__Time {
    #[doc = " The seconds component, valid over all int32 values."]
    pub sec: i32,
    #[doc = " The nanoseconds component, valid in the range [0, 1e9)."]
    pub nanosec: u32,
}
#[test]
fn bindgen_test_layout_builtin_interfaces__msg__Time() {
    const UNINIT: ::std::mem::MaybeUninit<builtin_interfaces__msg__Time> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<builtin_interfaces__msg__Time>(),
        8usize,
        concat!("Size of: ", stringify!(builtin_interfaces__msg__Time))
    );
    assert_eq!(
        ::std::mem::align_of::<builtin_interfaces__msg__Time>(),
        4usize,
        concat!("Alignment of ", stringify!(builtin_interfaces__msg__Time))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Time),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nanosec) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Time),
            "::",
            stringify!(nanosec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct builtin_interfaces__msg__Time__Sequence {
    pub data: *mut builtin_interfaces__msg__Time,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_builtin_interfaces__msg__Time__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<builtin_interfaces__msg__Time__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<builtin_interfaces__msg__Time__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(builtin_interfaces__msg__Time__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<builtin_interfaces__msg__Time__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(builtin_interfaces__msg__Time__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Time__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Time__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Time__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__float__Sequence {
    pub data: *mut f32,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__float__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__float__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__float__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__float__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__float__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__float__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__float__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__float__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__float__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__double__Sequence {
    pub data: *mut f64,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__double__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__double__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__double__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__double__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__double__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__double__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__double__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__double__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__double__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__long_double__Sequence {
    pub data: *mut u128,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__long_double__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__long_double__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__long_double__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_runtime_c__long_double__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__long_double__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__long_double__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__long_double__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__long_double__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__long_double__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__char__Sequence {
    pub data: *mut ::std::os::raw::c_schar,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__char__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__char__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__char__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__char__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__char__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__char__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__char__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__char__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__char__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__wchar__Sequence {
    pub data: *mut u16,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__wchar__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__wchar__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__wchar__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__wchar__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__wchar__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__wchar__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__wchar__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__wchar__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__wchar__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__boolean__Sequence {
    pub data: *mut bool,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__boolean__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__boolean__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__boolean__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__boolean__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__boolean__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__boolean__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__boolean__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__boolean__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__boolean__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__octet__Sequence {
    pub data: *mut u8,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__octet__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__octet__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__octet__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__octet__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__octet__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__octet__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__octet__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__octet__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__octet__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__uint8__Sequence {
    pub data: *mut u8,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__uint8__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__uint8__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__uint8__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__uint8__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__uint8__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__uint8__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint8__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint8__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint8__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__int8__Sequence {
    pub data: *mut i8,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__int8__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__int8__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__int8__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__int8__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__int8__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__int8__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int8__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int8__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int8__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__uint16__Sequence {
    pub data: *mut u16,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__uint16__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__uint16__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__uint16__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__uint16__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__uint16__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__uint16__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint16__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint16__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint16__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__int16__Sequence {
    pub data: *mut i16,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__int16__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__int16__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__int16__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__int16__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__int16__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__int16__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int16__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int16__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int16__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__uint32__Sequence {
    pub data: *mut u32,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__uint32__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__uint32__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__uint32__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__uint32__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__uint32__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__uint32__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint32__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint32__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint32__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__int32__Sequence {
    pub data: *mut i32,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__int32__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__int32__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__int32__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__int32__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__int32__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__int32__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int32__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int32__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int32__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__uint64__Sequence {
    pub data: *mut u64,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__uint64__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__uint64__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__uint64__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__uint64__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__uint64__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__uint64__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint64__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint64__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint64__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__int64__Sequence {
    pub data: *mut i64,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__int64__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__int64__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__int64__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__int64__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__int64__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__int64__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int64__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int64__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int64__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
pub type rosidl_runtime_c__bool__Sequence = rosidl_runtime_c__boolean__Sequence;
pub type rosidl_runtime_c__byte__Sequence = rosidl_runtime_c__octet__Sequence;
pub type rosidl_runtime_c__float32__Sequence = rosidl_runtime_c__float__Sequence;
pub type rosidl_runtime_c__float64__Sequence = rosidl_runtime_c__double__Sequence;
#[doc = " An array of 8-bit characters terminated by a null byte."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__String {
    #[doc = " The pointer to the first character, the sequence ends with a null byte."]
    pub data: *mut ::std::os::raw::c_char,
    #[doc = " The length of the string (excluding the null byte)."]
    pub size: usize,
    #[doc = " The capacity represents the number of allocated bytes (including the null byte)."]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__String() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__String> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__String>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__String))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__String>(),
        8usize,
        concat!("Alignment of ", stringify!(rosidl_runtime_c__String))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__String),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__String),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__String),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__String__Sequence {
    pub data: *mut rosidl_runtime_c__String,
    pub size: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__String__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__String__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__String__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__String__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__String__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__String__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__String__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__String__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__String__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_NOT_SET: _bindgen_ty_1 = 0;
#[doc = " Constant 'FIELD_TYPE_NOT_SET'.\n**\n* A constant for each type supported according to:\n*   http://design.ros2.org/articles/legacy_interface_definition.html\n* and:\n*   http://design.ros2.org/articles/idl_interface_definition.html\n* Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n*  https://www.omg.org/spec/IDL/4.2\n* Layout of constants across the 0-255 decimal values in the uint8:\n*\n* - 000    : Reserved for \"not set\"\n* - 001-048: Primitive types, strings, and reserved space for future primitive types\n* - 049-096: Fixed sized array of primitive and string types\n* - 097-144: Bounded Sequences of primitive and string types\n* - 145-192: Unbounded Sequences of primitive and string types\n* - 193-255: Reserved space for future array/sequence-like types\n*/"]
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_NESTED_TYPE: _bindgen_ty_2 = 1;
#[doc = " Constant 'FIELD_TYPE_NESTED_TYPE'.\n**\n* Nested type defined in other .msg/.idl files.\n*/"]
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT8: _bindgen_ty_3 = 2;
#[doc = " Constant 'FIELD_TYPE_INT8'.\n**\n* Integer Types\n*/"]
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT8: _bindgen_ty_4 = 3;
#[doc = " Constant 'FIELD_TYPE_UINT8'."]
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT16: _bindgen_ty_5 = 4;
#[doc = " Constant 'FIELD_TYPE_INT16'."]
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT16: _bindgen_ty_6 = 5;
#[doc = " Constant 'FIELD_TYPE_UINT16'."]
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT32: _bindgen_ty_7 = 6;
#[doc = " Constant 'FIELD_TYPE_INT32'."]
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT32: _bindgen_ty_8 = 7;
#[doc = " Constant 'FIELD_TYPE_UINT32'."]
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT64: _bindgen_ty_9 = 8;
#[doc = " Constant 'FIELD_TYPE_INT64'."]
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT64: _bindgen_ty_10 = 9;
#[doc = " Constant 'FIELD_TYPE_UINT64'."]
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_FLOAT: _bindgen_ty_11 = 10;
#[doc = " Constant 'FIELD_TYPE_FLOAT'.\n**\n* Floating-Point Types\n*/"]
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_DOUBLE: _bindgen_ty_12 = 11;
#[doc = " Constant 'FIELD_TYPE_DOUBLE'."]
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_LONG_DOUBLE: _bindgen_ty_13 =
    12;
#[doc = " Constant 'FIELD_TYPE_LONG_DOUBLE'."]
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_CHAR: _bindgen_ty_14 = 13;
#[doc = " Constant 'FIELD_TYPE_CHAR'.\n**\n* Char and WChar Types\n*/"]
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_WCHAR: _bindgen_ty_15 = 14;
#[doc = " Constant 'FIELD_TYPE_WCHAR'."]
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BOOLEAN: _bindgen_ty_16 = 15;
#[doc = " Constant 'FIELD_TYPE_BOOLEAN'.\n**\n* Boolean Type\n*/"]
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BYTE: _bindgen_ty_17 = 16;
#[doc = " Constant 'FIELD_TYPE_BYTE'.\n**\n* Byte/Octet Type\n*/"]
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_STRING: _bindgen_ty_18 = 17;
#[doc = " Constant 'FIELD_TYPE_STRING'.\n**\n* String Types\n*/"]
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_WSTRING: _bindgen_ty_19 = 18;
#[doc = " Constant 'FIELD_TYPE_WSTRING'."]
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_FIXED_STRING: _bindgen_ty_20 =
    19;
#[doc = " Constant 'FIELD_TYPE_FIXED_STRING'.\n**\n* Fixed String Types\n*/"]
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_FIXED_WSTRING: _bindgen_ty_21 =
    20;
#[doc = " Constant 'FIELD_TYPE_FIXED_WSTRING'."]
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BOUNDED_STRING: _bindgen_ty_22 =
    21;
#[doc = " Constant 'FIELD_TYPE_BOUNDED_STRING'.\n**\n* Bounded String Types\n*/"]
pub type _bindgen_ty_22 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BOUNDED_WSTRING:
    _bindgen_ty_23 = 22;
#[doc = " Constant 'FIELD_TYPE_BOUNDED_WSTRING'."]
pub type _bindgen_ty_23 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_NESTED_TYPE_ARRAY:
    _bindgen_ty_24 = 49;
#[doc = " Constant 'FIELD_TYPE_NESTED_TYPE_ARRAY'.\n**\n* Fixed Sized Array Types\n*/"]
pub type _bindgen_ty_24 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT8_ARRAY: _bindgen_ty_25 = 50;
#[doc = " Constant 'FIELD_TYPE_INT8_ARRAY'."]
pub type _bindgen_ty_25 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT8_ARRAY: _bindgen_ty_26 =
    51;
#[doc = " Constant 'FIELD_TYPE_UINT8_ARRAY'."]
pub type _bindgen_ty_26 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT16_ARRAY: _bindgen_ty_27 =
    52;
#[doc = " Constant 'FIELD_TYPE_INT16_ARRAY'."]
pub type _bindgen_ty_27 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT16_ARRAY: _bindgen_ty_28 =
    53;
#[doc = " Constant 'FIELD_TYPE_UINT16_ARRAY'."]
pub type _bindgen_ty_28 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT32_ARRAY: _bindgen_ty_29 =
    54;
#[doc = " Constant 'FIELD_TYPE_INT32_ARRAY'."]
pub type _bindgen_ty_29 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT32_ARRAY: _bindgen_ty_30 =
    55;
#[doc = " Constant 'FIELD_TYPE_UINT32_ARRAY'."]
pub type _bindgen_ty_30 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT64_ARRAY: _bindgen_ty_31 =
    56;
#[doc = " Constant 'FIELD_TYPE_INT64_ARRAY'."]
pub type _bindgen_ty_31 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT64_ARRAY: _bindgen_ty_32 =
    57;
#[doc = " Constant 'FIELD_TYPE_UINT64_ARRAY'."]
pub type _bindgen_ty_32 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_FLOAT_ARRAY: _bindgen_ty_33 =
    58;
#[doc = " Constant 'FIELD_TYPE_FLOAT_ARRAY'."]
pub type _bindgen_ty_33 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_DOUBLE_ARRAY: _bindgen_ty_34 =
    59;
#[doc = " Constant 'FIELD_TYPE_DOUBLE_ARRAY'."]
pub type _bindgen_ty_34 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_LONG_DOUBLE_ARRAY:
    _bindgen_ty_35 = 60;
#[doc = " Constant 'FIELD_TYPE_LONG_DOUBLE_ARRAY'."]
pub type _bindgen_ty_35 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_CHAR_ARRAY: _bindgen_ty_36 = 61;
#[doc = " Constant 'FIELD_TYPE_CHAR_ARRAY'."]
pub type _bindgen_ty_36 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_WCHAR_ARRAY: _bindgen_ty_37 =
    62;
#[doc = " Constant 'FIELD_TYPE_WCHAR_ARRAY'."]
pub type _bindgen_ty_37 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BOOLEAN_ARRAY: _bindgen_ty_38 =
    63;
#[doc = " Constant 'FIELD_TYPE_BOOLEAN_ARRAY'."]
pub type _bindgen_ty_38 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BYTE_ARRAY: _bindgen_ty_39 = 64;
#[doc = " Constant 'FIELD_TYPE_BYTE_ARRAY'."]
pub type _bindgen_ty_39 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_STRING_ARRAY: _bindgen_ty_40 =
    65;
#[doc = " Constant 'FIELD_TYPE_STRING_ARRAY'."]
pub type _bindgen_ty_40 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_WSTRING_ARRAY: _bindgen_ty_41 =
    66;
#[doc = " Constant 'FIELD_TYPE_WSTRING_ARRAY'."]
pub type _bindgen_ty_41 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_FIXED_STRING_ARRAY:
    _bindgen_ty_42 = 67;
#[doc = " Constant 'FIELD_TYPE_FIXED_STRING_ARRAY'."]
pub type _bindgen_ty_42 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_FIXED_WSTRING_ARRAY:
    _bindgen_ty_43 = 68;
#[doc = " Constant 'FIELD_TYPE_FIXED_WSTRING_ARRAY'."]
pub type _bindgen_ty_43 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BOUNDED_STRING_ARRAY:
    _bindgen_ty_44 = 69;
#[doc = " Constant 'FIELD_TYPE_BOUNDED_STRING_ARRAY'."]
pub type _bindgen_ty_44 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BOUNDED_WSTRING_ARRAY:
    _bindgen_ty_45 = 70;
#[doc = " Constant 'FIELD_TYPE_BOUNDED_WSTRING_ARRAY'."]
pub type _bindgen_ty_45 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE:
    _bindgen_ty_46 = 97;
#[doc = " Constant 'FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE'.\n**\n* Bounded Sequence Types\n*/"]
pub type _bindgen_ty_46 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT8_BOUNDED_SEQUENCE:
    _bindgen_ty_47 = 98;
#[doc = " Constant 'FIELD_TYPE_INT8_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_47 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT8_BOUNDED_SEQUENCE:
    _bindgen_ty_48 = 99;
#[doc = " Constant 'FIELD_TYPE_UINT8_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_48 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT16_BOUNDED_SEQUENCE:
    _bindgen_ty_49 = 100;
#[doc = " Constant 'FIELD_TYPE_INT16_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_49 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT16_BOUNDED_SEQUENCE:
    _bindgen_ty_50 = 101;
#[doc = " Constant 'FIELD_TYPE_UINT16_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_50 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT32_BOUNDED_SEQUENCE:
    _bindgen_ty_51 = 102;
#[doc = " Constant 'FIELD_TYPE_INT32_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_51 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT32_BOUNDED_SEQUENCE:
    _bindgen_ty_52 = 103;
#[doc = " Constant 'FIELD_TYPE_UINT32_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_52 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT64_BOUNDED_SEQUENCE:
    _bindgen_ty_53 = 104;
#[doc = " Constant 'FIELD_TYPE_INT64_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_53 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT64_BOUNDED_SEQUENCE:
    _bindgen_ty_54 = 105;
#[doc = " Constant 'FIELD_TYPE_UINT64_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_54 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE:
    _bindgen_ty_55 = 106;
#[doc = " Constant 'FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_55 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE:
    _bindgen_ty_56 = 107;
#[doc = " Constant 'FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_56 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE:
    _bindgen_ty_57 = 108;
#[doc = " Constant 'FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_57 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_CHAR_BOUNDED_SEQUENCE:
    _bindgen_ty_58 = 109;
#[doc = " Constant 'FIELD_TYPE_CHAR_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_58 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE:
    _bindgen_ty_59 = 110;
#[doc = " Constant 'FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_59 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE:
    _bindgen_ty_60 = 111;
#[doc = " Constant 'FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_60 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BYTE_BOUNDED_SEQUENCE:
    _bindgen_ty_61 = 112;
#[doc = " Constant 'FIELD_TYPE_BYTE_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_61 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_STRING_BOUNDED_SEQUENCE:
    _bindgen_ty_62 = 113;
#[doc = " Constant 'FIELD_TYPE_STRING_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_62 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE:
    _bindgen_ty_63 = 114;
#[doc = " Constant 'FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_63 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE : _bindgen_ty_64 = 115 ;
#[doc = " Constant 'FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_64 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE : _bindgen_ty_65 = 116 ;
#[doc = " Constant 'FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_65 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE : _bindgen_ty_66 = 117 ;
#[doc = " Constant 'FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_66 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE : _bindgen_ty_67 = 118 ;
#[doc = " Constant 'FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE'."]
pub type _bindgen_ty_67 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE : _bindgen_ty_68 = 145 ;
#[doc = " Constant 'FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE'.\n**\n* Unbounded Sequence Types\n*/"]
pub type _bindgen_ty_68 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE:
    _bindgen_ty_69 = 146;
#[doc = " Constant 'FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_69 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE:
    _bindgen_ty_70 = 147;
#[doc = " Constant 'FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_70 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE:
    _bindgen_ty_71 = 148;
#[doc = " Constant 'FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_71 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE:
    _bindgen_ty_72 = 149;
#[doc = " Constant 'FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_72 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE:
    _bindgen_ty_73 = 150;
#[doc = " Constant 'FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_73 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE:
    _bindgen_ty_74 = 151;
#[doc = " Constant 'FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_74 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE:
    _bindgen_ty_75 = 152;
#[doc = " Constant 'FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_75 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE:
    _bindgen_ty_76 = 153;
#[doc = " Constant 'FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_76 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE:
    _bindgen_ty_77 = 154;
#[doc = " Constant 'FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_77 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE:
    _bindgen_ty_78 = 155;
#[doc = " Constant 'FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_78 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE : _bindgen_ty_79 = 156 ;
#[doc = " Constant 'FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_79 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE:
    _bindgen_ty_80 = 157;
#[doc = " Constant 'FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_80 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE:
    _bindgen_ty_81 = 158;
#[doc = " Constant 'FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_81 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE:
    _bindgen_ty_82 = 159;
#[doc = " Constant 'FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_82 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE:
    _bindgen_ty_83 = 160;
#[doc = " Constant 'FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_83 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE:
    _bindgen_ty_84 = 161;
#[doc = " Constant 'FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_84 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE:
    _bindgen_ty_85 = 162;
#[doc = " Constant 'FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_85 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE : _bindgen_ty_86 = 163 ;
#[doc = " Constant 'FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_86 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE : _bindgen_ty_87 = 164 ;
#[doc = " Constant 'FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_87 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE : _bindgen_ty_88 = 165 ;
#[doc = " Constant 'FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_88 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE : _bindgen_ty_89 = 166 ;
#[doc = " Constant 'FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE'."]
pub type _bindgen_ty_89 = ::std::os::raw::c_uint;
pub const rosidl_runtime_c__type_description__FieldType__nested_type_name__MAX_STRING_SIZE:
    _bindgen_ty_90 = 255;
pub type _bindgen_ty_90 = ::std::os::raw::c_uint;
#[doc = " Struct defined in msg/FieldType in the package type_description_interfaces.\n**\n* Represents the type of a field and related meta-data.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__type_description__FieldType {
    #[doc = " Identifying number for the type of the field, using one of the above constants."]
    pub type_id: u8,
    #[doc = " Only used when the type is an array or a bounded sequence.\n In the case of an array, this is the fixed capacity of the array.\n In the case of a bounded sequence, this is the maximum capacity of the sequence.\n In all other cases this field is unused."]
    pub capacity: u64,
    #[doc = " Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n In the case of a fixed string/wstring, it is the fixed length of the string.\n In the case of a bounded string/wstring, it is the maximum capacity of the string.\n In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n It is not currently possible to have different string capacities per element in the array/sequence."]
    pub string_capacity: u64,
    #[doc = " Only used when the type is a nested type or array/sequence of nested types.\n This is limited to 255 characters.\n TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n   We lack a ROS 2 specific limit in our design documents, but we should update\n   this and/or link to the design doc when that is available."]
    pub nested_type_name: rosidl_runtime_c__String,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__type_description__FieldType() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__type_description__FieldType> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__type_description__FieldType>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_runtime_c__type_description__FieldType)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__type_description__FieldType>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__type_description__FieldType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__FieldType),
            "::",
            stringify!(type_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__FieldType),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string_capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__FieldType),
            "::",
            stringify!(string_capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nested_type_name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__FieldType),
            "::",
            stringify!(nested_type_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__type_description__FieldType__Sequence {
    pub data: *mut rosidl_runtime_c__type_description__FieldType,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__type_description__FieldType__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__type_description__FieldType__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__type_description__FieldType__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_runtime_c__type_description__FieldType__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__type_description__FieldType__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__type_description__FieldType__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__FieldType__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__FieldType__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__FieldType__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[doc = " Struct defined in msg/Field in the package type_description_interfaces.\n**\n* Represents a single field in a type.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__type_description__Field {
    #[doc = " Name of the field."]
    pub name: rosidl_runtime_c__String,
    #[doc = " Type of the field, including details about the type like length, nested name, etc."]
    pub type_: rosidl_runtime_c__type_description__FieldType,
    #[doc = " Literal default value of the field as a string, as it appeared in the original\n message description file, whether that be .msg/.srv/.action or .idl."]
    pub default_value: rosidl_runtime_c__String,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__type_description__Field() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__type_description__Field> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__type_description__Field>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_runtime_c__type_description__Field)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__type_description__Field>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__type_description__Field)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__Field),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__Field),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__Field),
            "::",
            stringify!(default_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__type_description__Field__Sequence {
    pub data: *mut rosidl_runtime_c__type_description__Field,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__type_description__Field__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__type_description__Field__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__type_description__Field__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_runtime_c__type_description__Field__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__type_description__Field__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__type_description__Field__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__Field__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__Field__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__Field__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
pub const rosidl_runtime_c__type_description__IndividualTypeDescription__type_name__MAX_STRING_SIZE : _bindgen_ty_91 = 255 ;
pub type _bindgen_ty_91 = ::std::os::raw::c_uint;
#[doc = " Struct defined in msg/IndividualTypeDescription in the package type_description_interfaces.\n**\n* Represents a single type, without the types it references, if any.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__type_description__IndividualTypeDescription {
    #[doc = " Name of the type.\n This is limited to 255 characters.\n TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n   We lack a ROS 2 specific limit in our design documents, but we should update\n   this and/or link to the design doc when that is available."]
    pub type_name: rosidl_runtime_c__String,
    #[doc = " Fields of the type."]
    pub fields: rosidl_runtime_c__type_description__Field__Sequence,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__type_description__IndividualTypeDescription() {
    const UNINIT: ::std::mem::MaybeUninit<
        rosidl_runtime_c__type_description__IndividualTypeDescription,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__type_description__IndividualTypeDescription>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_runtime_c__type_description__IndividualTypeDescription)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__type_description__IndividualTypeDescription>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__type_description__IndividualTypeDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__IndividualTypeDescription),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fields) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__IndividualTypeDescription),
            "::",
            stringify!(fields)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__type_description__IndividualTypeDescription__Sequence {
    pub data: *mut rosidl_runtime_c__type_description__IndividualTypeDescription,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__type_description__IndividualTypeDescription__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<
        rosidl_runtime_c__type_description__IndividualTypeDescription__Sequence,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            rosidl_runtime_c__type_description__IndividualTypeDescription__Sequence,
        >(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_runtime_c__type_description__IndividualTypeDescription__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            rosidl_runtime_c__type_description__IndividualTypeDescription__Sequence,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__type_description__IndividualTypeDescription__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__IndividualTypeDescription__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__IndividualTypeDescription__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__IndividualTypeDescription__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[doc = " Struct defined in msg/TypeDescription in the package type_description_interfaces.\n**\n* Represents a complete type description, including the type itself as well as the types it references.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__type_description__TypeDescription {
    #[doc = " Description of the type."]
    pub type_description: rosidl_runtime_c__type_description__IndividualTypeDescription,
    #[doc = " Descriptions of all referenced types, recursively."]
    pub referenced_type_descriptions:
        rosidl_runtime_c__type_description__IndividualTypeDescription__Sequence,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__type_description__TypeDescription() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__type_description__TypeDescription> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__type_description__TypeDescription>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_runtime_c__type_description__TypeDescription)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__type_description__TypeDescription>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__type_description__TypeDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_description) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__TypeDescription),
            "::",
            stringify!(type_description)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).referenced_type_descriptions) as usize - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__TypeDescription),
            "::",
            stringify!(referenced_type_descriptions)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__type_description__TypeDescription__Sequence {
    pub data: *mut rosidl_runtime_c__type_description__TypeDescription,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__type_description__TypeDescription__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<
        rosidl_runtime_c__type_description__TypeDescription__Sequence,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__type_description__TypeDescription__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_runtime_c__type_description__TypeDescription__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__type_description__TypeDescription__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__type_description__TypeDescription__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__TypeDescription__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__TypeDescription__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__TypeDescription__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[doc = " Struct defined in msg/TypeSource in the package type_description_interfaces.\n**\n* Represents the original source of a ROS 2 interface definition.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__type_description__TypeSource {
    #[doc = " ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format."]
    pub type_name: rosidl_runtime_c__String,
    #[doc = " The type of the original source file, typically matching the file extension.\n Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n \"implicit\" specifies a type created automatically as a subtype of a\n complex type (service or action) - such as the request message for a service.\n Implicit types will have no contents, the full source will be available on the parent srv/action."]
    pub encoding: rosidl_runtime_c__String,
    #[doc = " Dumped contents of the interface definition source file.\n If `encoding` is \"dynamic\" or \"implicit\", this field will be empty."]
    pub raw_file_contents: rosidl_runtime_c__String,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__type_description__TypeSource() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__type_description__TypeSource> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__type_description__TypeSource>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_runtime_c__type_description__TypeSource)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__type_description__TypeSource>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__type_description__TypeSource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__TypeSource),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoding) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__TypeSource),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_file_contents) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__TypeSource),
            "::",
            stringify!(raw_file_contents)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__type_description__TypeSource__Sequence {
    pub data: *mut rosidl_runtime_c__type_description__TypeSource,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__type_description__TypeSource__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<
        rosidl_runtime_c__type_description__TypeSource__Sequence,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__type_description__TypeSource__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_runtime_c__type_description__TypeSource__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__type_description__TypeSource__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__type_description__TypeSource__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__TypeSource__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__TypeSource__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__type_description__TypeSource__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[doc = " The type that holds a return value for an rcutils operation."]
pub type rcutils_ret_t = ::std::os::raw::c_int;
#[doc = " Encapsulation of an allocator.\n**\n* The default allocator uses malloc(), free(), calloc(), and realloc().\n* It can be obtained using rcutils_get_default_allocator().\n*\n* The allocator should be trivially copyable.\n* Meaning that the struct should continue to work after being assignment\n* copied into a new struct.\n* Specifically the object pointed to by the state pointer should remain valid\n* until all uses of the allocator have been made.\n* Particular care should be taken when giving an allocator to functions like\n* rcutils_*_init() where it is stored within another object and used later.\n* Developers should note that, while the fields of a const-qualified allocator\n* struct cannot be modified, the state of the allocator can be modified.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_allocator_s {
    #[doc = " Allocate memory, given a size and the `state` pointer.\n** An error should be indicated by returning `NULL`. */"]
    pub allocate: ::std::option::Option<
        unsafe extern "C" fn(
            size: usize,
            state: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Deallocate previously allocated memory, mimicking free().\n** Also takes the `state` pointer. */"]
    pub deallocate: ::std::option::Option<
        unsafe extern "C" fn(
            pointer: *mut ::std::os::raw::c_void,
            state: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Reallocate if possible, otherwise it deallocates and allocates.\n**\n* Also takes the `state` pointer.\n*\n* If unsupported then do deallocate and then allocate.\n* This should behave as realloc() does, as opposed to posix's\n* [reallocf](https://linux.die.net/man/3/reallocf), i.e. the memory given\n* by pointer will not be free'd automatically if realloc() fails.\n* For reallocf-like behavior use rcutils_reallocf().\n* This function must be able to take an input pointer of `NULL` and succeed.\n*/"]
    pub reallocate: ::std::option::Option<
        unsafe extern "C" fn(
            pointer: *mut ::std::os::raw::c_void,
            size: usize,
            state: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Allocate memory with all elements set to zero, given a number of elements and their size.\n** An error should be indicated by returning `NULL`. */"]
    pub zero_allocate: ::std::option::Option<
        unsafe extern "C" fn(
            number_of_elements: usize,
            size_of_element: usize,
            state: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Implementation defined state storage.\n**\n* This is passed as the final parameter to other allocator functions.\n* Note that the contents of the state can be modified even in const-qualified\n* allocator objects.\n*/"]
    pub state: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rcutils_allocator_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcutils_allocator_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcutils_allocator_s>(),
        40usize,
        concat!("Size of: ", stringify!(rcutils_allocator_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcutils_allocator_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcutils_allocator_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_allocator_s),
            "::",
            stringify!(allocate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deallocate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_allocator_s),
            "::",
            stringify!(deallocate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reallocate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_allocator_s),
            "::",
            stringify!(reallocate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zero_allocate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_allocator_s),
            "::",
            stringify!(zero_allocate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_allocator_s),
            "::",
            stringify!(state)
        )
    );
}
#[doc = " Encapsulation of an allocator.\n**\n* The default allocator uses malloc(), free(), calloc(), and realloc().\n* It can be obtained using rcutils_get_default_allocator().\n*\n* The allocator should be trivially copyable.\n* Meaning that the struct should continue to work after being assignment\n* copied into a new struct.\n* Specifically the object pointed to by the state pointer should remain valid\n* until all uses of the allocator have been made.\n* Particular care should be taken when giving an allocator to functions like\n* rcutils_*_init() where it is stored within another object and used later.\n* Developers should note that, while the fields of a const-qualified allocator\n* struct cannot be modified, the state of the allocator can be modified.\n*/"]
pub type rcutils_allocator_t = rcutils_allocator_s;
extern "C" {
    #[doc = " Return a zero initialized allocator.\n**\n* Note that this is an invalid allocator and should only be used as a placeholder.\n*/"]
    pub fn rcutils_get_zero_initialized_allocator() -> rcutils_allocator_t;
}
extern "C" {
    #[doc = " Return a properly initialized rcutils_allocator_t with default values.\n**\n* This defaults to:\n*\n* - allocate = wraps malloc()\n* - deallocate = wraps free()\n* - reallocate = wraps realloc()\n* - zero_allocate = wraps calloc()\n* - state = `NULL`\n*\n* <hr>\n* Attribute          | Adherence\n* ------------------ | -------------\n* Allocates Memory   | No\n* Thread-Safe        | Yes\n* Uses Atomics       | No\n* Lock-Free          | Yes\n*/"]
    pub fn rcutils_get_default_allocator() -> rcutils_allocator_t;
}
extern "C" {
    #[doc = " Return true if the given allocator has non-null function pointers.\n**\n* \\param[in] allocator to be checked by the function\n* \\return `true` if the allocator is valid, `false` otherwise.\n*/"]
    pub fn rcutils_allocator_is_valid(allocator: *const rcutils_allocator_t) -> bool;
}
extern "C" {
    #[doc = " Emulate the behavior of [reallocf](https://linux.die.net/man/3/reallocf).\n**\n* This function will return `NULL` if the allocator is `NULL` or has `NULL` for\n* function pointer fields.\n* \\param[inout] pointer to the memory which will be reallocated\n* \\param[in] size in bytes\n* \\param[in] allocator to be used to allocate and deallocate memory\n*/"]
    pub fn rcutils_reallocf(
        pointer: *mut ::std::os::raw::c_void,
        size: usize,
        allocator: *mut rcutils_allocator_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_sha256_ctx_s {
    pub data: [u8; 64usize],
    pub datalen: usize,
    pub bitlen: u64,
    pub state: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_rcutils_sha256_ctx_s() {
    const UNINIT: ::std::mem::MaybeUninit<rcutils_sha256_ctx_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcutils_sha256_ctx_s>(),
        112usize,
        concat!("Size of: ", stringify!(rcutils_sha256_ctx_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rcutils_sha256_ctx_s>(),
        8usize,
        concat!("Alignment of ", stringify!(rcutils_sha256_ctx_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_sha256_ctx_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).datalen) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_sha256_ctx_s),
            "::",
            stringify!(datalen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitlen) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_sha256_ctx_s),
            "::",
            stringify!(bitlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rcutils_sha256_ctx_s),
            "::",
            stringify!(state)
        )
    );
}
pub type rcutils_sha256_ctx_t = rcutils_sha256_ctx_s;
extern "C" {
    #[doc = " Initialize the sha256 algorithm context with starting state.\n**\n* Call this on any new context before starting to input data.\n*\n* \\param[inout] ctx\n* \\return void\n*/"]
    pub fn rcutils_sha256_init(ctx: *mut rcutils_sha256_ctx_t);
}
extern "C" {
    #[doc = " Add data to the sha256 algorithm\n**\n* This may be called repeatedly on an initialized context.\n*\n* \\param[inout] ctx Initialized sha256 context struct\n* \\param[in] data Data to add to the total message being hashed\n* \\param[in] data_len Size of the input data.\n* \\return void\n*/"]
    pub fn rcutils_sha256_update(ctx: *mut rcutils_sha256_ctx_t, data: *const u8, data_len: usize);
}
extern "C" {
    pub fn rcutils_sha256_final(ctx: *mut rcutils_sha256_ctx_t, output_hash: *mut u8);
}
#[doc = " A ROS 2 interface type hash per REP-2011 RIHS standard."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_type_hash_s {
    pub version: u8,
    pub value: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_rosidl_type_hash_s() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_type_hash_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_type_hash_s>(),
        33usize,
        concat!("Size of: ", stringify!(rosidl_type_hash_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_type_hash_s>(),
        1usize,
        concat!("Alignment of ", stringify!(rosidl_type_hash_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_type_hash_s),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_type_hash_s),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " A ROS 2 interface type hash per REP-2011 RIHS standard."]
pub type rosidl_type_hash_t = rosidl_type_hash_s;
extern "C" {
    #[doc = " Get a new zero-initialized type hash structure.\n**\n* Note that the version equals ROSIDL_TYPE_HASH_VERSION_UNSET.\n*/"]
    pub fn rosidl_get_zero_initialized_type_hash() -> rosidl_type_hash_t;
}
extern "C" {
    #[doc = " Convert type hash to a standardized string representation.\n**\n* Follows format RIHS{version}_{value}.\n*\n* \\param[in] type_hash Type hash to convert to string\n* \\param[in] allocator Allocator to use for allocating string space\n* \\param[out] output_string Handle to a pointer that will be set\n*   to the newly allocated null-terminated string representation.\n* \\return RCUTILS_RET_INVALID_ARGUMENT if any pointer arguments are null or allocator invalid\n* \\return RCUTILS_RET_BAD_ALLOC if space could not be allocated for resulting string\n* \\return RCUTILS_RET_OK otherwise\n*/"]
    pub fn rosidl_stringify_type_hash(
        type_hash: *const rosidl_type_hash_t,
        allocator: rcutils_allocator_t,
        output_string: *mut *mut ::std::os::raw::c_char,
    ) -> rcutils_ret_t;
}
extern "C" {
    #[doc = " Parse a stringified type hash to a struct.\n**\n* \\param[in] type_hash_string Null-terminated string with the hash representation\n* \\param[out] hash_out Preallocated structure to be filled with parsed hash information.\n*   hash_out->version will be 0 if no version could be parsed,\n*   but if a version could be determined this field will be set even if an error is returned\n* \\return RCTUILS_RET_INVALID_ARGUMENT on any null pointer argumunts, or malformed hash string.\n* \\return RCUTILS_RET_OK otherwise\n*/"]
    pub fn rosidl_parse_type_hash_string(
        type_hash_string: *const ::std::os::raw::c_char,
        hash_out: *mut rosidl_type_hash_t,
    ) -> rcutils_ret_t;
}
pub type rosidl_message_typesupport_handle_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_message_type_support_t,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const rosidl_message_type_support_t,
>;
pub type rosidl_message_get_type_hash_function = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const rosidl_message_type_support_t) -> *const rosidl_type_hash_t,
>;
pub type rosidl_message_get_type_description_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeDescription,
>;
pub type rosidl_message_get_type_description_sources_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource__Sequence,
>;
#[doc = " Contains rosidl message type support data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
struct rosidl_message_type_support_t_ {
    #[doc = " String identifier for the type_support."]
    pub typesupport_identifier: *const ::std::os::raw::c_char,
    #[doc = " Pointer to the message type support library"]
    pub data: *const ::std::os::raw::c_void,
    #[doc = " Pointer to the message type support handler function"]
    pub func: rosidl_message_typesupport_handle_function,
    #[doc = " Pointer to function to get the hash of the message's description"]
    pub get_type_hash_func: rosidl_message_get_type_hash_function,
    #[doc = " Pointer to function to get the description of the type"]
    pub get_type_description_func: rosidl_message_get_type_description_function,
    #[doc = " Pointer to function to get the text of the sources that defined the description of the type"]
    pub get_type_description_sources_func: rosidl_message_get_type_description_sources_function,
}
#[test]
fn bindgen_test_layout_rosidl_message_type_support_t() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_message_type_support_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_message_type_support_t>(),
        48usize,
        concat!("Size of: ", stringify!(rosidl_message_type_support_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_message_type_support_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rosidl_message_type_support_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).typesupport_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_message_type_support_t),
            "::",
            stringify!(typesupport_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_message_type_support_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_message_type_support_t),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_type_hash_func) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_message_type_support_t),
            "::",
            stringify!(get_type_hash_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_type_description_func) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_message_type_support_t),
            "::",
            stringify!(get_type_description_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).get_type_description_sources_func) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_message_type_support_t),
            "::",
            stringify!(get_type_description_sources_func)
        )
    );
}
extern "C" {
    #[doc = " Return a rosidl_message_type_support_t struct with members set to `NULL`."]
    pub fn rosidl_get_zero_initialized_message_type_support_handle() -> rosidl_message_type_support_t;
}
extern "C" {
    #[doc = " Get the message type support handle specific to this identifier.\n**\n* The handle's message typesupport identifier function is returned or if the parameters are NULL\n* then an assert will happen.\n*\n* \\param handle Handle to message type support\n* \\param identifier The typesupport identifier to get the handle function for\n* \\return The associated message typesupport handle function.\n*/"]
    pub fn get_message_typesupport_handle(
        handle: *const rosidl_message_type_support_t,
        identifier: *const ::std::os::raw::c_char,
    ) -> *const rosidl_message_type_support_t;
}
extern "C" {
    #[doc = " If the identifier is the same as this handle's typesupport_identifier the handle is simply\n returned or if the parameters are NULL then an assert will happen.\n\n \\param handle Handle to message type support\n \\param identifier The typesupport identifier to get the handle function for\n \\return if the identifier match's the handle's identifier then the handle's function\n   is returned."]
    pub fn get_message_typesupport_handle_function(
        handle: *const rosidl_message_type_support_t,
        identifier: *const ::std::os::raw::c_char,
    ) -> *const rosidl_message_type_support_t;
}
pub type rosidl_service_typesupport_handle_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_service_type_support_t,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const rosidl_service_type_support_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_service_introspection_info_s {
    pub event_type: u8,
    pub stamp_sec: i32,
    pub stamp_nanosec: u32,
    pub client_gid: [u8; 16usize],
    pub sequence_number: i64,
}
#[test]
fn bindgen_test_layout_rosidl_service_introspection_info_s() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_service_introspection_info_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_service_introspection_info_s>(),
        40usize,
        concat!("Size of: ", stringify!(rosidl_service_introspection_info_s))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_service_introspection_info_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_service_introspection_info_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_introspection_info_s),
            "::",
            stringify!(event_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stamp_sec) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_introspection_info_s),
            "::",
            stringify!(stamp_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stamp_nanosec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_introspection_info_s),
            "::",
            stringify!(stamp_nanosec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_gid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_introspection_info_s),
            "::",
            stringify!(client_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence_number) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_introspection_info_s),
            "::",
            stringify!(sequence_number)
        )
    );
}
pub type rosidl_service_introspection_info_t = rosidl_service_introspection_info_s;
#[doc = " Creates a ServiceEvent message for the service.\n**\n* Instantiates a ServiceEvent message with the given info and request/response message.\n* The message is allocated using the given allocator and must be deallocated using\n* the rosidl_service_introspection_destroy_handle\n*\n* \\param[in] info POD fields of service_msgs/msg/ServiceEventInfo to be passed from rcl\n* \\param[in] allocator The allocator to use for allocating the ServiceEvent message\n* \\param[in] request_message type-erased handle to request message from rcl. Can be NULL.\n* \\param[in] response_message type-erased handle to request message from rcl. Can be NULL.\n* \\return The built ServiceEvent message. Will return NULL if the message could not be built.\n**/"]
pub type rosidl_event_message_create_handle_function_function = ::std::option::Option<
    unsafe extern "C" fn(
        info: *const rosidl_service_introspection_info_t,
        allocator: *mut rcutils_allocator_t,
        request_message: *const ::std::os::raw::c_void,
        response_message: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Destroys a ServiceEvent message\n**\n* Destroys a ServiceEvent message returned by a rosidl_service_introspection_message_create_handle\n* by calling the corresponding __fini function then deallocating\n*\n* \\param[in] event_message The message to destroy.\n* \\param[in] allocator The allocator to use for deallocating the message.\n*/"]
pub type rosidl_event_message_destroy_handle_function_function = ::std::option::Option<
    unsafe extern "C" fn(
        event_message: *mut ::std::os::raw::c_void,
        allocator: *mut rcutils_allocator_t,
    ) -> bool,
>;
pub type rosidl_service_get_type_hash_function = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const rosidl_service_type_support_t) -> *const rosidl_type_hash_t,
>;
pub type rosidl_service_get_type_description_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_service_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeDescription,
>;
pub type rosidl_service_get_type_description_sources_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_service_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource__Sequence,
>;
#[doc = " Contains rosidl service type support data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
struct rosidl_service_type_support_t_ {
    #[doc = " String identifier for the type_support."]
    pub typesupport_identifier: *const ::std::os::raw::c_char,
    #[doc = " Pointer to the service type support library"]
    pub data: *const ::std::os::raw::c_void,
    #[doc = " Pointer to the service type support handler function"]
    pub func: rosidl_service_typesupport_handle_function,
    #[doc = " Service request message typesupport"]
    pub request_typesupport: *const rosidl_message_type_support_t,
    #[doc = " Service response message typesupport"]
    pub response_typesupport: *const rosidl_message_type_support_t,
    #[doc = " Service event message typesupport"]
    pub event_typesupport: *const rosidl_message_type_support_t,
    #[doc = " Pointer to function to create the introspection message"]
    pub event_message_create_handle_function: rosidl_event_message_create_handle_function_function,
    #[doc = " Pointer to function to finalize the introspection message"]
    pub event_message_destroy_handle_function:
        rosidl_event_message_destroy_handle_function_function,
    #[doc = " Pointer to function to get the hash of the message's description"]
    pub get_type_hash_func: rosidl_service_get_type_hash_function,
    #[doc = " Pointer to function to get the description of the type"]
    pub get_type_description_func: rosidl_service_get_type_description_function,
    #[doc = " Pointer to function to get the text of the sources that defined the description of the type"]
    pub get_type_description_sources_func: rosidl_service_get_type_description_sources_function,
}
#[test]
fn bindgen_test_layout_rosidl_service_type_support_t() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_service_type_support_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_service_type_support_t>(),
        88usize,
        concat!("Size of: ", stringify!(rosidl_service_type_support_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_service_type_support_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rosidl_service_type_support_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).typesupport_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_type_support_t),
            "::",
            stringify!(typesupport_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_type_support_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_type_support_t),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_typesupport) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_type_support_t),
            "::",
            stringify!(request_typesupport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_typesupport) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_type_support_t),
            "::",
            stringify!(response_typesupport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_typesupport) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_type_support_t),
            "::",
            stringify!(event_typesupport)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).event_message_create_handle_function) as usize
                - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_type_support_t),
            "::",
            stringify!(event_message_create_handle_function)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).event_message_destroy_handle_function) as usize
                - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_type_support_t),
            "::",
            stringify!(event_message_destroy_handle_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_type_hash_func) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_type_support_t),
            "::",
            stringify!(get_type_hash_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_type_description_func) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_type_support_t),
            "::",
            stringify!(get_type_description_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).get_type_description_sources_func) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_service_type_support_t),
            "::",
            stringify!(get_type_description_sources_func)
        )
    );
}
extern "C" {
    #[doc = " Get the service type support handle specific to this identifier.\n**\n* The handle's message typesupport identifier function is returned or if the parameters are NULL\n* then an assert will happen.\n*\n* \\param handle Handle to service type support\n* \\param identifier The typesupport identifier to get the handle function for\n* \\return The associated service typesupport handle function.\n*/"]
    pub fn get_service_typesupport_handle(
        handle: *const rosidl_service_type_support_t,
        identifier: *const ::std::os::raw::c_char,
    ) -> *const rosidl_service_type_support_t;
}
extern "C" {
    #[doc = " Get the service type support handle function specific to this identifier.\n**\n* If the identifier is the same as this handle's typesupport_identifier the handle is simply\n* returned or if the parameters are NULL then an assert will happen.\n*\n* \\param handle Handle to service type support\n* \\param identifier The typesupport identifier to get the handle function for\n* \\return if the identifier match's the handle's identifier then the handle's function\n*   is returned.\n*/"]
    pub fn get_service_typesupport_handle_function(
        handle: *const rosidl_service_type_support_t,
        identifier: *const ::std::os::raw::c_char,
    ) -> *const rosidl_service_type_support_t;
}
pub type rosidl_action_get_type_hash_function = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const rosidl_action_type_support_t) -> *const rosidl_type_hash_t,
>;
pub type rosidl_action_get_type_description_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_action_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeDescription,
>;
pub type rosidl_action_get_type_description_sources_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_action_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource__Sequence,
>;
#[doc = " Contains rosidl action type support data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_action_type_support_t {
    pub goal_service_type_support: *const rosidl_service_type_support_t,
    pub result_service_type_support: *const rosidl_service_type_support_t,
    pub cancel_service_type_support: *const rosidl_service_type_support_t,
    pub feedback_message_type_support: *const rosidl_message_type_support_t,
    pub status_message_type_support: *const rosidl_message_type_support_t,
    #[doc = " Pointer to function to get the hash of the action's description"]
    pub get_type_hash_func: rosidl_action_get_type_hash_function,
    #[doc = " Pointer to function to get the description of the type"]
    pub get_type_description_func: rosidl_action_get_type_description_function,
    #[doc = " Pointer to function to get the text of the sources that defined the description of the type"]
    pub get_type_description_sources_func: rosidl_action_get_type_description_sources_function,
}
#[test]
fn bindgen_test_layout_rosidl_action_type_support_t() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_action_type_support_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_action_type_support_t>(),
        64usize,
        concat!("Size of: ", stringify!(rosidl_action_type_support_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_action_type_support_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rosidl_action_type_support_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).goal_service_type_support) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_action_type_support_t),
            "::",
            stringify!(goal_service_type_support)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result_service_type_support) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_action_type_support_t),
            "::",
            stringify!(result_service_type_support)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cancel_service_type_support) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_action_type_support_t),
            "::",
            stringify!(cancel_service_type_support)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).feedback_message_type_support) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_action_type_support_t),
            "::",
            stringify!(feedback_message_type_support)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status_message_type_support) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_action_type_support_t),
            "::",
            stringify!(status_message_type_support)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_type_hash_func) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_action_type_support_t),
            "::",
            stringify!(get_type_hash_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_type_description_func) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_action_type_support_t),
            "::",
            stringify!(get_type_description_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).get_type_description_sources_func) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_action_type_support_t),
            "::",
            stringify!(get_type_description_sources_func)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Time message.\n**\n* If the init function is called twice for the same message without\n* calling fini inbetween previously allocated memory will be leaked.\n* \\param[in,out] msg The previously allocated message pointer.\n* Fields without a default value will not be initialized by this function.\n* You might want to call memset(msg, 0, sizeof(\n* builtin_interfaces__msg__Time\n* )) before or use\n* builtin_interfaces__msg__Time__create()\n* to allocate and initialize the message.\n* \\return true if initialization was successful, otherwise false\n*/"]
    pub fn builtin_interfaces__msg__Time__init(msg: *mut builtin_interfaces__msg__Time) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Time message.\n**\n* \\param[in,out] msg The allocated message pointer.\n*/"]
    pub fn builtin_interfaces__msg__Time__fini(msg: *mut builtin_interfaces__msg__Time);
}
extern "C" {
    #[doc = " Create msg/Time message.\n**\n* It allocates the memory for the message, sets the memory to zero, and\n* calls\n* builtin_interfaces__msg__Time__init().\n* \\return The pointer to the initialized message if successful,\n* otherwise NULL\n*/"]
    pub fn builtin_interfaces__msg__Time__create() -> *mut builtin_interfaces__msg__Time;
}
extern "C" {
    #[doc = " Destroy msg/Time message.\n**\n* It calls\n* builtin_interfaces__msg__Time__fini()\n* and frees the memory of the message.\n* \\param[in,out] msg The allocated message pointer.\n*/"]
    pub fn builtin_interfaces__msg__Time__destroy(msg: *mut builtin_interfaces__msg__Time);
}
extern "C" {
    #[doc = " Check for msg/Time message equality.\n**\n* \\param[in] lhs The message on the left hand size of the equality operator.\n* \\param[in] rhs The message on the right hand size of the equality operator.\n* \\return true if messages are equal, otherwise false.\n*/"]
    pub fn builtin_interfaces__msg__Time__are_equal(
        lhs: *const builtin_interfaces__msg__Time,
        rhs: *const builtin_interfaces__msg__Time,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Time message.\n**\n* This functions performs a deep copy, as opposed to the shallow copy that\n* plain assignment yields.\n*\n* \\param[in] input The source message pointer.\n* \\param[out] output The target message pointer, which must\n*   have been initialized before calling this function.\n* \\return true if successful, or false if either pointer is null\n*   or memory allocation fails.\n*/"]
    pub fn builtin_interfaces__msg__Time__copy(
        input: *const builtin_interfaces__msg__Time,
        output: *mut builtin_interfaces__msg__Time,
    ) -> bool;
}
extern "C" {
    #[doc = " Retrieve pointer to the hash of the description of this type."]
    pub fn builtin_interfaces__msg__Time__get_type_hash(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_type_hash_t;
}
extern "C" {
    #[doc = " Retrieve pointer to the description of this type."]
    pub fn builtin_interfaces__msg__Time__get_type_description(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeDescription;
}
extern "C" {
    #[doc = " Retrieve pointer to the single raw source text that defined this type."]
    pub fn builtin_interfaces__msg__Time__get_individual_type_description_source(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource;
}
extern "C" {
    #[doc = " Retrieve pointer to the recursive raw sources that defined the description of this type."]
    pub fn builtin_interfaces__msg__Time__get_type_description_sources(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource__Sequence;
}
extern "C" {
    #[doc = " Initialize array of msg/Time messages.\n**\n* It allocates the memory for the number of elements and calls\n* builtin_interfaces__msg__Time__init()\n* for each element of the array.\n* \\param[in,out] array The allocated array pointer.\n* \\param[in] size The size / capacity of the array.\n* \\return true if initialization was successful, otherwise false\n* If the array pointer is valid and the size is zero it is guaranteed\n# to return true.\n*/"]
    pub fn builtin_interfaces__msg__Time__Sequence__init(
        array: *mut builtin_interfaces__msg__Time__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Time messages.\n**\n* It calls\n* builtin_interfaces__msg__Time__fini()\n* for each element of the array and frees the memory for the number of\n* elements.\n* \\param[in,out] array The initialized array pointer.\n*/"]
    pub fn builtin_interfaces__msg__Time__Sequence__fini(
        array: *mut builtin_interfaces__msg__Time__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/Time messages.\n**\n* It allocates the memory for the array and calls\n* builtin_interfaces__msg__Time__Sequence__init().\n* \\param[in] size The size / capacity of the array.\n* \\return The pointer to the initialized array if successful, otherwise NULL\n*/"]
    pub fn builtin_interfaces__msg__Time__Sequence__create(
        size: usize,
    ) -> *mut builtin_interfaces__msg__Time__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Time messages.\n**\n* It calls\n* builtin_interfaces__msg__Time__Sequence__fini()\n* on the array,\n* and frees the memory of the array.\n* \\param[in,out] array The initialized array pointer.\n*/"]
    pub fn builtin_interfaces__msg__Time__Sequence__destroy(
        array: *mut builtin_interfaces__msg__Time__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Time message array equality.\n**\n* \\param[in] lhs The message array on the left hand size of the equality operator.\n* \\param[in] rhs The message array on the right hand size of the equality operator.\n* \\return true if message arrays are equal in size and content, otherwise false.\n*/"]
    pub fn builtin_interfaces__msg__Time__Sequence__are_equal(
        lhs: *const builtin_interfaces__msg__Time__Sequence,
        rhs: *const builtin_interfaces__msg__Time__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Time messages.\n**\n* This functions performs a deep copy, as opposed to the shallow copy that\n* plain assignment yields.\n*\n* \\param[in] input The source array pointer.\n* \\param[out] output The target array pointer, which must\n*   have been initialized before calling this function.\n* \\return true if successful, or false if either pointer\n*   is null or memory allocation fails.\n*/"]
    pub fn builtin_interfaces__msg__Time__Sequence__copy(
        input: *const builtin_interfaces__msg__Time__Sequence,
        output: *mut builtin_interfaces__msg__Time__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__builtin_interfaces__msg__Time(
    ) -> *const rosidl_message_type_support_t;
}
#[doc = " Struct defined in msg/Duration in the package builtin_interfaces.\n**\n* Duration defines a period between two time points.\n* Messages of this datatype are of ROS Time following this design:\n* https://design.ros2.org/articles/clock_and_time.html\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct builtin_interfaces__msg__Duration {
    #[doc = " Seconds component, range is valid over any possible int32 value."]
    pub sec: i32,
    #[doc = " Nanoseconds component in the range of [0, 1e9)."]
    pub nanosec: u32,
}
#[test]
fn bindgen_test_layout_builtin_interfaces__msg__Duration() {
    const UNINIT: ::std::mem::MaybeUninit<builtin_interfaces__msg__Duration> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<builtin_interfaces__msg__Duration>(),
        8usize,
        concat!("Size of: ", stringify!(builtin_interfaces__msg__Duration))
    );
    assert_eq!(
        ::std::mem::align_of::<builtin_interfaces__msg__Duration>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(builtin_interfaces__msg__Duration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Duration),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nanosec) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Duration),
            "::",
            stringify!(nanosec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct builtin_interfaces__msg__Duration__Sequence {
    pub data: *mut builtin_interfaces__msg__Duration,
    #[doc = " The number of valid items in data"]
    pub size: usize,
    #[doc = " The number of allocated items in data"]
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_builtin_interfaces__msg__Duration__Sequence() {
    const UNINIT: ::std::mem::MaybeUninit<builtin_interfaces__msg__Duration__Sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<builtin_interfaces__msg__Duration__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(builtin_interfaces__msg__Duration__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<builtin_interfaces__msg__Duration__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(builtin_interfaces__msg__Duration__Sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Duration__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Duration__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Duration__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Duration message.\n**\n* If the init function is called twice for the same message without\n* calling fini inbetween previously allocated memory will be leaked.\n* \\param[in,out] msg The previously allocated message pointer.\n* Fields without a default value will not be initialized by this function.\n* You might want to call memset(msg, 0, sizeof(\n* builtin_interfaces__msg__Duration\n* )) before or use\n* builtin_interfaces__msg__Duration__create()\n* to allocate and initialize the message.\n* \\return true if initialization was successful, otherwise false\n*/"]
    pub fn builtin_interfaces__msg__Duration__init(
        msg: *mut builtin_interfaces__msg__Duration,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Duration message.\n**\n* \\param[in,out] msg The allocated message pointer.\n*/"]
    pub fn builtin_interfaces__msg__Duration__fini(msg: *mut builtin_interfaces__msg__Duration);
}
extern "C" {
    #[doc = " Create msg/Duration message.\n**\n* It allocates the memory for the message, sets the memory to zero, and\n* calls\n* builtin_interfaces__msg__Duration__init().\n* \\return The pointer to the initialized message if successful,\n* otherwise NULL\n*/"]
    pub fn builtin_interfaces__msg__Duration__create() -> *mut builtin_interfaces__msg__Duration;
}
extern "C" {
    #[doc = " Destroy msg/Duration message.\n**\n* It calls\n* builtin_interfaces__msg__Duration__fini()\n* and frees the memory of the message.\n* \\param[in,out] msg The allocated message pointer.\n*/"]
    pub fn builtin_interfaces__msg__Duration__destroy(msg: *mut builtin_interfaces__msg__Duration);
}
extern "C" {
    #[doc = " Check for msg/Duration message equality.\n**\n* \\param[in] lhs The message on the left hand size of the equality operator.\n* \\param[in] rhs The message on the right hand size of the equality operator.\n* \\return true if messages are equal, otherwise false.\n*/"]
    pub fn builtin_interfaces__msg__Duration__are_equal(
        lhs: *const builtin_interfaces__msg__Duration,
        rhs: *const builtin_interfaces__msg__Duration,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Duration message.\n**\n* This functions performs a deep copy, as opposed to the shallow copy that\n* plain assignment yields.\n*\n* \\param[in] input The source message pointer.\n* \\param[out] output The target message pointer, which must\n*   have been initialized before calling this function.\n* \\return true if successful, or false if either pointer is null\n*   or memory allocation fails.\n*/"]
    pub fn builtin_interfaces__msg__Duration__copy(
        input: *const builtin_interfaces__msg__Duration,
        output: *mut builtin_interfaces__msg__Duration,
    ) -> bool;
}
extern "C" {
    #[doc = " Retrieve pointer to the hash of the description of this type."]
    pub fn builtin_interfaces__msg__Duration__get_type_hash(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_type_hash_t;
}
extern "C" {
    #[doc = " Retrieve pointer to the description of this type."]
    pub fn builtin_interfaces__msg__Duration__get_type_description(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeDescription;
}
extern "C" {
    #[doc = " Retrieve pointer to the single raw source text that defined this type."]
    pub fn builtin_interfaces__msg__Duration__get_individual_type_description_source(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource;
}
extern "C" {
    #[doc = " Retrieve pointer to the recursive raw sources that defined the description of this type."]
    pub fn builtin_interfaces__msg__Duration__get_type_description_sources(
        type_support: *const rosidl_message_type_support_t,
    ) -> *const rosidl_runtime_c__type_description__TypeSource__Sequence;
}
extern "C" {
    #[doc = " Initialize array of msg/Duration messages.\n**\n* It allocates the memory for the number of elements and calls\n* builtin_interfaces__msg__Duration__init()\n* for each element of the array.\n* \\param[in,out] array The allocated array pointer.\n* \\param[in] size The size / capacity of the array.\n* \\return true if initialization was successful, otherwise false\n* If the array pointer is valid and the size is zero it is guaranteed\n# to return true.\n*/"]
    pub fn builtin_interfaces__msg__Duration__Sequence__init(
        array: *mut builtin_interfaces__msg__Duration__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Duration messages.\n**\n* It calls\n* builtin_interfaces__msg__Duration__fini()\n* for each element of the array and frees the memory for the number of\n* elements.\n* \\param[in,out] array The initialized array pointer.\n*/"]
    pub fn builtin_interfaces__msg__Duration__Sequence__fini(
        array: *mut builtin_interfaces__msg__Duration__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/Duration messages.\n**\n* It allocates the memory for the array and calls\n* builtin_interfaces__msg__Duration__Sequence__init().\n* \\param[in] size The size / capacity of the array.\n* \\return The pointer to the initialized array if successful, otherwise NULL\n*/"]
    pub fn builtin_interfaces__msg__Duration__Sequence__create(
        size: usize,
    ) -> *mut builtin_interfaces__msg__Duration__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Duration messages.\n**\n* It calls\n* builtin_interfaces__msg__Duration__Sequence__fini()\n* on the array,\n* and frees the memory of the array.\n* \\param[in,out] array The initialized array pointer.\n*/"]
    pub fn builtin_interfaces__msg__Duration__Sequence__destroy(
        array: *mut builtin_interfaces__msg__Duration__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Duration message array equality.\n**\n* \\param[in] lhs The message array on the left hand size of the equality operator.\n* \\param[in] rhs The message array on the right hand size of the equality operator.\n* \\return true if message arrays are equal in size and content, otherwise false.\n*/"]
    pub fn builtin_interfaces__msg__Duration__Sequence__are_equal(
        lhs: *const builtin_interfaces__msg__Duration__Sequence,
        rhs: *const builtin_interfaces__msg__Duration__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Duration messages.\n**\n* This functions performs a deep copy, as opposed to the shallow copy that\n* plain assignment yields.\n*\n* \\param[in] input The source array pointer.\n* \\param[out] output The target array pointer, which must\n*   have been initialized before calling this function.\n* \\return true if successful, or false if either pointer\n*   is null or memory allocation fails.\n*/"]
    pub fn builtin_interfaces__msg__Duration__Sequence__copy(
        input: *const builtin_interfaces__msg__Duration__Sequence,
        output: *mut builtin_interfaces__msg__Duration__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__builtin_interfaces__msg__Duration(
    ) -> *const rosidl_message_type_support_t;
}
extern "C" {
    pub fn rosidl_runtime_c__float__Sequence__init(
        sequence: *mut rosidl_runtime_c__float__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__float__Sequence__fini(
        sequence: *mut rosidl_runtime_c__float__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__float__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__float__Sequence,
        rhs: *const rosidl_runtime_c__float__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__float__Sequence__copy(
        input: *const rosidl_runtime_c__float__Sequence,
        output: *mut rosidl_runtime_c__float__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__double__Sequence__init(
        sequence: *mut rosidl_runtime_c__double__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__double__Sequence__fini(
        sequence: *mut rosidl_runtime_c__double__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__double__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__double__Sequence,
        rhs: *const rosidl_runtime_c__double__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__double__Sequence__copy(
        input: *const rosidl_runtime_c__double__Sequence,
        output: *mut rosidl_runtime_c__double__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__long_double__Sequence__init(
        sequence: *mut rosidl_runtime_c__long_double__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__long_double__Sequence__fini(
        sequence: *mut rosidl_runtime_c__long_double__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__long_double__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__long_double__Sequence,
        rhs: *const rosidl_runtime_c__long_double__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__long_double__Sequence__copy(
        input: *const rosidl_runtime_c__long_double__Sequence,
        output: *mut rosidl_runtime_c__long_double__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__char__Sequence__init(
        sequence: *mut rosidl_runtime_c__char__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__char__Sequence__fini(sequence: *mut rosidl_runtime_c__char__Sequence);
}
extern "C" {
    pub fn rosidl_runtime_c__char__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__char__Sequence,
        rhs: *const rosidl_runtime_c__char__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__char__Sequence__copy(
        input: *const rosidl_runtime_c__char__Sequence,
        output: *mut rosidl_runtime_c__char__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__wchar__Sequence__init(
        sequence: *mut rosidl_runtime_c__wchar__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__wchar__Sequence__fini(
        sequence: *mut rosidl_runtime_c__wchar__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__wchar__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__wchar__Sequence,
        rhs: *const rosidl_runtime_c__wchar__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__wchar__Sequence__copy(
        input: *const rosidl_runtime_c__wchar__Sequence,
        output: *mut rosidl_runtime_c__wchar__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__boolean__Sequence__init(
        sequence: *mut rosidl_runtime_c__boolean__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__boolean__Sequence__fini(
        sequence: *mut rosidl_runtime_c__boolean__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__boolean__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__boolean__Sequence,
        rhs: *const rosidl_runtime_c__boolean__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__boolean__Sequence__copy(
        input: *const rosidl_runtime_c__boolean__Sequence,
        output: *mut rosidl_runtime_c__boolean__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__octet__Sequence__init(
        sequence: *mut rosidl_runtime_c__octet__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__octet__Sequence__fini(
        sequence: *mut rosidl_runtime_c__octet__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__octet__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__octet__Sequence,
        rhs: *const rosidl_runtime_c__octet__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__octet__Sequence__copy(
        input: *const rosidl_runtime_c__octet__Sequence,
        output: *mut rosidl_runtime_c__octet__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__uint8__Sequence__init(
        sequence: *mut rosidl_runtime_c__uint8__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__uint8__Sequence__fini(
        sequence: *mut rosidl_runtime_c__uint8__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__uint8__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__uint8__Sequence,
        rhs: *const rosidl_runtime_c__uint8__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__uint8__Sequence__copy(
        input: *const rosidl_runtime_c__uint8__Sequence,
        output: *mut rosidl_runtime_c__uint8__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__int8__Sequence__init(
        sequence: *mut rosidl_runtime_c__int8__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__int8__Sequence__fini(sequence: *mut rosidl_runtime_c__int8__Sequence);
}
extern "C" {
    pub fn rosidl_runtime_c__int8__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__int8__Sequence,
        rhs: *const rosidl_runtime_c__int8__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__int8__Sequence__copy(
        input: *const rosidl_runtime_c__int8__Sequence,
        output: *mut rosidl_runtime_c__int8__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__uint16__Sequence__init(
        sequence: *mut rosidl_runtime_c__uint16__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__uint16__Sequence__fini(
        sequence: *mut rosidl_runtime_c__uint16__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__uint16__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__uint16__Sequence,
        rhs: *const rosidl_runtime_c__uint16__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__uint16__Sequence__copy(
        input: *const rosidl_runtime_c__uint16__Sequence,
        output: *mut rosidl_runtime_c__uint16__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__int16__Sequence__init(
        sequence: *mut rosidl_runtime_c__int16__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__int16__Sequence__fini(
        sequence: *mut rosidl_runtime_c__int16__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__int16__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__int16__Sequence,
        rhs: *const rosidl_runtime_c__int16__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__int16__Sequence__copy(
        input: *const rosidl_runtime_c__int16__Sequence,
        output: *mut rosidl_runtime_c__int16__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__uint32__Sequence__init(
        sequence: *mut rosidl_runtime_c__uint32__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__uint32__Sequence__fini(
        sequence: *mut rosidl_runtime_c__uint32__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__uint32__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__uint32__Sequence,
        rhs: *const rosidl_runtime_c__uint32__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__uint32__Sequence__copy(
        input: *const rosidl_runtime_c__uint32__Sequence,
        output: *mut rosidl_runtime_c__uint32__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__int32__Sequence__init(
        sequence: *mut rosidl_runtime_c__int32__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__int32__Sequence__fini(
        sequence: *mut rosidl_runtime_c__int32__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__int32__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__int32__Sequence,
        rhs: *const rosidl_runtime_c__int32__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__int32__Sequence__copy(
        input: *const rosidl_runtime_c__int32__Sequence,
        output: *mut rosidl_runtime_c__int32__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__uint64__Sequence__init(
        sequence: *mut rosidl_runtime_c__uint64__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__uint64__Sequence__fini(
        sequence: *mut rosidl_runtime_c__uint64__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__uint64__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__uint64__Sequence,
        rhs: *const rosidl_runtime_c__uint64__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__uint64__Sequence__copy(
        input: *const rosidl_runtime_c__uint64__Sequence,
        output: *mut rosidl_runtime_c__uint64__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__int64__Sequence__init(
        sequence: *mut rosidl_runtime_c__int64__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__int64__Sequence__fini(
        sequence: *mut rosidl_runtime_c__int64__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__int64__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__int64__Sequence,
        rhs: *const rosidl_runtime_c__int64__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__int64__Sequence__copy(
        input: *const rosidl_runtime_c__int64__Sequence,
        output: *mut rosidl_runtime_c__int64__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " \\defgroup primitives_sequence_functions__legacy Sequence functions for legacy types for backward compatibility.\n/\n/**@{*/\n/** See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_INIT(bool)"]
    pub fn rosidl_runtime_c__bool__Sequence__init(
        sequence: *mut rosidl_runtime_c__boolean__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_FINI(bool)"]
    pub fn rosidl_runtime_c__bool__Sequence__fini(
        sequence: *mut rosidl_runtime_c__boolean__Sequence,
    );
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_EQ(bool)"]
    pub fn rosidl_runtime_c__bool__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__boolean__Sequence,
        rhs: *const rosidl_runtime_c__boolean__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_COPY(bool)"]
    pub fn rosidl_runtime_c__bool__Sequence__copy(
        input: *const rosidl_runtime_c__boolean__Sequence,
        output: *mut rosidl_runtime_c__boolean__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_INIT(byte)"]
    pub fn rosidl_runtime_c__byte__Sequence__init(
        sequence: *mut rosidl_runtime_c__octet__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_FINI(byte)"]
    pub fn rosidl_runtime_c__byte__Sequence__fini(sequence: *mut rosidl_runtime_c__octet__Sequence);
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_EQ(byte)"]
    pub fn rosidl_runtime_c__byte__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__octet__Sequence,
        rhs: *const rosidl_runtime_c__octet__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_COPY(byte)"]
    pub fn rosidl_runtime_c__byte__Sequence__copy(
        input: *const rosidl_runtime_c__octet__Sequence,
        output: *mut rosidl_runtime_c__octet__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_INIT(float32)"]
    pub fn rosidl_runtime_c__float32__Sequence__init(
        sequence: *mut rosidl_runtime_c__float__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_FINI(float32)"]
    pub fn rosidl_runtime_c__float32__Sequence__fini(
        sequence: *mut rosidl_runtime_c__float__Sequence,
    );
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_EQ(float32)"]
    pub fn rosidl_runtime_c__float32__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__float__Sequence,
        rhs: *const rosidl_runtime_c__float__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_COPY(float32)"]
    pub fn rosidl_runtime_c__float32__Sequence__copy(
        input: *const rosidl_runtime_c__float__Sequence,
        output: *mut rosidl_runtime_c__float__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_INIT(float64)"]
    pub fn rosidl_runtime_c__float64__Sequence__init(
        sequence: *mut rosidl_runtime_c__double__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_FINI(float64)"]
    pub fn rosidl_runtime_c__float64__Sequence__fini(
        sequence: *mut rosidl_runtime_c__double__Sequence,
    );
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_EQ(float64)"]
    pub fn rosidl_runtime_c__float64__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__double__Sequence,
        rhs: *const rosidl_runtime_c__double__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_COPY(float64)"]
    pub fn rosidl_runtime_c__float64__Sequence__copy(
        input: *const rosidl_runtime_c__double__Sequence,
        output: *mut rosidl_runtime_c__double__Sequence,
    ) -> bool;
}
#[doc = " Upper boundary for #rosidl_runtime_c__String or #rosidl_runtime_c__U16String."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__String__bound {
    #[doc = " The number of characters in the string (excluding the null character)."]
    pub bound: usize,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__String__bound() {
    const UNINIT: ::std::mem::MaybeUninit<rosidl_runtime_c__String__bound> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__String__bound>(),
        8usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__String__bound))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__String__bound>(),
        8usize,
        concat!("Alignment of ", stringify!(rosidl_runtime_c__String__bound))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bound) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__String__bound),
            "::",
            stringify!(bound)
        )
    );
}
extern "C" {
    #[doc = " Initialize a rosidl_runtime_c__String structure."]
    pub fn rosidl_runtime_c__String__init(str_: *mut rosidl_runtime_c__String) -> bool;
}
extern "C" {
    #[doc = " Deallocate the memory of the rosidl_runtime_c__String structure."]
    pub fn rosidl_runtime_c__String__fini(str_: *mut rosidl_runtime_c__String);
}
extern "C" {
    #[doc = " Copy rosidl_runtime_c__String structure content.\n**\n* This functions performs a deep copy, as opposed to the shallow copy that\n* plain assignment yields.\n*\n* \\param[in] input a pointer to a rosidl_runtime_c__String structure\n*   to copy from.\n* \\param[out] output a pointer to an initialized rosidl_runtime_c__String\n*   structure to copy into.\n* \\return true if successful, false if either pointer is null or memory\n*   allocation fails.\n*/"]
    pub fn rosidl_runtime_c__String__copy(
        input: *const rosidl_runtime_c__String,
        output: *mut rosidl_runtime_c__String,
    ) -> bool;
}
extern "C" {
    #[doc = " Check for rosidl_runtime_c__String structure equality.\n**\n* \\param[in] lhs a pointer to the left hand side of the equality operator.\n* \\param[in] lhs a pointer to the right hand side of the equality operator.\n* \\return true if rosidl_runtime_c__String structures are equal in size and content,\n*   otherwise false.\n*/"]
    pub fn rosidl_runtime_c__String__are_equal(
        lhs: *const rosidl_runtime_c__String,
        rhs: *const rosidl_runtime_c__String,
    ) -> bool;
}
extern "C" {
    #[doc = " Assign the c string pointer of n characters to the rosidl_runtime_c__String structure."]
    pub fn rosidl_runtime_c__String__assignn(
        str_: *mut rosidl_runtime_c__String,
        value: *const ::std::os::raw::c_char,
        n: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Assign the c string pointer to the rosidl_runtime_c__String structure."]
    pub fn rosidl_runtime_c__String__assign(
        str_: *mut rosidl_runtime_c__String,
        value: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize a rosidl_runtime_c__String__Sequence__init structure."]
    pub fn rosidl_runtime_c__String__Sequence__init(
        sequence: *mut rosidl_runtime_c__String__Sequence,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Deallocate the memory of the string sequence structure."]
    pub fn rosidl_runtime_c__String__Sequence__fini(
        sequence: *mut rosidl_runtime_c__String__Sequence,
    );
}
extern "C" {
    #[doc = " Check for rosidl_runtime_c__String__Sequence structure equality.\n**\n* \\param[in] lhs a pointer to the left hand side of the equality operator.\n* \\param[in] lhs a pointer to the right hand side of the equality operator.\n* \\return true if rosidl_runtime_c__String__Sequence structures are equal\n*   in size and content, otherwise false.\n*/"]
    pub fn rosidl_runtime_c__String__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__String__Sequence,
        rhs: *const rosidl_runtime_c__String__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy rosidl_runtime_c__String__Sequence structure content.\n**\n* This functions performs a deep copy, as opposed to the shallow copy\n* that plain assignment yields.\n*\n* \\param[in] input a pointer to a rosidl_runtime_c__String__Sequence\n*   structure to copy from.\n* \\param[out] output a pointer to an initialized rosidl_runtime_c__String__Sequence\n*   structure to copy into.\n* \\return true if successful, false if either pointer is null or memory\n*   allocation fails.\n*/"]
    pub fn rosidl_runtime_c__String__Sequence__copy(
        input: *const rosidl_runtime_c__String__Sequence,
        output: *mut rosidl_runtime_c__String__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Create a rosidl_runtime_c__String__Sequence structure with a specific size."]
    pub fn rosidl_runtime_c__String__Sequence__create(
        size: usize,
    ) -> *mut rosidl_runtime_c__String__Sequence;
}
extern "C" {
    #[doc = " Destroy a rosidl_runtime_c__String__Sequence structure."]
    pub fn rosidl_runtime_c__String__Sequence__destroy(
        sequence: *mut rosidl_runtime_c__String__Sequence,
    );
}
